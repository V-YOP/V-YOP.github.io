

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="友纪V-λOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="Pydantic，其实就是一个类型定义、校验、序列化、反序列化库，如果要论相似品的话，就是 Typescript 的 zod 加上 Java 的 Jackson">
<meta property="og:type" content="article">
<meta property="og:title" content="Pydantic 入门">
<meta property="og:url" content="http://example.com/2025/04-22Pydantic%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="友纪V-λOP">
<meta property="og:description" content="Pydantic，其实就是一个类型定义、校验、序列化、反序列化库，如果要论相似品的话，就是 Typescript 的 zod 加上 Java 的 Jackson">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-04-22T06:50:00.000Z">
<meta property="article:modified_time" content="2025-04-22T06:49:58.865Z">
<meta property="article:author" content="友纪V-λOP">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>Pydantic 入门 - 友纪V-λOP</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":100},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="友纪V-λOP" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友纪V-λOP的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Pydantic 入门">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-04-22 14:50" pubdate>
        2025年4月22日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Pydantic 入门</h1>
            
            <div class="markdown-body">
              <p>好久没学过 Python 基础的玩意儿了，最近要用 FastAPI 写点东西，然而 FastAPI 大量使用 Pydantic 用于数据定义和校验，而且之前学的 LangChain 也是大量依赖 Pydantic。这让学习 Pydantic 有实际意义。</p>
<p>所以，就去学。</p>
<p>下面基本把可能会用到的以及不大可能用到的概念都过了一遍，基本已经能够服务于实践并建立对 Pydantic 整体的感知了。给我热情都写没了。</p>
<hr>
<p>Pydantic，其实就是一个类型定义、校验、序列化、反序列化库，如果要论相似品的话，就是 Typescript 的 zod 加上 Java 的 Jackson。区别在于，<strong>Pydantic 通过继承 BaseModel 实现功能</strong>，而 zod 更纯，而 Java 使用 POJO 和注解。</p>
<p>Pydantic 有如下值得一提的功能：</p>
<ol>
<li>支持序列化、反序列化到 JSON，嵌套地</li>
<li>Strict 和 Lax 模式，前者严格，不进行类型转换，后者宽松，像 Jackson 的反序列化那样宽松</li>
<li>支持 Dataclass 和 TypedDict</li>
<li>支持自定义校验器和序列化器</li>
</ol>
<p>hmmm，这个或许使用 learn x in y minutes 的形式更容易写和学一些。</p>
<p>一个整蛊的地方是，pydantic 把反序列化叫成 validation。</p>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h1><p>下面是 Pydantic 的 HelloWorld——展示了 schema 中各种字段的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Literal</span>, Annotated<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br><span class="hljs-keyword">from</span> annotated_types <span class="hljs-keyword">import</span> Gt<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span>  <br>    color: <span class="hljs-type">Literal</span>[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]  <br>    weight: Annotated[<span class="hljs-built_in">float</span>, Gt(<span class="hljs-number">0</span>)]  <br>    bazam: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">list</span>[<span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>, <span class="hljs-built_in">float</span>]]]  <br><br><span class="hljs-built_in">print</span>(Fruit(<br>    name=<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-comment"># name 不能为其它类型</span><br>    color=<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-comment"># color 必须在 red 和 green 中</span><br>    weight=<span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-comment"># weight 可以是字符串形式的数字，但必须大于 0</span><br>    bazam=&#123;<span class="hljs-string">&#x27;foobar&#x27;</span>: [(<span class="hljs-number">1</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">0.1</span>)]&#125;, <span class="hljs-comment"># 嵌套校验</span><br>))<br></code></pre></div></td></tr></table></figure>
<p>注意到它某些地方莫名严格——name 是 str，传 int 不行，而某些地方又莫名宽松，weight 是 float，传 str 可以，这应该是故意设计为如此的，而其行为和我熟悉的 jackson 不合。实际上，这里有个 <a target="_blank" rel="noopener" href="https://docs.pydantic.dev/latest/concepts/conversion_table/">转换表</a>，描述了所有类型在默认模式（lax）以及 strict 模式下可以的入参。</p>
<p>但我怀疑，<strong>JSON 反序列化时可能不走同样的机制</strong>（因为这个表里入参都不是 JSON 类型）。</p>
<p>注意——只有初次创建实例时才会进行校验，在其后你可以自由地把值设置地违反约束。</p>
<p>这里也提一下——Pydantic 支持所谓的<code>RootModel</code>——它表示一个数据类型本身是一个 list 或者 str 这样的<strong>单数据类型</strong>，而并非是一个对象，要比较的话，就是 Jackson 的 JsonValue 注解。RootModel 通常用于生成文档等，它看上去几乎是可以被 TypeAlias（pydantic 提供的我是说，它能提供文档的）代替的……只不过 TypeAlias 没有直接提供校验功能，需要让 TypeAdapater 协助：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> RootModel<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeRequestBody</span>(RootModel[<span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]]):<br>    <span class="hljs-keyword">pass</span><br><br>v = SomeRequestBody.model_validate_json(<span class="hljs-string">&quot;&quot;&quot; [&quot;1&quot;, &quot;2&quot;] &quot;&quot;&quot;</span>)<br><span class="hljs-built_in">print</span>(v.root) <span class="hljs-comment"># 需要通过 root 字段去访问</span><br></code></pre></div></td></tr></table></figure>
<h1 id="序列化到-dict-或-JSON"><a href="#序列化到-dict-或-JSON" class="headerlink" title="序列化到 dict 或 JSON"></a>序列化到 dict 或 JSON</h1><p>关于序列化，pydantic 支持三种方式——</p>
<ol>
<li>序列化到 dict，字段包含 python 对象，如 datetime 等</li>
<li>序列化到 dict，所有字段类型和 json 兼容</li>
<li>序列化到 JSON</li>
</ol>
<p>前两者使用<code>model_dump</code>方法，后者使用<code>model_dump_json</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date, datetime<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Annotated<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br><span class="hljs-keyword">from</span> annotated_types <span class="hljs-keyword">import</span> Gt<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Idol</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br>    age: Annotated[<span class="hljs-built_in">int</span>, Gt(<span class="hljs-number">0</span>)]<br>    join_date: date<br>    <br><br>idol = Idol(name=<span class="hljs-string">&#x27;Chihaya&#x27;</span>, age=<span class="hljs-number">16</span>, join_date=datetime.strptime(<span class="hljs-string">&#x27;2004-01-01&#x27;</span>, <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>))<br><br><span class="hljs-built_in">print</span>(idol.model_dump()) <span class="hljs-comment"># 还有一堆配置项，如排除 None，排除默认值等</span><br><span class="hljs-built_in">print</span>(idol.model_dump(mode=<span class="hljs-string">&#x27;json&#x27;</span>)) <br><span class="hljs-built_in">print</span>(idol.model_dump_json()) <span class="hljs-comment"># 能配置缩进等，就像 json 库一样</span><br></code></pre></div></td></tr></table></figure>
<p>此外，也能使用<code>dict</code>函数去直接把 model 转成 dict，但<strong>这样操作只能转换顶层为 dict</strong>，这大多数时候恐怕都不是我们想要的结果。</p>
<p>此外，model 能通过<code>model_json_schema</code>方法去生成 JSON Schema（似乎是兼容 OpenAPI 格式的，即 Swagger 那个），不过这里不表，因为我不会显式地用它。</p>
<h1 id="从-dict-或-JSON-反序列化"><a href="#从-dict-或-JSON-反序列化" class="headerlink" title="从 dict 或 JSON 反序列化"></a>从 dict 或 JSON 反序列化</h1><p>从 dict 反序列化，有两种方式，使用构造函数或者<code>model_validate</code>方法，<strong>这两种方式就使用上来说好像 tmd 没有任何差别</strong>，我还以为至少在别名等地方有差别呢……</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clazz</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Idol</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br>    clazz: Clazz<br><br><span class="hljs-built_in">print</span>(Idol(name=<span class="hljs-string">&#x27;chihaya&#x27;</span>,clazz=&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;765&#x27;</span>&#125;))<br><span class="hljs-built_in">print</span>(Idol.model_validate(<span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&#x27;chihaya&#x27;</span>,clazz=&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;765&#x27;</span>&#125;)))<br></code></pre></div></td></tr></table></figure>
<p>还有一个<code>model_validate_strings</code>……它相较于<code>model_validate</code>，<strong>似乎在类型转换上更加智能，允许所有字段全部是 string</strong>。</p>
<p>然后是<code>model_validate_json</code>，从 JSON 字符串或 bytes 到 model，这个不言自明。</p>
<p>此外，还有一个<code>model_construct</code>方法直接构造 model，不进行校验，这个很坏。</p>
<h1 id="Schema-的花式定义法"><a href="#Schema-的花式定义法" class="headerlink" title="Schema 的花式定义法"></a>Schema 的花式定义法</h1><h2 id="自定义类型和约束"><a href="#自定义类型和约束" class="headerlink" title="自定义类型和约束"></a>自定义类型和约束</h2><p>Pydantic 既支持 Python 内置类型，也支持自定义类型的校验，同时它也提供了一些 Helper 类型，定制序列化反序列化的过程，如 StrictXXX，不表。</p>
<p>Pydantic 支持常见的标准库类型，大部分地方都是符合直觉的，所以标准库类型不表，只需要知道，datetime 支持我们习惯的 <code>YYYY-MM-DD HH:MM:SS</code>的格式（非严格时支持<code>YYYY-MM-DD</code>），date 则支持<code>YYYY-MM-DD</code>，很方便，就这点来说，沿用 Jackson 的经验已足够。</p>
<p>重点是，Pydantic 允许添加自定义规则的类型，比如，我们想要大于 0 的整型（有没有想到 Dependent Type？哈哈），我们就这么写。注意下面的 TypeAdapter，它<strong>相当于是利用类型的元信息构造的一个序列化、反序列化器</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Annotated<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field, TypeAdapter, ValidationError<br><br><span class="hljs-comment"># Annotated 只是增加元数据，就外观上来说，它仍旧是 int</span><br><span class="hljs-comment"># 这个类型有两种应用方式——要么作为 BaseModel 的字段，要么使用 TypeAdapter</span><br>PositiveInt = Annotated[<span class="hljs-built_in">int</span>, Field(gt=<span class="hljs-number">0</span>)]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClz</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    data: PositiveInt<br><br><span class="hljs-keyword">try</span>:<br>    TestClz(data=-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">except</span> ValidationError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;成功地失败了&#x27;</span>, e)<br><br>ta = TypeAdapter(PositiveInt)<br><br><span class="hljs-keyword">try</span>:<br>    v = ta.validate_python(-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">except</span> ValidationError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;成功地失败了&#x27;</span>, e)<br><br><span class="hljs-comment"># 最酷的地方在于，可以像 java 的嵌套的注解一样玩儿：</span><br>NotEmptyPositiveList = Annotated[<span class="hljs-built_in">list</span>[Annotated[<span class="hljs-built_in">int</span>, Field(gt=<span class="hljs-number">0</span>)]], Field(min_length=<span class="hljs-number">1</span>)]<br><br>ta= TypeAdapter(NotEmptyPositiveList)<br><br><span class="hljs-keyword">try</span>:<br>    ta.validate_python(<span class="hljs-literal">None</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;successfully failed&#x27;</span>)<br><span class="hljs-keyword">try</span>:<br>    ta.validate_python([])<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;successfully failed&#x27;</span>)<br><span class="hljs-keyword">try</span>:<br>    ta.validate_python([-<span class="hljs-number">1</span>])<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;successfully failed&#x27;</span>)<br><br>ta.validate_python([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>后面和 dataclass，TypedDict，NamedTuple 协同工作，同样要使用 TypeAdapter</strong>。</p>
<p>不过这里算是跑题了，现在问题是，<strong>有哪些像 gt 这样的规则和约束，如何自定义约束</strong>？大部分情况下，使用上面示例中的 <code>Field</code> 函数，它类似标准库中 dataclass 的<code>field</code>函数，但它放在 Annotated 注解中，这个注解用于添加元信息，Pydantic 大量使用这个模式。</p>
<p>Field 包含这些重要配置可能会常用：</p>
<ol>
<li>default, default_factory: 字面意思，但 pydantic 似乎不会有共享可变对象的问题</li>
<li>alias：字段别名，可以分别序列化、反序列化时使用的别名</li>
<li>gt, ge, lt, le, multiple_of, allow_inf_nan：数字约束；疑惑为什么没有 eq？直接用 Literal</li>
<li>min_length, max_length, pattern：字符串约束，但 min_length 和 max_length 都支持所有可迭代类型</li>
<li>strict：严格校验模式</li>
<li>frozen：不可变</li>
</ol>
<h2 id="Field-以外的元信息"><a href="#Field-以外的元信息" class="headerlink" title="Field 以外的元信息"></a>Field 以外的元信息</h2><p>Field 这个究竟叫什么好像没找到专门的术语，但除了 Field 以外，Pydantic 还支持其它的元信息，它们也是通过 Annotated 去使用的。以及，FastAPI 等框架也会依赖 Annotated 提供功能。</p>
<p>这里主要说的是内置库中提供的更多约束，实际上这些约束均在<code>annotated_type</code>包下，一些可能会用到且 Field 没有覆盖到的约束包括：</p>
<ol>
<li>Interval：相当于是 gt，lt，ge，le 的组合</li>
<li>Len：相当于是 min_length 和 max_length 的组合</li>
<li>Timezone：限制时区</li>
<li>Unit：数字的单位，如克，米等，这个好像没屁用</li>
<li>Predicate：接受 Callable，<strong>自定义断言</strong>！自定义断言在类型转换后才开始操作，所以可以安心！</li>
<li>Not：这是一个 dataclass，接受一个函数，行为为将函数的返回值取反</li>
<li>LowerCase，UpperCase，IsDigit：一堆使用 Annotated 和 Predicate 预定义的<strong>类型</strong>（注意是类型！它作为元信息是没效果的！）</li>
</ol>
<p>下面随意展示一下它的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Annotated<br><span class="hljs-keyword">from</span> annotated_types <span class="hljs-keyword">import</span> LowerCase, Predicate, IsDigit<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Idol</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: Annotated[LowerCase, Field(pattern=<span class="hljs-string">r&#x27;\w+ \w+&#x27;</span>)] <span class="hljs-comment"># bound=str</span><br>    clazz: IsDigit                                        <span class="hljs-comment"># bound=str</span><br>    age: Annotated[<span class="hljs-built_in">int</span>, Predicate(<span class="hljs-keyword">lambda</span> age: age &lt; <span class="hljs-number">18</span>)]  <span class="hljs-comment"># Idol 永远年轻！</span><br><br><span class="hljs-built_in">print</span>(Idol(name=<span class="hljs-string">&#x27;amami chihaya&#x27;</span>, clazz=<span class="hljs-string">&#x27;765&#x27;</span>, age=<span class="hljs-string">&#x27;16&#x27;</span>)) <span class="hljs-comment"># 注意 Predicate 在类型转换后才执行</span><br><span class="hljs-comment"># Idol(name=&#x27;abc&#x27;, clazz=&#x27;123&#x27;)                 # fail with pattern</span><br><span class="hljs-comment"># Idol(name=&#x27;ABC DEF&#x27;, clazz=&#x27;123&#x27;)             # fail with str.islower</span><br><span class="hljs-comment"># Idol(name=&#x27;abc def&#x27;, clazz=&#x27;123&#x27;, age = &#x27;19&#x27;) # fail with predicate</span><br></code></pre></div></td></tr></table></figure>
<h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><p><strong>这个只用来序列化</strong>，相当于是在 jackson 中给 getter 加 JsonProperty。<strong>注意顺序！！！computed_field 必须接受 property，这意味着它必须放在 property 外头</strong>！</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Annotated<br><span class="hljs-keyword">from</span> annotated_types <span class="hljs-keyword">import</span> Gt<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field, TypeAdapter, ValidationError, computed_field<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Idol</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    first_name: <span class="hljs-built_in">str</span><br>    last_name: <span class="hljs-built_in">str</span><br>    <br><span class="hljs-meta">    @computed_field </span><span class="hljs-comment"># 注意顺序！！！！！！！！</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">full_name</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> self.first_name + <span class="hljs-string">&#x27; &#x27;</span> + self.last_name<br>    <br><br><span class="hljs-built_in">print</span>(Idol(first_name=<span class="hljs-string">&#x27;Chihaya&#x27;</span>, last_name=<span class="hljs-string">&#x27;Amami&#x27;</span>).model_dump_json())<br></code></pre></div></td></tr></table></figure>
<h2 id="模式匹配（Discriminated-Unions）"><a href="#模式匹配（Discriminated-Unions）" class="headerlink" title="模式匹配（Discriminated Unions）"></a>模式匹配（Discriminated Unions）</h2><p>首先，Pydantic 支持 Union 类型，即<code>str | int | None</code>，<strong>Pydantic 会选择最匹配的类型</strong>。</p>
<p>就像 zod 一样，Pydantic 支持 Discriminated Union（就是 ts 的模式匹配那一套，根据特定字段的值去具体确定一个对象的类型），但 Pydantic 的相对更为复杂一些——Python 是强类型语言，在 js 里一切皆 object，但 Python 中要区分成不同的类，而且这些类互相之间是没有继承关系的。</p>
<p>但在此之前，我们先验证一下 Python 本身是否支持 ts 的模式匹配，使用下面的代码，检查 IDE 是否正确识别下面的 v 究竟是 Nothing 还是 Just。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Nothing</span>[T]:<br>    <span class="hljs-built_in">type</span>: <span class="hljs-type">Literal</span>[<span class="hljs-string">&#x27;NOTHING&#x27;</span>] = field(default=<span class="hljs-string">&#x27;NOTHING&#x27;</span>)<br><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Just</span>[T]:<br>    value: T<br>    <span class="hljs-built_in">type</span>: <span class="hljs-type">Literal</span>[<span class="hljs-string">&#x27;JUST&#x27;</span>] = field(default=<span class="hljs-string">&#x27;JUST&#x27;</span>)<br><br><span class="hljs-built_in">type</span> Maybe[T] = Nothing[T] | Just[T]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">some_maybe</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span></span>) -&gt; Maybe[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> Just(i)<br>    <span class="hljs-keyword">return</span> Nothing()<br><br>v = some_maybe(<span class="hljs-number">111</span>)<br><br><span class="hljs-keyword">if</span> v.<span class="hljs-built_in">type</span> == <span class="hljs-string">&#x27;JUST&#x27;</span>:<br>    v.value <span class="hljs-comment"># int</span><br><span class="hljs-keyword">else</span>:<br>    v.<span class="hljs-built_in">type</span> <span class="hljs-comment"># NOTHING</span><br><br><span class="hljs-keyword">if</span> v.<span class="hljs-built_in">type</span> == <span class="hljs-string">&#x27;NOTHING&#x27;</span>:<br>    v.value <span class="hljs-comment"># Any</span><br><span class="hljs-keyword">else</span>:<br>    v.value <span class="hljs-comment"># int</span><br></code></pre></div></td></tr></table></figure>
<p>但是，我为什么要学 ts？Python 的类本身就有类型信息，为什么要一个 type 字段？下面的实现<strong>更现代</strong>，更 Python：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Nothing</span>[T]: <span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Just</span>[T]:<br>    value: T<br><br><span class="hljs-built_in">type</span> Maybe[T] = Nothing[T] | Just[T]<br><br>v = cast(Maybe[<span class="hljs-built_in">int</span>], Just(<span class="hljs-number">100</span>))<br><br><span class="hljs-keyword">match</span> v:<br>    <span class="hljs-keyword">case</span> Just(x):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;just <span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">case</span> Nothing():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;nothing&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>直接展示代码，这代码会给人一点惊吓。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Annotated, <span class="hljs-type">Literal</span>, TypeAliasType, cast<br><span class="hljs-keyword">from</span> annotated_types <span class="hljs-keyword">import</span> Gt<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field, TypeAdapter, ValidationError, computed_field<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Nothing</span>[T](BaseModel): <br>    <span class="hljs-built_in">type</span>: Annotated[<span class="hljs-type">Literal</span>[<span class="hljs-string">&#x27;NOTHING&#x27;</span>], Field(default=<span class="hljs-string">&#x27;NOTHING&#x27;</span>)]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Just</span>[T](BaseModel):<br>    value: T<br>    <span class="hljs-built_in">type</span>: Annotated[<span class="hljs-type">Literal</span>[<span class="hljs-string">&#x27;JUST&#x27;</span>], Field(default=<span class="hljs-string">&#x27;JUST&#x27;</span>)]<br><br><span class="hljs-built_in">type</span> Maybe[T] = Annotated[Nothing[T] | Just[T], Field(discriminator=<span class="hljs-string">&#x27;type&#x27;</span>)]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WTF_MAN</span>[T](BaseModel):<br>    maybe: Maybe[T]<br><br><span class="hljs-comment"># 我操这是什么玩法？？？</span><br><span class="hljs-built_in">print</span>(WTF_MAN[<span class="hljs-built_in">int</span>].model_validate(&#123;<span class="hljs-string">&#x27;maybe&#x27;</span>: &#123;<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;NOTHING&#x27;</span>&#125;&#125;))<br><span class="hljs-built_in">print</span>(WTF_MAN[<span class="hljs-built_in">int</span>].model_validate(&#123;<span class="hljs-string">&#x27;maybe&#x27;</span>: &#123;<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;JUST&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>: <span class="hljs-number">100</span>&#125;&#125;))<br></code></pre></div></td></tr></table></figure>
<h1 id="函数参数校验"><a href="#函数参数校验" class="headerlink" title="函数参数校验"></a>函数参数校验</h1><p>一个经典的问题是校验入参，Pydantic 提供了一个装饰器 <code>validate_call</code>，支持对函数的参数进行校验。这个装饰器同时支持 async 函数，支持不定参，支持关键字参数，以及支持校验返回值（默认不开启）……<strong>总之支持 Python 函数的一切特性</strong>，只能说牛逼。</p>
<p>而且这个装饰器还带来一个好处——<strong>Pydantic 顺便还把隐式类型转换给做了，这意味着我们可以依赖它，比如直接传给 datetime 字段一个日期字符串</strong>，如果不想要这个，可以配置它。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> ConfigDict, validate_call<br><br><span class="hljs-meta">@validate_call</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> a + b<br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>)) <span class="hljs-comment"># 3（！！注意 Pydantic 的类型转换！！）</span><br><br><span class="hljs-meta">@validate_call(<span class="hljs-params">config=ConfigDict(<span class="hljs-params">strict=<span class="hljs-literal">True</span></span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> a + b<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(add(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>))<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;strict!&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>遗憾的是，这个装饰器不支持泛型</strong>。</p>
<h1 id="和-dataclass，TypedDict，NamedTuple-协同工作"><a href="#和-dataclass，TypedDict，NamedTuple-协同工作" class="headerlink" title="和 dataclass，TypedDict，NamedTuple 协同工作"></a>和 dataclass，TypedDict，NamedTuple 协同工作</h1><p>首先，Pydantic 提供了一个自己的 dataclasses 模块，它和标准库的 dataclass 兼容，只需要使用 Pydantic 提供的 dataclass 便可以利用上 Pydantic 的校验机制，这在不想使用 BaseModel 而想使用 dataclass 那样的模式又想品尝到校验机制时可以选择。这里不表。</p>
<p>要和 dataclass，TypedDict，NamedTuple 一起工作，即<strong>和原始 Python 类型的类型标注协同工作，需要使用 TypeAdapter</strong>，这里的 Adapter 的意思，显然就是将 Python 类型标注适配为 Pydantic 类型元信息。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypedDict, NamedTuple<br><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> TypeAdapter<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Idol1</span>(<span class="hljs-title class_ inherited__">TypedDict</span>):<br>    name: <span class="hljs-built_in">str</span><br>    age: <span class="hljs-built_in">int</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Idol2</span>(<span class="hljs-title class_ inherited__">NamedTuple</span>):<br>    name: <span class="hljs-built_in">str</span><br>    age: <span class="hljs-built_in">int</span><br><br>Idol3 = NamedTuple(<span class="hljs-string">&#x27;Idol3&#x27;</span>, [(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-built_in">str</span>), (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-built_in">int</span>)])<br><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Idol4</span>:<br>    name: <span class="hljs-built_in">str</span><br>    age: <span class="hljs-built_in">int</span><br><br>data  = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;amami haruka&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;17&#x27;</span>&#125;<br><br>ta = TypeAdapter(Idol1)<br><span class="hljs-built_in">print</span>(ta.validate_python(data))<br>ta = TypeAdapter(Idol2)<br><span class="hljs-built_in">print</span>(ta.validate_python(data))<br>ta = TypeAdapter(Idol3)<br><span class="hljs-built_in">print</span>(ta.validate_python(data))<br>ta = TypeAdapter(Idol4)<br><span class="hljs-built_in">print</span>(ta.validate_python(data))<br></code></pre></div></td></tr></table></figure>
<h1 id="自定义校验（即反序列化）"><a href="#自定义校验（即反序列化）" class="headerlink" title="自定义校验（即反序列化）"></a>自定义校验（即反序列化）</h1><p>就像 Hibernate Validator 和 Jackson 的 Serde，<strong>Pydantic 支持配置字段和模型级别的校验器</strong>，其中均允许配置<strong>前校验、后校验，环绕校验——对原始输入进行校验，对类型转换后的数据进行校验，对转换前后的数据进行校验</strong>。</p>
<p>校验器是什么呢？可以认为，校验器就是接受输入，然后返回校验后的值的一个 Callable，这个值可以和原值不同（做修改，或者类型转换等）。</p>
<p>同时，这个 Callable 可以抛出异常，Pydantic 支持<code>ValueError</code>，<code>AssertionError</code>，<code>PydanticCustomError</code>，Pydantic 会将这些异常包装成 <code>ValidationError</code>。Assertion 看着很香，但注意它在生产环境可能是会被关闭的！</p>
<h2 id="字段校验"><a href="#字段校验" class="headerlink" title="字段校验"></a>字段校验</h2><p>有两种方式去自定义校验器——使用 Annotated 模式，或者使用 field_validator 装饰器，显然前者供复用，后者临时用。</p>
<p>最常用的是<strong>后校验</strong>——<strong>后校验在 Pydantic 内置校验之后发生，因此类型安全，容易实现</strong>。下面同时展示 Annotated 模式和 Decorator 模式的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Annotated<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> AfterValidator, field_validator, BaseModel, ValidationError<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_even</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">assert</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> i<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeModel</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    field1: Annotated[<span class="hljs-built_in">int</span>, AfterValidator(is_even)]<br>    field2: <span class="hljs-built_in">int</span><br><br><span class="hljs-meta">    @field_validator(<span class="hljs-params"><span class="hljs-string">&#x27;field2&#x27;</span></span>)</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_even</span>(<span class="hljs-params">cls, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span> is not an even number&#x27;</span>)<br>        <span class="hljs-keyword">return</span> i<br><br><span class="hljs-keyword">try</span>:<br>    SomeModel(field1=<span class="hljs-number">1</span>, field2=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e)<br><span class="hljs-keyword">try</span>:<br>    SomeModel(field1=<span class="hljs-number">2</span>, field2=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e)<br></code></pre></div></td></tr></table></figure>
<p>前面提到，后校验发生在 Pydantic 内部校验之后，后校验的输入是 Pydantic 内部校验的输出，输出是用户看到的值，而<strong>前校验，输入是原始输入，输出喂给 Pydantic 的内部校验</strong>。</p>
<p>前校验器显然是更灵活的——它接受任意的输入并作处理然后再做后续流程。考虑一个经典问题：使用一个字符串传多个半角逗号分割的 ID 集合。下面同时以两种方式写：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Annotated<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BeforeValidator, field_validator, BaseModel<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">collection_str</span>(<span class="hljs-params">ids_str</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(ids_str, <span class="hljs-built_in">str</span>):<br>        <span class="hljs-keyword">return</span> ids_str.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(ids_str, <span class="hljs-built_in">list</span>):<br>        <span class="hljs-keyword">return</span> ids_str<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">str</span>(ids_str)]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeModel</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    field1: Annotated[<span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>], BeforeValidator(collection_str)]<br>    field2: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]<br><br><span class="hljs-meta">    @field_validator(<span class="hljs-params"><span class="hljs-string">&#x27;field2&#x27;</span>, mode=<span class="hljs-string">&#x27;before&#x27;</span></span>)</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">collection_str</span>(<span class="hljs-params">cls, i</span>):<br>        <span class="hljs-keyword">return</span> collection_str(i)<br><br><span class="hljs-built_in">print</span>(SomeModel(field1=<span class="hljs-string">&#x27;1,2,3&#x27;</span>, field2=[<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-string">&#x27;234&#x27;</span>]))<br></code></pre></div></td></tr></table></figure>
<p>注意——<strong>前校验器抛出异常不代表校验失败，比如 Union 类型，左边的类型校验失败后 Pydantic 会尝试右边的类型</strong>，这意味着<strong>前校验器不应当修改可变对象</strong>。</p>
<p>然后有个所谓的 PlainValidator，这个……它行为是 BeforeValidator，然而<strong>终止后续流程，直接把结果返回给用户</strong>。</p>
<p>最灵活的则是<strong>环绕校验</strong>，最灵活，它类似 Servlet 的 Filter，直接展示它的定义（<strong>注意它只有 Annotated 模式，Decorator 模式不支持它</strong>）：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> ValidatorFunctionWrapHandler, ValidationError<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_nothing</span>(<span class="hljs-params">value, handler: ValidatorFunctionWrapHandler</span>):<br>    <span class="hljs-comment"># 前校验器、Pydantic 内部校验之前</span><br>    <span class="hljs-comment"># do something...</span><br>    <span class="hljs-keyword">try</span>:<br>        result = handler(value) <span class="hljs-comment"># 前校验器，Pydantic 内部校验，后校验器</span><br>    <span class="hljs-keyword">except</span> ValidationError:<br>        <span class="hljs-comment"># 捕获这些校验器产生的异常</span><br>        <span class="hljs-comment"># do something...</span><br>        <span class="hljs-keyword">raise</span><br><br>    <span class="hljs-comment"># Pydantic 内部校验，后校验器之后</span><br>    <span class="hljs-comment"># do something...</span><br>    <span class="hljs-keyword">return</span> result<br></code></pre></div></td></tr></table></figure>
<h2 id="模型校验"><a href="#模型校验" class="headerlink" title="模型校验"></a>模型校验</h2><p>说句题外话，Pydantic 中没有像 Hibernate Validator 那样的校验组机制。</p>
<p>在 Hibernate Validator 中，我只使用过字段校验，然而实际上它也是支持模型校验的。Pydantic 同样支持模型校验，即<strong>对整个模型进行校验，因此可以看到字段之间的关系</strong>。</p>
<p>模型校验支持后校验，前校验，和环绕校验。<strong>考虑到模型校验是无法重用的，Pydantic 只提供了 Decorator 模式去实现校验</strong>。具体的说，使用<code>model_validator</code>装饰器。</p>
<p><strong>后校验使用实例方法（因此是实例化后执行的），前校验和环绕校验使用类方法</strong>。这里只写后校验的示例，因为我已经有点麻了：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> model_validator, BaseModel<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResetPasswordDto</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    username: <span class="hljs-built_in">str</span><br>    new_password: <span class="hljs-built_in">str</span><br>    new_password_repeat: <span class="hljs-built_in">str</span><br><br><span class="hljs-meta">    @model_validator(<span class="hljs-params">mode=<span class="hljs-string">&#x27;after&#x27;</span></span>) </span><span class="hljs-comment"># mode 必须给定</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_password_match</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.new_password != self.new_password_repeat:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Passwords do not match&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self <span class="hljs-comment"># 还能换成别人？？</span><br>    <br>ResetPasswordDto(username=<span class="hljs-string">&#x27;abc&#x27;</span>, new_password=<span class="hljs-string">&#x27;pass&#x27;</span>, new_password_repeat=<span class="hljs-string">&#x27;pass&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>我不研究各个校验器的执行顺序——我又不是去面试！真遇到问题再说！</strong></p>
<h1 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h1><p>配置序列化有四种方式，<code>@field_serializer</code>，<code>@model_serializer</code>，<code>PlainSerializer</code>，<code>WrapSerializer</code>。</p>
<p><code>@field_serializer</code>不能配置 mode，<code>@model_serialzer</code>能配置 wrap 或者 plain，显然<code>@field_serializer</code>在<code>model_serializer</code>配置为 plain 时是不会起效的。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> field_serializer, model_serializer, BaseModel<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    hello: <span class="hljs-built_in">str</span><br>    <br>    <span class="hljs-comment"># 如果签名没有返回值类型，需要配置 return_type 指定返回类型</span><br>    <span class="hljs-comment"># when_used=&#x27;json&#x27; 表示只有序列化成 json（兼容）模式时才生效</span><br>    <span class="hljs-comment"># 要知道，Pydantic 是能把模型序列化成 dict 的</span><br><span class="hljs-meta">    @field_serializer(<span class="hljs-params"><span class="hljs-string">&#x27;hello&#x27;</span>, when_used=<span class="hljs-string">&#x27;json&#x27;</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ser_hello</span>(<span class="hljs-params">x: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> x.upper()<br><br>    <span class="hljs-comment"># 会覆盖掉上面的 field_serializer</span><br>    <span class="hljs-comment"># @model_serializer(mode=&#x27;plain&#x27;)</span><br>    <span class="hljs-comment"># def ser_self(self):</span><br>    <span class="hljs-comment">#     return &#123;&#x27;hello&#x27;: &#x27;world!&#x27;&#125;</span><br>    <br>h = Hello(hello=<span class="hljs-string">&#x27;world&#x27;</span>)<br><span class="hljs-built_in">print</span>(h.model_dump()) <span class="hljs-comment"># &#123;&#x27;hello&#x27;: &#x27;world&#x27;&#125;</span><br><span class="hljs-built_in">print</span>(h.model_dump(mode=<span class="hljs-string">&#x27;json&#x27;</span>)) <span class="hljs-comment"># &#123;&#x27;hello&#x27;: &#x27;WORLD&#x27;&#125;</span><br><span class="hljs-built_in">print</span>(h.model_dump_json()) <span class="hljs-comment"># &#123;&quot;hello&quot;:&quot;WORLD&quot;&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>两个 Annotated 模式的 Serializer，显然<strong>是适用于字段的</strong>，使用方式和上面的一致，这里不表了。</p>
<h1 id="关于日期的序列化、反序列化"><a href="#关于日期的序列化、反序列化" class="headerlink" title="关于日期的序列化、反序列化"></a>关于日期的序列化、反序列化</h1><p>接下来是一个究极经典的问题——对日期的序列化、反序列化，就像 Jackson 的 JsonFormat 注解。</p>
<p>首先，Pydantic 对 date，datetime，默认的序列化、反序列化逻辑是怎样的？</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, date<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Annotated<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BeforeValidator, PlainSerializer, TypeAdapter<br><br>date_ta = TypeAdapter(date)<br>datetime_ta = TypeAdapter(datetime)<br><br>now_datetime = datetime.now()<br><br>date_ta.validate_python(date(year=<span class="hljs-number">2023</span>,month=<span class="hljs-number">1</span>,day=<span class="hljs-number">1</span>)) <span class="hljs-comment"># passed</span><br>date_ta.validate_python(datetime(year=<span class="hljs-number">2023</span>,month=<span class="hljs-number">1</span>,day=<span class="hljs-number">1</span>)) <span class="hljs-comment"># passed</span><br>date_ta.validate_python(now_datetime.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)) <span class="hljs-comment"># passed</span><br>date_ta.validate_python(now_datetime.strftime(<span class="hljs-string">&#x27;%Y-%m-%d 00:00:00&#x27;</span>)) <span class="hljs-comment"># passed</span><br><br><span class="hljs-comment"># failed!!!</span><br><span class="hljs-comment"># date 的所有时间必须全部是 0！</span><br><span class="hljs-comment"># date_ta.validate_python(now_datetime.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)) </span><br><br>datetime_ta.validate_python(date(year=<span class="hljs-number">2023</span>,month=<span class="hljs-number">1</span>,day=<span class="hljs-number">1</span>)) <span class="hljs-comment"># passed</span><br>datetime_ta.validate_python(datetime(year=<span class="hljs-number">2023</span>,month=<span class="hljs-number">1</span>,day=<span class="hljs-number">1</span>)) <span class="hljs-comment"># passed</span><br>datetime_ta.validate_python(now_datetime.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)) <span class="hljs-comment"># passed</span><br>datetime_ta.validate_python(now_datetime.strftime(<span class="hljs-string">&#x27;%Y-%m-%d 00:00:00&#x27;</span>)) <span class="hljs-comment"># passed</span><br></code></pre></div></td></tr></table></figure>
<p>注意到：</p>
<ol>
<li>date，datetime 均接受我们最熟悉的<code>YYYY-MM-dd</code>和<code>YYYY-MM-dd HH:mm:ss</code>格式</li>
<li>datetime 接受精确到时分秒的表示，但也能接受日期表示（后者在 strict 模式下不合法）</li>
<li>date 接受日期表示，但也能接受精确到时分秒的表示，只是时分秒必须为 0</li>
</ol>
<p>我想到两种方式：</p>
<ol>
<li>使用类似注解的形式——提供一个可配置的元信息去模拟 JsonFormat 注解</li>
<li>提供预先添加上面的元信息的类型</li>
</ol>
<p>其实两种都是同样的对不对？这里操作一个：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, date<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Annotated<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BeforeValidator, PlainSerializer, TypeAdapter<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">time_formatter</span>(<span class="hljs-params">pattern: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-comment"># 校验 pattenr 是否是合法 pattern</span><br>    datetime.now().strftime(pattern)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ser</span>(<span class="hljs-params">x: datetime | date</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> x.strftime(pattern)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deser</span>(<span class="hljs-params">x</span>) -&gt; datetime:<br>        <span class="hljs-keyword">return</span> datetime.strptime(<span class="hljs-built_in">str</span>(x), pattern)<br><br>    <span class="hljs-keyword">return</span> BeforeValidator(deser), PlainSerializer(ser)<br><br><span class="hljs-comment"># 这里得做一个解构……似乎也有不用解构的方式，见 annotated_types 包下的 Interval</span><br>YYYYMMDD_DATE = Annotated[date, *time_formatter(<span class="hljs-string">&#x27;%Y--%m--%d&#x27;</span>)]<br><br><span class="hljs-comment"># 换成字面量就是第一种了</span><br>ta = TypeAdapter(YYYYMMDD_DATE)<br><br>deser_test = ta.validate_python(<span class="hljs-string">&#x27;2025--12--31&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(deser_test), deser_test) <span class="hljs-comment"># &lt;class &#x27;datetime.date&#x27;&gt; 2025-12-31</span><br><br>ser_test = ta.dump_json(deser_test)<br><span class="hljs-built_in">print</span>(ser_test) <span class="hljs-comment"># b&#x27;&quot;2025--12--31&quot;&#x27;</span><br><br>YYYYMMDD_HHMMSS_DATETIME = Annotated[datetime, *time_formatter(<span class="hljs-string">&#x27;%Y-%m-%d//%H:%M:%S&#x27;</span>)]<br>ta = TypeAdapter(YYYYMMDD_HHMMSS_DATETIME)<br><br>d = ta.validate_python(<span class="hljs-string">&#x27;2025-12-31//12:34:56&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(d), d) <span class="hljs-comment"># &lt;class &#x27;datetime.datetime&#x27;&gt; 2025-12-31 12:34:56</span><br><span class="hljs-built_in">print</span>(ta.dump_json(d)) <span class="hljs-comment"># b&#x27;&quot;2025-12-31 12:34:56&quot;&#x27;</span><br></code></pre></div></td></tr></table></figure>
<h1 id="配置-Model"><a href="#配置-Model" class="headerlink" title="配置 Model"></a>配置 Model</h1><p>Pydantic 支持配置 Model 的校验、序列化配置，这些配置能够影响其所有字段的行为（实际上就是处理 Pydantic 关于内部校验的行为）。该配置利用所谓的<code>ConfigDict</code>类。配置似乎是不会递归影响的，只会影响本层。</p>
<p>无论是 BaseModel，Typeadapter，Pydantic 的 dataclass，还是 Python 自己的 dataclass，TypedDict 等，均允许进行配置。</p>
<ul>
<li>对 BaseModel，直接设置类字段<code>model_config</code>。</li>
<li>对 Pydantic 的 dataclass，设置装饰器中的 config 字段。</li>
<li>对 TypeAdapter，通过参数传递。</li>
<li>对 Python 的 dataclass，设置<code>__pydantic_config__</code>字段或者使用<code>with_config</code>装饰器。</li>
<li>对 TypedDict，只能使用<code>with_config</code>装饰器。</li>
</ul>
<p>ConfigDict 中具体能配置这些信息：</p>
<ol>
<li>JSON Schema 相关的生成</li>
<li>字符串的默认处理（全大写，小写，strip，长度等）</li>
<li>对多余字段的处理，<strong>默认是忽略</strong>，可以配置为 allow，这时候多余字段会存储到<code>__pydantic_extra__</code>字段下</li>
<li>是否 frozen，是否 strict……</li>
<li>关于枚举的配置</li>
<li>JSON 中日期的序列化方式，JSON 字节串的编解码方式</li>
</ol>
<p>就这样吧。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Python/">Python</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-NC-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04-19-2%E3%80%90%E5%91%A8%E8%AE%B0%E3%80%91%E8%A7%81%E4%BA%86%E9%AC%BC%E7%9A%84%E4%B8%80%E5%91%A87.html">
                        <span class="hidden-mobile">【周记】见了鬼的一周 7</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start -->
<script src="/assets/prism-bundle.js"></script>
<script src="/assets/prism-plus.js" data-pjax=""></script>
<!-- hexo injector body_end end --></body>
</html>
