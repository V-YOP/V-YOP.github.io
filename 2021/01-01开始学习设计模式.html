

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="友纪V-λOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="RT，学习设计模式对于我的发展和就业是很有帮助的。">
<meta property="og:type" content="article">
<meta property="og:title" content="开始学习设计模式——迭代器模式和适配器模式">
<meta property="og:url" content="http://example.com/2021/01-01%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">
<meta property="og:site_name" content="友纪V-λOP">
<meta property="og:description" content="RT，学习设计模式对于我的发展和就业是很有帮助的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/12/29/xblpFUkzGRIE8Hn.png">
<meta property="og:image" content="https://i.loli.net/2020/12/31/SWk6B9IcCF4qKmN.png">
<meta property="og:image" content="https://i.loli.net/2020/12/31/rMxnDy5g4PuCfYe.png">
<meta property="og:image" content="https://i.loli.net/2020/12/31/OdVDhZRkug7ybLr.png">
<meta property="og:image" content="https://i.loli.net/2020/12/31/eulizV3af98Sr5T.png">
<meta property="article:published_time" content="2021-01-01T00:00:00.000Z">
<meta property="article:modified_time" content="2023-11-12T03:44:40.282Z">
<meta property="article:author" content="友纪V-λOP">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2020/12/29/xblpFUkzGRIE8Hn.png">
  
  
  <title>开始学习设计模式——迭代器模式和适配器模式 - 友纪V-λOP</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":100},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="友纪V-λOP" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友纪V-λOP的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="开始学习设计模式——迭代器模式和适配器模式">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-01 08:00" pubdate>
        2021年1月1日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.8k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">开始学习设计模式——迭代器模式和适配器模式</h1>
            
            <div class="markdown-body">
              <!--Hello, Happy World-->

<p>开始看结城浩的《图解设计模式》～（对日本人写的书总有种莫名其妙的亲近感，或许是因为他们的语言比较……轻松？）</p>
<blockquote>
<p>这个老师似乎也写过 Java 多线程相关的书籍，先观望一个。</p>
</blockquote>
<p>什么是设计模式（Design Pattern）？我认为，我们在不断地编写代码的过程中，在不断地 debug，重构，思考中，经常会发现一些“套路”，发现这样那样编写能让代码容易维护，容易复用，写起来优雅 etc… 对这些“套路”进行系统的分析，归纳出来概念，形式，确定它的适用范围……这样所诞生的就是设计模式，它归根结底是从丰富的实践经验中抽象出来的，又反作用于我们的实践，帮助我们编写更加有可复用性，可维护性，高内聚低耦合的代码。<strong>就这方面</strong>（！类比只是类比，而不是论证，只负责提供一种感性经验罢了）来说，设计模式与具体的编程的关系，就如哲学同具体科学的关系一样。</p>
<blockquote>
<p>设计模式用来表现内部组件如何被<strong>组装</strong>在一起。一场话剧能由无数届演员来演，可是剧情（剧中人与人的<strong>关系</strong>）总是变动较少的。</p>
</blockquote>
<blockquote>
<p>其实我觉得粗糙地说，<code>for (int i = 0; i &lt; arr.length; i++)</code>这样的也算是设计模式 w</p>
</blockquote>
<blockquote>
<p>面向对象是一种设计模式，面向过程也是一种设计模式，Lisp 语言的宏编程也是一种设计模式，这是毫无疑问的。</p>
</blockquote>
<p>设计模式的目标有二——<strong>复用</strong>和易维护。应时时刻刻记住这两点。</p>
<p>不过也正如学习哲学一样，如果没有积累丰富的感性经验（无论是对日常生活的，还是对科学的），上来就整抽象的东西容易钻到牛角尖里，无法联系实际看问题。希望这本书能够提供足够的实例让我积累感性经验。</p>
<p>一个非常非常非常非常需要注意的地方是，此书基于 Java 2，所以<strong>没有泛型</strong>（因为这点，或许书中很多代码需要重构），没有函数式特性，没有 foreach 的语法糖……随便翻了几页，还觉得它有时候讲的不全面……应当批判地学习，同时应当多联系 Java 的源码。</p>
<p>先开个头，学一学它讲解的最早的两个设计模式——Iterator 迭代器模式和 Adapter 适配器模式。</p>
<h1 id="Iterator-模式——迭代器"><a href="#Iterator-模式——迭代器" class="headerlink" title="Iterator 模式——迭代器"></a>Iterator 模式——迭代器</h1><p>Iterator 模式归根结底是为（以各种方式）遍历各种不同的数据结构提供一套相同的接口，它满足这样的形式——</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Iterator</span> <span class="hljs-variable">iter</span> <span class="hljs-operator">=</span> colle.iterator(); <span class="hljs-comment">// 这其实……也算是一个工厂模式？</span><br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123; <span class="hljs-comment">// 当然我们也都知道，现在 Java 提供了一套 foreach 的语法糖来自动使用迭代器</span><br>    <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> iter.next();<br>    . . .<br>&#125;<br><span class="hljs-comment">// Java 为实现了 java.lang.iterable 的实现提供了这样的语法糖……</span><br><span class="hljs-keyword">for</span> (item i : aggregate) &#123;<br>    . . .<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>迭代器的优点在于，它抽象了对对象的遍历操作，让对各种不同集合（容器）对象的遍历的操作都变得统一。如果没有这种设计模式的话，该怎么办呢？那对每种数据结构，都需要<strong>根据它的具体实现</strong>（！）来确定对它的遍历方式，比如对于数组，我们就用<code>for (int i = 0; i &lt; arr.length; i++)</code>，对于链表，我们就<code>for (Node i = head; i != null; i = i.next)</code>，那对于树，对于堆，对于图呢？对于哈希表的拉链实现和数组——红黑树实现呢？对这样的形式该如何实现？显然，必须要根据其内部数据结构（和需要迭代的方式）来决定实现。迭代器其实也可以说是对这里的循环变量 i 抽象化了。</p>
<p>因此就可以使用迭代器模式。根据书中的一个例子来说——</p>
<p><img src="https://i.loli.net/2020/12/29/xblpFUkzGRIE8Hn.png"></p>
<p>在这里，Aggregate 表示一种集合（容器）类型接口，它只提供 iterator 接口。Iterator 接口就是迭代器接口，hasNext 判断是否还能继续迭代，next 方法则是获取一个元素，并让迭代器指针后移指向下一个元素。BookShelf 是为了实验而创建的数据结构，它实现 Aggregate 接口，内部存储 Book 对象（以数组形式），last 表示下一个要插入的元素的位置（同时也是已插入的元素的数量）。它的 iterator 方法返回一个对它自身的迭代器。需要注意的是，<strong>是迭代器包含类，而不是类包含迭代器</strong>，因为一个类可以同时存在多个迭代器进行迭代。</p>
<p>上源码。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Aggregate.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> MyIterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//MyIterator.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyIterator</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    T <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//Book.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//BookShelf.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookShelf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&lt;Book&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> Book[] books;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getBookAt</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">return</span> books[i];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendBook</span><span class="hljs-params">(Book book)</span> &#123;<br>        books[last++] = book;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookShelf</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>        books  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>[size];<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> MyIterator&lt;Book&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookIterator</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>然后是最重要的迭代器代码——</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//BookIterator.java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BookIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyIterator</span>&lt;Book&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br>    <span class="hljs-keyword">private</span> BookShelf bookshelf;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookIterator</span><span class="hljs-params">(BookShelf obj)</span> &#123;<br>        bookshelf = obj;<br>        index = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> index &lt; bookshelf.getLength();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> bookshelf.getBookAt(index++);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>它的使用如下——</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BookShelf</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookShelf</span>(<span class="hljs-number">10</span>);<br>        books.appendBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;双城记&quot;</span>));<br>        books.appendBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;毁灭&quot;</span>));<br>        books.appendBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;罗密欧与朱丽叶&quot;</span>));<br>        MyIterator&lt;Book&gt; iter = books.iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            System.out.println(iter.next().getName());<br>        &#125;<br>        <span class="hljs-comment">//也可以使用 for 循环来使用迭代器</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>一个原则是，对于声明类型，能用基类就用基类，能用接口就用接口。</p>
</blockquote>
<p>同时，迭代器也允许使用不同的迭代方式，只需要更改 next 和 hasNext 方法即可，比如跳跃着遍历，反向遍历……还能在迭代器内部暂存信息并不暴露给外界，比如遍历树的时候在迭代器里放个栈，队列之类的。这显然是符合抽象的。</p>
<p>问题：Java 中 iterable 是什么？它和迭代器有什么关系？</p>
<h1 id="Adapter-模式——适配器"><a href="#Adapter-模式——适配器" class="headerlink" title="Adapter 模式——适配器"></a>Adapter 模式——适配器</h1><p>所谓适配器模式，就是将别人的不能直接复用的代码拿来进行一些包装，让它能够被复用。这里帮助别人的代码适配我们的需要的设计模式就叫适配器（Adapter），也叫包装器（Wrapper），因为它不直接使用别人的代码，而是进行一些包装后使用。就像笔记本的适配器把 220 伏的交流电转成 12 伏的直流电一样。Adapter 的意思是“使……相互适合的东西”。</p>
<p>适配器模式中需要四个角色——Client，Target，Adapter，Adaptee，它们的关系是——Client（笔记本电脑）使用 Adapter（电源适配器），将 Adaptee（220 伏交流电）转换成它所需要的 Target（12 伏直流电）。其中 Client 是调用适配器的对象，Adapter 是适配器，Adaptee 是别人的需要进行包装的代码（因此不应直接修改），Target 是 Client 所需的方法。</p>
<p>适配器模式有两种实现——</p>
<ul>
<li>类适配器模式（使用<strong>继承</strong>的适配器）</li>
<li>对象适配器模式（使用<strong>委托</strong>的适配器）</li>
</ul>
<blockquote>
<p>此书给出的类适配器模式我觉得有一些漏洞，出现了抽象泄露的问题（虽然作者不可能没有意识到这个问题，因为习题 1 就涉及到了这个问题）。我认为，在设计自己的类库（就比如这里实现的适配器，对别人的类库进行包装，其实可以认为这里的 Target，Adapter，Adaptee 是自己设计出来的类库（其中 Adaptee 是“别人的代码”，在设计适配器的时候不应该对 Adaptee 进行任何改动），Client 是使用该类库的客户端）的时候，应该认为用户是“愚蠢”的，否则面向对象的<strong>封装</strong>原则就被破坏了。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/12/31/SWk6B9IcCF4qKmN.png"></p>
<p>这张图非常好地表现了适配器的功能和（对象适配器模式的）形式。</p>
<h2 id="类适配器实例"><a href="#类适配器实例" class="headerlink" title="类适配器实例"></a>类适配器实例</h2><p>所谓类适配器模式，就是编写 Adapter 继承 Adaptee，实现所需要的接口（Target）。</p>
<p>本书提供了这样一个实例——</p>
<p><img src="https://i.loli.net/2020/12/31/rMxnDy5g4PuCfYe.png"></p>
<p>首先有一个 Banner 类，这里假设是别人已经编写好的，要复用它。它提供了两个功能——将字符串用括号包围或用*包围，它的实现是非常简单的。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Banner.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Banner</span> &#123;<br>    <span class="hljs-keyword">private</span> String str;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Banner</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-built_in">this</span>.str = str;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showWithParen</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;(%s)&quot;</span>, str));<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showWithAster</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;*%s*&quot;</span>, str));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>我们的需求（也就是 Target）是 Print 接口，Print 接口假设有两个语法，使用成对括号包围字符串规定字符串变细，使用**包围则是规定字符串加粗。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Print.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Print</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span>; <span class="hljs-comment">// abstract 对于接口其实是无必要的，毕竟只有 default 方法能够添加实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>PrintBanner 担任 Adapter 的角色，它要提供 Target（因此就要实现 Print 接口），同时继承 Adaptee 以复用其代码。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//PrintBanner.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintBanner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Banner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Print</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintBanner</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-built_in">super</span>(str);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.showWithParen();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.showWithAster();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>然后是 Main，Main 担任 Client 的角色，它使用 Adapter 提供的 Print 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Print</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintBanner</span>(<span class="hljs-string">&quot;hello, happy world&quot;</span>); <span class="hljs-comment">// 我觉得有点问题。</span><br>        p.printStrong();<br>        p.printWeak();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>可见，Adaptee 的操作被包装（wrap）起来了，用户（Client）通过使用 Adapter 提供的接口（Target）来间接访问 Adaptee。</p>
<p>但我认为这里的抽象有一些问题——<strong>如何保证用户必然使用 Print 接口来作为声明类型</strong>？如果用户偏偏不按需求来，使用 PrintBanner 作为声明类型，进行这样的操作怎么办？</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">PrintBanner</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintBanner</span>(<span class="hljs-string">&quot;hello,happy world&quot;</span>);<br>p.showWithAster(); <span class="hljs-comment">// 合法！</span><br>p.showWithParen();<br></code></pre></div></td></tr></table></figure>

<p>这在语法上并无问题，但是这显然<strong>破坏了封装</strong>！用户不应该能通过任何途径来<strong>直接</strong>访问到 Adaptee。在这个示例中不会出问题，但若是联想上面的笔记本电源适配器的例子，就相当与是说用户可以直接把 220V 的交流电连接在笔记本电脑（而不是转换成 12V 直流电之后）上了，这不就出了事？我想也没有语法能够屏蔽父类的方法，只能重写或将父类方法改成 protected，但这也是不好的，我们很多时候不能更改别人的代码。</p>
<p>因此我认为类适配器有这样的缺陷——类库设计者必须与使用者做<strong>约定</strong>，要求使用者必须使用 Target 作为声明类型，才能正常使用。而且如果想要复用的是 final 类，则是不能使用的。</p>
<h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><p>对象适配器容易描述。它是指 Adapter 包含一个 Adaptee 实例，通过<strong>委托</strong>（也就是将方法的执行交给另一个类（实例）执行）的方式让 Client 访问 Adaptee。</p>
<p>该方法相对于类适配器只需要更改 PrintBanner 类。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//PrintBanner.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintBanner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Print</span>&#123;<br>    <span class="hljs-keyword">private</span> Banner banner;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintBanner</span><span class="hljs-params">(String str)</span> &#123;<br>        banner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Banner</span>(str);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span> &#123;<br>        banner.showWithParen();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span> &#123;<br>        banner.showWithAster();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这样的一个好处是，不再需要和 Client 做额外约定了，无论 Client 使用 Print 还是 PrintBanner 作为声明类型，都不会出问题。</p>
<blockquote>
<p>这一段是自己的想法，可能有错误。<br>我认为对象适配器模式中适配器的角色<strong>更加符合其概念</strong>。一般来说，<strong>Adapter 提供的功能应当是 Adaptee 的子集</strong>，也就是说，Adapter 能实现的方法，Adaptee 应当能实现，Adapter 不能实现的方法，Adaptee 也可能可以实现。比如，有一个库，能够把各种图片格式相互转换，比如 png, jpg, tiff, psd, pdf 等，但这时我只需要将 png 转换成其它格式，我就据此编写一个适配器，使用 Adaptee 功能的子集。而且使用委托的对象适配器模式，其结构也更加符合之前对适配器的感性理解。<br>然后考虑类适配器，类适配器使用继承来复用代码。而继承，虽然就概念来说，子类是基类的属概念，但是就功能，具体程度来说，子类是比基类更加具体的，在基类的基础上<strong>提供更多功能</strong>。因此这就和上面我所认为的 Adapter 同 Adaptee 提供的功能的关系相悖了。就上面的电源适配器的例子来说，就像是给 220V 交流电的电源<strong>加了个组件</strong>，让它能够转换成 12V 直流电，<strong>这个电源原本输出 220V 交流电的能力是没有改变的</strong>。这时就必须和用户做约定（Target），要求用户使用该 12V 的直流电。但是用户也有权力不遵守约定……</p>
</blockquote>
<p>对象适配器的 UML 类图如图。</p>
<p><img src="https://i.loli.net/2020/12/31/OdVDhZRkug7ybLr.png"></p>
<blockquote>
<p>学会看 UML 图还是比较方便的。</p>
</blockquote>
<p>使用适配器模式的目的是对现有的类进行适配，让其可复用，在出现 bug 的时候，也能够容易确定 bug 的位置出于 Adapter 中（假如 Adaptee 经过充分测试的话）。如果要去修改已经充分测试的类，则必须重新进行测试。</p>
<p>适配器模式也能够方便地让版本适配，从而让新旧版本兼容，让能够同时维护新版本和旧版本变得简单。</p>
<p><img src="https://i.loli.net/2020/12/31/eulizV3af98Sr5T.png"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>java.util.Properties 可以像这样管理键值对——</p>
<figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">year</span><span class="hljs-operator">=</span><span class="hljs-number">2021</span><br><span class="hljs-attribute">month</span><span class="hljs-operator">=</span><span class="hljs-number">4</span><br><span class="hljs-attribute">day</span><span class="hljs-operator">=</span><span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure>

<p>它提供了两个方法，帮助从<strong>流</strong>（<strong>这个需要去学习！</strong>）中取出属性（property）或将属性写入流中。要求使用 Adapter 适配器模式，编写一个将属性保存在文件中的 FileProperties 类。</p>
<p>扮演 Target 角色的 FileIO 接口如下——</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//FileIO.java</span><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileIO</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFromFIle</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToFile</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(String key, String value)</span>; <span class="hljs-comment">// 设置键值对</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getValue</span><span class="hljs-params">(String key)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>扮演 Adapter 角色的 FileProperties 类如下——</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//FileProperties.java</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileProperties</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileIO</span> &#123;<br>    <span class="hljs-keyword">private</span> Properties p;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileProperties</span><span class="hljs-params">()</span> &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFromFIle</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filename))) &#123;<br>            p.load(file);<br>        &#125;<br>    &#125; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToFile</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filename))) &#123;<br>            p.store(file,<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        p.setProperty(key, value);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getValue</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> p.getProperty(key);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>Client 角色如下——</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FileIO</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileProperties</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            f.readFromFIle(<span class="hljs-string">&quot;file.txt&quot;</span>);<br>            f.setValue(<span class="hljs-string">&quot;year&quot;</span>, <span class="hljs-string">&quot;21435&quot;</span>);<br>            f.setValue(<span class="hljs-string">&quot;month&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);<br>            f.setValue(<span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-string">&quot;2222&quot;</span>);<br>            f.writeToFile(<span class="hljs-string">&quot;newFile.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这本书将设计模式中各个组成部分称为“角色”相当精妙，而且有趣。感觉遇到了一个好的开始。</p>
<p>等回家后第一时间去学 Spring……其它的都缓缓。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-NC-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01-06%E7%BA%B5%E8%A7%88ArchLinux%E7%9A%84%E5%AE%89%E8%A3%85.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ArchLinux 及图形界面的安装</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12-26%E5%85%B3%E4%BA%8EThread%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.html">
                        <span class="hidden-mobile">关于 Thread 的一些代码</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start -->
<script src="/assets/prism-bundle.js"></script>
<script src="/assets/prism-plus.js" data-pjax=""></script>
<!-- hexo injector body_end end --></body>
</html>
