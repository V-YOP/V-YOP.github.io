

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="友纪V-λOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="没想到一整天都研究排序去了，拜它所赐，对 Partitioner，SortComparator，GroupComparator 等机制更为熟悉了。">
<meta property="og:type" content="article">
<meta property="og:title" content="MapReduce 开发模式 2——排序，二次排序，JOIN">
<meta property="og:url" content="http://example.com/2022/03-14MapReduce%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F2%E2%80%94%E2%80%94ORDER-BY%EF%BC%8CJOIN.html">
<meta property="og:site_name" content="友纪V-λOP">
<meta property="og:description" content="没想到一整天都研究排序去了，拜它所赐，对 Partitioner，SortComparator，GroupComparator 等机制更为熟悉了。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-14T15:06:58.000Z">
<meta property="article:modified_time" content="2024-01-07T08:02:45.494Z">
<meta property="article:author" content="友纪V-λOP">
<meta property="article:tag" content="MapReduce">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>MapReduce 开发模式 2——排序，二次排序，JOIN - 友纪V-λOP</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":100},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="友纪V-λOP" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友纪V-λOP的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="MapReduce 开发模式 2——排序，二次排序，JOIN">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-14 23:06" pubdate>
        2022年3月14日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MapReduce 开发模式 2——排序，二次排序，JOIN</h1>
            
            <div class="markdown-body">
              <h1 id="ORDER-BY（全局排序）"><a href="#ORDER-BY（全局排序）" class="headerlink" title="ORDER BY（全局排序）"></a>ORDER BY（全局排序）</h1><p>排序是一个常见的业务需求。我们不止可以用 MR 提供的原生类型进行排序，还能够用自定义的类型进行排序。在 SQL 中，我们使用 ORDER BY 子句进行排序，ORDER BY 子句可以接受一个或多个字段，也可以接受表达式。</p>
<p>MR 支持在两个地方进行排序——首先是 Reducer 接受的各 Mapper 发送的记录会按 KEY 进行归并排序；然后是对每个 KEY，允许在 KEY 对应的 VALUE 集合中进行排序，这个排序的进行是不太明显的。</p>
<p>考虑这样的需求——我们之前的航空公司数据集是按照月份和星期来排序的，现在突然需要将输出的数据按月份升序之后按星期降序去排序。<strong>我们要保证所有数据整体有序，且性能足够好</strong>。</p>
<p>之前学习过 MR 的排序机制，我们知道，如果想要让所有数据全排序并存放在同一个文件里，则只能使用一个 Reducer。否则我们必须定制化 Partitioner 和 KEY，以保证不同结果文件之间有序。</p>
<p>研究一下我们的业务，这里需要按月份去升序，按星期去降序，因此总共的索引数有 12 x 7 &#x3D; 84 个，它们顺序如下——</p>
<ol>
<li>1_7</li>
<li>1_6</li>
<li>…</li>
<li>2_7</li>
<li>…</li>
<li>12_2</li>
<li>12_1</li>
</ol>
<p>显然，<strong>Partitioner 需要保证所有相邻的索引必须分给同一个 Reducer</strong>。</p>
<p>首先，我们需要定义 KEY 类型（即 MonthDayWeek）以及 VALUE 类型（所需的结果），KEY 类型需要实现 WritableComparable 接口，VALUE 类型需要实现 Writable。</p>
<blockquote>
<p>不一定必须要 WritableComparable，也可以从外部指定另外的 Comparator，这个 Comparator 称为 SortComparator。</p>
</blockquote>
<p>类型的代码见此，非常繁琐，信息量很小。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> mapreduce<br><br><span class="hljs-keyword">import</span> mapreduce.<span class="hljs-type">DistributedSortJob</span>.args<br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.&#123;<span class="hljs-type">Configurable</span>, <span class="hljs-type">Configuration</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.<span class="hljs-type">Path</span><br><span class="hljs-keyword">import</span> org.apache.hadoop.io<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.&#123;<span class="hljs-type">IntWritable</span>, <span class="hljs-type">LongWritable</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Writable</span>, <span class="hljs-type">WritableComparable</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.&#123;<span class="hljs-type">FileInputFormat</span>, <span class="hljs-type">TextInputFormat</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.&#123;<span class="hljs-type">FileOutputFormat</span>, <span class="hljs-type">TextOutputFormat</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.&#123;<span class="hljs-type">Job</span>, <span class="hljs-type">Mapper</span>, <span class="hljs-type">Partitioner</span>, <span class="hljs-type">Reducer</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.util.<span class="hljs-type">GenericOptionsParser</span><br><br><span class="hljs-keyword">import</span> java.io.&#123;<span class="hljs-type">DataInput</span>, <span class="hljs-type">DataOutput</span>&#125;<br><span class="hljs-keyword">import</span> java.lang<br><br><span class="hljs-comment">// Scala 定义这玩意可太难受了，不能用类参数…否则 Scala 会创建出带参数的构造器，没法用反射创建了</span><br><span class="hljs-comment">// 键类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonthDayWeek</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparable</span>[<span class="hljs-type">MonthDayWeek</span>] </span>&#123;<br>  <span class="hljs-keyword">var</span> month : <span class="hljs-type">IntWritable</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> dayOfWeek : <span class="hljs-type">IntWritable</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(out: <span class="hljs-type">DataOutput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    month.write(out)<br>    dayOfWeek.write(out)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFields</span></span>(in: <span class="hljs-type">DataInput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    month.readFields(in)<br>    dayOfWeek.readFields(in)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compareTo</span></span>(o: <span class="hljs-type">MonthDayWeek</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.month.get == o.month.get) <span class="hljs-comment">// 如果月份相等，则逆序比较 dayOfWeek</span><br>      <span class="hljs-number">-1</span> * dayOfWeek.compareTo(o.dayOfWeek)<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">this</span>.month.compareTo(o.month)<br>  &#125;<br><br>  <span class="hljs-comment">// 自动生成</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canEqual</span></span>(other: <span class="hljs-type">Any</span>): <span class="hljs-type">Boolean</span> = other.isInstanceOf[<span class="hljs-type">MonthDayWeek</span>]<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">equals</span></span>(other: <span class="hljs-type">Any</span>): <span class="hljs-type">Boolean</span> = other <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> that: <span class="hljs-type">MonthDayWeek</span> =&gt;<br>      (that canEqual <span class="hljs-keyword">this</span>) &amp;&amp;<br>        month == that.month &amp;&amp;<br>        dayOfWeek == that.dayOfWeek<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hashCode</span></span>(): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">val</span> state = <span class="hljs-type">Seq</span>(month, dayOfWeek)<br>    state.map(_.hashCode()).foldLeft(<span class="hljs-number">0</span>)((a, b) =&gt; <span class="hljs-number">31</span> * a + b)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 值类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelaysWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Writable</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> year = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> month = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> dayOfWeek = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> arrDelay = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> depDelay = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> originAirportCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>()<br>  <span class="hljs-keyword">var</span> destAirportCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>()<br>  <span class="hljs-keyword">var</span> carrierCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>()<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(out: <span class="hljs-type">DataOutput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    year.write(out)<br>    month.write(out)<br>    date.write(out)<br>    dayOfWeek.write(out)<br>    arrDelay.write(out)<br>    depDelay.write(out)<br>    originAirportCode.write(out)<br>    destAirportCode.write(out)<br>    carrierCode.write(out)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFields</span></span>(in: <span class="hljs-type">DataInput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    year.readFields(in)<br>    month.readFields(in)<br>    date.readFields(in)<br>    dayOfWeek.readFields(in)<br>    arrDelay.readFields(in)<br>    depDelay.readFields(in)<br>    originAirportCode.readFields(in)<br>    destAirportCode.readFields(in)<br>    carrierCode.readFields(in)<br>  &#125;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= <br>    <span class="hljs-string">s&quot;<span class="hljs-subst">$year</span>, <span class="hljs-subst">$month</span>, <span class="hljs-subst">$date</span>, <span class="hljs-subst">$dayOfWeek</span>, <span class="hljs-subst">$arrDelay</span>, <span class="hljs-subst">$depDelay</span>, <span class="hljs-subst">$originAirportCode</span>, <span class="hljs-subst">$destAirportCode</span>, <span class="hljs-subst">$carrierCode</span>&quot;</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// Mapper 只是做一个映射</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonthDayWeekSortMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">MonthDayWeek</span>, <span class="hljs-type">DelaysWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">val</span> outputK = <span class="hljs-keyword">new</span> <span class="hljs-type">MonthDayWeek</span><br>  <span class="hljs-keyword">val</span> outputV = <span class="hljs-keyword">new</span> <span class="hljs-type">DelaysWritable</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">MonthDayWeek</span>, <span class="hljs-type">DelaysWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">if</span> (value.toString.startsWith(<span class="hljs-string">&quot;Year&quot;</span>)) <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">import</span> <span class="hljs-type">AirlineCol</span>._<br>    <span class="hljs-keyword">val</span> colGetter = <span class="hljs-type">AirlineCol</span>.build(value.toString.split(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    outputK.month = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">Month</span>).toInt)<br>    outputK.dayOfWeek = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">DayOfWeek</span>).toInt)<br><br>    outputV.year = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">Year</span>).toInt)<br>    outputV.month = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">Month</span>).toInt)<br>    outputV.dayOfWeek = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">DayOfWeek</span>).toInt)<br>    outputV.date = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">DayofMonth</span>).toInt)<br>    outputV.arrDelay = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">ArrDelay</span>).toInt)<br>    outputV.depDelay = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">DepDelay</span>).toInt)<br>    outputV.destAirportCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(colGetter(<span class="hljs-type">Dest</span>))<br>    outputV.originAirportCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(colGetter(<span class="hljs-type">Origin</span>))<br>    outputV.carrierCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(colGetter(<span class="hljs-type">UniqueCarrier</span>))<br><br>    context.write(outputK, outputV)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Reducer 更是啥也不干</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonthDayWeekSortReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">MonthDayWeek</span>, <span class="hljs-type">DelaysWritable</span>, <span class="hljs-type">DelaysWritable</span>, <span class="hljs-type">NullWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">MonthDayWeek</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">DelaysWritable</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">MonthDayWeek</span>, <span class="hljs-type">DelaysWritable</span>, <span class="hljs-type">DelaysWritable</span>, <span class="hljs-type">NullWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    values.forEach(context.write(_, <span class="hljs-type">NullWritable</span>.get))<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 继承 Configurable 接口后，就能够拿到配置信息了，通过 key.range 指定配置范围</span><br><span class="hljs-comment">// 用户给定一个 key.range，表示每个 Reducer 将要接受的 KEY 的数量，如果超出，则最后一个 reducer 照单全收；如果 Reducer 设置太多，后来的 Reducer 将会得不到数据。</span><br><span class="hljs-comment">// 比如，设置 key.range = 24，设置 Reducer 为 3 个，则第一个 Reducer 处理 0-23，第二个处理 24-48，第三个处理 49-83</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonthDayWeekSortJobPartitioner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Partitioner</span>[<span class="hljs-type">MonthDayWeek</span>, <span class="hljs-type">DelaysWritable</span>] <span class="hljs-keyword">with</span> <span class="hljs-title">Configurable</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> indexRange : <span class="hljs-type">Int</span> = <span class="hljs-number">84</span> / <span class="hljs-number">7</span>;<br>  <span class="hljs-keyword">var</span> config : <span class="hljs-type">Configuration</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Configuration</span>();<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setConf</span></span>(conf: <span class="hljs-type">Configuration</span>): <span class="hljs-type">Unit</span> = &#123;<br>    config = conf<br>  &#125;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getConf</span></span>: <span class="hljs-type">Configuration</span> = config<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPartition</span></span>(key: <span class="hljs-type">MonthDayWeek</span>, value: <span class="hljs-type">DelaysWritable</span>, numPartitions: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">val</span> index = ((key.month.get - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + (key.dayOfWeek.get - <span class="hljs-number">1</span>)) / config.getInt(<span class="hljs-string">&quot;key.range&quot;</span>, <span class="hljs-number">84</span>)<br><br>    <span class="hljs-keyword">if</span> (index &lt; numPartitions)<br>      index<br>    <span class="hljs-keyword">else</span><br>      numPartitions - <span class="hljs-number">1</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这里有两个参数需要配置——<code>mapreduce.job.reduces</code>，标识 Reducer 的数量，<code>key.range</code>，标识每个 Reducer 处理 key 的数量，默认为 84，即所有归一个 Reducer 来处理。将 Reducer 数量设置成 12，key 范围设置成 7，则得到每个文件保存一个月数据的结果。</p>
<p>可以看到，按 12，7 来设置时，<code>part-r-00000</code>的头部和<code>part-r-00011</code>的尾部是符合需求的——</p>
<figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">$ head part-r<span class="hljs-string">-00000</span><br>2007, 1, 28, 7, 24, <span class="hljs-string">-3</span>, PHL, PBI, US<br>2007, 1, 28, 7, 6, 11, DFW, BNA, AA<br>2007, 1, 7, 7, 2, <span class="hljs-string">-1</span>, ONT, PHX, US<br>2007, 1, 7, 7, <span class="hljs-string">-12</span>, 1, CLE, PHX, CO<br>2007, 1, 7, 7, 30, 0, ONT, LAS, US<br>2007, 1, 7, 7, <span class="hljs-string">-17</span>, <span class="hljs-string">-1</span>, OMA, PHX, US<br>2007, 1, 28, 7, <span class="hljs-string">-4</span>, <span class="hljs-string">-15</span>, MOT, MSP, NW<br>2007, 1, 7, 7, <span class="hljs-string">-23</span>, 6, OMA, PHX, US<br>2007, 1, 7, 7, <span class="hljs-string">-20</span>, 13, OMA, PHX, US<br>2007, 1, 7, 7, <span class="hljs-string">-8</span>, <span class="hljs-string">-9</span>, RDU, EWR, MQ<br><br>$ tail part-r<span class="hljs-string">-00011</span><br>2007, 12, 31, 1, <span class="hljs-string">-2</span>, 2, XNA, DFW, MQ<br>2007, 12, 24, 1, <span class="hljs-string">-12</span>, <span class="hljs-string">-1</span>, ATL, TYS, DL<br>2007, 12, 3, 1, 50, 39, DFW, XNA, MQ<br>2007, 12, 17, 1, <span class="hljs-string">-1</span>, 1, MDW, STL, WN<br>2007, 12, 24, 1, <span class="hljs-string">-18</span>, <span class="hljs-string">-3</span>, LGA, MCO, DL<br>2007, 12, 24, 1, 31, 54, MCO, LGA, DL<br>2007, 12, 10, 1, 6, 0, DFW, XNA, MQ<br>2007, 12, 10, 1, 66, 45, DFW, HSV, AA<br>2007, 12, 24, 1, <span class="hljs-string">-22</span>, <span class="hljs-string">-12</span>, RSW, BOS, DL<br>2007, 12, 24, 1, 1, <span class="hljs-string">-3</span>, BOS, RSW, DL<br></code></pre></div></td></tr></table></figure>

<p>至于如何进行进一步的优化呢？一个通常的操作是对输入数据进行采样，获取键的分布情况，并根据该情况特定地去规划分区并分发给相应 Reducer，保证每个 Reducer 的负载均衡。</p>
<p>可以料想，这种模式（ORDER BY）的实现是绝对能进行抽象的，</p>
<h1 id="二次排序"><a href="#二次排序" class="headerlink" title="二次排序"></a>二次排序</h1><blockquote>
<p>二次排序其实就是使用组合键进行排序，这引入了所谓的 GroupComparator 和 SortComparator。</p>
</blockquote>
<p>MR 默认的行为会按 KEY 进行排序，但是同一个 KEY 内的记录之间的顺序仍旧是无法保证的，这些记录来自各个 Mapper，因此即使原数据有序，被 Mapper 处理后的数据仍有序，但在这里将仍旧是无序的。</p>
<p>但 MR 同样也允许对 KEY 内的集合进行排序，这就是所谓的二次排序或辅助排序，<strong>二次排序是一个模式而非角色</strong>，<strong>它并非是直接对 VALUE 集合进行排序，而是将想再次排序的字段放在 KEY 里，使第一次排序时直接排出需要的顺序</strong>，因此二次排序这个名字实际上只描述了现象，没有点明实质。<strong>二次排序的一个难以理解的地方在于，在 Reducer 阶段，对 KEY 进行归并（即合并各个 Partition）和对 KEY 进行分组所使用的 Comparator 可以不是同一个 Comparator</strong>。</p>
<p>从一个示例看起，现在假设有一张网站浏览记录表，有如下字段——</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">website     IP               country  click_time</span><br><span class="hljs-section">---------------------------------------------------------</span><br>hoogle.com  123.123.123.123  UK       2022-02-02 12:23:34<br>hoogle.com  123.123.84.94    CA       2022-02-01 12:23:34<br>.....<br></code></pre></div></td></tr></table></figure>

<p>现在我们想要获取每个网站的每个国家的<strong>最近 5 次的访问时间</strong>。显然，我们可以以网站，国家作为 KEY 进行分组，然后维护一个大小为 5 的大顶堆，遍历整个集合得到结果，在 cleanup 方法中将结果写出。</p>
<p>但是这显然有一定的限制——要是我们要求获取最近 500 亿次的访问时间呢？这时，我们就必须考虑一些别的方案，比如，我们可以<strong>先把整个表按网站，国家，时间进行排序，再按照网站，国家进行分组</strong>（意识到这顺序和 SQL 中的不对应）即可，在 reduce 中只需要维护一个计数器。</p>
<p>但是我们之前所学的东西并不支持这种操作——在我们眼里，KEY 用于排序和分组时，使用的比较器是一样的，就是我们在 KEY 类型中实现的<code>WritableComparable</code>接口。因此，这里需要有一点新东西，被引入的就是所谓的<code>SortComparator</code>和<code>GroupComparator</code>。</p>
<p>SortComparator 用于对 Partitioner 的分区结果进行排序和 Reducer 归并 Mapper 结果时，默认的 SortComparator 就是 KEY 实现的 WritableComparable 接口；GroupComparator 用于 Reducer 进行分组并调用 reduce 方法时。GroupComparator 其实只用来比较是否相等——如果返回 0，则相等，传给用户的 reduce 方法；如果不返回 0，则终止当前的 reduce 方法，另起一个。</p>
<p>在这里，有三个组件需要自定义——首先是 Partitioner，要保证所有网站被分在一个文件里（不然这排序就没必要了）；然后是 SortComparator 和 GroupComparator，代码见下——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebsiteKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparable</span>[<span class="hljs-type">WebsiteKey</span>] </span>&#123;<br>  <span class="hljs-keyword">var</span> website : <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-keyword">var</span> country : <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-keyword">var</span> click_time : <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(out: <span class="hljs-type">DataOutput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFields</span></span>(in: <span class="hljs-type">DataInput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-comment">// 作为 SortComparator</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compareTo</span></span>(o: <span class="hljs-type">WebsiteKey</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (website != o.website)<br>      website.compareTo(o.website)<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (country != o.country)<br>      country.compareTo(o.country)<br>    <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span> * click_time.compareTo(o.click_time)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebsitePartitioner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Partitioner</span>[<span class="hljs-type">WebsiteKey</span>, <span class="hljs-type">Any</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPartition</span></span>(key: <span class="hljs-type">WebsiteKey</span>, value: <span class="hljs-type">Any</span>, numPartitions: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = ???<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebsiteKeyGroupComparator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparator</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare</span></span>(a: <span class="hljs-type">WritableComparable</span>[_], b: <span class="hljs-type">WritableComparable</span>[_]): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> l : <span class="hljs-type">WebsiteKey</span> = a.asInstanceOf[<span class="hljs-type">WebsiteKey</span>]<br>      <span class="hljs-keyword">val</span> r : <span class="hljs-type">WebsiteKey</span> = b.asInstanceOf[<span class="hljs-type">WebsiteKey</span>]<br><br>      <span class="hljs-keyword">if</span> (l.website != r.website)<br>        l.website .compareTo(r.website)<br>      <span class="hljs-keyword">else</span><br>        l.country.compareTo(r.country)<br>    &#125; <span class="hljs-keyword">catch</span> &#123;<span class="hljs-keyword">case</span> _: <span class="hljs-type">Throwable</span> =&gt; <span class="hljs-number">-1</span> &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>Mapper 和 Reducer 不表，Mapper 除了抽取出 KEY 什么都不做，Reducer 直接拿到集合的前五个元素。</p>
<p>这里的组合键中有三个字段，其中 GroupComparator 中所使用的称为<strong>自然键</strong>，其它的称为<strong>自然值</strong>, 自然键和自然值组成的组合键被 SortComparator 所使用，可以简单地认为 GroupComparator 就是 GROUP BY 中所使用的字段，ORDER BY 就是 SortComparator 所使用的字段。排序应当使用整个 KEY，分组应当使用排序使用的 KEY 的子集，否则可能会发生不可预料的结果。</p>
<p>但这在 SQL 上好像没有对应的语句——ORDER BY 在 SQL 里是最后才调用的，而 GROUP BY 在此之前执行，如果硬要放到 SQL 的语义中的话，可以认为是在 FROM 的表里进行了排序。可见，在 SQL 上的对应其实是不太明显的。SQL 这样设计的原因我猜测是因为聚集函数不关心列的顺序。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>二次排序使用的场景在于，<strong>需要在同一个分组里的记录有序，且各个记录组（即这里的“有序”区分出来的组）之间有相互依赖</strong>，如果没有后者，则组合键和自然键是一致的，就没必要再自己定义一个 GroupComparator。</p>
<p>下面对上面的说法进行测试，我们建立一个非常简单的实体，以及规定相应的 Mapper，Reducer，Reducer 仅用于在每一组之前进行一次打印——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TupleWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparable</span>[<span class="hljs-type">TupleWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">var</span> _1 : <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> _2 : <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> _3 : <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondarySortMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">IntTripleWritable</span>, <span class="hljs-type">NullWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">IntTripleWritable</span>, <span class="hljs-type">NullWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">Array</span>(_1,_2,_3) = value.toString.split(<span class="hljs-string">&quot; &quot;</span>).map(_.toInt)<br>    <span class="hljs-keyword">val</span> triple = <span class="hljs-keyword">new</span> <span class="hljs-type">IntTripleWritable</span><br>    triple._1 = _1<br>    triple._2 = _2<br>    triple._3 = _3<br>    context.write(triple, <span class="hljs-type">NullWritable</span>.get)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondarySortReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">IntTripleWritable</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">IntTripleWritable</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">NullWritable</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">IntTripleWritable</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;分组，key:&quot;</span> + key.toString), <span class="hljs-type">NullWritable</span>.get)<br>    values.forEach(_=&gt;context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(key.toString), <span class="hljs-type">NullWritable</span>.get))<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>输入数据如下，为 000 到 111 进行洗牌的结果——</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>

<ol>
<li>排序和分组一致</li>
</ol>
<p>按 2 个字段排序，2 个字段分组时，得到——</p>
<figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>

<p>这和预期比较一致。</p>
<ol start="2">
<li>按_1 和_2 排序，按_1 分组</li>
</ol>
<figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>

<p><strong>这相当于是把_2 当作了要排序的自然值</strong>，可以看到每个组的_2 都是有序的。</p>
<ol start="3">
<li>全排序，按_1 分组</li>
</ol>
<figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>

<p><strong>这相当于是把_2，_3 当作了要排序的自然值</strong>。</p>
<ol start="4">
<li>按_1 排序，按_1,_2 分组</li>
</ol>
<figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>

<p><strong>这是一个非法情况，相当于是在分组的时候拿到的数据不是有序的，分组的 KEY 必须为排序的 KEY 的子集！</strong></p>
<p>同时，通过上面的几个测试，可以看到 GroupComparator 是不会改变 SortComparator 排序的结果的，它只负责分组，也就是说<strong>只看当前记录是否等于上一条记录</strong>，如果 SortComparator 给出了就它看来是错误（无序）的结果，则它也会返回错误的结果。</p>
<h2 id="一个实际的实例"><a href="#一个实际的实例" class="headerlink" title="一个实际的实例"></a>一个实际的实例</h2><p>再考虑一个实际的实例，还是使用那张航班表，现在考虑获取每个月每个航班的最长的 10 次航行的时间。</p>
<p>根据需求，我们需要将数据按（月，航班）分组，按（月，航班，总飞行时间（降序））排序，并在每次 reduce 里取得前十条。注意这里使用的组合键，其 hashCode 仅使用 month 和 tailNum，这是为了能在分区的时候分到同一个 Reducer，这样才好分组。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombineKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparable</span>[<span class="hljs-type">CombineKey</span>] </span>&#123;<br>  <span class="hljs-keyword">var</span> month : <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> tailNum : <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-keyword">var</span> allDelay : <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(out: <span class="hljs-type">DataOutput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    out.writeInt(month)<br>    out.writeUTF(tailNum)<br>    out.writeInt(allDelay)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFields</span></span>(in: <span class="hljs-type">DataInput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    month = in.readInt()<br>    tailNum = in.readUTF()<br>    allDelay = in.readInt()<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compareTo</span></span>(o: <span class="hljs-type">CombineKey</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (month != o.month)<br>      month.compareTo(o.month)<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tailNum != o.tailNum)<br>      tailNum.compareTo(o.tailNum)<br>    <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span> * allDelay.compareTo(o.allDelay)<br>  &#125;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= <span class="hljs-string">s&quot;month=<span class="hljs-subst">$month</span>, tailNum=<span class="hljs-subst">$tailNum</span>, allDelay =<span class="hljs-subst">$allDelay</span>&quot;</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canEqual</span></span>(other: <span class="hljs-type">Any</span>): <span class="hljs-type">Boolean</span> = other.isInstanceOf[<span class="hljs-type">CombineKey</span>]<br>  <br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">equals</span></span>(other: <span class="hljs-type">Any</span>): <span class="hljs-type">Boolean</span> = other <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> that: <span class="hljs-type">CombineKey</span> =&gt;<br>      (that canEqual <span class="hljs-keyword">this</span>) &amp;&amp;<br>        month == that.month &amp;&amp;<br>        tailNum == that.tailNum<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hashCode</span></span>(): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">val</span> state = <span class="hljs-type">Seq</span>(month, tailNum)<br>    state.map(_.hashCode()).foldLeft(<span class="hljs-number">0</span>)((a, b) =&gt; <span class="hljs-number">31</span> * a + b)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongestAirtimePerMonthMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">CombineKey</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">CombineKey</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = <span class="hljs-type">Try</span> &#123;<br>    <span class="hljs-keyword">if</span> (value.toString.startsWith(<span class="hljs-string">&quot;Year&quot;</span>)) <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">val</span> colGetter = <span class="hljs-type">AirlineCol</span>.build(value.toString.split(<span class="hljs-string">&quot;,&quot;</span>))<br>    <span class="hljs-keyword">val</span> combineKey = <span class="hljs-keyword">new</span> <span class="hljs-type">CombineKey</span><br><br>    combineKey.month = colGetter(<span class="hljs-type">AirlineCol</span>.<span class="hljs-type">Month</span>).toInt<br>    combineKey.tailNum = colGetter(<span class="hljs-type">AirlineCol</span>.<span class="hljs-type">TailNum</span>)<br>    combineKey.allDelay =<br>      colGetter(<span class="hljs-type">AirlineCol</span>.<span class="hljs-type">ArrDelay</span>).toIntOption.getOrElse(<span class="hljs-number">0</span>)<br>    + colGetter(<span class="hljs-type">AirlineCol</span>.<span class="hljs-type">DepDelay</span>).toIntOption.getOrElse(<span class="hljs-number">0</span>)<br>    context.write(combineKey, value)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongestAirtimePerMonthReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">CombineKey</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">CombineKey</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">Text</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">CombineKey</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>) = &#123;<br>    <span class="hljs-keyword">import</span> scala.jdk.<span class="hljs-type">CollectionConverters</span>._<br>    context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;新分组&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;&quot;</span>))<br>    <span class="hljs-comment">// 在这里使用 take 函数会得到奇怪的结果，不知道底层是啥机制，只能使用最原始的迭代器了。</span><br>    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">val</span> iter = values.iterator()<br>    <span class="hljs-keyword">while</span> (counter &lt; <span class="hljs-number">10</span> &amp;&amp; iter.hasNext) &#123;<br>      counter += <span class="hljs-number">1</span><br>      context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(key.toString), iter.next())<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongestAirtimePerMonthGroupComparator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparator</span>(<span class="hljs-params">classOf[<span class="hljs-type">CombineKey</span>], true</span>) </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare</span></span>(a: <span class="hljs-type">WritableComparable</span>[_], b: <span class="hljs-type">WritableComparable</span>[_]): <span class="hljs-type">Int</span> = <span class="hljs-type">Try</span> &#123;<br>    <span class="hljs-keyword">val</span> l = a.asInstanceOf[<span class="hljs-type">CombineKey</span>]<br>    <span class="hljs-keyword">val</span> r = b.asInstanceOf[<span class="hljs-type">CombineKey</span>]<br><br>    <span class="hljs-keyword">if</span> (l.month != r.month)<br>      l.month.compareTo(r.month)<br>    <span class="hljs-keyword">else</span> l.tailNum.compareTo(r.tailNum)<br>  &#125;.getOrElse(<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二次排序看上去是相当的复杂，但其实原理就是那么简单——<strong>把要进一步排序的字段放到 KEY 里，同时确认哪些字段用于排序（一般是全部），哪些字段用于分组，BINGO</strong>。</p>
<p><strong>二次排序能够解决许多原本需要在 Reducer 实例中使用实例变量来维护一些状态才能解决的问题</strong>，比如前面说的求最近几次的访问时间，这就需要维护一个大顶堆。Hadoop 本就挺复杂了，再引入带副作用的 map 方法 reduce 方法……对脑袋是一个负担。</p>
<p>同时，<strong>二次排序必须结合对 Partitioner 的重写</strong>。在很多情况下我们需要让一系列数据在一个 reducer 中进行处理，比如 Hadoop 权威指南的那个例子，我们要求每年的最高气温，这时候我们按年，气温进行排序，按年进行分组，这时如果按照默认的 HashPartitioner（它按 KEY 的 hashCode 进行分区），则同年的数据可能分到不同的 Reducer 中，我们就会得到错误结果。</p>
<blockquote>
<p>感觉分区使用的字段好像很多时候和分组使用的字段相同。</p>
</blockquote>
<h1 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h1><p>连接操作应该是 MR 下的最后一个开发模式了，再之后就是去学习原理，输入输出等，然后是 Hive，学习 Hive 时要再次回来联想 MR 的模式。</p>
<p>连接操作就是 SQL 中的 JOIN，将两个数据集的记录做叉积并筛选出其中匹配的部分。</p>
<p>在 MR 中，连接操作的实现需要使用一些特定模式来实现，事实上，Hadoop 权威指南也承认 MR 编写连接操作比较棘手，建议使用 Pig，Hive，Spark 等抽象程度更高的框架。且根据两个数据集的大小以及分区方式的不同，具体的处理方式也会不同。比如，如果一个数据集非常大，而一个数据集非常小，则可以把较小的数据集直接维护在每一个节点的内存里并进行使用（使用名为“Side Data”的方式）。这和 SQL 简简单单一个 JOIN 一个 ON 就解决问题形成了鲜明对比，但这是数据集的巨大导致的不得已而为之。</p>
<p>连接操作如果在 Mapper 处进行，则称为 map 端连接，如果在 Reducer 处执行，则称为 reduce 端连接。数据的组织方式决定了究竟使用map端连接或reduce端连接，这两种连接方式都能够处理两个数据集规模均大的情况。</p>
<p>Hadoop权威指南没有展开讲map连接，所以我也跳过map连接了。</p>
<h2 id="reduce连接"><a href="#reduce连接" class="headerlink" title="reduce连接"></a>reduce连接</h2><p>reduce连接虽然性能较差，但适用范围更广，因此更常用，先去学习它。</p>
<p>reduce连接的思路使用一句话来描述，就是<strong>将要连接的键放入Mapper输出的KEY之中，而要连接的两个数据集都作为Mpper输出的VALUE</strong>，这样，在同一个迭代集合里我们就能够获取到两个数据集的值。显然，我们需要妥善处理它们的顺序（为此需要使用辅助排序），如果是一对多的关系，我们可以让第一个元素作为那个“一”，从而能够在后续的折叠过程中维护该记录；如果是多对多的关系……那就得具体问题具体分析了。</p>
<p>进行这种操作时，reduce的逻辑可能是这样，当作伪代码看吧——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 不想标注类型</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span> </span>= (key, values, context) =&gt; &#123;<br>  <span class="hljs-keyword">val</span> iter = values.iterator()<br>  <span class="hljs-type">Try</span>(iter.next)<br>    .map(parse)<br>    .filter(_.<span class="hljs-keyword">type</span> == &#x27;<span class="hljs-type">Station</span>&#x27;) <span class="hljs-comment">// 如果第一个值不是Station，则说明没有匹配的气象站，这时候的处理方式估计就对应内连接外连接了</span><br>    .foreach &#123; elem =&gt;<br>      <span class="hljs-keyword">while</span>(iter.hasNext) &#123;<br>        <span class="hljs-comment">// 这时候elem就是第一个元素了，现在对iter进行迭代，执行业务操作</span><br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="从示例开始"><a href="#从示例开始" class="headerlink" title="从示例开始"></a>从示例开始</h2><p>比如，我们现在有两个表，一个是气象站表，一个是气象记录表，它们的示例如下，我们想将它们通过气象站ID进行连接——</p>
<p>Stations表：  </p>
<table>
<thead>
<tr>
<th align="center">StationID</th>
<th align="center">StationName</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1199</td>
<td align="center">SIHCCAJAVRI</td>
</tr>
<tr>
<td align="center">1265</td>
<td align="center">TYNSET-HANSMOEN</td>
</tr>
</tbody></table>
<p>Records表：  </p>
<table>
<thead>
<tr>
<th align="center">StationID</th>
<th align="center">Timestamp</th>
<th align="center">Temperature</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1265</td>
<td align="center">194903241200</td>
<td align="center">111</td>
</tr>
<tr>
<td align="center">1265</td>
<td align="center">194903241800</td>
<td align="center">78</td>
</tr>
<tr>
<td align="center">1199</td>
<td align="center">195005150700</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1199</td>
<td align="center">195005151200</td>
<td align="center">22</td>
</tr>
<tr>
<td align="center">1199</td>
<td align="center">195005151800</td>
<td align="center">-11</td>
</tr>
</tbody></table>
<p>连接后的表：  </p>
<table>
<thead>
<tr>
<th align="center">StationID</th>
<th align="center">StationName</th>
<th align="center">Timestamp</th>
<th align="center">Temperature</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1199</td>
<td align="center">SIHCCAJAVRI</td>
<td align="center">195005150700</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1199</td>
<td align="center">SIHCCAJAVRI</td>
<td align="center">195005151200</td>
<td align="center">22</td>
</tr>
<tr>
<td align="center">1199</td>
<td align="center">SIHCCAJAVRI</td>
<td align="center">195005151800</td>
<td align="center">-11</td>
</tr>
<tr>
<td align="center">1265</td>
<td align="center">TYNSET-HANSMOEN</td>
<td align="center">194903241200</td>
<td align="center">111</td>
</tr>
<tr>
<td align="center">1265</td>
<td align="center">TYNSET-HANSMOEN</td>
<td align="center">194903241800</td>
<td align="center">78</td>
</tr>
</tbody></table>
<p>这时候，我们就以StationID以ID，将两个表的文件直接全都读到Mapper中。</p>
<p>那么如何在Mapper中处理多种形式的文件呢？我们可以在同一个Mapper中处理这两种数据，但也可以使用所谓的<code>MultipleInputs</code>类，使用多种Mapper，从多个数据源中读取数据，但各个Mapper的输出类型需要一致，这和我们的需求是吻合的。</p>
<p>但是在这么个简单的例子中，我们干脆只使用一个Mapper，在逻辑中区分两个表以避免引入额外的复杂度。</p>
<p>首先先假设输入文件，我们有两个输入文件分别作为气象站数据和天气数据，都使用CSV格式——</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">--</span> <span class="hljs-string">Station.csv</span><br><span class="hljs-number">1199</span><span class="hljs-string">,SIHCCAJAVRI</span><br><span class="hljs-number">1265</span><span class="hljs-string">,TYNSET-HANSMOEN</span><br><br><span class="hljs-string">--</span> <span class="hljs-string">Records.csv</span><br><span class="hljs-number">1265</span><span class="hljs-string">,194903241200,111</span><br><span class="hljs-number">1265</span><span class="hljs-string">,194903241800,78</span><br><span class="hljs-number">1199</span><span class="hljs-string">,195005150700,0</span><br><span class="hljs-number">1199</span><span class="hljs-string">,195005151200,22</span><br><span class="hljs-number">1199</span><span class="hljs-string">,195005151800,-11</span><br></code></pre></div></td></tr></table></figure>

<p>只需要检测其中<code>,</code>的数量即可判定数据究竟是气象站还是记录。</p>
<p>然后是Mapper的输出数据，我们输出的VALUE直接使用原数据，而KEY需要额外的设计——必须保证气象站的数据放在最前面，这时候我们就想到了我们的老朋友——二次排序，我们需要创建一个虚拟的键用来排序，而为了让气象站成为“一”，我们需要给它一个零，因为默认排序是按升序排序的，给它一个0保证它作为第一位，当然这需要其它的记录都是1。</p>
<p>为此，我们定义一个Pair，其中第一个字段是StationID，第二个字段是虚拟键。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// Scala可以自定义自己的构造器……我之前好像没学过这个</span><br><span class="hljs-comment">// 但是为了能够使用这鬼畜的序列化、反序列化框架，必须使用var定义，我麻了好嘛</span><br><span class="hljs-comment">// 想要不使用var的话就必须使用状态模式了，更麻</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyPair</span>(<span class="hljs-params">var stationID : <span class="hljs-type">String</span>, var virtualKey : <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparable</span>[<span class="hljs-type">KeyPair</span>] </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>() = <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">-1</span>) <span class="hljs-comment">// 供反射使用</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compareTo</span></span>(o: <span class="hljs-type">KeyPair</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (stationID != o.stationID)<br>      stationID.compareTo(o.stationID)<br>    <span class="hljs-keyword">else</span> virtualKey.compareTo(o.virtualKey)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(out: <span class="hljs-type">DataOutput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    out.writeUTF(stationID)<br>    out.writeInt(virtualKey)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFields</span></span>(in: <span class="hljs-type">DataInput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    stationID = in.readUTF()<br>    virtualKey = in.readInt()<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>整个Pair都将被用来排序，其中先按气象站ID进行排序，再按虚拟键进行排序，均为升序。</p>
<p>然后是GroupComparator，这里只按照气象站ID进行分组。如果定义Partitioner，也应只使用StationID的哈希值，这里没有定义Partitioner。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 考虑到是使用整个KEY进行排序，这里不用自定义SortComparator，让它调用KEY里定义的compareTo方法即可</span><br><span class="hljs-comment">// 顺便，记得调用指定的构造器，使用WritableComparator的空参构造器一定会抛出空指针异常</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinClauseGroupComparator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparator</span>(<span class="hljs-params">classOf[<span class="hljs-type">KeyPair</span>], true</span>) </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare</span></span>(a: <span class="hljs-type">WritableComparable</span>[_], b: <span class="hljs-type">WritableComparable</span>[_]): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-comment">// 犯了非常愚蠢的错误……变量名写错了，debug了半个小时</span><br>    <span class="hljs-keyword">val</span> l = a.asInstanceOf[<span class="hljs-type">KeyPair</span>]<br>    <span class="hljs-keyword">val</span> r = b.asInstanceOf[<span class="hljs-type">KeyPair</span>]<br>    l.stationID.compareTo(r.stationID)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>Mapper的定义同样简单，根据当前处理的数据的类型构造KEY即可。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinClauseMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">KeyPair</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">KeyPair</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> cols = value.toString.split(<span class="hljs-string">&quot;,&quot;</span>)<br>    <span class="hljs-comment">// 如果有两列，说明是Station表，虚拟键为0，否则是记录表，虚拟键为1</span><br>    context.write(<span class="hljs-type">KeyPair</span>(cols(<span class="hljs-number">0</span>), <span class="hljs-keyword">if</span> (cols.length == <span class="hljs-number">2</span>) <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>), value)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>最麻烦的是Reducer，Reducer首先要检查第一个元素是否是气象站，如果不是说明这个气象站ID对应的气象站不存在，直接退出执行；如果的确是气象站的话，对之后的每个元素同第一个元素都进行连接操作并写出。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinClauseReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">KeyPair</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">KeyPair</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">Text</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">KeyPair</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> iter = values.iterator()<br><br>    <span class="hljs-comment">// 使用Try的上下文——如果第一列不是站点（模式匹配会失败），则直接抛异常跑路</span><br>    <span class="hljs-keyword">for</span> &#123;<br>      firstElem &lt;- <span class="hljs-type">Try</span>(iter.next())<br>      <span class="hljs-type">Array</span>(stationId, stationName) = firstElem.toString.split(<span class="hljs-string">&quot;,&quot;</span>)<br>    &#125; <span class="hljs-keyword">yield</span> iter.forEachRemaining &#123; elem =&gt;<br>        <span class="hljs-keyword">val</span> <span class="hljs-type">Array</span>(_, timeStamp, temperature) = elem.toString.split(<span class="hljs-string">&quot;,&quot;</span>)<br>        context.write(<br>          <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(<br>            <span class="hljs-type">Array</span>(stationId,<br>            stationName,<br>            timeStamp,<br>            temperature).mkString(<span class="hljs-string">&quot;,&quot;</span>)),<br>          <span class="hljs-type">NullWritable</span>.get)<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>可以看到，Scala处理这种业务问题相当优美，但需要明确for的使用方式以及如何还原成原生Scala代码。需要记住，for代码体是不在Try的上下文之中的，这里如果抛出异常不会被捕获，除非用yield。</p>
<p>使用上面的csv文件作为输入进行执行，得到下面的结果，BINGO～</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1199</span>,SIHCCAJAVRI,<span class="hljs-number">195005151800</span>,-<span class="hljs-number">11</span><br><span class="hljs-attribute">1199</span>,SIHCCAJAVRI,<span class="hljs-number">195005151200</span>,<span class="hljs-number">22</span><br><span class="hljs-attribute">1199</span>,SIHCCAJAVRI,<span class="hljs-number">195005150700</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">1265</span>,TYNSET-HANSMOEN,<span class="hljs-number">194903241800</span>,<span class="hljs-number">78</span><br><span class="hljs-attribute">1265</span>,TYNSET-HANSMOEN,<span class="hljs-number">194903241200</span>,<span class="hljs-number">111</span><br></code></pre></div></td></tr></table></figure>

<p>如果想要使用多个Reducer使能够并行执行，则必须自定义Partitioner。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>使用MR进行分组表面上看起来还是比较简单的——把要合并的两个数据集放在同一个values集合里并特别地去规划它们的顺序即可，ON操作则是交给了二次排序；可是这种假想一遇到真实的业务需求就要抓瞎了——如果连接三个表，四个表，五个表怎么办？如果不使用等于运算符进行连接怎么办？如果连接的键不是主键，从而让这里不是一对多，而是多对多的情况该怎么办？这只能具体情况具体分析了，如果要真正地让这玩意成为生产力，更抽象的技术是必须的。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/MapReduce/">MapReduce</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-NC-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03-15MapReduce%20%E7%9A%84%E9%AD%94%E6%B3%95%E2%80%94%E2%80%94Shuffle.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MapReduce 的魔法——Shuffle</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03-13%E5%8A%9B%E6%89%A3SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html">
                        <span class="hidden-mobile">力扣 SQL 刷题笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start -->
<script src="/assets/prism-bundle.js"></script>
<script src="/assets/prism-plus.js" data-pjax=""></script>
<!-- hexo injector body_end end --></body>
</html>
