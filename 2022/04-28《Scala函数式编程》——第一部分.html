

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="那尔">
  <meta name="keywords" content="">
  
    <meta name="description" content="考虑对每个练习都自己实现一波，尽量使用最纯的方式，即不仅函数本身是纯的，内部也不有任何局部的副作用（这在工程实践中肯定是不好的）">
<meta property="og:type" content="article">
<meta property="og:title" content="《Scala 函数式编程》解题笔记——第一部分">
<meta property="og:url" content="http://example.com/2022/04-28%E3%80%8AScala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.html">
<meta property="og:site_name" content="那尔">
<meta property="og:description" content="考虑对每个练习都自己实现一波，尽量使用最纯的方式，即不仅函数本身是纯的，内部也不有任何局部的副作用（这在工程实践中肯定是不好的）">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-04-27T16:00:00.000Z">
<meta property="article:modified_time" content="2025-02-26T07:32:45.906Z">
<meta property="article:author" content="那尔">
<meta property="article:tag" content="FP">
<meta property="article:tag" content="Scala">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>《Scala 函数式编程》解题笔记——第一部分 - 那尔</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":100},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="那尔" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>那尔的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="《Scala 函数式编程》解题笔记——第一部分">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-28 00:00" pubdate>
        2022年4月28日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      25k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">《Scala 函数式编程》解题笔记——第一部分</h1>
            
            <div class="markdown-body">
              <p>考虑对每个练习都自己实现一波，尽量使用最纯的方式，即不仅函数本身是纯的，内部也不有任何局部的副作用（这在工程实践中肯定是不好的）。</p>
<h1 id="2-1-尾递归的斐波那契"><a href="#2-1-尾递归的斐波那契" class="headerlink" title="2.1 尾递归的斐波那契"></a>2.1 尾递归的斐波那契</h1><p>题目要求写一个递归函数，获取第 n 个斐波那契数。第一个和第二个斐波那契数分别为 0，1。</p>
<p>这一题讨论了尾递归函数，以及嵌套（局部）函数定义，其实现是比较显然的。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>  <span class="hljs-meta">@tailrec</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>, n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = <br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) a <span class="hljs-keyword">else</span> go(b, a + b, n - <span class="hljs-number">1</span>)<br>  go(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, n)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>一般该尾递归的辅助函数会命名为 go 或 loop（Haskell 里似乎喜欢叫 helper）。应当显式地增加<code>@tailrec</code>注解，以保证编译器会将其进行尾递归优化。如果优化无法进行，则将无法通过编译。</p>
<h1 id="2-2-isSorted"><a href="#2-2-isSorted" class="headerlink" title="2.2 isSorted"></a>2.2 isSorted</h1><p>该题要求实现一个 isSorted 方法，签名为<code>def isSorted[A](as: Array[A], ordered: (A, A) =&gt; Boolean): Boolean</code>。该题考查泛型（类型变量）的使用，类型变量就像函数参数一样，函数参数在函数体中引用，而类型变量在类型中引用。</p>
<p>也需要注意，这里使用的是 Array，因此不用考虑像 Haskell 中的 List 那样递归，使用索引进行递归即可。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSorted</span></span>[<span class="hljs-type">A</span>](as: <span class="hljs-type">Array</span>[<span class="hljs-type">A</span>], ordered: (<span class="hljs-type">A</span>, <span class="hljs-type">A</span>) =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Boolean</span> = &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span></span>(index: <span class="hljs-type">Int</span>): <span class="hljs-type">Boolean</span> = &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= as.length) <span class="hljs-literal">true</span> <span class="hljs-comment">// 基线条件</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordered(as(index - <span class="hljs-number">1</span>), as(index))) go(index + <span class="hljs-number">1</span>) <span class="hljs-comment">// 每次比较 index - 1 和 index</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-literal">false</span><br>  &#125;<br>  go(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>需要注意的是，这玩意如果要调用的话，直接写<code>isSorted(Array(1,2,2),_ &lt;= _)</code>是不行的，这是 Scala 类型系统一个非常蛋疼的地方——仅从第一个参数 as 的类型输入里，它居然推不出第二个参数 ordered 的具体类型。就连 Java 也能干这个鸭！</p>
<p>解决方案有几个——指定函数的参数（也可以带上返回值，但没必要），强制指定类型 A，强制指定 ordered 的类型，使用柯里化函数重新定义 isSorted 并调用，它们的语法分别为：</p>
<ul>
<li><code>isSorted(Array(1,2,2), (x: Int, y: Int) =&gt; x &lt;= y)</code></li>
<li><code>isSorted[Int](Array(1,2,2),_ &lt;= _)</code></li>
<li><code>isSorted(Array(1, 2, 2), (_ &lt;= _) : (Int, Int) =&gt; Boolean)</code></li>
<li><code>isSorted(Array(1,2,2))(_ &lt;= _)</code></li>
</ul>
<p>显然，只有第二种和第四种是比较合适的，Scala 的几个高阶函数比如 fold 等使用第四种方法。</p>
<h1 id="2-3-curry"><a href="#2-3-curry" class="headerlink" title="2.3 curry"></a>2.3 curry</h1><p>这三个都是比较经典的题目了——柯里化，反柯里化，函数组合。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">curry</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span> =&gt; <span class="hljs-type">C</span> = a =&gt; b =&gt; f(a, b)<br></code></pre></div></td></tr></table></figure>
<h1 id="2-4-uncurry"><a href="#2-4-uncurry" class="headerlink" title="2.4 uncurry"></a>2.4 uncurry</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uncurry</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](fn: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span> =&gt; <span class="hljs-type">C</span>): (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span> = (a, b) =&gt; fn(a)(b)<br></code></pre></div></td></tr></table></figure>
<h1 id="2-5-compose"><a href="#2-5-compose" class="headerlink" title="2.5 compose"></a>2.5 compose</h1><p>Haskell 中的 compose 就是<code>.</code>函数。</p>
<figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)<br><span class="hljs-title">f</span> . g = \x -&gt; f(g(x))<br></code></pre></div></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compose</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">C</span>, g: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span> = x =&gt; f(g(x))<br></code></pre></div></td></tr></table></figure>
<h1 id="3-1-模式匹配"><a href="#3-1-模式匹配" class="headerlink" title="3.1 模式匹配"></a>3.1 模式匹配</h1><p>这就不是道编程题，答案是 3，模式匹配会从上往下匹配，找到第一个匹配到的。</p>
<h1 id="3-2-tail"><a href="#3-2-tail" class="headerlink" title="3.2 tail"></a>3.2 tail</h1><p>tail 也是一个经典的函数，这里有个问题，就是如果原 List 是 Nil 的时候，tail 该返回什么？在 Haskell 中，此举会抛出异常，可以写一个全函数——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tail</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> _::xs =&gt; xs<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>其它选择是使用 Option，Try 等，抛出异常是中策，返回 null 是下下下策。</p>
<h1 id="3-3-setHead"><a href="#3-3-setHead" class="headerlink" title="3.3 setHead"></a>3.3 setHead</h1><p>重设列表的 head。函数式的 setter 是怎样的呢？这样。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setHead</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], neoHead: <span class="hljs-type">A</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> _::xs =&gt; neoHead::xs<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-4-drop"><a href="#3-4-drop" class="headerlink" title="3.4 drop"></a>3.4 drop</h1><p>移除掉前 n 个元素，返回剩下的就是 drop 函数。这里一个问题是如果 n 大于列表的长度时该怎么解决，这里返回 Nil。n 小于 0 的时候按等于 0 考虑。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drop</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], n: <span class="hljs-type">Int</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> _::xs <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> =&gt; drop(xs, n - <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">case</span> _ =&gt; l<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-5-dropWhile"><a href="#3-5-dropWhile" class="headerlink" title="3.5 dropWhile"></a>3.5 dropWhile</h1><p>有时候会把 take 和 drop 混淆，想象 take 把前面的元素“拿起来”，drop 把前面的元素“丢掉”。takeWhile 就是一直“拿”，直到不符合；dropWhile 就是一直“丢”，直到不符合。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dropWhile</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> x::xs <span class="hljs-keyword">if</span> p(x) =&gt; dropWhile(xs, p)<br>  <span class="hljs-keyword">case</span> _ =&gt; l<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-6-init"><a href="#3-6-init" class="headerlink" title="3.6 init"></a>3.6 init</h1><p>在 List 头部增加元素是常量级的开销，但在尾部进行操作就不是如此了，为了在尾部进行操作，之前的每一个元素都要被修改。想象一下一个链表<code>1 -&gt; 2 -&gt; 3 -&gt; Nil</code>，现在要在尾部添加一个元素 4，这时候若要保证原链表不变，则必须将整个链表复制一份，再在尾部添加一个元素；但是若在头部添加呢？直接上即可。新的链表是<code>4 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; Nil</code>，对原链表<code>1 -&gt; 2 -&gt; 3 -&gt; Nil</code>来说，它不需要做任何改变。同理，在尾部减少元素时，将整个列表拷贝一份也是必须的。</p>
<p>实现 init 时考虑和普通的递归函数一样的编写流程，对于<code>[x]</code>，这是基线条件，返回<code>[]</code>，然后对其它列表<code>x::xs</code>，则直接原样拼接即可。init 对于空列表就比较麻了，这里不多想，直接抛异常。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">&quot;empty list&quot;</span>)<br>  <span class="hljs-keyword">case</span> _::<span class="hljs-type">Nil</span> =&gt; l<br>  <span class="hljs-keyword">case</span> x::xs =&gt; x :: init(xs)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-7-foldRight-能否“短路”？"><a href="#3-7-foldRight-能否“短路”？" class="headerlink" title="3.7 foldRight 能否“短路”？"></a>3.7 foldRight 能否“短路”？</h1><p>foldRight 的定义如下，只要记住 foldRight 并非尾递归就容易写出它，把 op 当作右结合的二元操作符来看待有奇效。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldRight</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], z: <span class="hljs-type">B</span>)(op: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; z<br>  <span class="hljs-keyword">case</span> x::xs =&gt; op(x, foldRight(xs, z)(op))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这也不是一个编程题，但是确实很有实践意义，在很多时候能发现这样的业务需求，即我<strong>迭代集合迭代一半，突然发现后面不需要再迭代了，想现在立刻就返回</strong>，但是目前我是没找到合适的方法，唯一感觉可行的方法是利用 break 来终止，但这并不优雅，期待该书能提出更好的解决方案。</p>
<h1 id="3-8-foldRight-以-Nil-为初始值，以-为操作符？"><a href="#3-8-foldRight-以-Nil-为初始值，以-为操作符？" class="headerlink" title="3.8 foldRight 以 Nil 为初始值，以::为操作符？"></a>3.8 foldRight 以 Nil 为初始值，以<code>::</code>为操作符？</h1><blockquote>
<p>关于为什么此书定义函数时没有遵循数据放到最后的原则，我猜测原因是因为 Scala 是面向对象语言，而这样的话数据和参数的位置和进行方法调用时相同。</p>
</blockquote>
<p><code>foldRight(List(1,2,3),Nil:List[Int])(_::_)</code>会发生什么？这里可以用我之前“发明”的方法来去理解——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span> &gt;=&gt; <span class="hljs-type">Nil</span><br>=&gt; <span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; [<span class="hljs-number">3</span>]<br>=&gt; <span class="hljs-number">1</span> &gt;=&gt; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>=&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></div></td></tr></table></figure>
<h1 id="3-9-使用-foldRight-实现-length"><a href="#3-9-使用-foldRight-实现-length" class="headerlink" title="3.9 使用 foldRight 实现 length"></a>3.9 使用 foldRight 实现 length</h1><p>easy。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Int</span> =<br>  foldRight(l, <span class="hljs-number">0</span>)&#123;(x, acc) =&gt; <span class="hljs-number">1</span> + acc&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-10-foldLeft"><a href="#3-10-foldLeft" class="headerlink" title="3.10 foldLeft"></a>3.10 foldLeft</h1><p>理解 foldLeft 为尾递归，op 为左结合的二元运算符对编写 foldLeft 有帮助。</p>
<p>但最具建设性的想法是，对于<code>foldLeft(List(1,2,3,4), 0)(_ + _)</code>，它显然为<code>(((0 + 1) + 2) + 3) + 4</code>，容易发现，它和<code>((1 + 2) + 3) + 4</code>结构是完全一样的，还原后就得到了<code>foldLeft(List(2, 3, 4), 1)(_ + _)</code>，这已经足够编写出实现了。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldLeft</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], z: <span class="hljs-type">B</span>)(op: (<span class="hljs-type">B</span>, <span class="hljs-type">A</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; z<br>  <span class="hljs-keyword">case</span> x::xs =&gt; foldLeft(xs, op(z, x))(op)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-11-sum，product，length"><a href="#3-11-sum，product，length" class="headerlink" title="3.11 sum，product，length"></a>3.11 sum，product，length</h1><p>使用 foldLeft 实现这几个方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(l: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">Int</span> = <br>  foldLeft(l, <span class="hljs-number">0</span>)(_ + _)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">product</span></span>(l: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">Int</span> = <br>  foldLeft(l, <span class="hljs-number">1</span>)(_ * _)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Int</span> = <br>  foldLeft(l, <span class="hljs-number">0</span>)((acc, _) =&gt; acc + <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>
<h1 id="3-12-使用-fold-实现-reverse"><a href="#3-12-使用-fold-实现-reverse" class="headerlink" title="3.12 使用 fold 实现 reverse"></a>3.12 使用 fold 实现 reverse</h1><p>这也是之前实现过的东西，使用<code>flip (::)</code>作为 op，左折叠即可。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] =<br>  foldLeft(l, <span class="hljs-type">Nil</span>: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])((acc, x) =&gt; x::acc)<br></code></pre></div></td></tr></table></figure>
<h1 id="3-13-使用-foldLeft-实现-foldRight"><a href="#3-13-使用-foldLeft-实现-foldRight" class="headerlink" title="3.13 使用 foldLeft 实现 foldRight"></a>3.13 使用 foldLeft 实现 foldRight</h1><p>foldRight 由于是递归形式，所以可能爆栈，能否使用 foldLeft 实现 foldRight 以防止爆栈呢？</p>
<p>这个问题确实很难，我想到的唯一的方式是先把原列表 reverse 再进行 foldLeft，看看之后该书会提出什么好玩的解决方案。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldRight_</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], z: <span class="hljs-type">B</span>)(op: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> =<br>  foldLeft(reverse(l), z)((acc, x) =&gt; op(x, acc))<br></code></pre></div></td></tr></table></figure>
<h1 id="3-14-使用-foldLeft-或-foldRight-实现-append"><a href="#3-14-使用-foldLeft-或-foldRight-实现-append" class="headerlink" title="3.14 使用 foldLeft 或 foldRight 实现 append"></a>3.14 使用 foldLeft 或 foldRight 实现 append</h1><p>append 就是 Haskell 的<code>++</code>。</p>
<p>使用右折叠的话是比较容易实现的——第一个列表作为原列表，第二个列表作为 zero，op 为<code>::</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span></span>[<span class="hljs-type">A</span>](l1: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], l2: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <br>  foldRight(l1, l2)(_::_)<br></code></pre></div></td></tr></table></figure>
<p>左折叠的话救比较蛋疼，我想到的话还得先把原列表 reverse 再 append，但考虑到它说的是“或”……</p>
<h1 id="3-15-flatten"><a href="#3-15-flatten" class="headerlink" title="3.15 flatten"></a>3.15 flatten</h1><p>虽然题目没明确，但这显然是一个 flatten，使用折叠和 append 可以解决。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatten</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <br>  foldRight(l, <span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(append)<br></code></pre></div></td></tr></table></figure>
<p>为什么使用<code>Nil:List[A]</code>？因为它默认会认为<code>Nil</code>的类型是<code>List[Nothing]</code>，需要做一下向上转型。</p>
<h1 id="3-16-给列表的每个元素-1"><a href="#3-16-给列表的每个元素-1" class="headerlink" title="3.16 给列表的每个元素 +1"></a>3.16 给列表的每个元素 +1</h1><p>虽然这里可能并不是这个意思，但 map，filter，flatMap 都可以由 fold 操作实现，因此这里都使用 fold。可以发现，foldRight 虽然会导致爆栈，但实现特定函数还是比较方便的。使用 foldLeft 就需要 reverse 了。这里其实最合适的方法是使用循环来实现。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plus1</span></span>(l: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <br>  foldRight(l, <span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>])((x, acc) =&gt; (x + <span class="hljs-number">1</span>) :: acc)<br></code></pre></div></td></tr></table></figure>
<h1 id="3-17-将-List-Double-转成-List-String"><a href="#3-17-将-List-Double-转成-List-String" class="headerlink" title="3.17 将 List[Double] 转成 List[String]"></a>3.17 将 List[Double] 转成 List[String]</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allToString</span></span>(l: <span class="hljs-type">List</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <br>  foldRight(l, <span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">String</span>])((x, acc) =&gt; x.toString :: acc)<br></code></pre></div></td></tr></table></figure>
<h1 id="3-18-map"><a href="#3-18-map" class="headerlink" title="3.18 map"></a>3.18 map</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">List</span>[<span class="hljs-type">B</span>] = <br>  foldRight(l, <span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">B</span>])((x, acc) =&gt; f(x) :: acc)<br></code></pre></div></td></tr></table></figure>
<p>顺带一提，原始的方法为——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">List</span>[<span class="hljs-type">B</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> x::xs =&gt; f(x)::map(xs)(f)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-19-filter"><a href="#3-19-filter" class="headerlink" title="3.19 filter"></a>3.19 filter</h1><p>怎么不举例子啦？</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <br>  foldRight(l, <span class="hljs-type">Nil</span>: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])&#123;(x, acc) =&gt; <span class="hljs-keyword">if</span> (p(x)) x :: acc <span class="hljs-keyword">else</span> acc&#125;<br></code></pre></div></td></tr></table></figure>
<p>原始的方法为——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> x::xs =&gt; <span class="hljs-keyword">if</span> (p(x)) x::filter(xs)(p) <span class="hljs-keyword">else</span> filter(xs)(p)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>移除所有奇数的调用类似<code>filter(List(1, 2, 3))(_ % 2 == 0)</code>。</p>
<h1 id="3-20-flatMap"><a href="#3-20-flatMap" class="headerlink" title="3.20 flatMap"></a>3.20 flatMap</h1><p>flatMap 是列表的 bind 操作。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">List</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">B</span>] =<br>  foldRight(l, <span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">B</span>])((x, acc) =&gt; append(f(x), acc))<br></code></pre></div></td></tr></table></figure>
<p>递归法很显然，懒得写了。</p>
<h1 id="3-21-使用-flatMap-实现-filter（和-map）"><a href="#3-21-使用-flatMap-实现-filter（和-map）" class="headerlink" title="3.21 使用 flatMap 实现 filter（和 map）"></a>3.21 使用 flatMap 实现 filter（和 map）</h1><p>Scala 的 flatMap 比隔壁 Haskell 的骚操作还多一些。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <br>  flatMap(l)(x =&gt; <span class="hljs-keyword">if</span> (p(x)) <span class="hljs-type">List</span>(x) <span class="hljs-keyword">else</span> <span class="hljs-type">Nil</span>)<br></code></pre></div></td></tr></table></figure>
<p>再给个杀必死，使用 flatMap 实现 map。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">List</span>[<span class="hljs-type">B</span>] =<br>  flatMap(l)(x =&gt; <span class="hljs-type">List</span>(f(x)))<br></code></pre></div></td></tr></table></figure>
<h1 id="3-22-两个列表相应元素相加"><a href="#3-22-两个列表相应元素相加" class="headerlink" title="3.22 两个列表相应元素相加"></a>3.22 两个列表相应元素相加</h1><p>trival，但之前的玩意可没法再用了。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plusList</span></span>(l1: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>], l2: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = (l1, l2) <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> (x::xs, y::ys) =&gt; (x + y) :: plusList(xs, ys)<br>  <span class="hljs-keyword">case</span> (_, _) =&gt; <span class="hljs-type">Nil</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-23-zipWith"><a href="#3-23-zipWith" class="headerlink" title="3.23 zipWith"></a>3.23 zipWith</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zipWith</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](l1: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], l2: <span class="hljs-type">List</span>[<span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">List</span>[<span class="hljs-type">C</span>] = <br>  (l1, l2) <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> (x::xs, y::ys) =&gt; f(x, y) :: zipWith(xs, ys)(f)<br>    <span class="hljs-keyword">case</span> (_, _) =&gt; <span class="hljs-type">Nil</span><br>  &#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-24-是否是子序列"><a href="#3-24-是否是子序列" class="headerlink" title="3.24 是否是子序列"></a>3.24 是否是子序列</h1><p>给定两个列表 l1，sub，检查 sub 是否是 l1 的子序列。既然书中要求使用最自然的方式，那我就编写一个最自然的方式——从 l1 的每一个元素开始，检查从当前开始时 sub 是否是前缀。更高性能的方式之后再看。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasSubsequence</span></span>[<span class="hljs-type">A</span>](sup: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], sub: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Boolean</span> = &#123;<br>  <span class="hljs-meta">@tailrec</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startWith</span></span>(l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], prefix: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Boolean</span> = (l, prefix) <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> (x::xs, y::ys) =&gt; <span class="hljs-keyword">if</span> (x == y) startWith(xs, ys) <span class="hljs-keyword">else</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">case</span> (_, <span class="hljs-type">Nil</span>) =&gt; <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span><br>  &#125;<br>  sup <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">case</span> _::xs =&gt; <span class="hljs-keyword">if</span> (startWith(sup, sub)) <span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> hasSubsequence(xs, sub)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-25-树的-size"><a href="#3-25-树的-size" class="headerlink" title="3.25 树的 size"></a>3.25 树的 size</h1><p>这里引入了一个树的 ADT——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Tree</span>[+<span class="hljs-type">A</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span>[<span class="hljs-type">A</span>](<span class="hljs-params">value: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Tree</span>[<span class="hljs-type">A</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Branch</span>[<span class="hljs-type">A</span>](<span class="hljs-params">left: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>], right: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Tree</span>[<span class="hljs-type">A</span>]</span><br></code></pre></div></td></tr></table></figure>
<p>用 Haskell 的话来说，就是——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala">data <span class="hljs-type">Tree</span> a = <span class="hljs-type">Leaf</span> a | <span class="hljs-type">Branch</span> (<span class="hljs-type">Tree</span> a) (<span class="hljs-type">Tree</span> a)<br></code></pre></div></td></tr></table></figure>
<p>我还没见过根结点没有值的二叉树。</p>
<p>求树的 size 是简单的，对叶子结点，size 为 1，对根结点，size 为 1 + 左右子树的 size。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span></span>[<span class="hljs-type">A</span>](tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Int</span> = tree <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Leaf</span>(_) =&gt; <span class="hljs-number">1</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Branch</span>(left, right) =&gt; <span class="hljs-number">1</span> + size(left) + size(right)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-26-maximum"><a href="#3-26-maximum" class="headerlink" title="3.26 maximum"></a>3.26 maximum</h1><p>求一棵树<code>Tree[Int]</code>中最大的值，这也是十分显然的。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maximum</span></span>(tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">Int</span> = tree <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Leaf</span>(x) =&gt; x<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Branch</span>(left, right) =&gt; maximum(left) max maximum(right)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-27-depth"><a href="#3-27-depth" class="headerlink" title="3.27 depth"></a>3.27 depth</h1><p>求树的最大深度，这也是很显然的。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depth</span></span>[<span class="hljs-type">A</span>](tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Int</span> = tree <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Leaf</span>(x) =&gt; <span class="hljs-number">1</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Branch</span>(left, right) =&gt; <span class="hljs-number">1</span> + depth(left).max(depth(right))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-28-map"><a href="#3-28-map" class="headerlink" title="3.28 map"></a>3.28 map</h1><p>对一棵树的所有节点（其实只有叶子结点）应用相同的操作，仍旧是非常简单的。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>])(fn: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Tree</span>[<span class="hljs-type">B</span>] = tree <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Leaf</span>(x) =&gt; <span class="hljs-type">Leaf</span>(fn(x))<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Branch</span>(left, right) =&gt; <span class="hljs-type">Branch</span>(map(left)(fn), map(right)(fn))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="3-29-fold"><a href="#3-29-fold" class="headerlink" title="3.29 fold"></a>3.29 fold</h1><p>对树进行折叠，这题就离谱了。考虑上面的 size，maximum，depth 函数，它们都是对叶子结点做一个映射，然后对根结点，它会先将其左右子树进行同样的操作，再进行一个“合并”，因此可以猜测签名类似这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fold</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>])(mapper: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(combiner: (<span class="hljs-type">B</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span><br></code></pre></div></td></tr></table></figure>
<p>然后就容易得到实现了——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fold</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>])(mapper: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(combiner: (<span class="hljs-type">B</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = tree <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Leaf</span>(x) =&gt; mapper(x)<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Branch</span>(left, right) =&gt; combiner(fold(left)(mapper)(combiner), fold(right)(mapper)(combiner))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以发现，编写 List 的折叠时，我们需要考虑 Nil 和 Cons 的情况，编写 Tree 的折叠时，我们需要考虑叶结点和根结点的情况。</p>
<h1 id="4-1-实现-Option"><a href="#4-1-实现-Option" class="headerlink" title="4.1 实现 Option"></a>4.1 实现 Option</h1><p>实现 Option，其实这里最复杂的地方是关于类型系统的一些问题。签名如下——</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// 这是不是说，实现代数数据类型时都应当使用协变？</span><br><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Option</span>[+<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOrElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>])<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>关于这里的 getOrElse 和 orElse 方法中 B 的约束，考虑一个情形——在 Java 中，我们试图从一个 List 中取出一个值：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">List&lt;String&gt; lst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()&#123;&#123; <span class="hljs-comment">/* some add statement */</span> &#125;&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lst.get(<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure>
<p>这个问题其实就是在问，这里的 i 的声明类型可以为哪些？容易发现它需要是 String 的父类，即 String 和 Object，因此这里签名中 B 为 A 的父类是合理的。</p>
<p>实现是比较简单的，不再多嘴：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Some</span>[+<span class="hljs-type">A</span>](<span class="hljs-params">value: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Option</span>[<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) = <span class="hljs-type">Some</span>(f(value))<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]) = f(value)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOrElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">B</span>) = value<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]) = <span class="hljs-keyword">this</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>) = <span class="hljs-keyword">if</span> (f(value)) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> <span class="hljs-type">None</span><br>&#125;<br><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">None</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Option</span>[<span class="hljs-type">Nothing</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">Nothing</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] = <span class="hljs-type">None</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">Nothing</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] = <span class="hljs-type">None</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOrElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">Nothing</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">B</span>) = <span class="hljs-keyword">default</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">Nothing</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]) = <span class="hljs-keyword">default</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(f: <span class="hljs-type">Nothing</span> =&gt; <span class="hljs-type">Boolean</span>) = <span class="hljs-type">None</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们可以编写代码进行一些测试～</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOption</span></span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](map: <span class="hljs-type">Map</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], key: <span class="hljs-type">K</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">V</span>] =<br>  <span class="hljs-keyword">if</span> (map.contains(key)) <span class="hljs-type">Some</span>(map(key)) <span class="hljs-keyword">else</span> <span class="hljs-type">None</span><br><br><span class="hljs-keyword">val</span> map = <span class="hljs-type">Map</span>(<br>  <span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span>,<br>  <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br>)<br><br><span class="hljs-keyword">for</span> &#123;<br>  i &lt;- getOption(map, <span class="hljs-number">1</span>)<br>  j &lt;- getOption(map, <span class="hljs-number">2</span>)<br>&#125; <span class="hljs-keyword">yield</span> i + j <span class="hljs-comment">// Some(5)</span><br></code></pre></div></td></tr></table></figure>
<p>书中对该题的描述非常诡异，不知所云（英文版的如此，中文版的更甚），在搜索一番后才知道，它是要求将所有实现的方法全都塞在 trait 里面！根据书中的要求——除了 map 和 getOrElse，其它都不使用模式匹配，最后的代码应该是这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Option</span>[+<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Some</span>[+<span class="hljs-type">A</span>](<span class="hljs-params">value: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Option</span>[<span class="hljs-type">A</span>]</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">None</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Option</span>[<span class="hljs-type">Nothing</span>]</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">None</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(value) =&gt; <span class="hljs-type">Some</span>(f(value))<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] =<br>    <span class="hljs-keyword">this</span>.map(f).getOrElse(<span class="hljs-type">None</span>)<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOrElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-keyword">default</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(value) =&gt; value<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] =<br>    <span class="hljs-keyword">this</span>.map(<span class="hljs-type">Some</span>(_)).getOrElse(<span class="hljs-keyword">default</span>)<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =<br>    <span class="hljs-keyword">this</span>.flatMap(value =&gt; <span class="hljs-keyword">if</span> (f(value)) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> <span class="hljs-type">None</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>由于无法使用模式匹配，flatMap，orElse 和 filter 几个函数编写起来都是非常费劲的，但其中最重要的一个地方是，能够发现<code>getOrElse(None)</code>能起到<code>flatten</code>的效果。</p>
<p>对 flatMap，考虑对于一个<code>Option[Option[Int]]</code>，对<code>Some(Some(1))</code>抑或是<code>Some(None)</code>，我们对其调用<code>this.getOrElse(None)</code>，能发现它们会返回<code>Some(1)</code>和<code>None</code>；而对于<code>None</code>，返回的则是 None，该行为和<code>flatten</code>一致。有了 map，有了 flatten，我们就能够实现 flatMap。</p>
<p>对 orElse，它的行为是若 this 是 None，则返回 default，否则返回 this。为此我们又需要检查 this 的类型，为此我们又得包装成<code>Option[Option[A]]</code>，使用何种手段进行包装是显然的：对于 None，我们啥都做不了，只能整 None（<code>Some(None)</code>也行，但这里现有的工具做不到）；对于 Some(x)，我们必须要保留这个 x（之后还得用），为此我们返回<code>Some(Some(x))</code>，容易发现，使用<code>this.map(Some(_))</code>能做到这一点。</p>
<p>然后我们肯定得调用 getOrElse 对其展平。根据 orElse 的需求，对于<code>Some(Some(x))</code>，我们希望能得到<code>Some(x)</code>，对于<code>None</code>，我们希望得到 default，答案是字面的。</p>
<p>对于 filter，这种的之前也写过，不用多说。</p>
<p>顺带一提，getOrElse 中使用了非严格求值的语法，这使它能用于一些返回默认值之外的其它目的，比如<code>getOption(map, 1).getOrElse(throw new Exception(&quot;you bad bad&quot;))</code>，倘若 Java 能引入<code>=&gt; A</code>语法的话，就不需要为此定义好几个方法了。</p>
<h1 id="4-2-使用-flatMap-实现一个求方差的函数"><a href="#4-2-使用-flatMap-实现一个求方差的函数" class="headerlink" title="4.2 使用 flatMap 实现一个求方差的函数"></a>4.2 使用 flatMap 实现一个求方差的函数</h1><p>函数签名如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">variance</span></span>(xs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">Double</span>]<br></code></pre></div></td></tr></table></figure>
<p>方差的公式请自己百度。为什么这题和 Option 扯上关系呢？这一章是关于错误处理的，而能够发现，对于空的序列求平均数是无法做到的，平均数的函数我们得这么写：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mean</span></span>(xs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">Double</span>] =<br>  <span class="hljs-keyword">if</span> (xs.isEmpty) <span class="hljs-type">None</span> <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">val</span> (sum, length) = xs.foldLeft((<span class="hljs-number">0.0</span>, <span class="hljs-number">0</span>))<br>      &#123; <span class="hljs-keyword">case</span> ((sum, length), x) =&gt; (sum + x, length + <span class="hljs-number">1</span>) &#125;<br>    <span class="hljs-type">Some</span>(sum / length)<br>  &#125;<br></code></pre></div></td></tr></table></figure>
<p>在求方差时，我们先求出序列的平均数，再对序列的每个元素做映射，求映射后的序列的平均数，这里有两次求平均数，如果第一次失败，则后一次计算不应该执行，我们可以得到这样的代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">variance</span></span>(xs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">Double</span>] =<br>  mean(xs).flatMap(m =&gt; mean(xs.map(x =&gt; math.pow(x - m, <span class="hljs-number">2</span>))))<br></code></pre></div></td></tr></table></figure>
<p>使用 for 描述会更加清晰。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">variance</span></span>(xs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">Double</span>] = <span class="hljs-keyword">for</span> &#123;<br>  m &lt;- mean(xs)                          <span class="hljs-comment">// 求平均数</span><br>  ys = xs.map(x =&gt; math.pow(x - m, <span class="hljs-number">2</span>))   <span class="hljs-comment">// 对序列做映射</span><br>  result &lt;- mean(ys)                     <span class="hljs-comment">// 求映射后的序列的平均数</span><br>&#125; <span class="hljs-keyword">yield</span> result<br></code></pre></div></td></tr></table></figure>
<h1 id="4-3-map2"><a href="#4-3-map2" class="headerlink" title="4.3 map2"></a>4.3 map2</h1><p>实现一个 map2 函数，其行为是把<code>(A, B) =&gt; C</code>的函数提升为<code>(Option[A], Option[B]) =&gt; Option[C]</code>，签名和实现如下。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](a: <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>], b: <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">C</span>] = <br>  a.flatMap(va =&gt; b.map(vb =&gt; f(va, vb)))<br></code></pre></div></td></tr></table></figure>
<p>对它的实现是显然的，关键问题就是如何同时让 a 和 b 中的值处在作用域中，这在之前已经学习过了。</p>
<p>当然，也可以用 for 去实现，或者同时对 a 和 b 做模式匹配，只有两个都为 Some 的时候再返回<code>Some(f(va, vb))</code>，否则返回 None。</p>
<h1 id="4-4-sequence"><a href="#4-4-sequence" class="headerlink" title="4.4 sequence"></a>4.4 sequence</h1><p>把<code>List[Option[A]]</code>转换为<code>Option[List[A]]</code>，当原列表中存在任意<code>None</code>则返回 None，否则返回<code>Some(List(...))</code>。</p>
<p>该题在 Haskell 中做过，不用多说，重点是把<code>::</code>进行提升，转换为<code>(Option[A], Option[B]) =&gt; Option[C]</code>的函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence</span></span>[<span class="hljs-type">A</span>](xs: <span class="hljs-type">List</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">Option</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>]] =<br>  xs.foldRight(<span class="hljs-type">Some</span>(<span class="hljs-type">Nil</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>]])((x, acc) =&gt; map2(x, acc)(_ :: _))<br></code></pre></div></td></tr></table></figure>
<h1 id="4-5-traverse"><a href="#4-5-traverse" class="headerlink" title="4.5 traverse"></a>4.5 traverse</h1><p>traverse 的签名和实现如下，它相当于是把原列表先 map 成 Option 再执行 sequence 方法，但如此的话会遍历两次列表，效率不够好，这里只需要遍历一次。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traverse</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](a: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">List</span>[<span class="hljs-type">B</span>]] =<br>  a.foldRight(<span class="hljs-type">Some</span>(<span class="hljs-type">Nil</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">List</span>[<span class="hljs-type">B</span>]])((x, acc) =&gt; map2(f(x), acc)(_ :: _))<br></code></pre></div></td></tr></table></figure>
<p>容易发现，traverse 可以实现 sequence：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence</span></span>[<span class="hljs-type">A</span>](xs: <span class="hljs-type">List</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">Option</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>]] =<br>  traverse(xs)(identity)<br></code></pre></div></td></tr></table></figure>
<h1 id="4-6-map，flatMap，orElse，map2"><a href="#4-6-map，flatMap，orElse，map2" class="headerlink" title="4.6 map，flatMap，orElse，map2"></a>4.6 map，flatMap，orElse，map2</h1><p>实现 Either 的 map，flatMap，orElse，map2，注意 flatMap 和 orElse 的类型定义。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Either</span>[+<span class="hljs-type">E</span>, +<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(value) =&gt; <span class="hljs-type">Right</span>(f(value))<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(value) =&gt; <span class="hljs-type">Left</span>(value)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">EE</span> &gt;: <span class="hljs-type">E</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">B</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(value) =&gt; f(value)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(value) =&gt; <span class="hljs-type">Left</span>(value)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orElse</span></span>[<span class="hljs-type">EE</span> &gt;: <span class="hljs-type">E</span>, <span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">B</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(value) =&gt; <span class="hljs-type">Right</span>(value)<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-keyword">default</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2</span></span>[<span class="hljs-type">EE</span> &gt;: <span class="hljs-type">E</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](b: <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">C</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(aa) =&gt; b.map(bb =&gt; f(aa, bb))<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(value) =&gt; <span class="hljs-type">Left</span>(value)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Left</span>[+<span class="hljs-type">E</span>](<span class="hljs-params">value: <span class="hljs-type">E</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">Nothing</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Right</span>[+<span class="hljs-type">A</span>](<span class="hljs-params">value: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Either</span>[<span class="hljs-type">Nothing</span>, <span class="hljs-type">A</span>]</span><br></code></pre></div></td></tr></table></figure>
<h1 id="4-7-sequence-和-traverse"><a href="#4-7-sequence-和-traverse" class="headerlink" title="4.7 sequence 和 traverse"></a>4.7 sequence 和 traverse</h1><p>实现 Either 的 sequence 和 traverse 函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traverse</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">List</span>[<span class="hljs-type">B</span>]] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Right</span>(<span class="hljs-type">Nil</span>)<br>  <span class="hljs-keyword">case</span> x :: xs =&gt; f(x).map2(traverse(xs)(f))(_ :: _) <span class="hljs-comment">// 这里的 map2 使用函数形式的话更好看一些</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traverse_1</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">List</span>[<span class="hljs-type">B</span>]] = <br>  l.foldRight(<span class="hljs-type">Right</span>(<span class="hljs-type">Nil</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">List</span>[<span class="hljs-type">B</span>]])&#123;(x, acc) =&gt; f(x).map2(acc)(_ :: _)&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>]]): <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]] = <br>  traverse(l, identity)<br></code></pre></div></td></tr></table></figure>
<h1 id="4-8-如何保留所有错误？"><a href="#4-8-如何保留所有错误？" class="headerlink" title="4.8 如何保留所有错误？"></a>4.8 如何保留所有错误？</h1><p>Either 有一个缺点，就是它是“Fail Fast”的，第一次出现 Left 时就直接终止掉了，但有时候我们希望能保留每个 Left 的信息。比如我们定义一个 Person，有两个字段 name 和 age，两者都有格式要求，我们定义一个函数去创建 Person，并要求每个错误的输入都要保存错误信息。</p>
<p>根据 Either 的使用方法，我们首先写出这样的代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkName</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">String</span>] =<br>  <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span> || name.isEmpty) <span class="hljs-type">Left</span>(<span class="hljs-string">&quot;name can&#x27;t be empty!&quot;</span>)<br>  <span class="hljs-keyword">else</span> <span class="hljs-type">Right</span>(name)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkAge</span></span>(age: <span class="hljs-type">Int</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <br>  <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">150</span>) <span class="hljs-type">Left</span>(<span class="hljs-string">&quot;invalid age value!&quot;</span>)<br>  <span class="hljs-keyword">else</span> <span class="hljs-type">Right</span>(age)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkPerson</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Person</span>] = <span class="hljs-keyword">for</span> &#123;<br>  n &lt;- mkName(name)<br>  a &lt;- mkAge(age)<br>&#125; <span class="hljs-keyword">yield</span> <span class="hljs-type">Person</span>(n, a)<br></code></pre></div></td></tr></table></figure>
<p>这能用，但是问题是如果 name 和 age 同时不合法，则只有 name 的错误消息得以保存。这里需要使用类似 Haskell 的 Writer 这样的类型，这时候 E 要求是 Monoid。我们把 E 的范围放窄到 List[E]，可以临时定义一个 map2All 函数并用以实现满足需求的 mkPerson：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2All</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](a: <span class="hljs-type">Either</span>[<span class="hljs-type">List</span>[<span class="hljs-type">E</span>], <span class="hljs-type">A</span>], b: <span class="hljs-type">Either</span>[<span class="hljs-type">List</span>[<span class="hljs-type">E</span>], <span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">List</span>[<span class="hljs-type">E</span>], <span class="hljs-type">C</span>] = (a, b) <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> (<span class="hljs-type">Right</span>(aa), <span class="hljs-type">Right</span>(bb)) =&gt; <span class="hljs-type">Right</span>(f(aa, bb))<br>  <span class="hljs-keyword">case</span> (<span class="hljs-type">Left</span>(aa), <span class="hljs-type">Left</span>(bb)) =&gt; <span class="hljs-type">Left</span>(aa ++ bb)<br>  <span class="hljs-keyword">case</span> (<span class="hljs-type">Left</span>(aa), _) =&gt; <span class="hljs-type">Left</span>(aa)<br>  <span class="hljs-keyword">case</span> (_, <span class="hljs-type">Left</span>(bb)) =&gt; <span class="hljs-type">Left</span>(bb)<br>&#125;<br><br><span class="hljs-comment">// mkName 和 mkAge 的类型也需要改变</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkPerson</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">List</span>[<span class="hljs-type">String</span>], <span class="hljs-type">Person</span>] =<br>  map2All(mkName(name), mkAge(age))(<span class="hljs-type">Person</span>(_, _)) <br></code></pre></div></td></tr></table></figure>
<p>但这样的话就无法使用 for 和常用高阶函数了，还是另外定义一个新的 ADT（Monad）来干这活比较好。</p>
<h1 id="5-1-toList"><a href="#5-1-toList" class="headerlink" title="5.1 toList"></a>5.1 toList</h1><p>这一章就感觉整个都挺魔法的，之后还有更多魔法～</p>
<p>下面的代码都假设是使用 cons 函数而非 Cons 值构造器进行构造的，因此不考虑 thunk 重复计算的问题。</p>
<p>实现 Stream 的 toList 方法，其计算整个 Stream 并以 List 的形式返回结果，直接写最明显的递归。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toList</span></span>(): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; h() :: t().toList()<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>考虑到该方法可能有副作用，所以使用带括号的形式。</p>
<h1 id="5-2-take，drop"><a href="#5-2-take，drop" class="headerlink" title="5.2 take，drop"></a>5.2 take，drop</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">take</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> =&gt; <span class="hljs-type">Stream</span>.cons(h(), t().take(n - <span class="hljs-number">1</span>))<br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Empty</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drop</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> _ <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> =&gt; <span class="hljs-keyword">this</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">Empty</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; t().drop(n - <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="5-3-takeWhile"><a href="#5-3-takeWhile" class="headerlink" title="5.3 takeWhile"></a>5.3 takeWhile</h1><p>takeWhile 方法，可处理无穷列表。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeWhile</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) <span class="hljs-keyword">if</span> f(h()) =&gt; <span class="hljs-type">Stream</span>.cons(h(), t().takeWhile(f))<br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Empty</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="5-4-forAll"><a href="#5-4-forAll" class="headerlink" title="5.4 forAll"></a>5.4 forAll</h1><p>forAll 方法，特点是一旦遇到 false 就直接短路终止，因此可处理无穷列表，但如果全部都是 true 的话会一直运行下去。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forAll</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Boolean</span> =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-literal">true</span>)((x, acc) =&gt; p(x) &amp;&amp; acc)<br></code></pre></div></td></tr></table></figure>
<h1 id="5-5-使用-foldRight-实现-takeWhile-方法"><a href="#5-5-使用-foldRight-实现-takeWhile-方法" class="headerlink" title="5.5 使用 foldRight 实现 takeWhile 方法"></a>5.5 使用 foldRight 实现 takeWhile 方法</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeWhile</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>])&#123;(x, acc) =&gt;<br>    <span class="hljs-keyword">if</span> (p(x)) cons(x, acc)<br>    <span class="hljs-keyword">else</span> <span class="hljs-type">Empty</span><br>  &#125;<br></code></pre></div></td></tr></table></figure>
<p>这玩意为啥这样实现？还是考虑我的那种表示法，比如对<code>Nat.takeWhile(_ &lt; 5)</code>，会得到这样的序列：</p>
<figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Haskell"><span class="hljs-number">0</span> &lt;=&lt; <span class="hljs-number">1</span> &lt;=&lt; <span class="hljs-number">2</span> &lt;=&lt; <span class="hljs-number">3</span> &lt;=&lt; ... &lt;=&lt; n &lt;=&lt; []<br></code></pre></div></td></tr></table></figure>
<p>对后面的任意大于等于 5 的 n，<code>n &lt;=&lt; []</code>都返回<code>[]</code>，因此最后得到的计算序列仍旧是：</p>
<figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Haskell"><span class="hljs-number">0</span> &lt;=&lt; <span class="hljs-number">1</span> &lt;=&lt; <span class="hljs-number">2</span> &lt;=&lt; <span class="hljs-number">3</span> &lt;=&lt; <span class="hljs-number">4</span> &lt;=&lt; <span class="hljs-number">5</span> &lt;=&lt; []<br></code></pre></div></td></tr></table></figure>
<p>由此便得到了正确结果。但容易发现，惰性列表的 foldRight 仍旧是会爆栈的。</p>
<h1 id="5-6-使用-foldRight-实现-headOption-方法"><a href="#5-6-使用-foldRight-实现-headOption-方法" class="headerlink" title="5.6 使用 foldRight 实现 headOption 方法"></a>5.6 使用 foldRight 实现 headOption 方法</h1><p>这题……哪里难了？</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">headOption</span></span>: <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">None</span>: <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>])((x, _) =&gt; <span class="hljs-type">Some</span>(x))<br></code></pre></div></td></tr></table></figure>
<h1 id="5-7-使用-foldRight-实现-map，filter，append，flatMap"><a href="#5-7-使用-foldRight-实现-map，filter，append，flatMap" class="headerlink" title="5.7 使用 foldRight 实现 map，filter，append，flatMap"></a>5.7 使用 foldRight 实现 map，filter，append，flatMap</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>])((x, acc) =&gt; <span class="hljs-type">Stream</span>.cons(f(x), acc))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>])((x, acc) =&gt; <span class="hljs-keyword">if</span> (p(x)) <span class="hljs-type">Stream</span>.cons(x, acc) <span class="hljs-keyword">else</span> acc)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](ys: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(ys)(<span class="hljs-type">Stream</span>.cons(_, _))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>])((x, acc) =&gt; f(x).append(acc))<br></code></pre></div></td></tr></table></figure>
<p>关于 append 奇怪的类型参数，这再次关系到协变和逆变的机制，当前还没有学习。</p>
<h1 id="5-8-repeat"><a href="#5-8-repeat" class="headerlink" title="5.8 repeat"></a>5.8 repeat</h1><p>返回一个无穷流，每个元素都为一个给定值。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constant</span></span>[<span class="hljs-type">A</span>](n: <span class="hljs-type">A</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <br>  <span class="hljs-type">Stream</span>.cons(n, constant(n))<br></code></pre></div></td></tr></table></figure>
<h1 id="5-9-from"><a href="#5-9-from" class="headerlink" title="5.9 from"></a>5.9 from</h1><p>给定一个整数 n，返回 n，n + 1，n + 2……的无穷流。答案是挺显然的，这里有一个模式：之后的值由之前的值去生成。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] =<br>  <span class="hljs-type">Stream</span>.cons(n, from(n + <span class="hljs-number">1</span>))<br></code></pre></div></td></tr></table></figure>
<h1 id="5-10-fibs"><a href="#5-10-fibs" class="headerlink" title="5.10 fibs"></a>5.10 fibs</h1><p>斐波那契数列的无限流。实现类似 from——对于每个元素，我们求它的时候需要知道之前的两个元素，为此这两个元素需要当作状态去传递。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibs</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)] =<br>    <span class="hljs-type">Stream</span>.cons((a, b), from(b, a + b))<br>  from(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).map(_._1)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="5-11-unfold"><a href="#5-11-unfold" class="headerlink" title="5.11 unfold"></a>5.11 unfold</h1><p>从上面的 from 和 fibs 抽象出一个更广泛的流构造函数，其不断地去维护一个状态，每一次这个状态都将生成一个新的状态以及要添加到流中的值，也可以终止该操作（当返回 None 时）。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unfold</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">S</span>](z: <span class="hljs-type">S</span>)(f: <span class="hljs-type">S</span> =&gt; <span class="hljs-type">Option</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">S</span>)]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = f(z) <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">Empty</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>((value, nextState)) =&gt; <span class="hljs-type">Stream</span>.cons(value, unfold(nextState)(f))<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>但这个函数最有趣的地方其实是它叫”unfold”。</p>
<blockquote>
<p>这书的翻译真差劲！太差劲了！</p>
</blockquote>
<h1 id="5-12-使用-unfold-实现-fibs，from，constant，ones"><a href="#5-12-使用-unfold-实现-fibs，from，constant，ones" class="headerlink" title="5.12 使用 unfold 实现 fibs，from，constant，ones"></a>5.12 使用 unfold 实现 fibs，from，constant，ones</h1><p>题目本身是不难的。根据书中描述，原生的 constant，ones 只需要使用常量的内存，而 unfold 实现的无法如此，但这是可以容忍的。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibs</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] =<br>  unfold((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))&#123; <span class="hljs-keyword">case</span> (a, b) =&gt; <span class="hljs-type">Some</span>((a, (b, a + b))) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from</span></span>(n): <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = <br>  unfold(n)(x =&gt; <span class="hljs-type">Some</span>(x, x + <span class="hljs-number">1</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constant</span></span>[<span class="hljs-type">A</span>](elem: <span class="hljs-type">A</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <br>  unfold(elem)(x =&gt; <span class="hljs-type">Some</span>(x, x))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ones</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = constant(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>
<h1 id="5-13-使用-unfold-实现-map，take，takeWhile，zipWith，zipAll"><a href="#5-13-使用-unfold-实现-map，take，takeWhile，zipWith，zipAll" class="headerlink" title="5.13 使用 unfold 实现 map，take，takeWhile，zipWith，zipAll"></a>5.13 使用 unfold 实现 map，take，takeWhile，zipWith，zipAll</h1><p>我承认，作者十分擅长给读者造成惊吓。看起来，unfold 和 fold 就“原子性”来说具有十分类似的地位。但 unfold 无法实现像 filter 这样的操作，它只能取“前缀”。它们各有所长，各有有趣之处。</p>
<p>unfold 实现 map，为此需要再次回忆 unfold 的机制——根据当前的状态生成一个值以及新的状态，这些值将构成新的流。答案是显然的：我们用原列表作为初始状态，每次将头部的元素做映射，然后作为返回的值，剩下的列表作为新的状态。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-comment">// 这个函数写着就很不爽——这里需要进行解构，但解构的话会多一层括号，只能使用偏函数语法，但偏函数的话无法得到编译器的帮助，如果写错了那错误只能在运行时发现</span><br><span class="hljs-comment">// 另外，f 作为第一个参数的话 Scala 无法进行类型推导，实践中不能这么干</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] =<br>  unfold(xs) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; <span class="hljs-type">Some</span>( (f(h()), t()) )<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">None</span><br>  &#125;<br></code></pre></div></td></tr></table></figure>
<p>takeWhile 的编写是显然的：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeWhile</span></span>[<span class="hljs-type">A</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>)(xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>  unfold(xs) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) <span class="hljs-keyword">if</span> f(h()) =&gt; <span class="hljs-type">Some</span>((h(), t()))<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span><br>  &#125;<br></code></pre></div></td></tr></table></figure>
<p>根据前面编写 take 的实践，take 需要先将原值和 index 做 zip，因此先实现 zipWith。zipWith 在其中一个流没有元素的时候终止：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zipWith</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>)(xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>], ys: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">C</span>] =<br>  unfold((xs, ys)) &#123;<br>    <span class="hljs-keyword">case</span> (<span class="hljs-type">Cons</span>(hx, tx), <span class="hljs-type">Cons</span>(hy, ty)) =&gt; <span class="hljs-type">Some</span>((f(hx(), hy()), (tx(), ty())))<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span><br>  &#125;<br></code></pre></div></td></tr></table></figure>
<p>然后是 take，也是显然的：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">take</span></span>[<span class="hljs-type">A</span>](n: <span class="hljs-type">Int</span>)(xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>  zip(xs, <span class="hljs-type">Stream</span>.<span class="hljs-type">Nat</span>)<br>    .takeWhile &#123;<span class="hljs-keyword">case</span> (_, index) =&gt; index &lt; n &#125;<br>    .map(_._1)<br></code></pre></div></td></tr></table></figure>
<p>当然，也可以一个 unfold 直接解决问题。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">take</span></span>[<span class="hljs-type">A</span>](n: <span class="hljs-type">Int</span>)(xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <br>  unfold((xs, <span class="hljs-type">Stream</span>.<span class="hljs-type">Nat</span>)) &#123;<br>    <span class="hljs-keyword">case</span> (<span class="hljs-type">Cons</span>(hx, tx), <span class="hljs-type">Cons</span>(hy, ty)) <span class="hljs-keyword">if</span> hy() &lt; n =&gt; <span class="hljs-type">Some</span>(hx(), (tx(), ty()))<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span><br>  &#125;<br></code></pre></div></td></tr></table></figure>
<p>zipAll 函数的行为从它的签名就能看出来——相较于 zipWith，它会在其中一个流没有元素时仍旧进行操作，因此 zipAll 无法使用 zipWith 进行实现，其行为不同。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zipAll</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>], ys: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Stream</span>[(<span class="hljs-type">Option</span>[<span class="hljs-type">A</span>], <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>])] = &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tail</span></span>[<span class="hljs-type">X</span>](zs: <span class="hljs-type">Stream</span>[<span class="hljs-type">X</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">X</span>] = zs <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">Empty</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(_, t) =&gt; t()<br>  &#125;<br>  unfold((xs, ys)) &#123;<br>    <span class="hljs-keyword">case</span> (<span class="hljs-type">Empty</span>, <span class="hljs-type">Empty</span>) =&gt; <span class="hljs-type">None</span><br>    <span class="hljs-keyword">case</span> (xs, ys) =&gt; <span class="hljs-type">Some</span>((xs.headOption, ys.headOption), (tail(xs), tail(ys)))<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这里别想用 for 或者 Option 的方法去做实现，Option 的组合策略和这个无关。</p>
<h1 id="5-14-startsWith"><a href="#5-14-startsWith" class="headerlink" title="5.14 startsWith"></a>5.14 startsWith</h1><p>检查一个流是否以另一个流为起始，这题确实挺复杂。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream method</span><br><span class="hljs-comment">// 为啥我写这种方法都要问我要确定协变逆变呢……</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startsWith</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](ys: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Boolean</span> =<br>  <span class="hljs-type">Stream</span>.zipAll(<span class="hljs-keyword">this</span>, ys).foldRight(<span class="hljs-literal">true</span>)&#123;(pair, acc) =&gt;<br>    pair <span class="hljs-keyword">match</span> &#123;<br>      <span class="hljs-keyword">case</span> (<span class="hljs-type">Some</span>(x), <span class="hljs-type">Some</span>(y)) =&gt; x == y &amp;&amp; acc  <span class="hljs-comment">// 如果当前元素相等，去判断接下来的元素</span><br>      <span class="hljs-keyword">case</span> (<span class="hljs-type">Some</span>(_), <span class="hljs-type">None</span>) =&gt; <span class="hljs-literal">true</span>              <span class="hljs-comment">// 如果当前流有值，另一个流没有值，则 true</span><br>      <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span>                           <span class="hljs-comment">// 其它情况都是 false</span><br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="5-15-tails"><a href="#5-15-tails" class="headerlink" title="5.15 tails"></a>5.15 tails</h1><p>tails，行为类似 scan 操作，得到流的每一个元素的 tail 并组成新的流，比如对<code>Stream(1, 2, 3)</code>，会得到<code>Stream(Stream(1, 2, 3), Stream(2, 3), Stream(3), Empty)</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tails</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]] =<br>  <span class="hljs-type">Stream</span>.cons(<span class="hljs-keyword">this</span>, <span class="hljs-type">Stream</span>.unfold(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">None</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; <span class="hljs-type">Some</span>((t(), t()))<br>  &#125;)<br></code></pre></div></td></tr></table></figure>
<p>这个 tails 感觉很不优雅……</p>
<p>借助 tails 和 startsWith 方法，我们能方便地去表述 hasSubSequence 方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasSubSequence</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](ys: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Boolean</span> =<br>  tails exists (_ startsWith s)<br></code></pre></div></td></tr></table></figure>
<p>这个 hasSubSequence 和之前写的显式递归的方法的效率是一致的，区别在于这里使用高阶函数的组合去进行表述，这是惰性列表的优越之处。放到普通列表，tails 和 startsWith 都会有额外的计算。</p>
<h1 id="5-16-scanRight"><a href="#5-16-scanRight" class="headerlink" title="5.16 scanRight"></a>5.16 scanRight</h1><p>实现 scan 方法。scan 方法的签名和 fold 一致，但返回值为列表，其作用效果相当于是对列表本身以及每一个 tail 进行 fold 操作并拼接成结果的列表，但性能是线性的；也可以说是每一次折叠都去暂存结果。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scanRight</span></span>[<span class="hljs-type">B</span>](z: =&gt; <span class="hljs-type">B</span>)(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Stream</span>.cons(z, <span class="hljs-type">Empty</span>))&#123; <span class="hljs-keyword">case</span> (x, acc<span class="hljs-meta">@Cons</span>(h, _)) =&gt; <br>    <span class="hljs-type">Stream</span>.cons(f(x, h()), acc) &#125;<br></code></pre></div></td></tr></table></figure>
<p>unfold 能实现 scanRight 吗？当然能实现，每次都从当前的状态进行折叠即可，但它无法做到线性的时间复杂度，因为之前的状态无法被储存，比如对于<code>Stream(1, 2, 3).scanRight(0)(_ + _)</code>，在之前已经计算过<code>2 + 3</code>，因此计算<code>1 + 2 + 3</code>的时候只需要让<code>1</code>加上<code>2 + 3</code>的结果即可。</p>
<h1 id="6-1-nonNegativeInt"><a href="#6-1-nonNegativeInt" class="headerlink" title="6.1 nonNegativeInt"></a>6.1 nonNegativeInt</h1><p>获得一个随机非负整数，注意当拿到的随机数正巧为<code>Int.MinValue</code>时，<code>Math.abs</code>调用仍会返回这个最小值，因此在遇到这个值的时候重新随机。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-meta">@tailrec</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nonNegativeInt</span></span>(rng: <span class="hljs-type">RNG</span>): (<span class="hljs-type">Int</span>, <span class="hljs-type">RNG</span>) = &#123;<br>  <span class="hljs-keyword">val</span> (v, r) = rng.nextInt<br>  <span class="hljs-keyword">if</span> (v == <span class="hljs-type">Int</span>.<span class="hljs-type">MinValue</span>) nonNegativeInt(r)<br>  <span class="hljs-keyword">else</span> (<span class="hljs-type">Math</span>.abs(v), r)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="6-2-double"><a href="#6-2-double" class="headerlink" title="6.2 double"></a>6.2 double</h1><p>获得一个随机的0到1的double，仍旧比较容易。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">double</span></span>(rng: <span class="hljs-type">RNG</span>): (<span class="hljs-type">Double</span>, <span class="hljs-type">RNG</span>) = &#123;<br>  <span class="hljs-keyword">val</span> (v, r) = nonNegativeInt(rng)<br>  (v / <span class="hljs-type">Int</span>.<span class="hljs-type">MaxValue</span>.toDouble, r)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="6-3-intDouble，doubleInt，double3"><a href="#6-3-intDouble，doubleInt，double3" class="headerlink" title="6.3 intDouble，doubleInt，double3"></a>6.3 intDouble，doubleInt，double3</h1><p>这三个函数的实现都是比较简单的，主要目的是考虑它之中重复出现的模式——我们手动维护了状态的变化，即rng，r1，r2等变量。这写起来非常蛋疼，且容易出bug，难以维护。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intDouble</span></span>(rng: <span class="hljs-type">RNG</span>): ((<span class="hljs-type">Int</span>, <span class="hljs-type">Double</span>), <span class="hljs-type">RNG</span>) = &#123;<br>  <span class="hljs-keyword">val</span> (v1, r1) = rng.nextInt<br>  <span class="hljs-keyword">val</span> (v2, r2) = double(r1)<br>  ((v1, v2), r2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doubleInt</span></span>(rng: <span class="hljs-type">RNG</span>): ((<span class="hljs-type">Double</span>, <span class="hljs-type">Int</span>), <span class="hljs-type">RNG</span>) = &#123;<br>  <span class="hljs-keyword">val</span> (v1, r1) = double(rng)<br>  <span class="hljs-keyword">val</span> (v2, r2) = r1.nextInt<br>  ((v1, v2), r2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">double3</span></span>(rng: <span class="hljs-type">RNG</span>): ((<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>), <span class="hljs-type">RNG</span>) = &#123;<br>  <span class="hljs-keyword">val</span> (v1, r1) = double(rng)<br>  <span class="hljs-keyword">val</span> (v2, r2) = double(r1)<br>  <span class="hljs-keyword">val</span> (v3, r3) = double(r2)<br>  ((v1, v2, v3), r3)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="6-4-ints"><a href="#6-4-ints" class="headerlink" title="6.4 ints"></a>6.4 ints</h1><p>返回一个<code>Int</code>的列表，这种题目显然需要使用递归，感觉这好像是一个unfold操作，但既然书中没有对此进行进一步抽象，那我也就敬谢不敏了。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ints</span></span>(count: <span class="hljs-type">Int</span>)(rng: <span class="hljs-type">RNG</span>): (<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>], <span class="hljs-type">RNG</span>) =<br>  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) (<span class="hljs-type">Nil</span>, rng)<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">val</span> (v, r) = rng.nextInt<br>    <span class="hljs-keyword">val</span> (last, s) = ints(count - <span class="hljs-number">1</span>)(r)<br>    (v :: last, s)<br>  &#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="6-5-使用map实现double"><a href="#6-5-使用map实现double" class="headerlink" title="6.5 使用map实现double"></a>6.5 使用map实现double</h1><p>不难，用于熟悉抽象。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">val</span> double$: <span class="hljs-type">Rand</span>[<span class="hljs-type">Double</span>] = <br>  map(nonNegativeInt)(_ / <span class="hljs-type">Int</span>.<span class="hljs-type">MaxValue</span>.toDouble)<br></code></pre></div></td></tr></table></figure>
<h1 id="6-6-map2"><a href="#6-6-map2" class="headerlink" title="6.6 map2"></a>6.6 map2</h1><p>实现map2，该操作（组合子）的形式非常熟悉。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](a: <span class="hljs-type">Rand</span>[<span class="hljs-type">A</span>], b: <span class="hljs-type">Rand</span>[<span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Rand</span>[<span class="hljs-type">C</span>] = rng =&gt; &#123;<br>  <span class="hljs-keyword">val</span> (v1, r1) = a(rng)<br>  <span class="hljs-keyword">val</span> (v2, r2) = b(r1)<br>  (f(v1, v2), r2)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="6-7-sequence"><a href="#6-7-sequence" class="headerlink" title="6.7 sequence"></a>6.7 sequence</h1><p>sequence就是将一连串的Rand按序执行，可以注意到这操作的形式和折叠很像。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence</span></span>[<span class="hljs-type">A</span>](fs: <span class="hljs-type">List</span>[<span class="hljs-type">Rand</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">Rand</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>]] = rng =&gt; fs <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; (<span class="hljs-type">Nil</span>, rng)<br>  <span class="hljs-keyword">case</span> x :: xs =&gt; map2(x, sequence(xs))(_ :: _)(rng)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>使用sequence实现ints也是简单的：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ints$</span></span>(count: <span class="hljs-type">Int</span>): <span class="hljs-type">Rand</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]] =<br>  sequence(<span class="hljs-type">List</span>.fill(count)(_.nextInt))<br></code></pre></div></td></tr></table></figure>
<h1 id="6-8-flatMap"><a href="#6-8-flatMap" class="headerlink" title="6.8 flatMap"></a>6.8 flatMap</h1><p>flatMap的实现就很有趣了，可以将flatMap理解为顺序的计算，先将当前的计算进行执行，再将计算后得到的状态传递给后一个计算。这样理解大概对一切monad都适用。</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](a: <span class="hljs-type">Rand</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Rand</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Rand</span>[<span class="hljs-type">B</span>] = rng =&gt; &#123;<br>  <span class="hljs-keyword">val</span> (v, r) = a(rng)<br>  f(v)(r)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="6-9-使用flatMap实现map和map2"><a href="#6-9-使用flatMap实现map和map2" class="headerlink" title="6.9 使用flatMap实现map和map2"></a>6.9 使用flatMap实现map和map2</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map$</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](a: <span class="hljs-type">Rand</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Rand</span>[<span class="hljs-type">B</span>] = flatMap(a) &#123; i =&gt; unit(f(i)) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2$</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](ra: <span class="hljs-type">Rand</span>[<span class="hljs-type">A</span>], rb: <span class="hljs-type">Rand</span>[<span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Rand</span>[<span class="hljs-type">C</span>] =<br>  flatMap(ra)(a =&gt; map(rb)(b =&gt; f(a, b))) <span class="hljs-comment">// 或者 flatMap(ra)(a =&gt; flatMap(rb)(b =&gt; unit(f(a, b))))</span><br></code></pre></div></td></tr></table></figure>
<h1 id="6-10-泛化unit，map，map2，flatMap，sequence"><a href="#6-10-泛化unit，map，map2，flatMap，sequence" class="headerlink" title="6.10 泛化unit，map，map2，flatMap，sequence"></a>6.10 泛化unit，map，map2，flatMap，sequence</h1><p>将纯函数式状态（转移）抽象出来，并实现相应方法或函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span>[<span class="hljs-type">S</span>, +<span class="hljs-type">A</span>](<span class="hljs-params">run: <span class="hljs-type">S</span> =&gt; (<span class="hljs-type">A</span>, <span class="hljs-type">S</span></span>)) </span>&#123;<br>  <span class="hljs-comment">// map方法就是构造一个新的State，该State为当前State执行后对结果进行一个映射</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">B</span>] = <span class="hljs-type">State</span> &#123; s =&gt;<br>    <span class="hljs-keyword">val</span> (r, nextS) = run(s)<br>    (f(r), nextS)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2</span></span>[<span class="hljs-type">B</span>, <span class="hljs-type">C</span>](b: <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">C</span>] = <span class="hljs-type">State</span> &#123; s =&gt;<br>    <span class="hljs-keyword">val</span> (r1, s1) = run(s)<br>    <span class="hljs-keyword">val</span> (r2, s2) = b.run(s1)<br>    (f(r1, r2), s2)<br>  &#125;<br><br>  <span class="hljs-comment">// 先执行当前计算，将下一个值传给f，对生成的State执行计算</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">B</span>] = <span class="hljs-type">State</span> &#123; s =&gt;<br>    <span class="hljs-keyword">val</span> (r1, s1) = run(s)<br>    f(r1).run(s1)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">State</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unit</span></span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>] = <span class="hljs-type">State</span>((a, _))<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence</span></span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>](a: <span class="hljs-type">List</span>[<span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>]]): <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]] = a <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">State</span>((<span class="hljs-type">Nil</span>, _))<br>    <span class="hljs-keyword">case</span> x :: xs =&gt; x.map2(sequence(xs))(_ :: _)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="6-11-实现一个简单的有穷状态自动机"><a href="#6-11-实现一个简单的有穷状态自动机" class="headerlink" title="6.11 实现一个简单的有穷状态自动机"></a>6.11 实现一个简单的有穷状态自动机</h1><p>这题虽然说着难，但是操作起来还是挺简单的，主要是要根据规则编写状态转移的函数。当编写完状态转移的函数后，便能够编写接受一连串命令的函数了（我看这个函数好像又是个折叠操作）：</p>
<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Input</span></span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Coin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Input</span></span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Turn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Input</span></span><br><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Machine</span>(<span class="hljs-params">locked: <span class="hljs-type">Boolean</span>, coins: <span class="hljs-type">Int</span>, candies: <span class="hljs-type">Int</span></span>)</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Machine</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">operate</span></span>(input: <span class="hljs-type">Input</span>): <span class="hljs-type">State</span>[<span class="hljs-type">Machine</span>, (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-type">State</span> &#123; state =&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deconstruct</span></span>(state: <span class="hljs-type">Machine</span>): ((<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>), <span class="hljs-type">Machine</span>) = ((state.coins, state.candies), state)<br>    <span class="hljs-comment">// 有三个参数：Input，locked，candies &lt;= 0?</span><br>    (input, state.locked, state.candies) <span class="hljs-keyword">match</span> &#123;<br>      <span class="hljs-keyword">case</span> (input, _, candies) <span class="hljs-keyword">if</span> candies &lt;= <span class="hljs-number">0</span> =&gt; input <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Coin</span> =&gt; deconstruct(state.copy(coins = state.coins + <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Turn</span> =&gt; deconstruct(state)<br>      &#125;<br>      <span class="hljs-keyword">case</span> (<span class="hljs-type">Coin</span>, _, _) =&gt; deconstruct(state.copy(locked = <span class="hljs-literal">false</span>, coins = state.coins + <span class="hljs-number">1</span>))<br>      <span class="hljs-keyword">case</span> (<span class="hljs-type">Turn</span>, <span class="hljs-literal">false</span>, candies) =&gt; deconstruct(state.copy(locked = <span class="hljs-literal">true</span>, candies = candies - <span class="hljs-number">1</span>))<br>      <span class="hljs-keyword">case</span> (<span class="hljs-type">Turn</span>, <span class="hljs-literal">true</span>, _) =&gt; deconstruct(state)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">simulateMachine</span></span>(input: <span class="hljs-type">List</span>[<span class="hljs-type">Input</span>]): <span class="hljs-type">State</span>[<span class="hljs-type">Machine</span>, (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)] = input <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">State</span>.get[<span class="hljs-type">Machine</span>].map(s =&gt; (s.coins, s.candies))<br>    <span class="hljs-keyword">case</span> x :: xs =&gt; operate(x).flatMap(_ =&gt; simulateMachine(xs))<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>暂且到此，感觉对学到的东西仍旧不太清晰，待之后学习完第二第三部分后整个回过头来再看一遍吧。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/FP/">FP</a>
                    
                      <a class="hover-with-bg" href="/tags/Scala/">Scala</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-NC-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05-04todo-txt%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">todo.txt 简明教程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04-18%E5%85%B3%E4%BA%8EfoldRight%E4%B8%BA%E4%BD%95%E8%83%BD%E6%93%8D%E4%BD%9C%E6%97%A0%E7%A9%B7%E5%88%97%E8%A1%A8.html">
                        <span class="hidden-mobile">关于 foldRight 为何能操作无穷列表</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start -->
<script src="/assets/prism-bundle.js"></script>
<script src="/assets/prism-plus.js" data-pjax=""></script>
<!-- hexo injector body_end end --></body>
</html>
