<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>理解Pratt parsing——自顶向下算符优先解析法</title>
    <link href="/2024/01-06%E7%90%86%E8%A7%A3pratt_parsing.html"/>
    <url>/2024/01-06%E7%90%86%E8%A7%A3pratt_parsing.html</url>
    
    <content type="html"><![CDATA[<p>写篇笔记记录一下对 pratt parsing 的心智模型，这玩意需要的代码量很少，但理解难度上天，给我看了快两三天才稍微有点明白，还是得做点笔记记录一下，这大概是我回炉次数最多的笔记，反反复复调整代码结构和文字描述以保证清晰……最终效果还是比较满意的。感觉应上了那句老话——先把书读厚，再把书读薄。</p><p>关于 pratt parsing 的实际业务流程，主要是参考了 <a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html">这篇文章</a>。建立心智模型时部分地采用了这篇文章的 BP 概念，但没有使用 BP 表示结合性，因此要求运算符两边的 BP 是相同的，因此 BP 在这里实际上就是所谓的优先级。另外这篇文章的实现过于难懂了，loop 里面的各种 break 试图搅拌我的脑子，但实际的业务流程是能够更简单地去表示的。</p><p>关于 parselet，主要是参考了 <a href="https://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">这篇文章</a>，但并没有上来就引入 parselet 的概念，发现那样操作实在有点让人难懂…而且这篇文章没有提及前缀运算符的优先级。</p><p>循序渐进，首先实现对优先级的支持，然后是结合性的支持；然后，依次添加前缀，后缀，括号，取数组，三目的支持；这时代码已经乱成渣滓了，因此进行相应抽象，引入 parselet 的概念，将各运算符的逻辑抽离出来，再次实现之前已经实现的部分；最后另外使用栈去实现一下四则运算表达式的计算，因为其思想和 pratt 是基本一致的，而我之前从来没理解过那玩意是怎么操作。</p><p>完整的实现代码在最后。</p><hr><p>pratt parsing，即自顶向下算符优先解析法，是一种特别适用于解析表达式的解析法，它能轻易地使用表去表示各算符的优先级和结合性，同时也能够很容易引入各种复杂的算符比如三目，数组索引等。理解 pratt parsing 我感觉有两个关键：</p><ol><li>读取任意表达式时，根据 token 出现的位置和 token 的类型，我们马上就能识别出它是什么类型，属于哪个语法树节点，比如<code>1 + 2</code>，读到<code>1</code>后，我们马上就能知道这将是某操作符的左操作数，接下来要读一个中缀操作符（如果没到 EOF 的话）；比如<code>-1 + 2</code>，看到一个<code>-</code>，我们马上就知道这是一个前缀操作符，后面要读一个表达式</li><li>（这点是 pratt parsing 的精髓吧？）在尝试获取某操作符的右操作数的时候，对于可能的右操作数，只需要比较它右边的操作符的优先级和该操作符的优先级即可确认它是该操作符的右操作数还是它右边操作符的左操作数。这么说有点晦涩，但这个性质造成的特性是，<strong>某操作符的右操作数，是该操作符右边所有优先级高于该操作符的部分</strong>，这是说，<code>1 + 2 * 3 ^ 4 * 5 + 6 = 1 + (2 * 3 ^ 4 * 5) + 6</code>，理解这一点，就能够理解下面的第一版 pratt。</li></ol><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>先无视结合性，且只考虑中缀操作符。考虑下面的表达式，<code>^</code>为指数运算，优先级比<code>*</code>高：</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>+ <span class="hljs-number">2</span> * <span class="hljs-number">3</span> ^ <span class="hljs-number">4</span> <br></code></pre></div></td></tr></table></figure><p>如何解析它呢？作为人类，我们知道，<code>^</code>优先级最高，所以先把<code>3 ^ 4</code> 括起来，<code>*</code> 优先级次之，所以再把<code>2 * (3 ^ 4)</code> 括起来，然后是<code>+</code>，然后是<code>@</code>，总之添加括号是这个顺序：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-number">1</span> + <span class="hljs-number">2</span> * <span class="hljs-number">3</span> ^ <span class="hljs-number">4</span> <span class="hljs-meta">@ 5</span><br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> * (<span class="hljs-number">3</span> ^ <span class="hljs-number">4</span>) <span class="hljs-meta">@ 5</span><br><span class="hljs-number">1</span> + (<span class="hljs-number">2</span> * (<span class="hljs-number">3</span> ^ <span class="hljs-number">4</span>)) <span class="hljs-meta">@ 5</span><br>(<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> * (<span class="hljs-number">3</span> ^ <span class="hljs-number">4</span>))) <span class="hljs-meta">@ 5</span><br></code></pre></div></td></tr></table></figure><p>但计算机不是人，更擅长从左往右看，模仿计算机该怎样进行操作呢？首先把优先级规定一下，规定<code>@</code>，<code>+</code>，<code>*</code>，<code>@</code>优先级分别为 1，2，3，4，然后把优先级标在操作数和操作符之间：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> + <span class="hljs-number">2</span> * <span class="hljs-number">3</span> ^ <span class="hljs-number">4</span> @ <span class="hljs-number">5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">7</span><br> <span class="hljs-attribute">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>假装自己是计算机，从左往右读，首先看到<code>1</code>和<code>+</code>，马上能够明白，<code>1</code> 是 <code>+</code> 的左操作数，于是，<strong>现在的问题是找到 <code>+</code> 的右操作数</strong>。</p><p>但这里已知<code>1</code>要和<code>+</code>结合，所以这里可以预先加上一个<code>(</code>（别真加！）：</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">(1 +<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 3 </span>^<span class="hljs-number"> 4 </span>@<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>* 7<br> <span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>3<span class="hljs-number"> 4 </span>4<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>3<br></code></pre></div></td></tr></table></figure><p><strong>加一个括号表示建立了部分语法树节点，第一个 token 是左操作数，第二个 token 是操作符</strong>。</p><p>继续读，发现读到一个<code>2</code>，后面跟着一个<code>*</code>。然后这时候就要问，<code>2</code>是<code>+</code>的右操作数吗，或者说，<code>2</code>和<code>+</code>结合吗？不是，<code>*</code>的优先级高于<code>+</code>，所以<code>2</code>将首先和<code>*</code>结合。</p><p>ok，知道 2 要和<code>*</code>结合，我们首先可以在<code>+</code> 的右边加上一个<code>(</code>了：</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">(1 + (2 *<span class="hljs-number"> 3 </span>^<span class="hljs-number"> 4 </span>@<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>* 7<br> <span class="hljs-number"> 2 </span>2 <span class="hljs-number"> 3 </span>3<span class="hljs-number"> 4 </span>4<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>3<br></code></pre></div></td></tr></table></figure><p>光看 <code>2 * 3 ^ 4 @ 5</code>，我们已经读到<code>2</code>和<code>*</code>，<strong>现在的问题是找到 <code>*</code> 的右操作数</strong>。能直接猴急地马上把<code>2 * 3</code> 给括起来吗？不行，这需要首先确认<code>3</code> 要和 <code>*</code> 结合，我们继续读，发现<code>3</code>右边是个<code>^</code>，<code>^</code>优先级高于<code>*</code>，所以 3 和<code>^</code>结合，又得在<code>*</code>的右边再括一个括号了：</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">(1 + (2 * (3 ^<span class="hljs-number"> 4 </span>@<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>* 7<br><span class="hljs-number"> 2 </span>2 <span class="hljs-number"> 3 </span>3  <span class="hljs-number"> 4 </span>4<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>3<br></code></pre></div></td></tr></table></figure><p>光看 <code>3 ^ 4 @ 5</code>，已经读到了<code>3</code>和<code>^</code>，<strong>现在的问题是找到 <code>^</code> 的右操作数</strong>，需要确认<code>4</code>是否是和<code>^</code>结合，能发现<code>4</code>右边是<code>@</code>，优先级比<code>^</code>低，所以<code>4</code>和<code>^</code>结合，我们找到了<code>^</code>的右操作数。</p><p>找到了<code>^</code>的左右操作数，<strong>我们可以建立<code>^</code>相应的语法树节点了</strong>：</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">(1 + (2 * (3 ^ 4) @<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>* 7<br></code></pre></div></td></tr></table></figure><p><strong>一对括号表示创建了一个完整的语法树节点</strong>，在这里我们为<code>3 ^ 4</code>创建了相应语法树节点。</p><p>把<code>3 ^ 4</code> 括起来后，我们又发现我们找到了<code>*</code>的右操作数了（即语法树节点<code>3 ^ 4</code>），<strong>我们可以建立<code>*</code>相应的语法树节点了</strong>：</p><figure class="highlight clojure"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clojure">(<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> * (<span class="hljs-number">3</span> ^ <span class="hljs-number">4</span>)) @ <span class="hljs-number">5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure><p>把 <code>2 * (3 ^ 4)</code> 括起来，我们又发现这个节点是<code>+</code> 的右操作数了。</p><p>这就回答了上面的第一个问题——求<code>+</code> 的右操作数，求了<code>+</code>的右操作数之后，再做什么？当然是再建立<code>+</code>相应的语法树节点了，再括一个：</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">(1 + (2 * (3 ^ 4))) @<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>* 7<br></code></pre></div></td></tr></table></figure><p>问的第一个问题已经被回答了，但解析还没结束——建立了语法树<code>(1 + (2 * (3 ^ 4)))</code>，但还有<code> @ 5 + 6 * 7</code>没处理呢。将已经处理完的语法树写作 X（它已经是“原子”的了），现在表达式写作：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">X</span> @ <span class="hljs-number">5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">7</span><br> <span class="hljs-attribute">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>问题又变为解析该表达式。从左往右读，首先看到 X 和<code>@</code>，我们又开始问问题了，<code>@</code>的右操作数是什么……</p><p>再考虑另一个表达式，<code>1 + 2 + 3 + 4</code>，它读到一个 1，给它暂存作为 X：</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">X</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span><br> <span class="hljs-regexp"> ^</span><br>where x = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>然后继续读，读到一个<code>+</code>，马上明白，X 是<code>+</code>的左操作数，于是问，<code>+</code>的右操作数是什么？往前一看，是<code>2</code>，ok，建立语法树<code>(X + 2)</code>，并再次命名为 X：</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">X</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span><br> <span class="hljs-regexp"> ^</span><br>where x = (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><p>然后继续……</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">X</span> + <span class="hljs-number">4</span><span class="hljs-regexp"></span><br><span class="hljs-regexp">^</span><br>where x = ((<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) + <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><p>后面不用描述了，注意这操作和在递归下降法中解析左结合的操作符是基本一样的。</p><p>如何理解特定某一趟的行为呢？可以认为，每一次求右操作数时，它把所有<strong>高于上一操作符优先级的部分</strong>全都给括起来了，然后当成黑箱返回过来：</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">对于<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 3 </span>^<span class="hljs-number"> 4 </span>@<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 7 </span>@ 1<br><br>         <span class="hljs-number"> 3 </span>^ 4<br>    <span class="hljs-number"> 2 </span>* -------         * 7<br>1 + ------------     + 6<br>                 @<span class="hljs-number"> 5 </span>        @ 1<br><br></code></pre></div></td></tr></table></figure><p>求到右操作数后，建立语法树，把当前结果暂存，继续进行该操作（就像一个循环）：</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">           * <span class="hljs-number">7</span><br>       + <span class="hljs-number">6</span> <span class="hljs-comment">---</span><br>X @ <span class="hljs-number">5</span> <span class="hljs-comment">--------  @ 1</span><br><br></code></pre></div></td></tr></table></figure><p>能发现，在寻找右操作数时，所有优先级比该操作符高的操作符及相关操作数会作为右操作数的一部分，比如<code>1 + 2 * 3 ^ 4 @ 5</code>，能直接发现<code>+</code>的右操作数是<code>(2 * 3 ^ 4)</code>，而对于<code>1 + 2 @ 3</code>，右操作数是 2。</p><p>能发现，<strong>只需要记住上一个操作符的优先级，我们能从表达式的任意位置开始进行解析</strong>。</p><p>伪代码表示或许会是这样（假设这里是解析它，因此目标是生成 AST）：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">algo</span>(<span class="hljs-params">lexer, lastOp = ZERO_PRECEDENCE_OP</span>):<br>  x = Expr.<span class="hljs-type">Literal</span>(lexer.nextAtom())<br>  <span class="hljs-keyword">while</span> currentOpPrecedenceHigherThan(lastOp):<br>    op = lexer.nextOp()<br>    right = algo(lexer, op)<br>    x = Expr.Binary(op, x, right)<br>  <span class="hljs-keyword">return</span> x<br></code></pre></div></td></tr></table></figure><p><strong>algo 的行为是解析表达式中优先级高于特定优先级的部分</strong>。lastOp 的缺省值 ZERO_PRECEDENCE_OP 怎么理解呢？约定所有操作符的优先级都大于 0，因此初始的上一个操作符设为 0 就能保证把整个表达式都读进去了，也就是说<strong>对于第一趟 algo，while 的条件总为真</strong>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了学习方便，定义一个很糙的 Lexer，规定所有 Token 均为单字符，Atom 形如<code>/[a-zA-Z0-9]/</code>，其它的认为是 Op。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">AtomToken</span> = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ATOM&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">OpToken</span> = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-built_in">string</span>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">EofToken</span> = &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Token</span> = <span class="hljs-title class_">AtomToken</span> | <span class="hljs-title class_">OpToken</span> | <span class="hljs-title class_">EofToken</span><br><br><span class="hljs-keyword">function</span> tokenMatch&lt;T&gt;(<span class="hljs-attr">token</span>: <span class="hljs-title class_">Token</span>, <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Partial</span>&lt;&#123;<span class="hljs-attr">ATOM</span>: <span class="hljs-function">(<span class="hljs-params">t: AtomToken</span>) =&gt;</span> T, <span class="hljs-attr">OP</span>: <span class="hljs-function">(<span class="hljs-params">t: OpToken</span>) =&gt;</span> T, <span class="hljs-attr">EOF</span>: <span class="hljs-function">(<span class="hljs-params">t: EofToken</span>) =&gt;</span> T&#125;&gt;) &#123;<br>  <span class="hljs-keyword">if</span> (!fn[token.<span class="hljs-property">type</span>]) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`pattern match failed, type: <span class="hljs-subst">$&#123;token.<span class="hljs-keyword">type</span>&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> (fn[token.<span class="hljs-property">type</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)(token)<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Lexer</span> = &#123;<br>  <span class="hljs-title function_">next</span>(): <span class="hljs-title class_">Token</span>,<br>  <span class="hljs-title function_">peek</span>(): <span class="hljs-title class_">Token</span>,<br>  <span class="hljs-title function_">nextAtom</span>(): <span class="hljs-title class_">AtomToken</span><br>  <span class="hljs-title function_">nextOp</span>(): <span class="hljs-title class_">OpToken</span><br>  <span class="hljs-title function_">peekAtom</span>(): <span class="hljs-title class_">AtomToken</span>,<br>  <span class="hljs-title function_">peekOp</span>(): <span class="hljs-title class_">OpToken</span><br>  <span class="hljs-title function_">isAtEnd</span>(): <span class="hljs-built_in">boolean</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkLexer</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Lexer</span> &#123;<br>  <span class="hljs-keyword">const</span> tokens = source.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span>!<span class="hljs-regexp">/\s/</span>.<span class="hljs-title function_">test</span>(c))<br>    .<span class="hljs-property">map</span>&lt;<span class="hljs-title class_">Token</span>&gt;(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-regexp">/[a-zA-Z0-9]/</span>.<span class="hljs-title function_">test</span>(c) ? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ATOM&#x27;</span>, <span class="hljs-attr">literal</span>: c &#125; : &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: c&#125;)<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-params">token: Token, <span class="hljs-keyword">type</span>: Token[<span class="hljs-string">&#x27;type&#x27;</span>]</span>): <span class="hljs-built_in">any</span> &#123;<br>    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> != <span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Expect <span class="hljs-subst">$&#123;<span class="hljs-keyword">type</span>&#125;</span>, got <span class="hljs-subst">$&#123;token.<span class="hljs-keyword">type</span>&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> token<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> tokens.<span class="hljs-title function_">shift</span>() ?? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> tokens[<span class="hljs-number">0</span>] ?? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    next,<br>    peek,<br>    <span class="hljs-title function_">nextAtom</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">next</span>(), <span class="hljs-string">&#x27;ATOM&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">nextOp</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">next</span>(), <span class="hljs-string">&#x27;OP&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">peekAtom</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">peek</span>(), <span class="hljs-string">&#x27;ATOM&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">peekOp</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">peek</span>(), <span class="hljs-string">&#x27;OP&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">isAtEnd</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> tokens.<span class="hljs-property">length</span> == <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Expr</span> = (&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LITERAL&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">AtomToken</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">OpToken</span>, <span class="hljs-attr">left</span>: <span class="hljs-title class_">Expr</span>, <span class="hljs-attr">right</span>: <span class="hljs-title class_">Expr</span><br>&#125;) &amp; &#123; <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span> &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkBinary</span>(<span class="hljs-params">op: OpToken, left: Expr, right: Expr</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, op, left, right, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">$&#123;left.toString()&#125;</span> <span class="hljs-subst">$&#123;op.op&#125;</span> <span class="hljs-subst">$&#123;right.toString()&#125;</span>)`</span><br>  &#125;&#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkLiteral</span>(<span class="hljs-params">value: AtomToken</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LITERAL&#x27;</span>, value, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> value.<span class="hljs-property">value</span> &#125; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后，实现上面的 algo 函数，这里为它取名叫 expr，这里同时定义了各运算符的优先级，获取优先级的函数同时要传入操作符的位置，因为同一个操作符在不同位置可以拥有不同优先级：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">OpDef</span> = &#123;<span class="hljs-attr">token</span>: <span class="hljs-title class_">OpToken</span>, <span class="hljs-attr">precedence</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span> | <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-attr">position</span>: <span class="hljs-string">&#x27;postfix&#x27;</span> | <span class="hljs-string">&#x27;infix&#x27;</span> | <span class="hljs-string">&#x27;prefix&#x27;</span>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">ZERO_OP_DEF</span>: <span class="hljs-title class_">OpDef</span> = &#123; <span class="hljs-attr">precedence</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-attr">position</span>: <span class="hljs-string">&#x27;infix&#x27;</span>, <span class="hljs-attr">token</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;ZERO&#x27;</span> &#125; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">opDef</span>(<span class="hljs-params">token: OpToken, position: OpDef[<span class="hljs-string">&#x27;position&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, assoc: OpDef[<span class="hljs-string">&#x27;assoc&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;token, precedence, assoc, position&#125;<br>  &#125;<br>  <span class="hljs-keyword">switch</span> (position) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;infix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ZERO&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">ZERO_OP_DEF</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;R&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">break</span><br>  &#125;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`unknown <span class="hljs-subst">$&#123;position&#125;</span> operator: <span class="hljs-subst">$&#123;token.op&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">precedenceHigherThan</span>(<span class="hljs-params">lexer: Lexer, lastOp: OpDef</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> currentOp = <span class="hljs-title function_">opDef</span>(lexer.<span class="hljs-title function_">peekOp</span>(), <span class="hljs-string">&#x27;infix&#x27;</span>)<br>  <span class="hljs-keyword">return</span> currentOp.<span class="hljs-property">precedence</span> &gt; lastOp.<span class="hljs-property">precedence</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOpDef: OpDef = ZERO_OP_DEF</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">mkLiteral</span>(lexer.<span class="hljs-title function_">nextAtom</span>())<br>  <span class="hljs-keyword">while</span> (<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOpDef)) &#123;<br>    <span class="hljs-keyword">const</span> op = lexer.<span class="hljs-title function_">nextOp</span>()<br>    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">expr</span>(lexer, <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;infix&#x27;</span>))<br>    x = <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>  &#125;<br>  <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">parseAndPrint</span> = (<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">expr</span>(<span class="hljs-title function_">mkLexer</span>(str)).<span class="hljs-title function_">toString</span>())<br><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2&quot;</span>) <span class="hljs-comment">// (1 + 2)</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 * 3&quot;</span>) <span class="hljs-comment">// (1 + (2 * 3))</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 * 3 ^ 4&quot;</span>) <span class="hljs-comment">// (1 + (2 * (3 ^ 4)))</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 * 3 ^ 4 @ 5&quot;</span>) <span class="hljs-comment">// ((1 + (2 * (3 ^ 4))) @ 5)</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 @ 3&quot;</span>) <span class="hljs-comment">// ((1 + 2) @ 3)</span><br></code></pre></div></td></tr></table></figure><h1 id="结合性"><a href="#结合性" class="headerlink" title="结合性"></a>结合性</h1><p>优先级能处理了，那结合性呢？看看当前的实现的结合性是怎样的：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 + 3&quot;</span>) <span class="hljs-comment">// ((1 + 2) + 3)</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 ^ 2 ^ 3&quot;</span>) <span class="hljs-comment">// ((1 ^ 2) ^ 3)</span><br></code></pre></div></td></tr></table></figure><p>看上去是左结合，将优先级检查中<code>currentOp.precedence &gt; op.precedence</code>的<code>&gt;</code>改为<code>&gt;=</code>能得到右结合的结果，因此，只需要调整比较优先级的逻辑即可实现结合性：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">precedenceHigherThan</span>(<span class="hljs-params">lexer: Lexer, lastOp: OpDef</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> currentOp = <span class="hljs-title function_">opDef</span>(lexer.<span class="hljs-title function_">peekOp</span>(), <span class="hljs-string">&#x27;infix&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (currentOp.<span class="hljs-property">precedence</span> != lastOp.<span class="hljs-property">precedence</span>) &#123;<br>    <span class="hljs-keyword">return</span> currentOp.<span class="hljs-property">precedence</span> &gt; lastOp.<span class="hljs-property">precedence</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (currentOp.<span class="hljs-property">assoc</span> != lastOp.<span class="hljs-property">assoc</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`同一优先级两运算符 <span class="hljs-subst">$&#123;currentOp.token.op&#125;</span>, <span class="hljs-subst">$&#123;lastOp.token.op&#125;</span> 有不同结合性！`</span>)<br>  &#125;<br>  <span class="hljs-comment">// 对于 1 + 2 + 3，+是左结合，认为右边（current）的+优先级小于左边（last）的+</span><br>  <span class="hljs-comment">// 所以左结合要返回 false</span><br>  <span class="hljs-keyword">return</span> currentOp.<span class="hljs-property">assoc</span> === <span class="hljs-string">&#x27;L&#x27;</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 + 3&quot;</span>) <span class="hljs-comment">// ((1 + 2) + 3)</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 ^ 2 ^ 3&quot;</span>) <span class="hljs-comment">// (1 ^ (2 ^ 3))</span><br></code></pre></div></td></tr></table></figure><h1 id="前缀操作符"><a href="#前缀操作符" class="headerlink" title="前缀操作符"></a>前缀操作符</h1><p>然后实现前缀和中缀操作符，关于这两种操作符的性质，参考一下 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">js 的相关文档</a>，一般来说前缀和中缀的操作符的优先级都要比中缀的高。</p><p>如何理解前缀运算符？<strong>前缀运算符就像是一个没有左操作符的中缀操作符</strong>，比如<code>-1 + 2</code>，理解为<code>X - 1 + 2</code>，前缀运算符也有其优先级，它优先级比幂运算低，也就是说<code>-2 ^ 3 = - (2 ^ 3)</code>。要处理前缀运算符，需要修改第一次读取 x 时的逻辑——如果为 op，走前缀运算符逻辑，否则走原逻辑：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 添加新 Expr Prefix……</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">opDef</span>(<span class="hljs-params">token: OpToken, position: OpDef[<span class="hljs-string">&#x27;position&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, assoc: OpDef[<span class="hljs-string">&#x27;assoc&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;token, precedence, assoc, position&#125;<br>  &#125;<br>  <span class="hljs-keyword">switch</span> (position) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;prefix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;R&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;infix&#x27;</span>:<br>      <span class="hljs-comment">/* ... */</span><br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`unknown <span class="hljs-subst">$&#123;position&#125;</span> operator: <span class="hljs-subst">$&#123;token.op&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOpDef: OpDef = ZERO_OP_DEF</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">tokenMatch</span>(lexer.<span class="hljs-title function_">next</span>(), &#123;<br>    <span class="hljs-title function_">ATOM</span>(<span class="hljs-params">t</span>) &#123;<br>      <span class="hljs-comment">// 原逻辑</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkLiteral</span>(t)<br>    &#125;,<br>    <span class="hljs-title function_">OP</span>(<span class="hljs-params">op</span>) &#123;<br>      <span class="hljs-keyword">const</span> def = <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;prefix&#x27;</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkPrefix</span>(op, <span class="hljs-title function_">expr</span>(lexer, def))<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">while</span> (<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOpDef)) &#123;<br>    <span class="hljs-keyword">const</span> op = lexer.<span class="hljs-title function_">nextOp</span>()<br>    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">expr</span>(lexer, <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;infix&#x27;</span>))<br>    x = <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>  &#125;<br>  <span class="hljs-keyword">return</span> x<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>实践可以发现，前缀操作符的优先级<strong>只会改变它右边的表达式的解析顺序，它不关心当前的 lastOp</strong>。同时，前缀操作符的结合性是无关紧要的——无论是什么结合性，它本质上都得走右结合。</p><h1 id="后缀操作符"><a href="#后缀操作符" class="headerlink" title="后缀操作符"></a>后缀操作符</h1><p>后缀操作符和中缀操作符其实形式一致，<strong>它们均是先读了左操作数，再根据当前操作符决定进一步操作，如果是加减乘除等，就走相应中缀逻辑，如果是阶乘<code>!</code>，就走相应后缀的逻辑</strong>……为了实现方便，这里要求后缀操作符和中缀操作符不能重复（这也没啥问题，有哪个语言这个是重复的？）。规定阶乘的优先级要高于<code>^</code>。</p><p><strong>因为在检测操作数后的操作符时，中缀和后缀操作符都可能会出现，所以 opDef 函数需要允许返回 null，在没找到相应操作符时不直接失败</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">opDef</span>(<span class="hljs-params">token: OpToken, position: OpDef[<span class="hljs-string">&#x27;position&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, assoc: OpDef[<span class="hljs-string">&#x27;assoc&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;token, precedence, assoc, position&#125;<br>  &#125;<br>  <span class="hljs-keyword">switch</span> (position) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;prefix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;infix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ZERO&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">ZERO_OP_DEF</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;R&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;postfix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;!&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;R&#x27;</span>)<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后，修改检查优先级的函数，获取当前操作符时同时检查中缀和后缀；<strong>如果没有获取到当前操作符的定义，返回 false</strong>，这样设计在后面会看到好处。然后修改 expr 函数，<strong>根据操作符的性质把业务分发给相应的代码块</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">precedenceHigherThan</span>(<span class="hljs-params">lexer: Lexer, lastOp: OpDef</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> currentOp = <span class="hljs-title function_">opDef</span>(lexer.<span class="hljs-title function_">peekOp</span>(), <span class="hljs-string">&#x27;infix&#x27;</span>) ?? <span class="hljs-title function_">opDef</span>(lexer.<span class="hljs-title function_">peekOp</span>(), <span class="hljs-string">&#x27;postfix&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (currentOp == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (currentOp.<span class="hljs-property">precedence</span> != lastOp.<span class="hljs-property">precedence</span>) &#123;<br>    <span class="hljs-keyword">return</span> currentOp.<span class="hljs-property">precedence</span> &gt; lastOp.<span class="hljs-property">precedence</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (currentOp.<span class="hljs-property">assoc</span> != lastOp.<span class="hljs-property">assoc</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`同一优先级两运算符 <span class="hljs-subst">$&#123;currentOp.token.op&#125;</span>, <span class="hljs-subst">$&#123;lastOp.token.op&#125;</span> 有不同结合性！`</span>)<br>  &#125;<br>  <span class="hljs-comment">// 对于 1 + 2 + 3，+是左结合，认为右边（current）的+优先级小于左边（last）的+</span><br>  <span class="hljs-comment">// 所以左结合要返回 false</span><br>  <span class="hljs-keyword">return</span> currentOp.<span class="hljs-property">assoc</span> === <span class="hljs-string">&#x27;L&#x27;</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOpDef: OpDef = ZERO_OP_DEF</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">tokenMatch</span>(lexer.<span class="hljs-title function_">next</span>(), &#123;<br>    <span class="hljs-title function_">ATOM</span>(<span class="hljs-params">t</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkLiteral</span>(t)  <span class="hljs-comment">// 原逻辑</span><br>    &#125;, <br>    <span class="hljs-title function_">OP</span>(<span class="hljs-params">op</span>) &#123;<br>      <span class="hljs-keyword">const</span> def = <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;prefix&#x27;</span>)<br>      <span class="hljs-keyword">if</span> (!def) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`unknown prefix op: <span class="hljs-subst">$&#123;def&#125;</span>`</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkPrefix</span>(op, <span class="hljs-title function_">expr</span>(lexer, def))<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">while</span> (<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOpDef)) &#123;<br>    <span class="hljs-keyword">const</span> op = lexer.<span class="hljs-title function_">nextOp</span>()<br>    <span class="hljs-keyword">const</span> infixOpDef = <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;infix&#x27;</span>)<br>    <span class="hljs-keyword">const</span> postfixOpDef = <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;postfix&#x27;</span>)<br>    <span class="hljs-comment">// 如果是中缀</span><br>    <span class="hljs-keyword">if</span> (infixOpDef) &#123;<br>      <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">expr</span>(lexer, infixOpDef)<br>      x = <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (postfixOpDef) &#123;<br>      x = <span class="hljs-title function_">mkPostfix</span>(op, x)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 这里不可能到达，precedenceHigherThan 为 true 要求操作符必须是合法的中缀或后缀操作符</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Impossible&#x27;</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h1><p>然后是括号，没有括号怎么成？</p><p>如何处理括号呢？考虑表达式<code>1 * (2 + 3) * 4</code>能注意到，左括号<code>(</code>是出现在操作符之前，右括号<code>)</code>出现在操作符之后，所以处理左括号的逻辑理应放到前缀操作符，右括号的逻辑理应放到后缀操作符中……</p><p>先处理左括号，注意<strong>在处理括号中的表达式时，它是不关心括号之前的操作符的优先级的，因此 lastOp 重设为 0</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOpDef: OpDef = ZERO_OP_DEF</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">tokenMatch</span>(lexer.<span class="hljs-title function_">next</span>(), &#123;<br>    <span class="hljs-title function_">ATOM</span>(<span class="hljs-params">t</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkLiteral</span>(t)  <span class="hljs-comment">// 原逻辑</span><br>    &#125;, <br>    <span class="hljs-title function_">OP</span>(<span class="hljs-params">op</span>) &#123;<br>      <span class="hljs-keyword">if</span> (op.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> inner = <span class="hljs-title function_">expr</span>(lexer)<br>        lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;)&#x27;</span>)<br>        <span class="hljs-keyword">return</span> inner<br>      &#125;<br>      <span class="hljs-comment">// 前缀操作符</span><br>    &#125;<br>  &#125;)<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>但其实只改这里就行了，不需要在后缀的部分显式处理<code>)</code>：while 在检查当前操作符的优先级时会遇到<code>)</code>，然后它发现没有<code>)</code>的中缀、后缀操作符的定义，因此马上停止解析，把当前的 x 返回出来，<code>)</code>就像一堵墙，把所有解析过程给它阻断，最后控制流又回到前缀中处理<code>(</code>的那部分代码去处理，消费掉这个<code>)</code>。</p><h1 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h1><p>数组索引形如<code>1 + a[i] + 3</code>，这里有让人将它分到中缀运算符的冲动，但其实它分到后缀更合适——<strong>i 的范围是明确界定的，不参与优先级的运算</strong>。</p><p>但要我觉得，其实放哪都一样，它和后缀的<code>!</code>，中缀的<code>+-*/^</code>并非一路货色，<strong>实际上每个中缀（出现在第一个操作数后的）操作符都有自己的处理逻辑，只不过某些运算符的逻辑正好一样罢了</strong>，后面实际上也是这样操作的。</p><p><strong>需要定义后缀操作符<code>[</code>的优先级</strong>——这里究竟应当解释为<code>(1 + a)[i] + 3</code>还是<code>1 + (a[i]) + 3</code>呢？此外，处理<code>[i]</code>中的 i 和处理括号时的行为是相同的：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">opDef</span>(<span class="hljs-params">token: OpToken, position: OpDef[<span class="hljs-string">&#x27;position&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">switch</span> (position) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;postfix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;!&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;R&#x27;</span>) <br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOpDef: OpDef = ZERO_OP_DEF</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOpDef)) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (infixOpDef) &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (postfixOpDef) &#123;<br>      <span class="hljs-keyword">if</span> (op.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> i = <span class="hljs-title function_">expr</span>(lexer)<br>        lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;]&#x27;</span>)<br>        x = <span class="hljs-title function_">mkBinary</span>(op, x, i)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 原逻辑</span><br>        x = <span class="hljs-title function_">mkPostfix</span>(op, x)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 这里不可能到达，precedenceHigherThan 为 true 要求操作符必须是合法的中缀或后缀</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Impossible&#x27;</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h1><p>最后是三目，最终 boss。作为一个现代语言，要我说就不该支持三目，让三目滚蛋，换成 if 表达式。但这里还是实现一下。</p><p>如何理解三目呢？<code>a ? b : c</code>，一种最直接的方式是，<strong>将<code>?:</code>想象成一对括号，从而让 b 不再参与优先级的计算以简化问题</strong>。对于<code>a ? b : c ? d : e</code>，将它理解为<code>a ?: c ?: e</code>即可，记住三目是右结合的。并非所有语言的三目都是这样实现的，但同时并非所有语言的三目的行为都是一样的（恼，正经人谁用三目不加括号的？除了右结合，假设三目的其他特性都是作死）</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (infixOpDef) &#123;<br>  <span class="hljs-keyword">if</span> (op.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> thenExpr = <span class="hljs-title function_">expr</span>(lexer)<br>    lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br>    <span class="hljs-keyword">const</span> elseExpr = <span class="hljs-title function_">expr</span>(lexer, infixOpDef) <span class="hljs-comment">// 把优先级得带上！ ? 和：中间的部分等于是加了括号，但：后面的部分优先级是起作用的</span><br>    x = <span class="hljs-title function_">mkTernary</span>(op, x, thenExpr, elseExpr)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 原逻辑</span><br>    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">expr</span>(lexer, infixOpDef)<br>    x = <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="抽象各运算符的逻辑"><a href="#抽象各运算符的逻辑" class="headerlink" title="抽象各运算符的逻辑"></a>抽象各运算符的逻辑</h1><p>在 pratt parsing 法中，<strong>一切操作符归根结底是前缀操作符和中缀操作符</strong>——如果操作符比第一个操作数先出现，则是前缀操作符，否则是中缀操作符（虽然它叫中缀，但只是说指示对应操作符的 token 出现在第一个操作数之后，无关其他操作数在什么位置，有多少个操作数）。另外，<strong>Atom 也认为是前缀操作符</strong>。</p><p>为此，可以把不同运算符的逻辑都抽象出来——加减乘除？自增自减，阶乘？乃至于括号，三目，数组运算符？甚至 Atom？都抽象出对应的逻辑（并让这些逻辑都可以回调 expr），这些逻辑块称为 Parselet，这些 Parselet 均返回<code>Expr</code>，<strong>前缀和中缀需要各自定义相应的 Parselet 类型，因为它们已知的信息不同——前缀只知道当前的 token，中缀知道已有的 x 和当前的 token</strong>。这些 Parselet 进行自己的逻辑时必然会回调 expr 函数。</p><p>假设我们已经把每个 parselet 都抽象出来了，但将它们硬编码到了 expr 函数中，形式可能会是这样的：</p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">def expr(lexer, lastOp):<br>  xToken = lexer.next()<br>  x = xToken match &#123;<br>    <span class="hljs-comment"># 这里的 atom@Atom(_) 模仿的是 haskell 的相应语法，在模式匹配成功后再次把整个模式对应的值都赋给它</span><br>    atom@Atom(_) =&gt; atomPrefixParselet(lexer, atom) <span class="hljs-comment"># 注意到 parselet 是不需要知晓当前的 lastOp 信息的</span><br>    op@Op(<span class="hljs-string">&#x27;(&#x27;</span>)   =&gt; parenPrefixParselet(lexer, op)<br>    op@Op(<span class="hljs-string">&#x27;+&#x27;</span>)   =&gt; plusPrefixParselet(lexer, op)<br>    op@Op(<span class="hljs-string">&#x27;-&#x27;</span>)   =&gt; minusPrefixParselet(lexer, op)<br>    <span class="hljs-comment"># ...</span><br>    _            =&gt; panic(<span class="hljs-string">&quot;unknown token: ...&quot;</span>)<br>  &#125;<br>  <span class="hljs-comment"># 注意 precedenceHigherThan 仍旧需要知道各操作符的优先级，这点不能变</span><br>  <span class="hljs-keyword">while</span> precedenceHigherThan(lexer, lastOp):<br>    op = lexer.next()<br>    <span class="hljs-comment"># 注意这里的左结合行为</span><br>    x = op match &#123;<br>      op@Op(<span class="hljs-string">&#x27;?&#x27;</span>) =&gt; conditionalInfixParselet(lexer, x, op)<br>      op@Op(<span class="hljs-string">&#x27;[&#x27;</span>) =&gt; arrayAccessInfixParselet(lexer, x, op)<br>      op@Op(<span class="hljs-string">&#x27;+&#x27;</span>) =&gt; plusInfixParselet(lexer, x, op) <br>      op@Op(<span class="hljs-string">&#x27;!&#x27;</span>) =&gt; factorialInfixParselet(lexer, x, op) <br>      <span class="hljs-comment"># ...</span><br>      _          =&gt; panic(<span class="hljs-string">&#x27;impossible&#x27;</span>) <span class="hljs-comment"># 如果 token 没定义过，它根本不可能进到 while 里来</span><br>    &#125;<br>  <span class="hljs-keyword">return</span> x<br></code></pre></div></td></tr></table></figure><p>如何避免硬编码相应 parselet 到 expr 函数中呢？能注意到这里实际上是根据 token 的 type 和 value 去决定分发到哪个 parselet 上，<strong>因此我们可以建立相应哈希表，根据 type 和 value 获取相应 parselet</strong>（工业上必定是类似的操作），但这 key 有两个实际上不太优雅，我们可以做两次分发，为每个 type 定义相应 parselet（这样甚至能把泛型给利用起来了），再让这些 parselet 根据 value 去分发到对应 parselet，缺点是代码比较复杂些。</p><p><strong>这里走最省事的方式——每个 parselet 都直接定义相应谓词检查该 token 自己要不要</strong>，这是不合适的，应当在“编译期”就知晓当前的定义，因为需要检查当前的优先级和结合性规则是否合法。</p><p>最终形状可能会是这样：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer, lastOp</span>):<br>  xToken = lexer.<span class="hljs-built_in">next</span>()<br>  x: Expr = prefixParseletMap[xToken](lexer, xToken) <span class="hljs-comment"># getPrefixParselet 可能失败</span><br>  <span class="hljs-keyword">while</span> precedenceHigherThan(lexer, lastOp):<br>    op = lexer.<span class="hljs-built_in">next</span>()<br>    x = infixParselet[op](lexer, x, op)<br>  <span class="hljs-keyword">return</span> x<br></code></pre></div></td></tr></table></figure><p>但注意 precedenceHigherThan 的实现，precedenceHigherThan 同样需要知道<strong>这里的 op</strong>（通过 peek）的优先级。因此，我们可以将优先级信息保存到 parselet 中，在 precedenceHigherThan 函数中同样去找到 parselet，再找到优先级信息。</p><p><strong>但前缀操作符也有优先级信息——这决定前缀操作符后的 atom 是和它先结合还是和它的下一个操作符先结合</strong>，总之能得到下面的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PrefixParselet</span> = &#123;<br>  <span class="hljs-attr">accept</span>: <span class="hljs-function">(<span class="hljs-params">token: Token</span>) =&gt;</span> <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">precedence</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-comment">// 这里 expr 调用 parselet 的时候把自己也给传进去，保证 parselet 在看不到 expr 函数的情况下也能直接调用 expr 函数</span><br>  <span class="hljs-attr">parse</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, x: Token, exprFn: Parser[<span class="hljs-string">&#x27;expr&#x27;</span>]</span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">InfixParselet</span> = &#123;<br>  <span class="hljs-attr">accept</span>: <span class="hljs-function">(<span class="hljs-params">token: Token</span>) =&gt;</span> <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">precedence</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span> | <span class="hljs-string">&#x27;R&#x27;</span>,<br>  <span class="hljs-attr">parse</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, x: Expr, op: Token, exprFn: Parser[<span class="hljs-string">&#x27;expr&#x27;</span>]</span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parser</span> = &#123;<br>  <span class="hljs-comment">// 因为谓词直接定义在 parselet 上了…</span><br>  <span class="hljs-attr">registerPrefixParselet</span>: <span class="hljs-function">(<span class="hljs-params">parselet: PrefixParselet</span>) =&gt;</span> <span class="hljs-built_in">void</span>,<br>  <span class="hljs-attr">registerInfixParselet</span>: <span class="hljs-function">(<span class="hljs-params">parselet: InfixParselet</span>) =&gt;</span> <span class="hljs-built_in">void</span>,<br>  <span class="hljs-attr">expr</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, lastOpPrecedence?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意 expr 不需要知晓上一个操作符的结合性——如果上一个操作符的优先级和当前操作符的优先级相同，则它们的结合性会是一致的，不然这语法规则就是有歧义的——同一个优先级下的操作符的结合性需要一致</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newParser</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Parser</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">prefixParselets</span>: <span class="hljs-title class_">PrefixParselet</span>[] = []<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">infixParselets</span>: <span class="hljs-title class_">InfixParselet</span>[] = []<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPrefixParselet</span>(<span class="hljs-params">token: Token</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = prefixParselets.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">parselet</span> =&gt;</span> parselet.<span class="hljs-title function_">accept</span>(token))<br>    <span class="hljs-keyword">if</span> (!res) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`No Prefix parselet defined for <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(token)&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getInfixParselet</span>(<span class="hljs-params">token: Token</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = infixParselets.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">parselet</span> =&gt;</span> parselet.<span class="hljs-title function_">accept</span>(token))<br>    <span class="hljs-keyword">return</span> res ?? <span class="hljs-literal">null</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">precedenceHigherThan</span>(<span class="hljs-params">lexer: Lexer, lastOpPrecedence: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> currentParselet = <span class="hljs-title function_">getInfixParselet</span>(lexer.<span class="hljs-title function_">peek</span>())<br>    <span class="hljs-keyword">if</span> (currentParselet == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (currentParselet.<span class="hljs-property">precedence</span> != lastOpPrecedence) &#123;<br>      <span class="hljs-keyword">return</span> currentParselet.<span class="hljs-property">precedence</span> &gt; lastOpPrecedence<br>    &#125;<br>    <span class="hljs-keyword">return</span> currentParselet.<span class="hljs-property">assoc</span> === <span class="hljs-string">&#x27;L&#x27;</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOp = <span class="hljs-number">0</span></span>): <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-keyword">const</span> xToken = lexer.<span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">getPrefixParselet</span>(xToken).<span class="hljs-title function_">parse</span>(lexer, xToken, expr)<br>    <span class="hljs-keyword">while</span>(<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOp)) &#123;<br>      <span class="hljs-keyword">const</span> op = lexer.<span class="hljs-title function_">next</span>()<br>      x = <span class="hljs-title function_">getInfixParselet</span>(op)!.<span class="hljs-title function_">parse</span>(lexer, x, op, expr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>  &#125; <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-params">parselet</span>) &#123; infixParselets.<span class="hljs-title function_">push</span>(parselet) &#125;,<br>    <span class="hljs-title function_">registerPrefixParselet</span>(<span class="hljs-params">parselet</span>) &#123; prefixParselets.<span class="hljs-title function_">push</span>(parselet) &#125;,<br>    expr<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>接下来，用 parselet 把之前定义过的东西再定义一次，其中为“一般”的前缀、中缀、后缀操作符定义了相关函数以方便其的定义，但像原子，括号，三目，数组索引等语法仍需要手写相应 parselet。</p><p><strong>注意 parselet 在被调用时，触发 parselet 的 token 已经被消费了，不需要在 parselet 中进行消费操作</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> parser = <span class="hljs-title function_">newParser</span>()<br><br><span class="hljs-comment">// 原子</span><br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">// 这个优先级不会被使用到</span><br>  <span class="hljs-attr">accept</span>: <span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> token.<span class="hljs-property">type</span> == <span class="hljs-string">&#x27;ATOM&#x27;</span>,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkLiteral</span>(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">AtomToken</span>)<br>  &#125;,<br>&#125;)<br><br><span class="hljs-comment">// 括号</span><br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">// 同样的不会使用到</span><br>  <span class="hljs-attr">accept</span>: <span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> token.<span class="hljs-property">type</span> == <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;(&#x27;</span>,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">exprFn</span>(lexer)<br>    <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">nextOp</span>().<span class="hljs-property">op</span> !== <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Expect &#x27;)&#x27;`</span>)<br>    <span class="hljs-keyword">return</span> res<br>  &#125;,<br>&#125;)<br><br><span class="hljs-comment">// 一般的前缀运算符对应的 praselet</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">prefixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">PrefixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    precedence,<br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkPrefix</span>(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>, right)<br>    &#125;,<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 一般的中缀运算符对应的 parselet</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, assoc: <span class="hljs-string">&#x27;L&#x27;</span>| <span class="hljs-string">&#x27;R&#x27;</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">InfixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123; <br>    assoc, precedence,<br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>      op = op <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span><br>      <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>    &#125;,<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 一般的后缀运算符对应的 parselet</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">suffixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">InfixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    precedence, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-comment">// 后缀运算符的结合性是个有意思的问题…但一般来说，后缀运算符的优先级会高于中缀，因此结合性应当是不起作用的</span><br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkPostfix</span>(op <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>, x)<br>    &#125;,<br>  &#125;<br>&#125;<br><br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(<span class="hljs-title function_">prefixOperators</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;+-!&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;+-&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;*/%&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;^&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">suffixOperators</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;!&#x27;</span>))<br><br><span class="hljs-comment">// 数组索引</span><br>parser.<span class="hljs-title function_">registerInfixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-comment">// 这个结合性同样是没意义的，因为数组索引属于后缀运算符</span><br>  <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>    <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;[&#x27;</span><br>  &#125;,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">exprFn</span>(lexer)<br>    lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;]&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkBinary</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;[]&#x27;</span>&#125;, x, index)<br>  &#125;,<br>&#125;)<br><span class="hljs-comment">// 三目</span><br>parser.<span class="hljs-title function_">registerInfixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-comment">// 三目的结合性有用</span><br>  <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>    <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;?&#x27;</span><br>  &#125;,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> thenExpr = <span class="hljs-title function_">exprFn</span>(lexer)<br>    lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br>    <span class="hljs-keyword">const</span> elseExpr = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkTernary</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;?:&#x27;</span>&#125;, x, thenExpr, elseExpr)<br>  &#125;,<br>&#125;)<br></code></pre></div></td></tr></table></figure><h1 id="使用栈处理四则运算"><a href="#使用栈处理四则运算" class="headerlink" title="使用栈处理四则运算"></a>使用栈处理四则运算</h1><p>在学习 pratt 解析后，我突然意识到其实使用栈来处理四则运算表达式的思想和 partt 是一致的——，<strong>如果遇到的上一个操作符的优先级大于等于当前的（左结合），则栈顶的操作数就是右操作数，去马上计算该操作符对应的表达式</strong>（<strong>马上</strong>得给它标红）。这样把整个表达式过一遍后，<strong>所有连续的非严格降序的操作符都已被计算，因此没有处理的操作符的优先级会是一个非严格升序的状态</strong>，再处理这些升序的操作符即可，巧的是操作符出栈的顺序正好就是计算的顺序。</p><p>比如，计算<code>1 + 4 * 2 * 3 + 2</code>，读到第二个<code>*</code>后<strong>马上</strong>计算<code>4 * 2</code>，然后读到第二个<code>+</code>后，马上计算 <code>8 * 3</code>，最后表达式会变成<code>1 + 24 + 2</code>，但此时就停止了——<strong>业务逻辑是在遇到操作符时执行的</strong>，所以最终还得把这个表达式再操作一遍，但操作这个是很方便的。</p><p>为什么需要维护两个栈？因为我们总是需要上一个操作符的优先级信息，所以操作数和操作符分开放。先不考虑括号的话，实现会是下面这样：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> stackTop&lt;T&gt;(<span class="hljs-attr">stack</span>: T[]): T &#123;<br>  <span class="hljs-keyword">if</span> (!stack || stack.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;stack is empty&#x27;</span>)<br>  <span class="hljs-keyword">return</span> stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">applyEvalOnce</span>(<span class="hljs-params">numStack: <span class="hljs-built_in">number</span>[], opStack: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">applyOp</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, op: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> a + b<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> a - b<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">return</span> a * b<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> a / b<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ZERO&#x27;</span>: <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()<br>  &#125;<br>  <br>  <span class="hljs-keyword">const</span> b = numStack.<span class="hljs-title function_">pop</span>()!<br>  <span class="hljs-keyword">const</span> a = numStack.<span class="hljs-title function_">pop</span>()!<br>  <span class="hljs-keyword">const</span> op = opStack.<span class="hljs-title function_">pop</span>()!<br>  numStack.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">applyOp</span>(a, op, b)) <br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">precedence</span>(<span class="hljs-params">op: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">map</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">number</span>&gt; = &#123;<br>    <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ZERO&#x27;</span>: <span class="hljs-number">0</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> map[op]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">evalExpr</span>(<span class="hljs-params">expr: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">const</span> lexer = <span class="hljs-title function_">mkLexer</span>(expr)<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">numStack</span>: <span class="hljs-built_in">number</span>[] = [-<span class="hljs-number">9999</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">opStack</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;ZERO&#x27;</span>]<br><br>  <span class="hljs-keyword">while</span> (!lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>    <span class="hljs-keyword">const</span> token = lexer.<span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;ATOM&#x27;</span>) &#123;<br>      numStack.<span class="hljs-title function_">push</span>(+token.<span class="hljs-property">literal</span>)<br>      <span class="hljs-keyword">continue</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> op = (token <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>).<span class="hljs-property">op</span><br>    <span class="hljs-comment">// 如果当前优先级小于等于上一个操作符的优先级，上一个操作符已经可以执行了</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">precedence</span>(op) &lt;= <span class="hljs-title function_">precedence</span>(<span class="hljs-title function_">stackTop</span>(opStack))) &#123;<br>      <span class="hljs-title function_">applyEvalOnce</span>(numStack, opStack)<br>    &#125;<br>    opStack.<span class="hljs-title function_">push</span>(op) <br>  &#125;<br>  <span class="hljs-comment">// 然后，栈中仍剩的操作符将是升序的</span><br>  <span class="hljs-keyword">while</span> (opStack.<span class="hljs-property">length</span> != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title function_">applyEvalOnce</span>(numStack, opStack)<br>  &#125;<br>  <span class="hljs-keyword">return</span> numStack[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意这实现中为了处理方便，不用在检查上一个操作符的时候检查操作符栈非空，给它填充一个最低优先级的操作符，并让它的语义为返回右操作数。</p><p>然后是括号，括号很trick，括号就像一堵高墙，阻止左括号前面的操作符进行计算，比如对<code>1 * (2 + 3)</code>，不能在遇到<code>+</code>的时候把<code>(</code>当作操作符去处理了（同时也不能遇到<code>(</code>先把<code>*</code>给处理了，因此左括号要走自己的逻辑），因此可以给左括号设置一个很<strong>低</strong>的优先级来避免它猴急。但<strong>此后仍然是照常计算，直到遇到右括号</strong>，此时在操作符栈中，左括号上面的操作符的优先级会是非严格升序的，因此在遇到左括号之前把它们全都给计算掉，然后扔掉栈顶的左括号即可，这样就计算出来了括号中的结果并填入操作符栈中。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">precedence</span>(<span class="hljs-params">op: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">map</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">number</span>&gt; = &#123;<br>    <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ZERO&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;|&#x27;</span>: -<span class="hljs-number">999</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> map[op]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">evalExpr</span>(<span class="hljs-params">expr: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">const</span> lexer = <span class="hljs-title function_">mkLexer</span>(expr)<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">numStack</span>: <span class="hljs-built_in">number</span>[] = [-<span class="hljs-number">9999</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">opStack</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;ZERO&#x27;</span>]<br><br>  <span class="hljs-keyword">while</span> (!lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>    <span class="hljs-keyword">const</span> token = lexer.<span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;ATOM&#x27;</span>) &#123;<br>      numStack.<span class="hljs-title function_">push</span>(+token.<span class="hljs-property">literal</span>)<br>      <span class="hljs-keyword">continue</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> op = (token <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>).<span class="hljs-property">op</span><br>    <span class="hljs-keyword">if</span> (op === <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 其实这时候push个啥都行，它只是个标识符，所以这里push一个&#x27;|&#x27;因为它更应景</span><br>      opStack.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;|&#x27;</span>) <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op === <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-title function_">stackTop</span>(opStack) !== <span class="hljs-string">&#x27;|&#x27;</span>) &#123;<br>        <span class="hljs-title function_">applyEvalOnce</span>(numStack, opStack)<br>      &#125;<br>      opStack.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// 丢掉 &#x27;|&#x27;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">precedence</span>(op) &lt;= <span class="hljs-title function_">precedence</span>(<span class="hljs-title function_">stackTop</span>(opStack))) &#123;<br>        <span class="hljs-title function_">applyEvalOnce</span>(numStack, opStack)<br>      &#125;<br>      opStack.<span class="hljs-title function_">push</span>(op) <br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (opStack.<span class="hljs-property">length</span> != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title function_">applyEvalOnce</span>(numStack, opStack)<br>  &#125;<br>  <span class="hljs-keyword">return</span> numStack[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="pratt-完整实现"><a href="#pratt-完整实现" class="headerlink" title="pratt 完整实现"></a>pratt 完整实现</h1><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">AtomToken</span> = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ATOM&#x27;</span>, <span class="hljs-attr">literal</span>: <span class="hljs-built_in">string</span>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">OpToken</span> = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-built_in">string</span>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">EofToken</span> = &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Token</span> = <span class="hljs-title class_">AtomToken</span> | <span class="hljs-title class_">OpToken</span> | <span class="hljs-title class_">EofToken</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Lexer</span> = &#123;<br>  <span class="hljs-title function_">next</span>(): <span class="hljs-title class_">Token</span>,<br>  <span class="hljs-title function_">peek</span>(): <span class="hljs-title class_">Token</span>,<br>  <span class="hljs-title function_">nextAtom</span>(): <span class="hljs-title class_">AtomToken</span><br>  <span class="hljs-title function_">nextOp</span>(value?: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">OpToken</span><br>  <span class="hljs-title function_">peekAtom</span>(): <span class="hljs-title class_">AtomToken</span>,<br>  <span class="hljs-title function_">peekOp</span>(): <span class="hljs-title class_">OpToken</span><br>  <span class="hljs-title function_">isAtEnd</span>(): <span class="hljs-built_in">boolean</span><br>&#125;<br><br><span class="hljs-keyword">function</span> tokenMatch&lt;T&gt;(<span class="hljs-attr">token</span>: <span class="hljs-title class_">Token</span>, <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Partial</span>&lt;&#123;<span class="hljs-attr">ATOM</span>: <span class="hljs-function">(<span class="hljs-params">t: AtomToken</span>) =&gt;</span> T, <span class="hljs-attr">OP</span>: <span class="hljs-function">(<span class="hljs-params">t: OpToken</span>) =&gt;</span> T, <span class="hljs-attr">EOF</span>: <span class="hljs-function">(<span class="hljs-params">t: EofToken</span>) =&gt;</span> T&#125;&gt;) &#123;<br>  <span class="hljs-keyword">if</span> (!fn[token.<span class="hljs-property">type</span>]) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`pattern match failed, type: <span class="hljs-subst">$&#123;token.<span class="hljs-keyword">type</span>&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> (fn[token.<span class="hljs-property">type</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)(token)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkLexer</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Lexer</span> &#123;<br>  <span class="hljs-keyword">const</span> tokens = source.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span>!<span class="hljs-regexp">/\s/</span>.<span class="hljs-title function_">test</span>(c))<br>    .<span class="hljs-property">map</span>&lt;<span class="hljs-title class_">Token</span>&gt;(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-regexp">/[a-zA-Z0-9]/</span>.<span class="hljs-title function_">test</span>(c) ? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ATOM&#x27;</span>, <span class="hljs-attr">literal</span>: c &#125; : &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: c&#125;)<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-params">token: Token, <span class="hljs-keyword">type</span>: Token[<span class="hljs-string">&#x27;type&#x27;</span>]</span>): <span class="hljs-built_in">any</span> &#123;<br>    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> != <span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Expect <span class="hljs-subst">$&#123;<span class="hljs-keyword">type</span>&#125;</span>, got <span class="hljs-subst">$&#123;token.<span class="hljs-keyword">type</span>&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> token<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> tokens.<span class="hljs-title function_">shift</span>() ?? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> tokens[<span class="hljs-number">0</span>] ?? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    next,<br>    peek,<br>    <span class="hljs-title function_">nextAtom</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">next</span>(), <span class="hljs-string">&#x27;ATOM&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">nextOp</span>(<span class="hljs-params">value?: <span class="hljs-built_in">string</span></span>) &#123;<br>      <span class="hljs-keyword">const</span> op = <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">next</span>(), <span class="hljs-string">&#x27;OP&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span><br>      <span class="hljs-keyword">if</span> (value &amp;&amp; value != op.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Expect <span class="hljs-subst">$&#123;value&#125;</span>, got <span class="hljs-subst">$&#123;op.op&#125;</span>`</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> op<br>    &#125;,<br>    <span class="hljs-title function_">peekAtom</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">peek</span>(), <span class="hljs-string">&#x27;ATOM&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">peekOp</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">peek</span>(), <span class="hljs-string">&#x27;OP&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">isAtEnd</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> tokens.<span class="hljs-property">length</span> == <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Expr</span> = (&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LITERAL&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">AtomToken</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;UNARY&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">OpToken</span>, <span class="hljs-attr">right</span>: <span class="hljs-title class_">Expr</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">OpToken</span>, <span class="hljs-attr">left</span>: <span class="hljs-title class_">Expr</span>, <span class="hljs-attr">right</span>: <span class="hljs-title class_">Expr</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;TERNARY&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">OpToken</span>, <span class="hljs-attr">left</span>: <span class="hljs-title class_">Expr</span>, <span class="hljs-attr">middle</span>: <span class="hljs-title class_">Expr</span>, <span class="hljs-attr">right</span>: <span class="hljs-title class_">Expr</span><br>&#125;) &amp; &#123; <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span> &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkLiteral</span>(<span class="hljs-params">value: AtomToken</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LITERAL&#x27;</span>, value, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> value.<span class="hljs-property">literal</span> &#125; &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkUnary</span>(<span class="hljs-params">op: OpToken, right: Expr</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;UNARY&#x27;</span>, op, right, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">$&#123;op.op&#125;</span> <span class="hljs-subst">$&#123;right&#125;</span>)`</span> &#125; &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkBinary</span>(<span class="hljs-params">op: OpToken, left: Expr, right: Expr</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, op, left, right, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">$&#123;op.op&#125;</span> <span class="hljs-subst">$&#123;left&#125;</span> <span class="hljs-subst">$&#123;right&#125;</span>)`</span><br>  &#125;&#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkTernary</span>(<span class="hljs-params">op: OpToken, left: Expr, middle: Expr, right: Expr</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;TERNARY&#x27;</span>, op, left, middle, right, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">$&#123;op.op&#125;</span> <span class="hljs-subst">$&#123;left&#125;</span> <span class="hljs-subst">$&#123;middle&#125;</span> <span class="hljs-subst">$&#123;right&#125;</span>)`</span> &#125; &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PrefixParselet</span> = &#123;<br>  <span class="hljs-attr">accept</span>: <span class="hljs-function">(<span class="hljs-params">token: Token</span>) =&gt;</span> <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">precedence</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-comment">// 这里 expr 调用 parselet 的时候把自己也给传进去，保证 parselet 在看不到 expr 函数的情况下也能直接调用 expr 函数</span><br>  <span class="hljs-attr">parse</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, x: Token, exprFn: Parser[<span class="hljs-string">&#x27;expr&#x27;</span>]</span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">InfixParselet</span> = &#123;<br>  <span class="hljs-attr">accept</span>: <span class="hljs-function">(<span class="hljs-params">token: Token</span>) =&gt;</span> <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">precedence</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span> | <span class="hljs-string">&#x27;R&#x27;</span>,<br>  <span class="hljs-attr">parse</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, x: Expr, op: Token, exprFn: Parser[<span class="hljs-string">&#x27;expr&#x27;</span>]</span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parser</span> = &#123;<br>  <span class="hljs-comment">// 因为谓词直接定义在 parselet 上了…</span><br>  <span class="hljs-attr">registerPrefixParselet</span>: <span class="hljs-function">(<span class="hljs-params">parselet: PrefixParselet</span>) =&gt;</span> <span class="hljs-built_in">void</span>,<br>  <span class="hljs-attr">registerInfixParselet</span>: <span class="hljs-function">(<span class="hljs-params">parselet: InfixParselet</span>) =&gt;</span> <span class="hljs-built_in">void</span>,<br>  <span class="hljs-attr">expr</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, lastOpPrecedence?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">newParser</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Parser</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">prefixParselets</span>: <span class="hljs-title class_">PrefixParselet</span>[] = []<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">infixParselets</span>: <span class="hljs-title class_">InfixParselet</span>[] = []<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPrefixParselet</span>(<span class="hljs-params">token: Token</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = prefixParselets.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">parselet</span> =&gt;</span> parselet.<span class="hljs-title function_">accept</span>(token))<br>    <span class="hljs-keyword">if</span> (!res) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`No Prefix parselet defined for <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(token)&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getInfixParselet</span>(<span class="hljs-params">token: Token</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = infixParselets.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">parselet</span> =&gt;</span> parselet.<span class="hljs-title function_">accept</span>(token))<br>    <span class="hljs-keyword">return</span> res ?? <span class="hljs-literal">null</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">precedenceHigherThan</span>(<span class="hljs-params">lexer: Lexer, lastOpPrecedence: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> currentParselet = <span class="hljs-title function_">getInfixParselet</span>(lexer.<span class="hljs-title function_">peek</span>())<br>    <span class="hljs-keyword">if</span> (currentParselet == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (currentParselet.<span class="hljs-property">precedence</span> != lastOpPrecedence) &#123;<br>      <span class="hljs-keyword">return</span> currentParselet.<span class="hljs-property">precedence</span> &gt; lastOpPrecedence<br>    &#125;<br>    <span class="hljs-keyword">return</span> currentParselet.<span class="hljs-property">assoc</span> === <span class="hljs-string">&#x27;L&#x27;</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOp = <span class="hljs-number">0</span></span>): <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-keyword">const</span> xToken = lexer.<span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">getPrefixParselet</span>(xToken).<span class="hljs-title function_">parse</span>(lexer, xToken, expr)<br>    <span class="hljs-keyword">while</span>(<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOp)) &#123;<br>      <span class="hljs-keyword">const</span> op = lexer.<span class="hljs-title function_">next</span>()<br>      x = <span class="hljs-title function_">getInfixParselet</span>(op)!.<span class="hljs-title function_">parse</span>(lexer, x, op, expr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>  &#125; <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-params">parselet</span>) &#123; infixParselets.<span class="hljs-title function_">push</span>(parselet) &#125;,<br>    <span class="hljs-title function_">registerPrefixParselet</span>(<span class="hljs-params">parselet</span>) &#123; prefixParselets.<span class="hljs-title function_">push</span>(parselet) &#125;,<br>    expr<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> parser = <span class="hljs-title function_">newParser</span>()<br><br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">// 这个优先级不会被使用到</span><br>  <span class="hljs-attr">accept</span>: <span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> token.<span class="hljs-property">type</span> == <span class="hljs-string">&#x27;ATOM&#x27;</span>,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkLiteral</span>(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">AtomToken</span>)<br>  &#125;,<br>&#125;)<br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">// 同样的不会使用到</span><br>  <span class="hljs-attr">accept</span>: <span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> token.<span class="hljs-property">type</span> == <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;(&#x27;</span>,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">exprFn</span>(lexer)<br>    <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">nextOp</span>().<span class="hljs-property">op</span> !== <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Expect &#x27;)&#x27;`</span>)<br>    <span class="hljs-keyword">return</span> res<br>  &#125;,<br>&#125;)<br><br><span class="hljs-comment">// 一般的前缀运算符对应的praselet</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">prefixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">PrefixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    precedence,<br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkUnary</span>(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>, right)<br>    &#125;,<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 一般的中缀运算符对应的parselet</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, assoc: <span class="hljs-string">&#x27;L&#x27;</span>| <span class="hljs-string">&#x27;R&#x27;</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">InfixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123; <br>    assoc, precedence,<br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>      op = op <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span><br>      <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>    &#125;,<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">suffixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">InfixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    precedence, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-comment">// 后缀运算符的结合性是个有意思的问题…但一般来说，后缀运算符的优先级会高于中缀，因此结合性应当是不起作用的</span><br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkUnary</span>(op <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>, x)<br>    &#125;,<br>  &#125;<br>&#125;<br><br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(<span class="hljs-title function_">prefixOperators</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;+-!&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;+-&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;*/%&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;^&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">suffixOperators</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;!&#x27;</span>))<br><br><span class="hljs-comment">// 数组索引</span><br>parser.<span class="hljs-title function_">registerInfixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-comment">// 这个结合性同样是没意义的，因为数组索引属于后缀运算符</span><br>  <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>    <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;[&#x27;</span><br>  &#125;,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">exprFn</span>(lexer)<br>    lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;]&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkBinary</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;[]&#x27;</span>&#125;, x, index)<br>  &#125;,<br>&#125;)<br><span class="hljs-comment">// 三目</span><br>parser.<span class="hljs-title function_">registerInfixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-comment">// 三目的结合性有用</span><br>  <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>    <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;?&#x27;</span><br>  &#125;,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> thenExpr = <span class="hljs-title function_">exprFn</span>(lexer)<br>    lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br>    <span class="hljs-keyword">const</span> elseExpr = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkTernary</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;?:&#x27;</span>&#125;, x, thenExpr, elseExpr)<br>  &#125;,<br>&#125;)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">parse</span> = (<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parser.<span class="hljs-title function_">expr</span>(<span class="hljs-title function_">mkLexer</span>(str)).<span class="hljs-title function_">toString</span>())<br><br><span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;3 + a[i[2]![3] * 2 + 1]&#x27;</span>) <span class="hljs-comment">// (+ 3 ([] a (+ (* ([] (! ([] i 2)) 3) 2) 1)))</span><br><span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;a ? b + 1 : c + d ? d : e + 2&#x27;</span>) <span class="hljs-comment">// (?: a (+ b 1) (?: (+ c d) d (+ e 2)))</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Crafting Interpreters》学习笔记 2——状态，控制流，函数，语义分析</title>
    <link href="/2023/12-28%E3%80%8ACrafting-Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%EF%BC%8C%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90.html"/>
    <url>/2023/12-28%E3%80%8ACrafting-Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%EF%BC%8C%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90.html</url>
    
    <content type="html"><![CDATA[<p>对 AST，有各种各样的方式去料理它——编译到另一门高级语言，生成机器码，字节码……这里采取最直接的方式——直接执行它。</p><p>当前的实现中只支持表达式，因此执行代码就是去计算表达式，并产生一个值。为此，对表达式中的每种元素，字面量，操作符等，都需要知晓如何去计算它和产生结果。</p><hr><p>该实现解释器了，该解释器直接遍历 AST 并产生一个结果，解释器仍旧是一个 Visitor，返回值是 Object，因为我们并不知道表达式具体会返回什么，是 Double 还是 String 还是 Boolean。</p><p>注意字面量和值的区别——字面量是 lexer 和 parser 的领域，而值是 interpreter，运行时的领域。</p><p>实现解释器当前是很简单的，语言中当前只有表达式，和四则运算一样简单，但有些东西需要注意：</p><ol><li>不应该暴露底层的实现细节，应当妥善处理任何运行时异常，避免抽象泄漏，并且保证其行为最终和后面的 clox 一致。</li><li>始终关心 Java 和 Lox 的类型系统，变量生命周期之间的关系（虽然这玩意全让 JVM 操心去了，到 clox 后才对这玩意有完全的控制权）</li></ol><p>总之这一章其实没多少需要做笔记的地方，直接进下一章。</p><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>该让这玩意有点编程语言的样子了，为了让它真正能做点什么，不至于当一个计算器，命令式语言要能真正做什么需要引入什么东西？语句 Statement！先做什么后做什么。在大多数编程语言中，整个源代码是由一个个语句组成的。</p><p>为此，需要在语法中引入语句的概念，这里先从简单的开始，引入一个 expression 语句（即计算该表达式并利用它的副作用，但目前什么额外的操作都不能做）和一个 print 语句（没错，语句而非库函数，因为定义函数是后面的事情，现在要马上能看到效果）：</p><figure class="highlight bnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BNF">program   -&gt; statement* EOF<br>statement -&gt; exprStmt<br>          |  printStmt<br>exprStmt  -&gt; expr &quot;;&quot;<br>printStmt -&gt; &quot;print&quot; expr &quot;;&quot;<br></code></pre></div></td></tr></table></figure><p>注意 program 规则最后的 EOF，这是为了避免解析器遗漏某些 token 没处理，在之前的四则运算的玩意里如果写一个 <code>1 + 2 3 + 4</code>，它处理完<code>1 + 2</code>就停了。</p><h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><p>这样就有点编程语言的样子了，但这里还欠缺一个要素——<strong>状态 State</strong>，离开了状态，那这些语句不过是一堆独立的个体，没有任何相互联系的地方。引入状态就是引入<strong>变量——绑定 binding 值到一个名字上</strong>。而这又引入一个问题——变量存在哪？这又引入一个概念——<strong>环境 Environment</strong>——关联变量和值的数据结构。</p><p>这里为了简化，不考虑作用域问题，把什么词法作用域啊函数作用域啊先留到将来，只考虑全局变量，这样，Environment 的实现就非常显然了——直接上哈希表就行。</p><p>为此，再次扩充变量定义语法（这里加个私货 VAL）：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">program        → declaration* EOF <br>declaration    → varDecl        <span class="hljs-meta"># 这里的 varDecl 其实不太合适定义出来一个新的规则，其实 declaration 的实现中就需要根据第一个 token 是否是 var 来做操作。.</span><br>               <span class="hljs-string">|  statement </span><br>statement      → exprStmt<br>               <span class="hljs-string">|  printStmt </span><br>varDecl        → <span class="hljs-string">&quot;var&quot;</span> IDENTIFIER ( <span class="hljs-string">&quot;=&quot;</span> expression )? <span class="hljs-string">&quot;;&quot;</span> <br>valDecl        -&gt; <span class="hljs-string">&quot;val&quot;</span> IDENTIFIER <span class="hljs-string">&quot;=&quot;</span> expression;<br></code></pre></div></td></tr></table></figure><p>注意这里把语句做了一些分离，为了避免这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>这玩意在 java，kotlin，js，scala 中均不合法，提示需要一个表达式。为了和该行为保持一致，只要在后来实现 if 的时候让它只接受 statement 而非 declaration 即可。</p><p>以及，生成一个新的 AST 类 Stmt 表示语句，并定义其子类 Expression，Print，Var。</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">generate_ast <span class="hljs-string">&#x27;Stmt&#x27;</span>, <span class="hljs-string">%/</span><br><span class="hljs-string">  Expression : Expr expression</span><br><span class="hljs-string">  Print      : Expr expression</span><br><span class="hljs-string">  Var        : Token name, Expr initializer</span><br><span class="hljs-string">/</span><br></code></pre></div></td></tr></table></figure><p>另外，关于上一节中的错误处理，declaration 显然很适合作为同步点，因此 synchronize 方法放到这里。</p><p>实现这些之后，又抛出另一个问题——在引用变量时，如果该变量找不着怎么办？有三种操作：</p><ol><li>抛出编译期错误，这能实现当然是最好的，但会引入一些复杂度——比如编写两个共递归的函数，他们互相引用，这时如果要抛编译期错误就不允许函数这样定义了。这当然是能处理的，比如在处理出现在顶层的标识符时不把它们当作语句的序列，而是当它们是“同时”定义的，但实现这玩意对于这样一个 tree-walker 解释器来说不值得（就连 typescript 中，函数中引用的变量写在函数定义之后，调用该函数的代码之前（因此会抛运行时异常）这种情况也无法处理呢）</li><li><strong>抛出运行时错误</strong>，许多脚本语言就是这样处理的，这里也这么处理</li><li>返回一个默认值比如 nil，不严格的 perl 是这么操作的，不应该这样搞，不然有了拼写错误都发现不了</li></ol><p>这也是为啥这语言中不像 python，ruby 那样直接<code>a = 1</code>就定义变量了——要是有拼写错误就麻了，同时也避免像 python 那样引入智障的 global，nonlocal 关键字。</p><h2 id="赋值表达式语法"><a href="#赋值表达式语法" class="headerlink" title="赋值表达式语法"></a>赋值表达式语法</h2><p>上面说的是变量定义语句<code>var variableName = initValue;</code>，这里得研究一下变量赋值表达式，它的形式形如<code>variableName = initValue</code>。</p><p>这里有个非常有趣的点——在 js，c 的优先级表中，三目的优先级比赋值高，但 js 的行为和 c，java 的行为均不同，后两者的行为是符合其优先级的。js 的这个有点令人费解……不按 js 的来。</p><p>相应语法规则如下，注意赋值运算符是右结合的（如果把 ternary 的 body 里的 ternary 改成 assignment 应该就是 js 那种效果）：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">expression</span> -&gt;</span> assignment<br><span class="hljs-function"><span class="hljs-title">assignment</span> -&gt;</span> IDENTIFIER <span class="hljs-string">&quot;=&quot;</span> assignment <br>           |  ternary <br><span class="hljs-function"><span class="hljs-title">ternary</span>    -&gt;</span> equality (<span class="hljs-string">&quot;?&quot;</span> ternary <span class="hljs-string">&quot;:&quot;</span> ternary)?<br><span class="hljs-function"><span class="hljs-title">equality</span>   -&gt;</span> comparison ((<span class="hljs-string">&quot;==&quot;</span> | <span class="hljs-string">&quot;!=&quot;</span>) comparsion)*<br><span class="hljs-function"><span class="hljs-title">comparsion</span> -&gt;</span> term ((<span class="hljs-string">&quot;&gt;&quot;</span> | <span class="hljs-string">&quot;&gt;=&quot;</span> | <span class="hljs-string">&quot;&lt;&quot;</span> | <span class="hljs-string">&quot;&lt;=&quot;</span>) term)*<br><span class="hljs-function"><span class="hljs-title">term</span>       -&gt;</span> factor ((<span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;+&quot;</span>) factor)*<br><span class="hljs-function"><span class="hljs-title">factor</span>     -&gt;</span> unary ((<span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;/&quot;</span>) unary)*<br><span class="hljs-function"><span class="hljs-title">unary</span>      -&gt;</span> (<span class="hljs-string">&quot;!&quot;</span> | <span class="hljs-string">&quot;-&quot;</span>) unary | primary<br><span class="hljs-function"><span class="hljs-title">primary</span>    -&gt;</span> NUMBER | STRING | <span class="hljs-string">&quot;true&quot;</span> | <span class="hljs-string">&quot;false&quot;</span> | <span class="hljs-string">&quot;nil&quot;</span> <br>            | <span class="hljs-string">&quot;(&quot;</span> expression <span class="hljs-string">&quot;)&quot;</span> <br></code></pre></div></td></tr></table></figure><p>虽然看上去轻松，但实现的时候还是有一些问题的，这关乎赋值语句本身的特性——左值和右值，在运行时，<strong>左值求的不是值，而是它对应的“地址”</strong>。如何保证等号左边是左值？这里的诀窍是退一步进两步——先放宽需求，这样去定义 assignment：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">assignment</span> -&gt;</span> ternary (<span class="hljs-string">&quot;=&quot;</span> assignment)?<br></code></pre></div></td></tr></table></figure><p>然后实际操作的时候，先获取一个 ternary，并检查下一个 token 是否是 EQUAL，若是就进入赋值表达式的逻辑，检查这里的 ternary 是否是 IDENTIFIER，如何检查呢？这里是个 Expr 啊？我们知道解析 IDENTIFIER 会解析成<code>Expr.Variable</code>，那就做个 instanceof 呗。<strong>这里实际上是一个把右值转换为左值的过程</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">assignment</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> ternary();<br>    <span class="hljs-keyword">if</span> (match(EQUAL)) &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">equal</span> <span class="hljs-operator">=</span> previous();<br>        <span class="hljs-type">val</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> assignment();<br>        <span class="hljs-comment">// 后续可以进行更多处理，比如左边是 arr[i]，instance.field 等形式时</span><br>        <span class="hljs-comment">// 左值不能当成普通表达式看待，需要特别的处理逻辑，比如 (a) = 1，即使看上去没啥问题，我们也不应当认为它合法</span><br>        <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> Expr.Variable) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Assign(((Expr.Variable) res).name, value);<br>        &#125;<br>        error(equal, <span class="hljs-string">&quot;Invalid assignment target&quot;</span>); <span class="hljs-comment">// 非法的左值</span><br>        <span class="hljs-comment">// 这里还是继续解析，这个错误不至于去进入 panic mode</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里如果直接尝试匹配一个 IDENTIFIER，再尝试匹配一个 EQUAL 来走到赋值表达式的逻辑如何呢？其实应该也是能做到的，但后续不好扩展。</p><p>在退一步时，可以退的更远，允许甚至不是表达式的东西出现在左边，只要保证退了后还能进就行，哈哈哈哈哈。</p><h2 id="赋值表达式语义"><a href="#赋值表达式语义" class="headerlink" title="赋值表达式语义"></a>赋值表达式语义</h2><p>这个倒简单——若先前存在该变量定义，就继续赋值操作，不然就报错说 undefined 的变量。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域，即能看到映射到特定名字的特定实体的地方。词法作用域是一种特殊的作用域，即仅通过程序的源代码便能够看出作用域的开始和结束位置。大多数现代语言中，变量都是词法作用域的（不全是，ruby 和 python 的变量没有词法作用域，只有函数作用域）。</p><p>而在 lox 中，方法，字段是动态作用域的——直到运行时，你才知道特定对象是否包含该方法、字段。</p><p>要引入词法作用域，只使用哈希表来作存储是不够的——需要考虑作用域遮蔽的情况，即内层作用域的变量遮蔽外层作用域的同名变量，而离开内层作用域之后，外层作用域的同名变量变得又能访问到了。</p><p>为此，Environment 需要是某种嵌套结构——在进入一个词法块的时候，创建一个新的 Environment，该 Environment 需要引用包围它的 Environment，定义变量时在该 Environment 中定义，查询时先查询该 Environment，再递归查询包围它的 Environment，如果不存在包围它的 Environment 再认为是 undefined 的变量。</p><p>离开词法块的时候，设定当前 Environment 为包围它的 Environment 即可。这里并不需要整出来个树结构，实际上链表即可。</p><p>另外，需要引入块：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">statement → exprStmt<br>          <span class="hljs-string">|  printStmt </span><br>          <span class="hljs-string">|  block</span><br>block     → <span class="hljs-string">&quot;&#123;&quot;</span> declaration* <span class="hljs-string">&quot;&#125;&quot;</span> ;<br></code></pre></div></td></tr></table></figure><h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><p>后面只记一些最值得记的地方，感觉并不需要跟着书见到啥记啥，又不是学马哲，没必要啥东西都抓，整点实用主义。</p><p>控制流最基本来说，只有两种类型：条件和循环。实现了这俩，那语言就图灵完备了。</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>if 的语法如下：</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">statement → exprStmt<br>          |  <span class="hljs-type">printStmt</span> <br>          |  <span class="hljs-type">block</span><br>          |  <span class="hljs-type">ifStmt</span><br>ifStmt    -&gt; <span class="hljs-string">&quot;if&quot;</span> <span class="hljs-string">&quot;(&quot;</span> expression <span class="hljs-string">&quot;)&quot;</span> statement (<span class="hljs-string">&quot;else&quot;</span> statement)?<br></code></pre></div></td></tr></table></figure><p>处理 if 时，有个经典的问题：对下面的代码，else 对应的是哪个 if？</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (first)<br>  <span class="hljs-keyword">if</span> (second) &#123;<span class="hljs-comment">/*...*/</span>&#125;<br><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/*...*/</span>&#125;<br></code></pre></div></td></tr></table></figure><p>一些语言为了避免这个问题，直接为 else if 去提供新的关键字，这里直接走最自然的逻辑——让 else 匹配最近的 if，这正好和解析器的工作方式相吻合——在解析内层的 if 的时候，它会贪婪地把 else 子句马上消费掉。</p><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p>条件表达式，注意 or 的优先级更低，就像一堵高墙把不同的 and 隔离开来。同时注意条件表达式计算时有短路操作，所以值得为条件表达式新增对应的语法树节点类型。</p><h2 id="while，for"><a href="#while，for" class="headerlink" title="while，for"></a>while，for</h2><p>没啥好说的。关于 for，书中提了语法糖的概念，即不引入新的语法树节点，对于语法糖，手动去把它 desugar 成已有的语法树节点。</p><p>考虑到实现 for 有点蛋疼，书中的 for 限制颇多，这里干脆不要 for 了。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>最激动人心的时刻——函数。有了函数，就有了过程抽象的能力。</p><p>函数调用的语法如下：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">call</span>      -&gt;</span>  primary (<span class="hljs-string">&quot;(&quot;</span> arguments? <span class="hljs-string">&quot;)&quot;</span>)*<br><span class="hljs-function"><span class="hljs-title">arguments</span> -&gt;</span> expression (<span class="hljs-string">&quot;,&quot;</span> expression)*<br></code></pre></div></td></tr></table></figure><p>注意函数调用是左结合，因此它的实现类似中缀操作符。</p><p>函数定义的语法如下：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">fnStmt</span> -&gt;</span> <span class="hljs-string">&quot;FUN&quot;</span> IDENTIFIER <span class="hljs-string">&quot;(&quot;</span> parameters? <span class="hljs-string">&quot;)&quot;</span> <span class="hljs-keyword">block</span><br><span class="hljs-function"><span class="hljs-title">parameters</span> -&gt;</span> IDENTIFIER (<span class="hljs-string">&quot;,&quot;</span> IDENTIFIER)*<br></code></pre></div></td></tr></table></figure><p>注意这里的命名——argument 和 parameter。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>关于函数，实际上有两个作用域和它相关——函数定义时的作用域，函数调用时的作用域，前者用于创建闭包（这玩意好像本身就叫闭包？），后者……或许可以在像 scala 之类的语言中传递隐式参数之类的玩意？</p><p>要实现闭包，只需要让函数记住函数定义时的作用域即可。</p><h1 id="变量获取和绑定"><a href="#变量获取和绑定" class="headerlink" title="变量获取和绑定"></a>变量获取和绑定</h1><p>上面的作用域的实现是有问题的——函数创建时，保存函数当前的环境，在获取变量时，它跟随着作用域链一层层往上找，找到最近的该变量。问题是，<strong>环境是可变的</strong>，在变量定义后，如果在比原所捕获变量的作用域更深的作用域下再次定义同名变量，函数再次调用后找到的变量和函数想要找到的变量就不同了。这是不符合直觉的：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">val a = <span class="hljs-string">&quot;global&quot;</span>;<br>&#123;<br>  fun <span class="hljs-title function_">showA</span>(<span class="hljs-params"></span>) &#123;<br>    print a;<br>  &#125;<br><br>  <span class="hljs-title function_">showA</span>(); <span class="hljs-comment">// global</span><br>  val a = <span class="hljs-string">&quot;block&quot;</span>;<br>  <span class="hljs-title function_">showA</span>(); <span class="hljs-comment">// block</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的问题在于，在函数定义的该层环境中，又定义了同名变量 a，函数往外找变量 a 时，先找到了同层的这个 a，即使它是在函数定义后才定义的。词法作用域是<strong>静态语义</strong>，函数捕获的变量应当是比它先定义的，最深的变量。这里没有给变量 a 重新赋值，因此函数的输出结果不同绝对是哪里出现了问题。</p><p>这里有两个概念——静态的作用域和动态的环境，需要保证它们正确地同步。大多数时候同步是得到保障的——进入新作用域时创建新环境，离开该作用域时丢掉环境。变量定义时，把变量绑定到环境上。</p><p>错误来自于一个前提——我们假设块中的每一行语句都在同一个作用域中。根据该前提，这里使用单个环境去表达作用域。新增变量时，不是创建新作用域，而是把变量绑定在现有的这个作用域上，即不断地<strong>修改</strong>这个作用域。函数需要看到的，是函数定义时的作用域的一个不变的快照。</p><p>要处理这个问题，最明显的方案是丢掉这个前提，每次新增一个变量，也要新创建一个 Environment，保证运行时的行为和静态语义完全一致，但要实现这个估计会很痛苦且低效。考虑到只有对函数才有这种情况，可以在定义函数时把整个作用域完全拷贝一次。</p><p>但这里使用更直接的方案——进行语义分析，在函数定义时直接“烘培”函数中引用的外部变量。</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>resolve——遇到标识符时，找到相应的变量定义。每次遇到带变量的表达式就要进行这一过程。考虑到对静态作用域，每一个用到的变量，都能唯一地找到它的变量定义，没必要在运行时才去一层一层地去找，而是只找一次，找一次就固化它（我是说，烘培 lol）。</p><p>为此，需要进行一次语义分析，在解析完 token 序列之后，真正执行代码之前；类型分析，优化通常在此时执行。一般来说，一切不依赖运行时状态的工作都可以在这里完成。</p><p>这里，需要根据每个标识符去找到对应的变量定义，因此所有和变量（标识符）以及块相关的语句和表达式需要处理，其他的节点就直接继续遍历它的子节点：</p><ol><li>块</li><li>函数定义</li><li>变量定义</li><li>变量引用和赋值表达式</li></ol><p>在进行语义分析时，<strong>遇到变量和函数的定义时，记录定义位置（以作用域为单位）；遇到引用变量和函数的地方时，检查当前以及定义位置之间差了多少层作用域，并让这个信息被解释器知晓</strong>。</p><p>这里定义一个 Resolver 用来进行变量的获取，它要维护一个作用域栈，栈中元素为哈希表，保存当前作用域下定义的变量。该哈希表的类型为<code>Map&lt;String, Boolean&gt;</code>，key 为标识符名称，至于 value……要考虑一个边缘情况：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">val a = <span class="hljs-number">1</span>;<br>&#123;<br>  val a = a;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这认为是不合法的，要报错<code>Cannot access &#39;a&#39; before initialization</code>。为了能区分这种情况，不能直接用集合去保存当前作用域，这里的 value 表示变量是否“准备完毕”，这里先把 a 先“声明”，处理完右值后，再把 a 去“定义”；在获取变量时，如果发现变量“声明”了但没“定义”就报错。（如果没有找到变量，就认为变量是在顶层作用域，因为顶层作用域是非常灵活的，这里不报错）</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 下面是这两个过程的伪代码描述</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">node: ASTNode</span>):<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> VAR_STMT:<br>        declare node<br>        resolve node.initializer <br>        define node<br>    <span class="hljs-keyword">elif</span> node <span class="hljs-keyword">is</span> FUNCTION:<br>        declare_and_define node<br>        with_new_scope:<br>            declare_and_define params<br>            resolve <span class="hljs-keyword">for</span> node.body<br>    <span class="hljs-keyword">elif</span> node <span class="hljs-keyword">is</span> BLOCK:<br>        with_new_scope:<br>            resolve <span class="hljs-keyword">for</span> node.stmts<br>    <span class="hljs-keyword">elif</span> node <span class="hljs-keyword">is</span> VARIABLE:<br>        var_stmt, depth = find_define_location node<br>        <span class="hljs-keyword">assert</span> var_stmt <span class="hljs-keyword">is</span> defined<br>        interpreter.resolveLocal node, depth<br>    <span class="hljs-keyword">else</span>:<br>        resolve <span class="hljs-keyword">for</span> node.childrens<br></code></pre></div></td></tr></table></figure><p>如何让解析器保存该信息？增加一个哈希表字段，映射相应 AST 节点（必将是<code>Variable</code>或<code>Assign</code>类型，即赋值和取值）到其和其定义位置的距离。使用<code>IdentityHashMap</code>以使能够利用到节点本身的唯一标识符——地址。</p><p>之后，修改解释器对赋值和变量的处理，直接根据该哈希表去找到相应字段所在的 Environment，如果没找到，则默认是在全局作用域中。</p><p>这一趟语义分析也可以干点其他的，比如，检查变量是否在同一个作用域被重复定义了，检查 return 时是否在函数内，检查 return 后是否还有不可到达的代码…</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 TS 使用递归下降法实现解析四则运算</title>
    <link href="/2023/12-19%E4%BD%BF%E7%94%A8TS%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97.html"/>
    <url>/2023/12-19%E4%BD%BF%E7%94%A8TS%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97.html</url>
    
    <content type="html"><![CDATA[<p>为了巩固和确认当前成果，换一个语言去把词法分析、递归下降语法分析再做一遍，其中使用正则表达式去实现词法分析，实现一下解析四则运算表达式。考虑到相关需求，使用 ts 去进行实现，理由如下：</p><ol><li>之前在 java 里写解析器是逐字符来的，这次想试试用正则，而 js 有正则字面量，写正则表达式比 java 舒服一些，特别是处理转义符的时候（虽然这里估计用不到很复杂的）</li><li>ts 支持代数数据类型，用来对 Token 和 AST 建模很方便</li><li>js 方便做AST的可视化……本来想做的，但发现直接展示的话没啥乐子，想做个步进又发现过于复杂了。先摆了，将来再说</li></ol><p>同时也期待这玩意能作为一个原型，打算等后面把 jlox 实现完后整个给它搬到浏览器上，如果我真的学的完的话。</p><p>该四则运算语言中，支持<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>**</code>（乘方，没有这个就无聊了）和括号，优先级、结合性和 js 中的一致。为了让它更整蛊，字面量允许字符串和数字，其中<code>-</code>，<code>/</code>，<code>%</code>，<code>**</code> 等不允许左右两边出现字符串字面量（这个限制在计算的时候:P）。</p><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>词法分析需要定义词素，定义下面的 Token 类型（虽然这里会忽略空白，但为了后面能正确维护 Scanner 的状态，还是需要知道空白的数量以及其中包含多少个换行符的，所以另外定义了一个 BLANK token，但后续会直接扔掉）：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">TokenValue</span> = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;NUMBER&#x27;</span>,<br>  <span class="hljs-attr">literal</span>: <span class="hljs-built_in">number</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;STRING&#x27;</span>,<br>  <span class="hljs-attr">literal</span>: <span class="hljs-built_in">string</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;PLUS&#x27;</span> | <span class="hljs-string">&#x27;MINUS&#x27;</span> | <span class="hljs-string">&#x27;SLASH&#x27;</span> | <span class="hljs-string">&#x27;STAR&#x27;</span> | <span class="hljs-string">&#x27;PERCENT&#x27;</span> | <span class="hljs-string">&#x27;LEFT_PAREN&#x27;</span> | <span class="hljs-string">&#x27;RIGHT_PAREN&#x27;</span> | <span class="hljs-string">&#x27;STAR_STAR&#x27;</span> | <span class="hljs-string">&#x27;BLANK&#x27;</span> | <span class="hljs-string">&#x27;EOF&#x27;</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Token</span> = <span class="hljs-title class_">TokenValue</span> &amp; &#123;<br>  <span class="hljs-attr">lexeme</span>: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 原始的词素</span><br>  <span class="hljs-attr">line</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 行数</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后，需要为单字符的 token，双字符的 token，字符串字面量，数字字面量，还有空白，为它们分别定义正则表达式，然后把它们用<code>|</code>拼接到一起，并且给予 g flag——这让正则表达式能够包含状态，设置正则从字符串的特定位置去开始进行匹配。</p><p>要注意最长匹配原则——如果<code>**</code>能匹配，就不要匹配成两个<code>*</code>，因此各 token 的顺序需要被正确处理——如果两个正则表达式有歧义，较长的要放前面。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 该正则的各位置对应 token 如下：</span><br><span class="hljs-comment">// 1: STAR_STAR</span><br><span class="hljs-comment">// 2: PLUS, MINUS, STAR, SLASH, PERCENT, LEFT_PAREN, RIGHT_PAREN</span><br><span class="hljs-comment">// 3: STRING</span><br><span class="hljs-comment">// 4: NUMBER</span><br><span class="hljs-comment">// 5: BLANK</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REGEXP</span> = (<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DOUBLE_TOKEN_REGEXP</span> = <span class="hljs-regexp">/(\*\*)/</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SINGLE_TOKEN_REGEXP</span> = <span class="hljs-regexp">/(\+|\-|\*|\/|\%|\(|\))/</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">STRING_LITERAL_REGEXP</span> = <span class="hljs-regexp">/&quot;(.*?)(?&lt;!\\)&quot;/</span> <span class="hljs-comment">// (?&lt;!y)x 是负向否定预查，它会匹配这样的 x，它前面不是 y，这里是为了跳过、&quot;</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NUMBER_LITERAL_REGEXP</span> = <span class="hljs-regexp">/(\d+(?:\.\d+)?)/</span> <span class="hljs-comment">// 支持 1 和 1.0 这样的形式 ，?: 表示忽略该分组</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IGNORE_TOKEN_REGEXP</span> = <span class="hljs-regexp">/(\s+)/</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ANOTHER_STRING_LITERAL_REGEXP</span> = <span class="hljs-regexp">/&quot;((?:[^&quot;\\]|\\.)*)&quot;/</span> <span class="hljs-comment">// GPT 给的另一个字符串字面量正则</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>([<br>    <span class="hljs-variable constant_">DOUBLE_TOKEN_REGEXP</span>,<br>    <span class="hljs-variable constant_">SINGLE_TOKEN_REGEXP</span>,<br>    <span class="hljs-variable constant_">STRING_LITERAL_REGEXP</span>,<br>    <span class="hljs-variable constant_">NUMBER_LITERAL_REGEXP</span>,<br>    <span class="hljs-variable constant_">IGNORE_TOKEN_REGEXP</span><br>  ].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">regexp</span> =&gt;</span> regexp.<span class="hljs-property">source</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;|&#x27;</span>), <span class="hljs-string">&#x27;g&#x27;</span>)<br>&#125;)()<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tryMatch</span>(<span class="hljs-params">code: <span class="hljs-built_in">string</span>, startIndex: <span class="hljs-built_in">number</span>, line: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Token</span> &#123;<br>  <span class="hljs-comment">// lastIndex 是正则的开始匹配位置</span><br>  <span class="hljs-variable constant_">REGEXP</span>.<span class="hljs-property">lastIndex</span> = startIndex<br>  <span class="hljs-keyword">const</span> match = <span class="hljs-variable constant_">REGEXP</span>.<span class="hljs-title function_">exec</span>(code)<br>  <span class="hljs-comment">// 如果没有匹配到，或者并非从开始位置匹配到（这证明字符串开始位置有非法字符）</span><br>  <span class="hljs-keyword">if</span> (!match || match.<span class="hljs-property">index</span> != startIndex) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`词法错误！行数：<span class="hljs-subst">$&#123;line&#125;</span>`</span>)<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (match[<span class="hljs-number">1</span>] != <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;STAR_STAR&#x27;</span>, line, <span class="hljs-attr">lexeme</span>: match[<span class="hljs-number">1</span>] &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (match[<span class="hljs-number">2</span>] != <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = &#123; <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-string">&#x27;PLUS&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-string">&#x27;MINUS&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-string">&#x27;STAR&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-string">&#x27;SLASH&#x27;</span>, <span class="hljs-string">&#x27;%&#x27;</span>: <span class="hljs-string">&#x27;PERCENT&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-string">&#x27;LEFT_PAREN&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-string">&#x27;RIGHT_PAREN&#x27;</span> &#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span><br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: map[match[<span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> keyof <span class="hljs-keyword">typeof</span> map], <span class="hljs-attr">lexeme</span>: match[<span class="hljs-number">2</span>], line &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (match[<span class="hljs-number">3</span>] != <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;STRING&#x27;</span>, <span class="hljs-attr">lexeme</span>: <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;match[<span class="hljs-number">3</span>]&#125;</span>&quot;`</span>, line, <span class="hljs-attr">literal</span>: match[<span class="hljs-number">3</span>]&#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (match[<span class="hljs-number">4</span>] != <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;NUMBER&#x27;</span>, <span class="hljs-attr">lexeme</span>: match[<span class="hljs-number">4</span>], line, <span class="hljs-attr">literal</span>: <span class="hljs-built_in">parseInt</span>(match[<span class="hljs-number">4</span>])&#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (match[<span class="hljs-number">5</span>] != <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BLANK&#x27;</span>, <span class="hljs-attr">lexeme</span>: match[<span class="hljs-number">5</span>], line &#125;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(match)<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Impossible&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readTokens</span>(<span class="hljs-params">code: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Token</span>[] &#123;<br>  <span class="hljs-comment">// 使用正则的话，只需要维护下一个词素的开始位置就行，因此这里把 start 直接给去掉了</span><br>  <span class="hljs-keyword">let</span> line = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> current = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">res</span>: <span class="hljs-title class_">Token</span>[] = []<br><br>  <span class="hljs-keyword">while</span> (current &lt; code.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> token = <span class="hljs-title function_">tryMatch</span>(code, current, line)<br>    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;BLANK&#x27;</span>)&#123;<br>      res.<span class="hljs-title function_">push</span>(token)<br>    &#125;<br>    <span class="hljs-keyword">const</span> lexeme = token.<span class="hljs-property">lexeme</span><br>    <span class="hljs-comment">// 维护 current 和 line</span><br>    current += lexeme.<span class="hljs-property">length</span> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> lexeme) &#123;<br>      <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&#x27;\n&#x27;</span>) line++<br>    &#125;<br>  &#125;<br>  res.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span>, line, <span class="hljs-attr">lexeme</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;)<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></div></td></tr></table></figure><p>逻辑比 java 还清晰些……主要是不需要同时维护两个指针，不需要在字符的粒度上去进行编码，缺点是无法给予清晰的报错。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">readTokens</span>(<span class="hljs-string">`  -1 + 2.3 </span><br><span class="hljs-string">2+2.3+&quot;123&quot;+3.4-1*2/3**4* *5%6</span><br><span class="hljs-string">7(1+2) &quot;11\\&quot;23\\&quot;44&quot;`</span>))<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  &#123; type: &#x27;MINUS&#x27;, lexeme: &#x27;-&#x27;, line: 1 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;1&#x27;, line: 1, literal: 1 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;PLUS&#x27;, lexeme: &#x27;+&#x27;, line: 1 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;2.3&#x27;, line: 1, literal: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;2&#x27;, line: 2, literal: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;PLUS&#x27;, lexeme: &#x27;+&#x27;, line: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;2.3&#x27;, line: 2, literal: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;PLUS&#x27;, lexeme: &#x27;+&#x27;, line: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;STRING&#x27;, lexeme: &#x27;&quot;123&quot;&#x27;, line: 2, literal: &#x27;123&#x27; &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;PLUS&#x27;, lexeme: &#x27;+&#x27;, line: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;3.4&#x27;, line: 2, literal: 3 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;MINUS&#x27;, lexeme: &#x27;-&#x27;, line: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;1&#x27;, line: 2, literal: 1 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;STAR&#x27;, lexeme: &#x27;*&#x27;, line: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;2&#x27;, line: 2, literal: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;SLASH&#x27;, lexeme: &#x27;/&#x27;, line: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;3&#x27;, line: 2, literal: 3 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;STAR_STAR&#x27;, line: 2, lexeme: &#x27;**&#x27; &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;4&#x27;, line: 2, literal: 4 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;STAR&#x27;, lexeme: &#x27;*&#x27;, line: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;5&#x27;, line: 2, literal: 5 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;PERCENT&#x27;, lexeme: &#x27;%&#x27;, line: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;6&#x27;, line: 2, literal: 6 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;7&#x27;, line: 3, literal: 7 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;LEFT_PAREN&#x27;, lexeme: &#x27;(&#x27;, line: 3 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;1&#x27;, line: 3, literal: 1 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;PLUS&#x27;, lexeme: &#x27;+&#x27;, line: 3 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;NUMBER&#x27;, lexeme: &#x27;2&#x27;, line: 3, literal: 2 &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;RIGHT_PAREN&#x27;, lexeme: &#x27;)&#x27;, line: 3 &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    type: &#x27;STRING&#x27;,</span><br><span class="hljs-comment">    lexeme: &#x27;&quot;11\\&quot;23\\&quot;44&quot;&#x27;,</span><br><span class="hljs-comment">    line: 3,</span><br><span class="hljs-comment">    literal: &#x27;11\\&quot;23\\&quot;44&#x27;</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123; type: &#x27;EOF&#x27;, line: 3, lexeme: &#x27;&#x27; &#125;</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>然后是语法分析，首先确认这些运算符的优先级和结合性，下表优先级从低到高。</p><table><thead><tr><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center"><code>-</code> <code>+</code></td><td align="center">左</td></tr><tr><td align="center"><code>*</code> <code>/</code> <code>%</code></td><td align="center">左</td></tr><tr><td align="center"><code>**</code></td><td align="center">右</td></tr><tr><td align="center">unary <code>-</code> <code>+</code></td><td align="center">右</td></tr></tbody></table><p>根据优先级，定义相应 BNF，注意这里的乘方的规则 <code>Exponent -&gt; Unary (&quot;**&quot; Exponent)?</code>——乘方是右结合的，因此右方要允许其它乘方的出现且为它的右子树，这也体现在 parser 中。</p><figure class="highlight bnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BNF">Expr     -&gt; Term<br>Term     -&gt; Factor ((&quot;-&quot; | &quot;+&quot;) Factor)*<br>Factor   -&gt; Exponent ((&quot;*&quot; | &quot;/&quot; | &quot;%&quot;) Exponent)*<br>Exponent -&gt; Unary (&quot;**&quot; Exponent)?  # 注意这里！<br>Unary    -&gt; (&quot;+&quot; | &quot;-&quot;) Unary | Primary<br>Primary  -&gt; NUMBER | STRING | &quot;(&quot; Expr &quot;)&quot;<br></code></pre></div></td></tr></table></figure><p>说到底递归下降法为啥是这样呢，该怎样建立它的心智模型呢……想不通啊想不通</p><p>然后实现解析器，这里实际上只有三种类型了——一元操作，二元操作和字面量，这里没必要去表示括号，但还是给它带上。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Expr</span> = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;UNARY&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">Token</span>, <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Expr</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, <span class="hljs-attr">left</span>: <span class="hljs-title class_">Expr</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">Token</span>,  <span class="hljs-attr">right</span>: <span class="hljs-title class_">Expr</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LITERAL&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GROUPING&#x27;</span>, <span class="hljs-attr">expr</span>: <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">tokens: Token[]</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-comment">// 同样的，需要一个 current 状态</span><br>  <span class="hljs-comment">// 但和 Scanner 不同，因为递归下降中每个规则都要对应一个函数，没法很好地直接维护 current，因此需要定义一些原子的函数去读取 token 和获取 current</span><br>  <span class="hljs-keyword">let</span> current = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">isAtEnd</span> = (<span class="hljs-params"></span>) =&gt; current &gt;= tokens.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">peek</span> = (<span class="hljs-params"></span>) =&gt; tokens[current]<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">advance</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">isAtEnd</span>() ? <span class="hljs-title function_">peek</span>() : tokens[current++]<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">previous</span> = (<span class="hljs-params"></span>) =&gt; tokens[current - <span class="hljs-number">1</span>]<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">...tokenTypes: Token[<span class="hljs-string">&#x27;type&#x27;</span>][]</span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isAtEnd</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> current = <span class="hljs-title function_">peek</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> tokenType <span class="hljs-keyword">of</span> tokenTypes) &#123;<br>      <span class="hljs-keyword">if</span> (current.<span class="hljs-property">type</span> === tokenType) &#123;<br>        <span class="hljs-title function_">advance</span>()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">token: Token, msg: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Error</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`语法错误，#&#123;msg&#125;。行数：<span class="hljs-subst">$&#123;token.line&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">consume</span>(<span class="hljs-params">tokenType: Token[<span class="hljs-string">&#x27;type&#x27;</span>], msg: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">match</span>(tokenType)) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-title function_">error</span>(<span class="hljs-title function_">peek</span>(), msg)<br>  &#125;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">Expr     -&gt; Term</span><br><span class="hljs-comment">Term     -&gt; Factor ((&quot;-&quot; | &quot;+&quot;) Factor)*</span><br><span class="hljs-comment">Factor   -&gt; Exponent ((&quot;*&quot; | &quot;/&quot; | &quot;%&quot;) Exponent)*</span><br><span class="hljs-comment">Exponent -&gt; Unary (&quot;**&quot; Exponent)?   # 右结合！</span><br><span class="hljs-comment">Unary    -&gt; (&quot;+&quot; | &quot;-&quot;) Unary | Primary</span><br><span class="hljs-comment">Primary  -&gt; NUMBER | STRING | &quot;(&quot; Expr &quot;)&quot;</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">term</span>()<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">term</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-title function_">factor</span>()<br>    <span class="hljs-keyword">while</span> (<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;MINUS&#x27;</span>, <span class="hljs-string">&#x27;PLUS&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">const</span> op = <span class="hljs-title function_">previous</span>()<br>      <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">factor</span>()<br>      left = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, op, left, right&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">factor</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-title function_">exponent</span>()<br>    <span class="hljs-keyword">while</span> (<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;STAR&#x27;</span>, <span class="hljs-string">&#x27;SLASH&#x27;</span>, <span class="hljs-string">&#x27;PERCENT&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">const</span> op = <span class="hljs-title function_">previous</span>()<br>      <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">exponent</span>()<br>      left = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, op, left, right&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">exponent</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-title function_">unary</span>()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;STAR_STAR&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">const</span> op = <span class="hljs-title function_">previous</span>()<br>      <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">exponent</span>()<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, left, op, right&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unary</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;MINUS&#x27;</span>, <span class="hljs-string">&#x27;PLUS&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">const</span> op = <span class="hljs-title function_">previous</span>()<br>      <span class="hljs-keyword">const</span> expr = <span class="hljs-title function_">unary</span>()<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;UNARY&#x27;</span>, op, expr&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">primary</span>()<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">primary</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;LEFT_PAREN&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">expr</span>()<br>      <span class="hljs-title function_">consume</span>(<span class="hljs-string">&#x27;RIGHT_PAREN&#x27;</span>, <span class="hljs-string">&quot;Expect &#x27;)&#x27;&quot;</span>)<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GROUPING&#x27;</span>, <span class="hljs-attr">expr</span>: res&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;NUMBER&#x27;</span>, <span class="hljs-string">&#x27;STRING&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">previous</span>()<br>      <span class="hljs-keyword">if</span> (!(res.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;NUMBER&#x27;</span> || res.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;STRING&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Impossible&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LITERAL&#x27;</span>, <span class="hljs-attr">value</span>: res.<span class="hljs-property">literal</span>&#125;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-title function_">error</span>(<span class="hljs-title function_">peek</span>(), <span class="hljs-string">&#x27;Expect expression&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">expr</span>()<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="打印和执行"><a href="#打印和执行" class="headerlink" title="打印和执行"></a>打印和执行</h1><p>最难的部分已经结束了，现在只欠打印和计算了，而它们本身也没啥难度（和意思），这里实现lisp形式和逆波兰表达式（不允许一元运算符）形式打印。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// lisp形式打印</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printAst</span>(<span class="hljs-params">expr: Expr</span>): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">if</span> (expr.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;LITERAL&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> expr.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> expr.<span class="hljs-property">value</span>.<span class="hljs-title function_">toString</span>()<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;expr.value&#125;</span>&quot;`</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (expr.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;BINARY&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;op, left, right&#125; = expr<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">$&#123;op.lexeme&#125;</span> <span class="hljs-subst">$&#123;printAst(left)&#125;</span> <span class="hljs-subst">$&#123;printAst(right)&#125;</span>)`</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (expr.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;GROUPING&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">printAst</span>(expr.<span class="hljs-property">expr</span>)<br>  &#125;<br>  <span class="hljs-keyword">const</span> &#123;op, <span class="hljs-attr">expr</span>: e&#125; = expr<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">$&#123;op.lexeme&#125;</span> <span class="hljs-subst">$&#123;printAst(e)&#125;</span>)`</span><br>&#125;<br><br><span class="hljs-comment">// 容易发现逆波兰表达式是后序遍历</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reversePolishNotation</span>(<span class="hljs-params">expr: Expr</span>): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">if</span> (expr.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;LITERAL&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> expr.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> expr.<span class="hljs-property">value</span>.<span class="hljs-title function_">toString</span>()<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;expr.value&#125;</span>&quot;`</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (expr.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;UNARY&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;逆波兰表达式不允许一元运算符&quot;</span>)<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (expr.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;GROUPING&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reversePolandExpr</span>(expr.<span class="hljs-property">expr</span>)<br>  &#125;<br>  <span class="hljs-keyword">const</span> &#123;op, left, right&#125; = expr<br>  <span class="hljs-keyword">const</span> leftRes = <span class="hljs-title function_">reversePolandExpr</span>(left)<br>  <span class="hljs-keyword">const</span> rightRes = <span class="hljs-title function_">reversePolandExpr</span>(right)<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;leftRes&#125;</span> <span class="hljs-subst">$&#123;rightRes&#125;</span> <span class="hljs-subst">$&#123;op.lexeme&#125;</span>`</span><br>&#125;<br><br><br><br><br><span class="hljs-comment">// 计算，如果出现错误则返回Error</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">expr: Expr</span>): <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-title class_">Error</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">token: Token, msg: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Error</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`计算错误，<span class="hljs-subst">$&#123;msg&#125;</span>。行数：<span class="hljs-subst">$&#123;token.line&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">go</span>(<span class="hljs-params">expr: Expr</span>): <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">if</span> (expr.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;LITERAL&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> expr.<span class="hljs-property">value</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (expr.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;GROUPING&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">go</span>(expr.<span class="hljs-property">expr</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (expr.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;UNARY&#x27;</span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123;op , <span class="hljs-attr">expr</span>: subExpr&#125; = expr<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">go</span>(subExpr)<br>      <span class="hljs-keyword">if</span> (op.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;MINUS&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-title function_">error</span>(op, <span class="hljs-string">&quot;Unary &#x27;-&#x27; cannot apply to string&quot;</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> -res;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (op.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;PLUS&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 对字符串会转成数字</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>          <span class="hljs-keyword">const</span> numRes = <span class="hljs-built_in">parseInt</span>(res)<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(numRes)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-title function_">error</span>(op, <span class="hljs-string">`string &quot;<span class="hljs-subst">$&#123;res&#125;</span>&quot; cannot cast to number`</span>)<br>          &#125;<br>          <span class="hljs-keyword">return</span> numRes<br>        &#125;<br>        <span class="hljs-keyword">return</span> res<br>      &#125;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Impossible&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">const</span> &#123;op, left, right&#125; = expr<br>    <span class="hljs-keyword">const</span> l = <span class="hljs-title function_">go</span>(left)<br>    <span class="hljs-keyword">const</span> r = <span class="hljs-title function_">go</span>(right)<br>    <span class="hljs-keyword">if</span> (op.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;PLUS&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 如果任一操作数是字符串，使用字符串操作</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> l === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> r === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> l.<span class="hljs-title function_">toString</span>() + r.<span class="hljs-title function_">toString</span>()<br>      &#125;<br>      <span class="hljs-keyword">return</span> l + r<br>    &#125;<br>    <span class="hljs-keyword">if</span> (op.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;MINUS&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> l === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> r === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title function_">error</span>(op, <span class="hljs-string">&quot;Binary &#x27;-&#x27; cannot apply to string&quot;</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> l - r<br>    &#125;<br>    <span class="hljs-keyword">if</span> (op.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;STAR&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> l === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> r === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title function_">error</span>(op, <span class="hljs-string">&quot;Binary &#x27;*&#x27; cannot apply to string and string&quot;</span>)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> l === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> r === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> l * r<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> l === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> r.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">repeat</span>(l)<br>      &#125; <br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> r === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> l.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">repeat</span>(r)<br>      &#125; <br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;impossible&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (op.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;PERCENT&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> l === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> r === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title function_">error</span>(op, <span class="hljs-string">&quot;Binary &#x27;%&#x27; cannot apply to string&quot;</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> l % r<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (op.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;SLASH&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> l === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> r === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title function_">error</span>(op, <span class="hljs-string">&quot;Binary &#x27;/&#x27; cannot apply to string&quot;</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> l / r<br>    &#125;<br>    <span class="hljs-keyword">if</span> (op.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;STAR_STAR&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> l === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> r === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title function_">error</span>(op, <span class="hljs-string">&quot;Binary &#x27;**&#x27; cannot apply to string&quot;</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> l ** r<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;impossible&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">go</span>(expr)<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">return</span> e <span class="hljs-keyword">as</span> <span class="hljs-title class_">Error</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">&#x27;+(&quot;111&quot; + &quot;222&quot;) * 2 ** 3&#x27;</span><br><span class="hljs-keyword">const</span> tokens = <span class="hljs-title function_">readTokens</span>(code)<br><span class="hljs-keyword">const</span> expr = <span class="hljs-title function_">parse</span>(tokens)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">printAst</span>(expr)) <span class="hljs-comment">// (* (+ (+ &quot;111&quot; &quot;222&quot;)) (** 2 3))</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evaluate(expr)) <span class="hljs-comment">// 889776</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Crafting Interpreters》学习笔记 1——词法分析，递归下降法</title>
    <link href="/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95.html"/>
    <url>/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<p>最近感觉缺乏热情，找点新东西玩玩。编译原理是个好选择，之前半途而废了，这次能继续下去吗？</p><p>跟随 <a href="http://www.craftinginterpreters.com/contents.html">Crafting Interpreters</a> 这本书去学习，首先是用 java 实现一个 tree-walk interpreter，即生成 AST 之后直接进行解释执行。</p><hr><p>编译&#x2F;解释有诸多步骤，每一步都是为了让下一步实现起来更方便。第一步是 scanning，即词法分析，把源代码的字符串读入为 token，比如有一行代码 <code>var language = &quot;lox&quot;;</code>，词法分析的结果是<code>[var, language, =, &quot;lox&quot;, ;]</code>。一般来说空白字符会被忽略，但某些语言中缩进很重要，比如 Haskell 和 python，这些语言中的空格显然也会被当作 token。</p><p>token 是后续分析的“原子”，词法分析就是把源代码中的字符去进行分组得到 token 序列。要分组，就得有个分组的规则，称为词法 lexical grammar，这个规则需要预先定义，定义该规则，就是定义何为“词汇”，这里它叫词素 Lexeme，最小的意义单位。</p><p>词素仍然是普通的字符串，不带有语义，但可以根据词素和相关信息去获得对应的 token（这话怎么理解？一个词素可能是关键字，也可能是标识符，得看它出现的位置？像 SQL 这样的语言确实有类似的例子……但这事要在词法分析阶段处理吗？）。但为了方便，我们识别词素时就要知道它的类型——操作符，字面量，关键字，字面量。</p><p>词素更多是概念性的，在代码里没有直接表示它的结构。</p><h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><p>识别词素是 scanner 的工作，scanner 要知道哪个字符属于哪个词素。从源代码中第一个字符开始，scanner 检查每个字符，并识别和消费它以及和它处在同一个词素中的字符，到达词素结尾时，便丢出相应的 token。scanner 循环执行该过程，直到到达字符串结尾，生成一个 token 序列。</p><p><img src="/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/lexigator.png" alt="Alt text"></p><p>scanner 有两个必须的状态——start，标识正在扫描的词素的开始位置，current 表示正在处理的字符的位置，这里需要维护 start，是因为我们需要知道从 start 到 current 之间的子字符串的信息。如果有必要，current 可能会再倒回 start，重新开始处理。处理完一个词素后，start 再指向 current，即去处理下一个词素。</p><p>为了在出错时方便地指定行数，也可以增加一个 line 状态，去指示当前 current 的所在行。</p><p>下面的代码展示了 scanner 运行的基本流程：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Token&gt; <span class="hljs-title function_">readTokens</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 只要还没读到源代码结尾，反复读</span><br>    <span class="hljs-keyword">while</span> (!isAtEnd()) &#123;<br>        start = current; <span class="hljs-comment">// 重设 start 到下一个词素开头</span><br>        scanToken(); <span class="hljs-comment">// 维护 current，读一个 token</span><br>    &#125;<br>    addToken(EOF); <span class="hljs-comment">// 全部读完了就添加一个特殊的 token 标识结束，这样写 parser 更干净些</span><br>    <span class="hljs-keyword">return</span> tokens;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">scanToken</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// ... 不断维护 current，读一个 token，出错了就直接抛异常</span><br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> advance(); <span class="hljs-comment">// 获得下一个字符，并维护 current</span><br>    <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-comment">// ... 根据 c 的值，执行相应逻辑（但不递归）</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取 token 时，有三个方法用来帮助读取字符：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 无条件读取当前字符，并将 current 指向下一个字符</span><br><span class="hljs-type">char</span> <span class="hljs-title function_">advance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> source.charAt(current++);<br>&#125;<br><br><span class="hljs-comment">// match 就像一个带条件的 advance 方法，检查当前字符满足了条件才去进行消费</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(<span class="hljs-type">char</span> expected)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isAtEnd()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (source.charAt(current) != expected) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 匹配的逻辑，需要维护 current，并返回 true</span><br>    current++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 返回 current 指向字符，不维护 current</span><br><span class="hljs-type">char</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (isAtEnd()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> source.charAt(current);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>如果所有词素只有单个字符，如<code>()[]+-*/;</code>这些，读 token 时直接读到这单个字符便可直接构造 token——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scanToken</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> advance(); <span class="hljs-comment">// 获得下一个字符，并维护 current</span><br>    <span class="hljs-comment">// 在此时，c 是 current 的前一个位置的字符，同时也是 start 处的位置（只要后面 scanToken 没有递归调用，应该没有……）</span><br>    <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: addToken(LEFT_PAREN); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: addToken(RIGHT_PAREN); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>: addToken(LEFT_BRACE); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>: addToken(RIGHT_BRACE); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;,&#x27;</span>: addToken(COMMA); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;.&#x27;</span>: addToken(DOT); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: addToken(MINUS); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: addToken(PLUS); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;;&#x27;</span>: addToken(SEMICOLON); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: addToken(STAR); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>: <br>            Lox.error(line, <span class="hljs-string">&quot;Unexpected character.&quot;</span>); <span class="hljs-comment">// 这里只是打了个日志，然后忽略掉该字符继续去处理</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里没有包括<code>!&lt;&gt;=</code>，因为这些字符既可能是单字符的词素如<code>!</code>，也可能是双字符的词素如<code>!=</code>，但这个也好办，往后再看一位就行了：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scanToken</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> advance(); <span class="hljs-comment">// 获得 current 处的字符，并 current++</span><br>    <span class="hljs-comment">// 这时候 current 已经指向下一个需要处理的字符了</span><br>    <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-comment">// ... 单字符的 case</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;!&#x27;</span>:<br>            addToken(match(<span class="hljs-string">&#x27;=&#x27;</span>)? BANG_EQUAL : BANG);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;=&#x27;</span>:<br>            addToken(match(<span class="hljs-string">&#x27;=&#x27;</span>) ? EQUAL_EQUAL : EQUAL);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// ...&lt;=, &gt;=</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>除法<code>/</code>需要特别考虑，<code>//</code>是单行注释的语法，其后的东西将被忽略，直到遇到换行符。</p><p>所以遇到<code>/</code>时，要检查下一个字符是否也是<code>/</code>，如果真的是，反复移动 current，直到遇到换行符，保证 current 最终指向换行符。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>    <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>        addToken(SLASH);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (peek() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; !isAtEnd()) &#123;<br>        advance();<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></div></td></tr></table></figure><p>像 peek 这样检查当前字符但不把指针往后拨的操作称为“lookahead”，前向搜索。这里只是查询当前字符，称作前向搜索 1 个字符。语言的词法决定我们需要使用多少个字符的前向查找，字符数量越多性能越差，但很多语言的实现中只需要一两个字符的前向查找。</p><p>其实 match 也是前向搜索，它 peek 一下当前字符是否和需求匹配，匹配成功了才消费当前字符。</p><p>然后，是需要忽略的各种字符——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:<br>    line++;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27; &#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\r&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\t&#x27;</span>: <br>    <span class="hljs-keyword">break</span>;<br></code></pre></div></td></tr></table></figure><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><p>下一个对手是字符串字面量，即形如<code>&quot;Hello&quot;</code>的玩意。先不考虑字符串中出现双引号的情况。字符串相对好搞定，因为它的第一个字符永远是双引号。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&quot;&#x27;</span>: string(); <span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">string</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 该函数调用时，current 正指向字符串开始的&quot;的下一个字符，start 还在开始的&quot;上</span><br>    <span class="hljs-comment">// 找到另一个 &quot;</span><br>    <span class="hljs-keyword">while</span> (peek() != <span class="hljs-string">&#x27;&quot;&#x27;</span> &amp;&amp; !isAtEnd()) &#123;<br>        <span class="hljs-keyword">if</span> (peek() == <span class="hljs-string">&#x27;\n&#x27;</span>) line++; <span class="hljs-comment">// oh...</span><br>        advance();<br>    &#125;<br>    <span class="hljs-comment">// 到最后也没找着另一个&quot;</span><br>    <span class="hljs-keyword">if</span> (isAtEnd()) &#123;<br>        Lox.error(line, <span class="hljs-string">&quot;Unterminated string.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 此时，current 会指向字符串结尾的&quot;</span><br>    <span class="hljs-comment">// 要获得该字符串的实际代表的值，只需要获取&quot;&quot;之间的东西。</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">literal</span> <span class="hljs-operator">=</span> source.substring(start + <span class="hljs-number">1</span>, current);<span class="hljs-comment">// 前开后闭</span><br>    advance(); <span class="hljs-comment">// skip right &quot;，将 current 指向右双引号的下一个字符，这是因为 addToken 方法需要 start 和 current 的位置正确</span><br>    addToken(STRING, literal);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>字符串支持多行比只支持单行实现起来更方便，但这中间必须得插入维护 line 的逻辑……其实这个可以加到 advance 方法里。</p><h2 id="数字字面量"><a href="#数字字面量" class="headerlink" title="数字字面量"></a>数字字面量</h2><p>lox 中只有 double 来表示数字，和 js 一样，为了实现方便，不允许前导和后导小数点（方便实现<code>123.sqrt()</code>这样的调用）。</p><p>数字字面量的“trigger”也是容易找的——0-9，找后面连续的数字，若遇到小数点，需要检查小数点后一位是否也是数字。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">if</span> (isDigit(c)) &#123;<br>        number();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 原报错逻辑。..   </span><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">number</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 跳过中途所有数字</span><br>    <span class="hljs-keyword">while</span> (Character.isDigit(peek())) &#123;<br>        advance();<br>    &#125;<br><br>    <span class="hljs-comment">/// 如果遇到小数点，检查下一位是否还是数字，若是，继续</span><br>    <span class="hljs-keyword">if</span> (peek() == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; Character.isDigit(peekNext())) &#123;<br>        advance(); <span class="hljs-comment">// skip .</span><br>        <span class="hljs-keyword">while</span> (Character.isDigit(peek())) &#123;<br>            advance();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 此时 current 指向最后一个数字的下一个字符</span><br>    addToken(NUMBER, Double.parseDouble(source.substring(start, current)));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p>最后了，关键字以及标识符。匹配这玩意要满足最长匹配原则——如果当前看的玩意的部分同时满足两条词法，找最长的，比如有个<code>forever</code>，不能光看到这个<code>for</code>就认为它是关键字了，<code>forever</code>整个是合法的标识符，它比关键字更长。</p><p>实际上，关键字本身就是标识符，只是这些标识符被语言预先使用罢了，这也是为什么它们也叫保留字。检查标识符时，需检查它是否是保留字，这需要一个符号表去做映射。</p><p>读取标识符的逻辑也放在 default 里：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">if</span> (isDigit(c)) &#123;<br>        number();<br>        <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isAlpha(c)) &#123;<br>        identifier();<br>        <span class="hljs-keyword">break</span>;<br>    &#125; <br>    <span class="hljs-comment">// 原报错逻辑。..   </span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlpha</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-keyword">return</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) ||<br>            (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) ||<br>            c == <span class="hljs-string">&#x27;_&#x27;</span>;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlphaNumeric</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-keyword">return</span> isAlpha(c) || isDigit(c);<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">identifier</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 后面还是和 number 一样，读取直到非合法标识符字符</span><br>    <span class="hljs-keyword">while</span> (isAlphaNumeric(peek())) &#123;<br>        advance();<br>    &#125;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> source.substring(start, current);<br>    <span class="hljs-comment">// 再次注意，addToken 会获取 start 到 current 的字符串，不需要再自己传啥东西</span><br>    addToken(keywords.getOrDefault(value, IDENTIFIER));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">fun <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-comment">// this is a comment</span><br>    <span class="hljs-comment">/* multiple lines</span><br><span class="hljs-comment">       comment</span><br><span class="hljs-comment">    */</span><br>    fun <span class="hljs-title function_">go</span>(<span class="hljs-params">n, a, b</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">go</span>(n - <span class="hljs-number">1</span>, b, a + b)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">go</span>(n, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>得到：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">1:</span> [ <span class="hljs-attr">FUN :</span> <span class="hljs-string">fun</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">fib</span> ] [ <span class="hljs-attr">LEFT_PAREN :</span> <span class="hljs-string">(</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">n</span> ] [ <span class="hljs-attr">RIGHT_PAREN :</span> <span class="hljs-string">)</span> ] [ <span class="hljs-attr">LEFT_BRACE :</span> &#123; ]<br><span class="hljs-attr">6:</span> [ <span class="hljs-attr">FUN :</span> <span class="hljs-string">fun</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">go</span> ] [ <span class="hljs-attr">LEFT_PAREN :</span> <span class="hljs-string">(</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">n</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">a</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">b</span> ] [ <span class="hljs-attr">RIGHT_PAREN :</span> <span class="hljs-string">)</span> ] [ <span class="hljs-attr">LEFT_BRACE :</span> &#123; ]<br><span class="hljs-attr">7:</span> [ <span class="hljs-attr">IF :</span> <span class="hljs-string">if</span> ] [ <span class="hljs-attr">LEFT_PAREN :</span> <span class="hljs-string">(</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">n</span> ] [ <span class="hljs-attr">EQUAL_EQUAL :</span> <span class="hljs-string">==</span> ] [ <span class="hljs-attr">NUMBER :</span> <span class="hljs-number">0</span> ] [ <span class="hljs-attr">RIGHT_PAREN :</span> <span class="hljs-string">)</span> ] [ <span class="hljs-attr">LEFT_BRACE :</span> &#123; ]<br><span class="hljs-attr">8:</span> [ <span class="hljs-attr">RETURN :</span> <span class="hljs-string">return</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">a</span> ] [ <span class="hljs-attr">SEMICOLON :</span> <span class="hljs-string">;</span> ]<br><span class="hljs-attr">9:</span> [ <span class="hljs-attr">RIGHT_BRACE :</span> &#125; ]<br><span class="hljs-attr">10:</span> [ <span class="hljs-attr">RETURN :</span> <span class="hljs-string">return</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">go</span> ] [ <span class="hljs-attr">LEFT_PAREN :</span> <span class="hljs-string">(</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">n</span> ] [ <span class="hljs-attr">MINUS :</span> <span class="hljs-bullet">-</span> ] [ <span class="hljs-attr">NUMBER :</span> <span class="hljs-number">1</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">b</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">a</span> ] [ <span class="hljs-attr">PLUS :</span> <span class="hljs-string">+</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">b</span> ] [ <span class="hljs-attr">RIGHT_PAREN :</span> <span class="hljs-string">)</span> ]<br><span class="hljs-attr">11:</span> [ <span class="hljs-attr">RIGHT_BRACE :</span> &#125; ]<br><span class="hljs-attr">12:</span> [ <span class="hljs-attr">RETURN :</span> <span class="hljs-string">return</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">go</span> ] [ <span class="hljs-attr">LEFT_PAREN :</span> <span class="hljs-string">(</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">n</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">NUMBER :</span> <span class="hljs-number">0</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">NUMBER :</span> <span class="hljs-number">1</span> ] [ <span class="hljs-attr">RIGHT_PAREN :</span> <span class="hljs-string">)</span> ]<br><span class="hljs-attr">13:</span> [ <span class="hljs-attr">RIGHT_BRACE :</span> &#125; ]<br><span class="hljs-attr">14:</span> [ <span class="hljs-attr">EOF :</span>  ]<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些玩意实际上也可以用正则表达式处理，但为了学习起见，这里手写。使用正则表达式的话，维护 line 就有点不明显，估计需要每次匹配成功后都检查上次和这次匹配之间的子字符串中有多少个换行符。</p><p>这种功能和正则表达式相同的玩意称为正则语言 regular language，它有一定限制——不能记忆之前的匹配情况，因此不能处理嵌套。</p><h1 id="代码表示"><a href="#代码表示" class="headerlink" title="代码表示"></a>代码表示</h1><p>这节真 tm 抽象。记录一下 <a href="http://www.craftinginterpreters.com/representing-code.html#context-free-grammars">原文地址</a>。</p><h2 id="语法分析，BNF"><a href="#语法分析，BNF" class="headerlink" title="语法分析，BNF"></a>语法分析，BNF</h2><p>Token 相较于原始字符串乃至于词素已经是一个更丰富和抽象的概念了，但这还不够，需要根据 token 序列去得到一种更丰富和抽象的代码表示，parser 需要能够简单地生成它，interpreter 需要能够简单地使用它。这里的代码表示是树，就像 lisp 那样的玩意（但也有其他的代码表示，比如字节码）。</p><p>处理 token 序列时，再不能像词法分析一样使用类似正则语言的玩意来进行处理——需要考虑任意深度嵌套的情况，这是编程语言必须的。要能够做到这一点，需要一把新锤子——<strong>上下文无关文法 context-free grammar（CFG）</strong>，它是一种<strong>形式文法 formal grammar</strong>。 这里的上下文指的是分析特定符号&#x2F;规则时它的上下文，上下文无关也就是说文法的规则只取决于规则本身，和周围环境无关，听上去就很纯。</p><p><a href="https://www.zhihu.com/question/21833944/answer/40689967">应该如何理解「上下文无关文法」？ - 徐辰的回答 - 知乎</a></p><p>词法分析是词法 lexical grammar，这里是语法 syntactic grammar。词法处理的原子是字符，字符组合产生词素和 token，词法由 Scanner 实现；语法处理的原子是 Token，Token 组合产生表达式（并非语言上的表达式），语法由 Parser 实现。</p><p>语法由规则组成，规则也叫<strong>产生式</strong>——规则可以产生语法中合法的字串。一个规则分为两部分——head 和 body，分别表示规则的名称，以及该规则会产生什么（token 串的形式）。body 由终结符和非终结符组成，前者就像语法中的“字面量”，后者为其他规则——这让规则之间可以组合，直接进行代换即可。<strong>在上下文无关文法中，head 部分总是只有一个符号——该规则和周围的环境不相关</strong>。</p><p>多个规则可以引用同一个名称，表示该规则可以产生多种 token 串。规则的 body 中可以引用自己。</p><p>一种描述这些产生式的语言是 BNF，BNF 也有自己的语法，类似正则，但原子是整个符号而非字符。</p><figure class="highlight bnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BNF">breakfast  → protein &quot;with&quot; breakfast &quot;on the side&quot; ;<br>breakfast  → protein ;<br>breakfast  → bread ;<br><br>protein    → crispiness &quot;crispy&quot; &quot;bacon&quot; ;<br>protein    → &quot;sausage&quot; ;<br>protein    → cooked &quot;eggs&quot; ;<br><br>crispiness → &quot;really&quot; ;<br>crispiness → &quot;really&quot; crispiness ;<br><br>cooked     → &quot;scrambled&quot; ;<br>cooked     → &quot;poached&quot; ;<br>cooked     → &quot;fried&quot; ;<br><br>bread      → &quot;toast&quot; ;<br>bread      → &quot;biscuits&quot; ;<br>bread      → &quot;English muffin&quot; ;<br></code></pre></div></td></tr></table></figure><p>根据这些规则，我们能生成任意满足这些语法的符号串，注意下面的树形结构。</p><p><img src="/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/breakfast.png" alt="Alt text"></p><p>然后是 EBNF，支持括号，<code>|</code>，<code>*</code>，<code>+</code>，<code>?</code>，它们的语义和正则的相同：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">breakfast → protein ( <span class="hljs-string">&quot;with&quot;</span> breakfast <span class="hljs-string">&quot;on the side&quot;</span> )?<br>          <span class="hljs-string">| bread ;</span><br><br>protein   → <span class="hljs-string">&quot;really&quot;</span>+ <span class="hljs-string">&quot;crispy&quot;</span> <span class="hljs-string">&quot;bacon&quot;</span><br>          <span class="hljs-string">| &quot;</span>sausage<span class="hljs-string">&quot;</span><br>          <span class="hljs-string">| ( &quot;</span>scrambled<span class="hljs-string">&quot; | &quot;</span>poached<span class="hljs-string">&quot; | &quot;</span>fried<span class="hljs-string">&quot; ) &quot;</span>eggs<span class="hljs-string">&quot; ;</span><br><br>bread     → <span class="hljs-string">&quot;toast&quot;</span> <span class="hljs-string">| &quot;</span>biscuits<span class="hljs-string">&quot; | &quot;</span>English muffin<span class="hljs-string">&quot; ;</span><br></code></pre></div></td></tr></table></figure><p>不考虑早餐了（别面包，我是和食主义者。jpg），先考虑一下 lox 的一个更小的子集——纯字面的表达式，它由字面量，操作符和括号组成：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">expression     → literal<br>               <span class="hljs-string">| unary</span><br>               <span class="hljs-string">| binary</span><br>               <span class="hljs-string">| grouping ;</span><br><br>literal        → NUMBER <span class="hljs-string">| STRING | &quot;</span>true<span class="hljs-string">&quot; | &quot;</span>false<span class="hljs-string">&quot; | &quot;</span>nil<span class="hljs-string">&quot; ;</span><br>grouping       → <span class="hljs-string">&quot;(&quot;</span> expression <span class="hljs-string">&quot;)&quot;</span> ;<br>unary          → ( <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">| &quot;</span>!<span class="hljs-string">&quot; ) expression ;</span><br>binary         → expression operator expression ;<br>operator       → <span class="hljs-string">&quot;==&quot;</span> <span class="hljs-string">| &quot;</span>!=<span class="hljs-string">&quot; | &quot;</span>&lt;<span class="hljs-string">&quot; | &quot;</span>&lt;=<span class="hljs-string">&quot; | &quot;</span>&gt;<span class="hljs-string">&quot; | &quot;</span>&gt;=<span class="hljs-string">&quot;</span><br>               <span class="hljs-string">| &quot;</span>+<span class="hljs-string">&quot;  | &quot;</span>-<span class="hljs-string">&quot;  | &quot;</span>*<span class="hljs-string">&quot; | &quot;</span>/<span class="hljs-string">&quot; ;</span><br></code></pre></div></td></tr></table></figure><p>其中，NUMBER 和 STRING 被大写，大写表示是终结符而且符合条件的“字面量”太多以至于写不下来。</p><h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><p>根据这些产生式，可以编写相应的 java 类型去反映相关结构。这显然是一种树形结构（emm 可以说父子关系为“包括”？），因此叫语法树 Syntax Tree。语法树和抽象语法树 AST 有一定区别——前者包含产生式中任意的 token，即使它们是不必要的，比如 python 的三目 <code>ifexpr → expr &quot;if&quot; expr &quot;else&quot; expr</code>，语法树中就会包含这里的<code>&quot;if&quot;</code>和<code>&quot;else&quot;</code>，抽象语法树中就可以丢掉它。</p><p>这里当然可以使用一个普通的多叉树来表示语法树，但这里可以把 java 的类型系统利用一下——定义一个抽象父类 Expr 表示任何表达式，为字面量，操作符等都定义相应子类。</p><p>子类需要包含所有它需要包含的东西——对字面量，包含它的实际的值，对二元运算，包含它的操作符和左右的表达式。它或许会长这样：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Literal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Expr</span> &#123;<br>        <span class="hljs-keyword">final</span> Object value;<br>    &#125;<br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Binary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Expr</span> &#123;<br>        <span class="hljs-keyword">final</span> Expr left;<br>        <span class="hljs-keyword">final</span> Token operator;<br>        <span class="hljs-keyword">final</span> Expr right;<br>    &#125;<br>    <span class="hljs-comment">// Other expressions...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用父子类来表达的话，就需要就需要在运行时获取特定节点的类型信息（不然怎么知道它有啥字段？），这可以使用 instanceof，但至少在 java8 里这玩意不安全，毕竟没有 sealed。然后不使用 instanceof 的话，给特定子类添加特定方法就需要影响所有子类。这里可以用访问者模式，其实本质就是扩展方法和模式匹配。</p><h2 id="生成语法树定义"><a href="#生成语法树定义" class="headerlink" title="生成语法树定义"></a>生成语法树定义</h2><p>这里写个脚本去手动生成相关代码，它接受一个父类名，以及每个子类名和它包含的字段，因为懒得拷贝，所以手写，用 ruby：</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-comment"># 在该路径下生成该类 java 文件</span><br><span class="hljs-variable constant_">LOX_SOURCE_PATH</span> = <span class="hljs-string">&#x27;C:\Users\Administrator\Desktop\CODES\lox\src\main\java\me\yki\lox&#x27;</span><br><span class="hljs-variable constant_">PACKAGE</span> = <span class="hljs-string">&#x27;me.yki.lox&#x27;</span><br><span class="hljs-variable constant_">PARENT_CLASS_NAME</span> = <span class="hljs-string">&#x27;Expr&#x27;</span><br><br><span class="hljs-comment"># 编辑这里去添加子类定义</span><br><span class="hljs-variable constant_">SUBCLASS_DEFS</span> = <span class="hljs-string">%/</span><br><span class="hljs-string">  Binary   : Expr left, Token operator, Expr right</span><br><span class="hljs-string">  Grouping : Expr expression</span><br><span class="hljs-string">  Literal  : Object value</span><br><span class="hljs-string">  Unary    : Token operator, Expr right</span><br><span class="hljs-string">/</span>.strip<br> .split(<span class="hljs-string">&quot;\n&quot;</span>)<br> .map &#123;_1.strip &#125;<br> .filter &#123; <span class="hljs-keyword">not</span> _1.empty? &#125;<br> .map &#123; |<span class="hljs-params">class_def</span>|<br>   class_def.split(<span class="hljs-string">&#x27;:&#x27;</span>) =&gt; [class_name, body]<br>   class_name.strip!<br>   fields = body.strip.split(<span class="hljs-string">&#x27;,&#x27;</span>).map&#123;_1.strip.split <span class="hljs-string">&#x27; &#x27;</span>&#125;<br>   [class_name, fields]<br> &#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">indent</span>(<span class="hljs-params">space, str</span>)<br>  str.split(<span class="hljs-string">&quot;\n&quot;</span>).map&#123;<span class="hljs-string">&#x27; &#x27;</span> * space + _1&#125;.join(<span class="hljs-string">&quot;\n&quot;</span>).strip<br><span class="hljs-keyword">end</span><br><br>res =  <span class="hljs-string">&lt;&lt;~EOF</span><br><span class="hljs-string">  package <span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PACKAGE</span>&#125;</span>;</span><br><span class="hljs-string">  import lombok.Data;</span><br><span class="hljs-string">  public abstract class <span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span> &#123;</span><br><span class="hljs-string">      public interface <span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span>Visitor&lt;T&gt; &#123;</span><br><span class="hljs-string">          <span class="hljs-subst">#&#123;<span class="hljs-variable constant_">SUBCLASS_DEFS</span>.map&#123; <span class="hljs-string">&quot;T visit(<span class="hljs-subst">#&#123;_1[<span class="hljs-number">0</span>]&#125;</span> expr);&quot;</span> &#125;</span>.join(&quot;\n&quot;).then&#123;indent 8, _1&#125;&#125;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">      public abstract &lt;T&gt; T accept(<span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span>Visitor&lt;T&gt; visitor);</span><br><span class="hljs-string">      <span class="hljs-subst">#&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-variable constant_">SUBCLASS_DEFS</span>.map <span class="hljs-keyword">do</span> |<span class="hljs-params">field_defs</span>|</span></span><br><span class="hljs-subst"><span class="hljs-string">          subclass, fields = field_defs</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">&lt;&lt;~SUBEOF</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            @Data</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            public static class <span class="hljs-subst">#&#123;subclass&#125;</span> extends <span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span> &#123;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">                <span class="hljs-subst">#&#123;fields.map &#123;<span class="hljs-string">&quot;final <span class="hljs-subst">#&#123;_1[<span class="hljs-number">0</span>]&#125;</span> <span class="hljs-subst">#&#123;_1[<span class="hljs-number">1</span>]&#125;</span>;&quot;</span>&#125;</span>.join(&quot;\n&quot;).then&#123;indent 4, _1&#125;&#125;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">                @Override</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">                public &lt;T&gt; T accept(<span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span>Visitor&lt;T&gt; visitor) &#123;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">                    return visitor.visit(this);</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">                &#125;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            &#125;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">          SUBEOF</span></span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-keyword">end</span>.join(<span class="hljs-string">&quot;\n&quot;</span>).<span class="hljs-keyword">then</span>&#123;indent <span class="hljs-number">4</span>, _1&#125;</span></span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">      </span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">EOF</span><br><span class="hljs-string">Dir.chdir LOX_SOURCE_PATH</span><br><span class="hljs-string">File.write(&quot;<span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span>.java&quot;, res)</span><br></code></pre></div></td></tr></table></figure><p>最后，关于第一道题目，得到这样的结果：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">arglist</span> -&gt;</span>  expr <br><span class="hljs-function"><span class="hljs-title">arglist</span> -&gt;</span>  expr <span class="hljs-string">&quot;,&quot;</span> arglist<br><span class="hljs-function"><span class="hljs-title">expr</span> -&gt;</span> expr <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-string">&quot;)&quot;</span><br><span class="hljs-function"><span class="hljs-title">expr</span> -&gt;</span> expr <span class="hljs-string">&quot;(&quot;</span> arglist <span class="hljs-string">&quot;)&quot;</span><br><span class="hljs-function"><span class="hljs-title">expr</span> -&gt;</span> expr <span class="hljs-string">&quot;.&quot;</span> IDENTIFIER <br>expr → IDENTIFIER<br>expr → NUMBER<br></code></pre></div></td></tr></table></figure><p>看上去是某种函数调用或者取字段的语法，且支持数字作为对象。</p><h1 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h1><p>Parser 的任务即是解析表达式（token 序列）到 AST。上面，我们根据语法和 AST 去生成表达式， 现在要根据语法和表达式去生成 AST。前者是造句，后者是理解句子，后者才是真正的重头戏，事情真正变得不 trival 的地方。<strong>我们需要把所有 toekn 映射到终结符，然后找到是哪些规则生成了这些 token</strong>。</p><p>不 trival 的原因在于，答案并不唯一——同一套语法，能通过多种方式（AST）生成同一个 token 序列；同一个 token 序列，能解析成多个 AST。</p><p>考虑一套四则运算的 BNF，不考虑括号：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl">E<span class="hljs-function"><span class="hljs-title">xpr</span> -&gt;</span> NUMBER<br>E<span class="hljs-function"><span class="hljs-title">xpr</span> -&gt;</span> NUMBER op Expr<br><span class="hljs-function"><span class="hljs-title">op</span> -&gt;</span> <span class="hljs-string">&quot;+&quot;</span> | <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;/&quot;</span><br></code></pre></div></td></tr></table></figure><p>这里第二条更符合直觉的写法是<code>Expr -&gt; Expr op Expr</code>，但这是一种“左递归”，在<strong>生成式规则中要避免左递归</strong>，想象在递归函数的第一行就调用自己。</p><p>考虑<code>1 - 2 * 3</code>，生成它有两种方式——先生成<code>*</code>部分，再生成<code>-</code>部分，或者反之；因此解析它也有两种方式——先解析<code>Expr * 3</code>，再解析<code>1 - 2</code>，或者是先解析<code>1 - Expr</code>，再解析<code>2 * 3</code>：</p><p><img src="/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/image.png" alt="Alt text"></p><p><img src="/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/image-1.png" alt="Alt text"></p><p>这决定了后续解释该 AST 时的计算顺序——前者会先执行 <code>1 - 2</code>，后者会先执行 <code>2 * 3</code>。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>这里需要定义结合性和优先级（其实就是打括号），结合这俩才能唯一地确定要生成怎样的 AST。</p><p>如何在 BNF 中体现结合性和优先级呢？重点是，必须要对 Expr 做出限制，不能让加减乘除直接全落到同一个的 Expr 上去，这丢失了它的优先级的信息。对于高优先级的运算符，必须让它不被低优先级运算符对应的规则去抓到。</p><p>对于优先级，简单的解决方案是为每个优先级的运算符创建自己的生成式，<strong>低优先级的运算符总是依赖高优先级的运算符，这保证生成时必须先生成高优先级的 AST，再生成低优先级的 AST，保证低优先级的运算符在 AST 中总是更靠近根部，而高优先级的运算符总是低优先级的运算符的子树</strong>，比如依此下面定义新的四则运算的规则，咱知道，加减的优先级低于乘除，乘除又低于括号。加减的两边称为项 Term，乘除的两边称为因子 Factor，在这里可以理解为“加减法表达式”和“乘除法表达式”：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl">E<span class="hljs-function"><span class="hljs-title">xpr</span> -&gt;</span> Term<br>T<span class="hljs-function"><span class="hljs-title">erm</span> -&gt;</span> Factor (( <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;+&quot;</span> ) Factor)*<br>F<span class="hljs-function"><span class="hljs-title">actor</span> -&gt;</span> Primary (( <span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;/&quot;</span> ) Primary)*<br>P<span class="hljs-function"><span class="hljs-title">rimary</span> -&gt;</span> NUMBER | <span class="hljs-string">&quot;(&quot;</span> Expr <span class="hljs-string">&quot;)&quot;</span><br></code></pre></div></td></tr></table></figure><p>回到上面的 Lox 的 BNF：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">expression     → literal<br>               <span class="hljs-string">| unary</span><br>               <span class="hljs-string">| binary</span><br>               <span class="hljs-string">| grouping ;</span><br><br>literal        → NUMBER <span class="hljs-string">| STRING | &quot;</span>true<span class="hljs-string">&quot; | &quot;</span>false<span class="hljs-string">&quot; | &quot;</span>nil<span class="hljs-string">&quot; ;</span><br>grouping       → <span class="hljs-string">&quot;(&quot;</span> expression <span class="hljs-string">&quot;)&quot;</span> ;<br>unary          → ( <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">| &quot;</span>!<span class="hljs-string">&quot; ) expression ;</span><br>binary         → expression operator expression ;<br>operator       → <span class="hljs-string">&quot;==&quot;</span> <span class="hljs-string">| &quot;</span>!=<span class="hljs-string">&quot; | &quot;</span>&lt;<span class="hljs-string">&quot; | &quot;</span>&lt;=<span class="hljs-string">&quot; | &quot;</span>&gt;<span class="hljs-string">&quot; | &quot;</span>&gt;=<span class="hljs-string">&quot;</span><br>               <span class="hljs-string">| &quot;</span>+<span class="hljs-string">&quot;  | &quot;</span>-<span class="hljs-string">&quot;  | &quot;</span>*<span class="hljs-string">&quot; | &quot;</span>/<span class="hljs-string">&quot; ;</span><br></code></pre></div></td></tr></table></figure><p>关于优先级和结合性，在 c 和 lox 中有这样的规则，越上面优先级越低：</p><table><thead><tr><th align="center">Name</th><th align="center">Operators</th><th align="center">Associates</th></tr></thead><tbody><tr><td align="center">Equality</td><td align="center"><code>==</code> <code>!=</code></td><td align="center">Left</td></tr><tr><td align="center">Comparison</td><td align="center"><code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></td><td align="center">Left</td></tr><tr><td align="center">Term</td><td align="center"><code>-</code> <code>+</code></td><td align="center">Left</td></tr><tr><td align="center">Factor</td><td align="center"><code>/</code> <code>*</code></td><td align="center">Left</td></tr><tr><td align="center">Unary</td><td align="center"><code>!</code> <code>-</code></td><td align="center">Right</td></tr></tbody></table><p>对其中的每一个优先级，都需要一个对应规则，它被更低优先级的规则去引用，同时引用更高优先级的规则。</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">expression</span> -&gt;</span> equality<br><span class="hljs-function"><span class="hljs-title">equality</span>   -&gt;</span> comparison ((<span class="hljs-string">&quot;==&quot;</span> | <span class="hljs-string">&quot;!=&quot;</span>) comparsion)*<br><span class="hljs-function"><span class="hljs-title">comparsion</span> -&gt;</span> term ((<span class="hljs-string">&quot;&gt;&quot;</span> | <span class="hljs-string">&quot;&gt;=&quot;</span> | <span class="hljs-string">&quot;&lt;&quot;</span> | <span class="hljs-string">&quot;&lt;=&quot;</span>) term)*<br><span class="hljs-function"><span class="hljs-title">term</span>       -&gt;</span> factor ((<span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;+&quot;</span>) factor)*<br><span class="hljs-function"><span class="hljs-title">factor</span>     -&gt;</span> unary ((<span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;/&quot;</span>) unary)*<br><span class="hljs-function"><span class="hljs-title">unary</span>      -&gt;</span> (<span class="hljs-string">&quot;!&quot;</span> | <span class="hljs-string">&quot;-&quot;</span>) unary | primary<br><span class="hljs-function"><span class="hljs-title">primary</span>    -&gt;</span> NUMBER | STRING | <span class="hljs-string">&quot;true&quot;</span> | <span class="hljs-string">&quot;false&quot;</span> | <span class="hljs-string">&quot;nil&quot;</span> <br>            | <span class="hljs-string">&quot;(&quot;</span> expression <span class="hljs-string">&quot;)&quot;</span> <br></code></pre></div></td></tr></table></figure><p>遗憾的是，单凭 BNF 似乎不允许控制结合性（不允许左递归的话）。这得留到 Parser 中去处理了。</p><h2 id="递归下降法"><a href="#递归下降法" class="headerlink" title="递归下降法"></a>递归下降法</h2><p>该开始整 parser 了。使用实现起来最简单但仍然强大的方式——递归下降法。递归下降法是一种<strong>自顶向下</strong>的解析器——它从最顶部的规则开始，在这里是 expression，然后再处理它的嵌套的子表达式，直到到达 AST 的叶子。与此相反的还有<strong>自底向上</strong>的解析器，从 primary 的表达式开始，组合成更复杂的形式。</p><p>递归下降法很容易根据语法规则直接映射到对应的命令式的代码：</p><table><thead><tr><th align="center">Grammar notation</th><th align="left">Code representation</th></tr></thead><tbody><tr><td align="center">rule</td><td align="left">函数，处理当前和接下来的几个 token，返回 AST（节点）</td></tr><tr><td align="center">Terminal</td><td align="left">匹配和消费 token 的代码</td></tr><tr><td align="center">Nonterminal</td><td align="left">调用相应 rule</td></tr><tr><td align="center">|</td><td align="left">多路条件语句</td></tr><tr><td align="center">* or +</td><td align="left">循环语句</td></tr><tr><td align="center">?</td><td align="left">无 else，提前返回的条件语句</td></tr></tbody></table><p>递归下降——这些规则对应的函数会反复递归调用自身和其他规则函数。</p><h2 id="Parser-的实现"><a href="#Parser-的实现" class="headerlink" title="Parser 的实现"></a>Parser 的实现</h2><p>如何理解递归下降法的解析过程——贪婪。</p><p>Scanner 需要维护两个状态——start 和 current，表示当前处理的词素和字符的下标。而 Parser，好家伙，只需要一个，current，表示下一个需要处理的 Token。</p><p>同样的，Parser 需要一些获取当前&#x2F;前后 token 同时维护 current 的方法，其中 peek 和 match 均前向搜索 1 步：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> tokens.get(current);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAtEnd</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> peek().type == EOF;<br>&#125;<br><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">previous</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> tokens.get(current - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">advance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isAtEnd()) current++;<br>    <span class="hljs-keyword">return</span> tokens.get(current);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TokenType type)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isAtEnd()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> peek().type == type;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(TokenType... types)</span> &#123;<br>    <span class="hljs-keyword">for</span> (TokenType type : types) &#123;<br>        <span class="hljs-keyword">if</span> (check(type)) &#123;<br>            advance();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这些方法已经足够了，先整出 equality：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">expr</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> equality();<br>&#125;<br><br><span class="hljs-comment">//equlity -&gt; comparsion ((&quot;!=&quot; | &quot;==&quot;) comparsion)*</span><br><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">equality</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Expr</span> <span class="hljs-variable">expr</span> <span class="hljs-operator">=</span> comparison();<br>    <span class="hljs-comment">// 如果看到了！=和==，就继续给它延伸下去</span><br>    <span class="hljs-keyword">while</span> (match(BANG_EQUAL, EQUAL_EQUAL)) &#123;<br>        <span class="hljs-type">Token</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> previous(); <span class="hljs-comment">// 获取在 while 里匹配的玩意</span><br>        <span class="hljs-type">Expr</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> comparison();<br>        <span class="hljs-comment">// 这一段则是自由发挥，容易发现当前子树会变成新的子树的左子树——左结合</span><br>        <span class="hljs-comment">// 如果新的子树为当前子树的右子树，则这就是个右结合</span><br>        expr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Binary(expr, operator, right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> expr;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>贪婪，如果没看到<code>!=</code>或<code>==</code>，就已经到头了，但若是看到了，就做相应处理并继续找<code>!=</code>和<code>==</code>。</p><p><img src="/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/sequence.png" alt="Alt text"></p><p>容易看到，这里这样处理的话会得到一个左结合——这棵树正常画的话，会逐渐往右上角生长。如果要右结合……好像就不是那么 trival 了，有点像右折叠，需要借助递归或栈来做操作。</p><p>然后，后面的也是一样的实现法，直到一元操作符和 primary 有些不同，但仍然是平铺直叙的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// unary      -&gt; (&quot;!&quot; | &quot;-&quot;) unary | primary</span><br><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">unary</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (match(BANG, MINUS)) &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> previous();<br>        <span class="hljs-type">val</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> unary();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Unary(operator, value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> primary();<br>&#125;<br><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">primary</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> advance();<br>    <span class="hljs-keyword">if</span> (match(FALSE)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Literal(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (match(TRUE)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Literal(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (match(NIL)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Literal(<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">if</span> (match(NUMBER, STRING)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Literal(previous().literal);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (match(LEFT_PAREN)) &#123;<br>        <span class="hljs-type">Expr</span> <span class="hljs-variable">expr</span> <span class="hljs-operator">=</span> expression();<br>        <span class="hljs-comment">// 断言和消费 token</span><br>        consume(RIGHT_PAREN, <span class="hljs-string">&quot;Expect &#x27;)&#x27; after expression.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Grouping(expr);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>问题来了，primary 如果到最后也没有 return，该怎么办？</p><p>到最后也没有 return，这证明是出现了<strong>语法错误 syntax error</strong>，这里可以简单抛个异常了事，然后让用户看着 token 里指示的位置干瞪眼，但也可以做更多。但无论如何，到这一步，能用的 parser 已经完成了，只不过不够人性化。</p><p>不知道有啥更好的理解方式没有对递归下降的这一套…其实还蛮简单的，但不知道该怎么对它的行为建模。</p><h2 id="错误回复"><a href="#错误回复" class="headerlink" title="错误回复"></a>错误回复</h2><p>对 Parser 来说，其实检查不合法的 token 序列中的错误也是一个重要的工作。在生产中，parser 总是会遇上代码不完全，包含错误的情况——比如 IDE 的代码高亮和补全，在用户编辑代码时会不断地解析代码。Parser 应当正确处理错误，提供丰富的错误类型，避免级联错误，提供可能的解决方案，同时避免自己直接罢工、崩溃或无限循环，也就是说，从错误中恢复过来。</p><p>一个经受住实践考验的错误回复技术称为 <strong>panic mode</strong>，当 parser 检测到错误时，它进入到 panic mode，知道在当前，语法产生式的堆栈的某个中间部分中，至少一个 token 在当前状态中是不相符的。<strong>Parser 需要调整当前状态以及接下来的 token 序列，保证下一个记号符合当前正在解析的规则，这称为 synchronization</strong>。</p><p>需要选定特定规则作为<strong>同步点 synchronization point</strong>，在 panic mode 下，parser 跳出任意嵌套的产生式直到回到同步点以调整当前状态（调用栈），然后持续丢掉 token 直到遇上下一个合法的 token，中间这些被丢掉的 token 虽然无法报告它们的语法错误，但也避免了级联错误。可以想象，很多语言会以语句或块等来作为同步点。</p><p>如何跳出任意嵌套的产生式？该利用上高级语言的另一项特性——异常了。这里实现一个 consume 方法来报告错误并进行同步。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">consume</span><span class="hljs-params">(TokenType type, String message)</span> &#123;<br>    <span class="hljs-keyword">if</span> (check(type)) <span class="hljs-keyword">return</span> advance();<br>    <span class="hljs-keyword">throw</span> error(peek(), message);<br>&#125;<br><span class="hljs-keyword">private</span> ParseError <span class="hljs-title function_">error</span><span class="hljs-params">(Token token, String message)</span> &#123;<br>    Lox.error(token, message); <span class="hljs-comment">// 设置 hasError 标志，打印日志</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParseError</span>();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParseError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;&#125;<br></code></pre></div></td></tr></table></figure><p>这个 error 函数没有直接抛，这是考虑到有时候遇到了错误也仍需要继续处理，只是把错误报告一下，比如在 lox 中有限制函数参数的个数，如果传的太多但又符合语法，就报错但仍旧继续处理。又比如在 java 语言里写一个超过 int 最大值的字面量又没加 L，这种情况也是可以继续处理的。</p><p>然后关于丢掉 token，该如何丢呢？<strong>我们希望丢掉 token 直到下一个语句开始</strong>。同时也注意到，很多语句以关键字起始，for，class，var 等，丢掉直到遇到这些关键字也是好的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronize</span><span class="hljs-params">()</span> &#123;<br>    advance(); <span class="hljs-comment">// 不合法的 token，先直接丢掉</span><br><br>    <span class="hljs-keyword">while</span> (!isAtEnd()) &#123;<br>        <span class="hljs-keyword">if</span> (previous().type == SEMICOLON) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果上一个 token 是 semicolon，这就是下一条语句的开始</span><br><br>        <span class="hljs-keyword">switch</span> (peek().type) &#123;<br>            <span class="hljs-comment">// 如果当前是这些关键字，不用再丢了</span><br>            <span class="hljs-keyword">case</span> CLASS: <span class="hljs-keyword">case</span> FUN: <span class="hljs-keyword">case</span> VAR: <span class="hljs-keyword">case</span> FOR: <br>            <span class="hljs-keyword">case</span> IF: <span class="hljs-keyword">case</span> WHILE: <span class="hljs-keyword">case</span> PRINT: <span class="hljs-keyword">case</span> RETURN:<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        advance();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但这个方法后续再用，先让 parser 出现异常时直接无视即可。</p><h2 id="关于三目运算符"><a href="#关于三目运算符" class="headerlink" title="关于三目运算符"></a>关于三目运算符</h2><p>题目里有要求实现三目运算符的解析，这个比较有意思。</p><p>咱知道，三目可以模拟 if-elseif-else：</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">co<span class="hljs-symbol">nd1</span> ? <br>    co<span class="hljs-symbol">nd4</span> ? a : b:<br>    co<span class="hljs-symbol">nd2</span> ?<br>        c:<br>        co<span class="hljs-symbol">nd3</span> ?<br>            d:<br>            e<br><br><span class="hljs-attr"># 等价于</span><br><span class="hljs-attr">if (cond1</span>) &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-comment">(cond4)</span> &#123;<br>        a<br>    &#125; else &#123;<br>        b<br>    &#125;<br>&#125; else <span class="hljs-keyword">if</span> <span class="hljs-comment">(cond2)</span> &#123;<br>    b<br>&#125; else <span class="hljs-keyword">if</span> <span class="hljs-comment">(cond3)</span> &#123;<br>    c<br>&#125; else &#123;<br>    d<br>&#125;<br></code></pre></div></td></tr></table></figure><p>容易发现，三目是右结合的，这倒是第一次处理右结合，但其实描述右结合是很容易的——只消在body里把引用下一个优先级的规则修改为引用自身就行了。</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">ternary -&gt; <span class="hljs-built_in">equality</span> (<span class="hljs-string">&quot;?&quot;</span> ternary <span class="hljs-string">&quot;:&quot;</span> ternary)?<br></code></pre></div></td></tr></table></figure><p>实现其实很显然，显然到我有点没明白为啥会这么显然…需要新增加问号和冒号这两种 token。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">ternary</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">cond</span> <span class="hljs-operator">=</span> equality();<br>    <span class="hljs-keyword">if</span> (match(QUESTION)) &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> previous();<br>        <span class="hljs-type">val</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> ternary();<br>        consume(COLON, <span class="hljs-string">&quot;expect &#x27;:&#x27;.&quot;</span>);<br>        <span class="hljs-type">val</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> ternary();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Ternary(op, cond, left, right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cond;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用环境搭建</title>
    <link href="/%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <url>/%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    
    <content type="html"><![CDATA[<p>决定记录一下搭建和配置各种常用<strong>编程环境</strong>，包括 maven，jdk，node 等，和<strong>软件环境</strong>，包括 mysql，redis，kafka 等的过程以方便在将来进行参考和查阅，能使用 docker 则使用 docker。该文档将持续维护。</p><p>需注意：该文档目的是为了之后搭建本地开发环境时能更加方便，不需要反复去查阅文档和博客，并非为了生产目的，因此（对一些中间件）不考虑安全性等问题。</p><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><h2 id="关于解压"><a href="#关于解压" class="headerlink" title="关于解压"></a>关于解压</h2><p>*nix 系统使用命令行进行解压，因此有一些必要去介绍一下使用。</p><p>对于 tar.xz 和 tar.gz，使用 tar 命令，模版如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">tar xvf <span class="hljs-selector-attr">[要解压的文件名]</span> <span class="hljs-attr">--directory</span>=<span class="hljs-selector-attr">[要解压到的文件夹]</span><br></code></pre></div></td></tr></table></figure><p>比如，解压当前目录的一个压缩文件到当前目录的 test 文件夹（该文件夹需提前创建）：</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">tar xvf <span class="hljs-keyword">node</span><span class="hljs-title">-v14</span>.<span class="hljs-number">19.2</span>-linux-arm64.tar.gz --<span class="hljs-attr">directory=</span>./test<br></code></pre></div></td></tr></table></figure><blockquote><p>tar.gz其实上是2个工具。tar是打包工具，把很多文件打包成一个文件，gz是压缩格式。</p></blockquote><p>对于 zip，使用 unzip 命令，模板如下：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">unzip <span class="hljs-selector-attr">[要解压的文件]</span> -d <span class="hljs-selector-attr">[要解压到的文件夹]</span><br></code></pre></div></td></tr></table></figure><p>示例如下，要解压的文件夹不需要提前创建：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">unzip</span> ttf-iosevka-curly-slab-<span class="hljs-number">15</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.zip -d some_dir <br></code></pre></div></td></tr></table></figure><h2 id="docker-run-的使用示例"><a href="#docker-run-的使用示例" class="headerlink" title="docker run 的使用示例"></a>docker run 的使用示例</h2><p>拷贝自<code>tldr docker-run</code>命令。</p><p>docker run</p><p>Run a command in a new Docker container.<br>More information: <a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a>.</p><ul><li><p>Run command in a new container from a tagged image:<br><code>docker run image:tag command</code></p></li><li><p>Run command in a new container in background and display its ID:<br><code>docker run -d image command</code></p></li><li><p>Run command in a one-off container in interactive mode and pseudo-TTY:<br><code>docker run --rm -it image command</code></p></li><li><p>Run command in a new container with passed environment variables:<br><code>docker run -e &#39;variable=value&#39; -e variable image command</code></p></li><li><p>Run command in a new container with bind mounted volumes:<br><code>docker run -v /path/to/host_path:/path/to/container_path image command</code></p></li><li><p>Run command in a new container with published ports:<br><code>docker run -p host_port:container_port image command</code></p></li><li><p>Run command in a new container overwriting the entrypoint of the image:<br><code>docker run --entrypoint command image</code></p></li><li><p>Run command in a new container connecting it to a network:<br><code>docker run --network network image</code></p></li></ul><h1 id="编程环境"><a href="#编程环境" class="headerlink" title="编程环境"></a>编程环境</h1><p>对于编程环境，尽量从国内镜像站去下载以保证速度。</p><blockquote><p>小 tip: Windows 系统可以按 win 键，输入“env”或“path”并回车，能直接打开“编辑系统环境变量”窗口</p></blockquote><h2 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/Adoptium/8/jdk/">在这里</a> 下载对应架构和系统的 JDK 的压缩包并解压到特定位置，将其 <code>bin</code> 和 <code>jre\bin</code> 目录加入 PATH，并添加变量 JAVA_HOME，以其目录作为值即可。</p><p>比如，将该压缩包解压至<code>E:\env</code>，此时目录结构为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">E:\env\<span class="hljs-keyword">jdk8u332-b09</span><br><span class="hljs-keyword"></span>  ├─<span class="hljs-keyword">bin</span><br><span class="hljs-keyword"></span>  ├─include<br>  ├─<span class="hljs-keyword">jre</span><br><span class="hljs-keyword"></span>  ├─lib<br>  └─sample<br></code></pre></div></td></tr></table></figure><p>此时，在 PATH 中添加：</p><figure class="highlight moonscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs moonscript"><span class="hljs-name">E</span>:\env\jdk8u332-b09\bin<br><span class="hljs-name">E</span>:\env\jdk8u332-b09\jre\bin<br></code></pre></div></td></tr></table></figure><p>添加 JAVA_HOME 变量，值为：<code>E:\env\jdk8u332-b09</code>。</p><blockquote><p>虽然很多资料说 JAVA_HOME 已经不需要设置了，但事实证明很多环境，如 maven 的一些插件，hadoop 等都是依赖这个变量的，仍旧有必要进行配置。</p></blockquote><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>TODO</p><h3 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h3><p>TODO</p><h2 id="Sbt"><a href="#Sbt" class="headerlink" title="Sbt"></a>Sbt</h2><p>TODO</p><h3 id="修改镜像源-1"><a href="#修改镜像源-1" class="headerlink" title="修改镜像源"></a>修改镜像源</h3><p>TODO</p><h1 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h1><p>mysql，redis 等环境虽然也能够直接安装环境，但其总是比较麻烦的，且 win 下可能会出现更多问题，为此使用 docker 减轻负担是非常合适的。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a><a href="https://hub.docker.com/_/mysql">MySQL</a></h2><ul><li><p>创建 MySQL 8 容器，其 hostname 为 some-mysql，使用 root 账户作为用户，密码为 root，启动时创建 database db：<br><code>docker run --name some-mysql --hostname some-mysql -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=db -d mysql:8</code></p></li><li><p>在命令行下连接到 mysql 8 服务器，其 host 为 some-mysql，使用 root 用户（好像需要在同一个 network 下，且 bridge 不行）：<br><code>docker run --rm -it mysql:8 mysql -hsome-mysql -uroot -proot</code></p></li><li><p>使用自定义的 mysql 配置文件：<br><code>docker run --name some-mysql -v /my/custom:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:8</code></p></li><li><p>使用命令行的方式进行配置：<br><code>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</code></p></li><li><p>启动时执行特定 sql 文件：<br><code>docker run --name some-mysql -v /my/custom/sql/dir:/docker-entrypoint-initdb.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:8</code></p></li></ul><p>需注意：MySQL 服务器在容器启动后才会开始启动，这在使用 docker-compose 等工具时可能会出现问题，这时应当用轮询等手段待服务器启动后再进行其他操作。</p><h3 id="JDBC-配置"><a href="#JDBC-配置" class="headerlink" title="JDBC 配置"></a>JDBC 配置</h3><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.driverClassName</span> = <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/prod?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">spring.datasource.username</span> = <span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span> = <span class="hljs-string">root</span><br></code></pre></div></td></tr></table></figure><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><p>TODO</p><h3 id="JDBC-配置-1"><a href="#JDBC-配置-1" class="headerlink" title="JDBC 配置"></a>JDBC 配置</h3><p>TODO</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="https://hub.docker.com/_/redis">Redis</a></h2><ul><li><p>跑个 Redis 实例：<br><code>docker run --name some-redis -d redis</code></p></li><li><p>使用 redis-cli 连接 hostname 为<code>some-redis</code>的实例：<br><code>docker run -it --rm redis redis-cli -h some-redis</code></p></li><li><p>把默认配置文件拷出来：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">docker run --<span class="hljs-built_in">rm</span> -it -v $(<span class="hljs-built_in">pwd</span>):/shareFiles redis bash<br><span class="hljs-built_in">cp</span> /usr/local/etc/redis/ /shareFiles/redis<br><span class="hljs-built_in">exit</span> <br></code></pre></div></td></tr></table></figure></li><li><p>自定义配置：<br>可以使用 Dockerfile 直接替换：</p><div class="hljs code-wrapper"><pre class="language-dockerfile" style="" tabindex="0"><code id="57308e3e" class="language-dockerfile" data-prism-hydrate="{&quot;element&quot;:&quot;57308e3e&quot;,&quot;language&quot;:&quot;dockerfile&quot;,&quot;code&quot;:&quot;\nFROM redis\nCOPY redis.conf /usr/local/etc/redis/redis.conf\nCMD [ \&quot;redis-server\&quot;, \&quot;/usr/local/etc/redis/redis.conf\&quot; ]\n&quot;,&quot;highlightedCode&quot;:&quot;\n\u003cspan class=\&quot;token instruction\&quot;\u003e<span class=\&quot;token keyword\&quot;>FROM</span> redis</span>\n<span class=\&quot;token instruction\&quot;><span class=\&quot;token keyword\&quot;>COPY</span> redis.conf /usr/local/etc/redis/redis.conf</span>\n<span class=\&quot;token instruction\&quot;><span class=\&quot;token keyword\&quot;>CMD</span> [ <span class=\&quot;token string\&quot;>\&quot;redis-server\&quot;</span>, <span class=\&quot;token string\&quot;>\&quot;/usr/local/etc/redis/redis.conf\&quot;</span> ]</span>\n&quot;}"><span class="token instruction"><span class="token keyword">FROM</span> redis</span><span class="token instruction"><span class="token keyword">COPY</span> redis.conf /usr/local/etc/redis/redis.conf</span><span class="token instruction"><span class="token keyword">CMD</span> [ <span class="token string">"redis-server"</span>, <span class="token string">"/usr/local/etc/redis/redis.conf"</span> ]</span></code></pre></div>  <p>或者使用<code>-v</code>：<br><code>docker run -v /myredis/conf:/usr/local/etc/redis --name myredis redis redis-server /usr/local/etc/redis/redis.conf</code></p></li></ul><p>TODO 还有哨兵，集群模式</p>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Perl 入门</title>
    <link href="/2023/09-17Perl%E5%85%A5%E9%97%A8.html"/>
    <url>/2023/09-17Perl%E5%85%A5%E9%97%A8.html</url>
    
    <content type="html"><![CDATA[<p>出差两周，无心画画，编码环境又恶劣，恰逢一些需要进行文本处理的需求（csv-&gt;sql），用 java 处理起来痛苦至极（早该把 node 环境装上的），幻想能否有更好的工具来做文本处理。某日看到一篇 <a href="https://blog.csdn.net/ringliwei/article/details/80448997">文章</a>，声称两个半小时学会 perl，猛然意识到 git for windows 自带 perl，遂起了一些念头。回家又问 GPT，发现 Perl 对函数式编程有部分支持，语法简洁，系统调用方便，因此开始幻想着能否熟练 perl，将其当作主力的脚本语言。</p><p>其实在上一家公司里，编码环境恶劣的情况下也尝试学习过 perl，但当时应该是能力问题且没找到正确的资料，始终没能理解印记（<code>$@%</code>）的使用，遂放弃，这次跟随这篇文章把这个坎越过去了（心智模型是，根据印记后的东西的类型决定用何种印记，比如我们知道数组，哈希均是只能存储标量的，因此从其中取出的东西必然是标量，因此访问数组和访问哈希时，均使用<code>$</code>作为印记，但该心智模型对函数的返回值，对<code>&amp;</code>印记似乎行不通），这里记录一下学习过程中敲的代码。</p><p>正则表达式，模块&#x2F;包，OOP 还没有开始学习，后两者没啥必要，前者之后专门了解。</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> strict;<br><span class="hljs-keyword">use</span> warnings;<br><span class="hljs-keyword">use</span> <span class="hljs-number">5.010</span>; <span class="hljs-comment"># 指定最低兼容版本，目的是为了开启 say 函数</span><br><span class="hljs-comment"># print 不会在末尾添加换行符，使用 say 保证好看</span><br><br><span class="hljs-comment"># 函数调用不需要括号，不一定需要</span><br><span class="hljs-comment"># 行末分号必须！</span><br><span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Hello&#x27;</span>; <br><span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;World&#x27;</span>;<br><br><span class="hljs-comment"># 三种类型：标量，数组，哈希，相应变量相关的符号分别是 $，@，%</span><br><br><span class="hljs-comment"># 标量，包含：undef（即 null），数值（即 number），字符串，变量引用（指针）</span><br><span class="hljs-keyword">my</span> $undef = <span class="hljs-keyword">undef</span>;<br><span class="hljs-keyword">my</span> $someScalar = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-keyword">my</span> $someNumber = <span class="hljs-number">12.3</span> + <span class="hljs-number">12.4</span>;<br><span class="hljs-keyword">say</span> $someNumber;<br><br><span class="hljs-comment"># . 连接字符串</span><br><span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Hello, &#x27;</span> . <span class="hljs-string">&#x27;World!&#x27;</span>;<br><br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;双引号字符串允许插值，就像 shell：$someScalar&quot;</span>;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;同时，只有在双引号下形如、n 的转义符才会作用&#x27;</span>;<br><br><span class="hljs-comment"># &quot;bool&quot; 类型，undef，0，&#x27;&#x27;，&quot;0&quot; 为 false，其它为 true</span><br><span class="hljs-comment"># 一般来说，true===1，false===&quot;&quot;</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">undef</span>) &#123;<br>    <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;undef is true!&#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;undef is false!&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment"># 很难判断 0 和 &#x27;0&#x27; 的区别，但它们确实是不同的，去 json 序列化一下就知道了</span><br><br><span class="hljs-keyword">my</span> $str1 = <span class="hljs-string">&#x27;4A&#x27;</span>;<br><span class="hljs-keyword">my</span> $str2 = <span class="hljs-string">&#x27;4B&#x27;</span>;<br><br><span class="hljs-comment"># 为什么很难？看看这个：</span><br><span class="hljs-keyword">say</span> ($str1 + $str2), <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># 8</span><br><br><span class="hljs-comment"># 数字和字符串使用不同的两套运算符——</span><br><span class="hljs-comment"># 数字  ： &lt; &gt; &lt;= &gt;= == != &lt;=&gt; + *</span><br><span class="hljs-comment"># 字符串： lt gt le ge eq ne cmp . x</span><br><span class="hljs-comment"># &lt;=&gt;返回-1，0，1；字符串的 x 需要一个操作符为数字</span><br><br><span class="hljs-keyword">say</span> (<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-keyword">x</span> <span class="hljs-string">&#x27;10&#x27;</span>), <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># 或者 10 也行，hellohellohello..</span><br><br><span class="hljs-comment"># Array，使用@，() 来声明</span><br><span class="hljs-keyword">my</span> @array = (<br>    <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>    <span class="hljs-string">&#x27;World&#x27;</span>,<br>    <span class="hljs-string">&#x27;Me&#x27;</span>, <span class="hljs-comment"># 末尾可以有，好文明</span><br>);<br><br><span class="hljs-comment"># !!! 使用$来存取 array 中的值，因为取到的是标量</span><br><span class="hljs-keyword">say</span> $array[<span class="hljs-number">1</span>]; <span class="hljs-comment"># World</span><br><span class="hljs-keyword">say</span> $array[-<span class="hljs-number">2</span>]; <span class="hljs-comment"># World</span><br><span class="hljs-keyword">say</span> $array[-<span class="hljs-number">4</span>]; <span class="hljs-comment"># &quot;&quot;，返回警告</span><br><br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;数组长度：&quot;</span>. <span class="hljs-keyword">scalar</span> @array;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;数组最后下标：&quot;</span>. $#array;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;数组内容：@array&quot;</span>;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;\$和、@如果出现在双引号字符串中需要转义&quot;</span>;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;$$$@@@&#x27;</span>;<br><span class="hljs-comment"># 数组“解构”</span><br><span class="hljs-keyword">my</span> ($a, $b) = @array;<br><span class="hljs-keyword">say</span> $a, $b; <span class="hljs-comment"># HelloWorld</span><br><br><span class="hljs-comment"># hash，使用%符号</span><br><span class="hljs-comment"># 注意，$@%变量处在不同的命名空间下，因此可以重名</span><br><span class="hljs-keyword">my</span> %idol = (<br>    <span class="hljs-string">name =&gt;</span> <span class="hljs-string">&#x27;haruka&#x27;</span>,<br>    <span class="hljs-string">age =&gt;</span> <span class="hljs-number">16</span>, <br>    <span class="hljs-string">3 =&gt;</span> <span class="hljs-number">4</span>,<br>);<br><span class="hljs-comment"># =&gt;和，完全等价，决定是 Array 还是 Hash 的看是@还是%</span><br><span class="hljs-keyword">my</span> @ohMeOneArray = (<br>    <span class="hljs-string">name =&gt;</span> <span class="hljs-string">&#x27;11&#x27;</span>,<br>    <span class="hljs-string">age =&gt;</span> <br>);<br><span class="hljs-comment"># 好吧，其实不一样，“key”可以不加引号</span><br><span class="hljs-comment"># 取字段要使用&#123;&#125;，前面仍然是$，因为结果是标量</span><br><span class="hljs-comment"># 为什么 Array 和 Hash 要使用不同的操作符来取元素？因为它们能重名，可以有歧义……wqnmd</span><br><span class="hljs-keyword">say</span> $idol&#123;<span class="hljs-string">&#x27;name&#x27;</span>&#125;; <span class="hljs-comment"># haruka</span><br><br><span class="hljs-comment"># 能同时取多个项，显然这时候的结果是数组，因此是@</span><br><span class="hljs-keyword">say</span> @idol&#123;<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>&#125;; <span class="hljs-comment"># haruka16</span><br><br><span class="hljs-comment"># 哈希&quot;解构&quot;</span><br><span class="hljs-keyword">my</span> ($name, $age) = @idol&#123;<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>&#125;;<br><span class="hljs-keyword">say</span> $name, $age; <span class="hljs-comment"># haruka16</span><br><br><span class="hljs-comment"># Array 和 Hash 可以互转，只要 Array 元素数量是偶数就行</span><br><span class="hljs-comment"># 但是键值对的位置可能改变，因为 Hash 不是顺序存储的</span><br><span class="hljs-keyword">my</span> @idol = %idol;<br><br><span class="hljs-comment"># 上面，Array 和 Hash 的初始化语法中，=右边的形式是完全一样的</span><br><span class="hljs-comment"># 这样的字面量称为列表 list</span><br><span class="hljs-comment"># !!! 因为它们形式完全一样，所以列表不能嵌套，因为 perl 无法知晓嵌套的列表的类型</span><br><span class="hljs-comment"># !!! perl 会直接放弃治疗，把这玩意扁平化再处理</span><br><span class="hljs-keyword">my</span> @array = (<br>    <span class="hljs-string">&#x27;hello&#x27;</span>,<br>    <span class="hljs-string">&#x27;world&#x27;</span>,<br>    (<br>        <span class="hljs-string">&#x27;earth&#x27;</span>,<br>        <span class="hljs-string">&#x27;is&#x27;</span>,<br>        (<span class="hljs-string">&#x27;flat!&#x27;</span>)<br>    )<br>);<br><span class="hljs-keyword">say</span> @array; <span class="hljs-comment"># helloworldearthisflat!</span><br><span class="hljs-keyword">my</span> %whatTheFuck = (<br>    <span class="hljs-string">&#x27;hello&#x27;</span>,<br>    <span class="hljs-string">&#x27;world&#x27;</span>,<br>    (<br>        <span class="hljs-string">&#x27;earth&#x27;</span>,<br>        <span class="hljs-string">&#x27;is&#x27;</span>,<br>        (<span class="hljs-string">&#x27;flat!&#x27;</span>)<br>    )<br>);<br><span class="hljs-keyword">say</span> %whatTheFuck; <span class="hljs-comment"># 警告 Odd number of elements in hash，打印：earth is flat!  hello world</span><br><br><span class="hljs-comment"># 但这个行为让连接 Array 和合并 Hash 变得简单：</span><br><span class="hljs-keyword">my</span> @arrayA = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">my</span> @arrayB = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, @arrayA, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">say</span> @arrayB; <span class="hljs-comment"># 00123234</span><br><br><span class="hljs-keyword">my</span> %hashA = (<span class="hljs-string">name =&gt;</span> <span class="hljs-string">&#x27;haruka&#x27;</span>, <span class="hljs-string">age =&gt;</span> <span class="hljs-number">16</span>);<br><span class="hljs-keyword">my</span> %hashB = (%hashA, <span class="hljs-string">class =&gt;</span> <span class="hljs-number">765</span>);<br><span class="hljs-keyword">say</span> %hashB; <span class="hljs-comment"># name haruka age 16 class 765</span><br><br><span class="hljs-comment"># !!! perl 代码对上下文敏感——表达式要么在 scalar 上下文中求值，要么在列表上下文求值，取决于此处期待产生一个 scalar 还是列表</span><br><br><span class="hljs-comment"># 首先，scalar 和 array，hash 初始化时，分别为 scalar 上下文和列表上下文</span><br><span class="hljs-comment"># 这意味着……</span><br><span class="hljs-keyword">my</span> @array = <span class="hljs-string">&#x27;hello&#x27;</span>; <span class="hljs-comment"># 等价于 my @array = (&#x27;hello&#x27;);，虽然&#x27;hello&#x27;是 scalar，但是因为上下文，是作为列表被看待的</span><br><span class="hljs-keyword">my</span> $scalar = (<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>); <span class="hljs-comment"># 等价于 my #scalar = &#x27;world&#x27;;</span><br><span class="hljs-keyword">say</span> $scalar; <span class="hljs-comment"># world</span><br><span class="hljs-keyword">my</span> $scalar = @array; <span class="hljs-comment"># 等价于 my $scalar = scalar @array;，即返回 array 的长度</span><br><span class="hljs-keyword">say</span> $scalar; <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 如何理解这个不是返回最后一个元素？因为这是 Array 在 scalar 上下文中求值，而不是 list 在 scalar 上下文中求值</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">scalar</span> @array; <span class="hljs-comment"># 1</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">scalar</span> (<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>); <span class="hljs-comment"># 1</span><br><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">scalar</span> %hashB; <span class="hljs-comment"># 3，hash 在 scalar 上下文中求值也是大小</span><br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;%hashB \n&quot;</span>;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;say 函数&#x27;</span>, <span class="hljs-string">&#x27;本身在 list 上下文中求值&#x27;</span>, <span class="hljs-string">&#x27;它接受任意个参数&#x27;</span>;<br><br><span class="hljs-comment"># 列表只能包含标量，到了引用出场的时候了</span><br><span class="hljs-keyword">my</span> @outer = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">my</span> @inner = (<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br><span class="hljs-comment"># 如何让 outer 的头部存储 inner 呢？</span><br>$outer[<span class="hljs-number">0</span>] = @inner; <span class="hljs-comment"># 这样？</span><br><span class="hljs-keyword">say</span> @outer; <span class="hljs-comment"># 223，因为@inner 在标量上下文中求值得到 2</span><br><span class="hljs-comment"># 使用反斜杠创建引用</span><br><span class="hljs-keyword">my</span> $someValue = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-keyword">my</span> $someValueRef = \$someValue; <span class="hljs-comment"># 这 tmd 是指针啊草</span><br><span class="hljs-keyword">say</span> $someValueRef; <span class="hljs-comment"># SCALAR(0x7fa5a9073d40)</span><br>$&#123;$someValueRef&#125; = <span class="hljs-string">&#x27;world&#x27;</span>; <span class="hljs-comment"># 解引用，等价于 $$someValueRef = &#x27;world&#x27;;</span><br><span class="hljs-keyword">say</span> $someValue;<br><br><span class="hljs-comment"># array 和 hash 的引用可以使用-&gt;运算符来取元素</span><br><span class="hljs-keyword">my</span> @color = (<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>);<br><span class="hljs-keyword">my</span> $colorRef = \@color;<br><span class="hljs-comment"># 三者等价</span><br><span class="hljs-keyword">say</span> $color[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">say</span> $&#123;$colorRef&#125;[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">say</span> $colorRef-&gt;[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">my</span> %idol = ( <span class="hljs-string">name =&gt;</span> <span class="hljs-string">&#x27;haruka&#x27;</span>, <span class="hljs-string">age =&gt;</span> <span class="hljs-number">16</span>,  <span class="hljs-string">3 =&gt;</span> <span class="hljs-number">4</span>, );<br><span class="hljs-keyword">my</span> $idolRef = \%idol;<br><span class="hljs-comment"># 三者等价</span><br><span class="hljs-keyword">say</span> $idol&#123;<span class="hljs-string">&#x27;name&#x27;</span>&#125;;<br><span class="hljs-keyword">say</span> $&#123;$idolRef&#125;&#123;<span class="hljs-string">&#x27;name&#x27;</span>&#125;; <span class="hljs-comment"># 可以理解为 $$idolRef = @idol，左结合 lol</span><br><span class="hljs-keyword">say</span> $idolRef-&gt;&#123;<span class="hljs-string">&#x27;name&#x27;</span>&#125;;<br><br><span class="hljs-comment"># []，&#123;&#125; 生成匿名 array 和 hash，它们以引用的形式返回，因此是标量</span><br><span class="hljs-keyword">my</span> $office = &#123;<br>    <span class="hljs-string">name =&gt;</span> <span class="hljs-string">&#x27;765&#x27;</span>,<br>    <span class="hljs-string">description =&gt;</span> <span class="hljs-string">&#x27;...&#x27;</span>,<br>    <span class="hljs-string">idols =&gt;</span> [<br>        &#123;<span class="hljs-string">name =&gt;</span> <span class="hljs-string">&#x27;haruka&#x27;</span>, <span class="hljs-string">age =&gt;</span> <span class="hljs-number">16</span>&#125;,<br>        &#123;<span class="hljs-string">name =&gt;</span> <span class="hljs-string">&#x27;chihaya&#x27;</span>, <span class="hljs-string">age =&gt;</span> <span class="hljs-number">16</span>&#125;,<br>        &#123;<span class="hljs-string">name =&gt;</span> <span class="hljs-string">&#x27;miki&#x27;</span>, <span class="hljs-string">age =&gt;</span> <span class="hljs-number">14</span>&#125;,<br>    ],<br>&#125;;<br><span class="hljs-keyword">say</span> $office-&gt;&#123;<span class="hljs-string">&#x27;name&#x27;</span>&#125;; <span class="hljs-comment"># 765</span><br><span class="hljs-comment"># 如何获取 haruka 的 age 呢？</span><br><span class="hljs-comment"># 首先要获取 idols 数组引用，即</span><br><span class="hljs-keyword">my</span> $idolsRef = $office-&gt;&#123;<span class="hljs-string">&#x27;idols&#x27;</span>&#125;; <span class="hljs-comment"># ARRAY(0x7fb094829ed0)</span><br><span class="hljs-comment"># 然后，获取第一项元素的引用</span><br><span class="hljs-keyword">my</span> $harukaRef = $idolsRef-&gt;[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">say</span> $harukaRef; <span class="hljs-comment"># HASH(0x7f7ac18d7430)</span><br><span class="hljs-comment"># 然后，获取 age</span><br><span class="hljs-keyword">say</span> $harukaRef-&gt;&#123;<span class="hljs-string">&#x27;age&#x27;</span>&#125;; <span class="hljs-comment"># 16</span><br><span class="hljs-comment"># 还好，能够链式调用</span><br><span class="hljs-keyword">say</span> $office-&gt;&#123;<span class="hljs-string">&#x27;idols&#x27;</span>&#125;-&gt;[<span class="hljs-number">0</span>]-&gt;&#123;<span class="hljs-string">&#x27;age&#x27;</span>&#125;; <br><span class="hljs-comment"># perl 很贴心，允许连续的调用时省略后面的-&gt;</span><br><span class="hljs-keyword">say</span> $office-&gt;&#123;<span class="hljs-string">&#x27;idols&#x27;</span>&#125;[<span class="hljs-number">1</span>]&#123;<span class="hljs-string">&#x27;name&#x27;</span>&#125;; <span class="hljs-comment"># chihaya</span><br><span class="hljs-keyword">my</span> %office = (<br>    <span class="hljs-string">idols =&gt;</span> [<br>        &#123;<span class="hljs-string">name =&gt;</span> <span class="hljs-string">&#x27;hibiki&#x27;</span>&#125;<br>    ]<br>);<br><span class="hljs-comment"># 更贴心的是，如果最外层是 Hash，第一个-&gt;也可以省略，这下原汁原味了</span><br><span class="hljs-comment"># 显然，这就是定义复杂数据类型的最佳实践，没有之一，最外层使用列表，里层使用匿名 array 和匿名 hash</span><br><span class="hljs-keyword">say</span> $office&#123;<span class="hljs-string">&#x27;idols&#x27;</span>&#125;[<span class="hljs-number">0</span>]&#123;<span class="hljs-string">&#x27;name&#x27;</span>&#125;; <span class="hljs-comment"># hibiki</span><br><span class="hljs-keyword">say</span> $office&#123;<span class="hljs-string">&#x27;idols&#x27;</span>&#125;-&gt;[<span class="hljs-number">0</span>]-&gt;&#123;<span class="hljs-string">&#x27;name&#x27;</span>&#125;; <span class="hljs-comment"># hibiki</span><br><span class="hljs-comment"># 理解这个语法的心智模型可以是，首先处理$office&#123;&#x27;idols&#x27;&#125; 得到 Array 引用，然后 perl 在后面每个间隔处添加一个-&gt;</span><br><br><span class="hljs-comment"># !!! 如何整蛊——这个 array 只有一个元素，即这个匿名 array 的引用</span><br><span class="hljs-keyword">my</span> @itsMyFaultNow = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">say</span> <span class="hljs-keyword">scalar</span> @itsMyFaultNow; <span class="hljs-comment"># 1</span><br><span class="hljs-keyword">say</span> @&#123;$itsMyFaultNow[<span class="hljs-number">0</span>]&#125;; <span class="hljs-comment"># 12345</span><br><br><span class="hljs-comment"># 类似 $&#123;$SOME_REF&#125;，@&#123;$SOME_REF&#125;，可以认为是解引用$SOME_REF 为 scalar，array...</span><br><br><span class="hljs-comment"># 这语言指定有点大病</span><br><span class="hljs-keyword">my</span> $magic = \\\\\\<span class="hljs-number">1</span>;<br><span class="hljs-keyword">say</span> $$$$$$$magic; <span class="hljs-comment"># 1</span><br><br><span class="hljs-comment"># 所以，嵌套数组是——</span><br><span class="hljs-keyword">my</span> @matrix = ([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-keyword">say</span> $matrix[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment"># 2</span><br><span class="hljs-keyword">say</span> @&#123;$matrix[<span class="hljs-number">0</span>]&#125;; <span class="hljs-comment"># 12</span><br><span class="hljs-comment"># 记住，最左边，最外面的$@%符号，始终指示着返回值的类型</span><br><br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;\n&quot;</span>.<span class="hljs-string">&#x27;分隔符=================================&#x27;</span>;<br><br><span class="hljs-comment"># 变量终于结束了……开始控制结构</span><br><br><span class="hljs-comment"># if，elsif，else，典型的，注意拼写</span><br><span class="hljs-comment"># !!! if 语句在 scalar 上下文中求值，这符合逻辑</span><br><span class="hljs-keyword">my</span> $cash = <span class="hljs-number">30</span>;<br><span class="hljs-comment"># 括号必须……</span><br><span class="hljs-keyword">if</span> ($cash &lt; <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;you pool&#x27;</span> <span class="hljs-comment"># 注意最后一个语句可以不用加分号</span><br>&#125; <span class="hljs-keyword">elsif</span> ($cash &gt;= <span class="hljs-number">10</span> &amp;&amp; $cash &lt; <span class="hljs-number">20</span>) &#123;<br>    <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;just soso&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;worth a headshot&#x27;</span><br>&#125;<br><span class="hljs-comment"># 注意 || 和 &amp;&amp;，行为同 js</span><br><span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-number">1</span>; <span class="hljs-comment"># 1</span><br><span class="hljs-keyword">say</span> <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">1</span>; <span class="hljs-comment"># 0</span><br><br><span class="hljs-keyword">my</span> $tempo = <span class="hljs-number">120</span>;<br><span class="hljs-comment"># 类似 ruby 的语法</span><br><span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;It\&#x27;s too slow!&#x27;</span> <span class="hljs-keyword">if</span> $tempo &lt;= <span class="hljs-number">222</span>; <span class="hljs-comment"># It&#x27;s to slow!</span><br><span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;It\&#x27;s too slow!&#x27;</span> <span class="hljs-keyword">unless</span> $tempo &gt; <span class="hljs-number">222</span>;<br><br><span class="hljs-comment"># 有 c 风格的三目，但我不给例子</span><br><br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;\n&quot;</span>.<span class="hljs-string">&#x27;分隔符=================================&#x27;</span>;<br><br><span class="hljs-comment"># 循环</span><br><br><span class="hljs-comment"># 最基本的 while, until, for</span><br><span class="hljs-keyword">my</span> @arr = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">my</span> $i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ($i &lt; <span class="hljs-keyword">scalar</span> @arr) &#123;<br>    <span class="hljs-keyword">say</span> $arr[$i++];<br>&#125;<br><span class="hljs-keyword">my</span> $i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">until</span> ($i &gt;= <span class="hljs-keyword">scalar</span> @arr) &#123;<br>    <span class="hljs-keyword">say</span> $arr[$i++];<br>&#125;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">my</span> $i = <span class="hljs-number">0</span>; $i &lt; <span class="hljs-keyword">scalar</span> @arr; $i++) &#123;<br>    <span class="hljs-keyword">say</span> $i . <span class="hljs-string">&#x27;:&#x27;</span> . $arr[$i] . <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-comment"># 这里就离开了$i 的作用域了</span><br><br><span class="hljs-comment"># 但是若没有必要，谁愿意写这种 for 呢？</span><br><span class="hljs-comment"># 迭代器语法 foreach（和 for 可以互相替换，用可读性高的）</span><br><span class="hljs-comment"># 想象 python 的 for i in arr</span><br><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $v (@arr) &#123;<br>    <span class="hljs-keyword">say</span> $v;<br>&#125;<br><br><span class="hljs-comment"># range 操作符。.，返回一个匿名的整型列表，前闭后闭</span><br><span class="hljs-keyword">my</span> @range = (<span class="hljs-number">1</span> .. <span class="hljs-number">10</span>);<br><span class="hljs-keyword">say</span> @range; <span class="hljs-comment"># 1234512345678910</span><br><br><span class="hljs-comment"># 从 0 到最后一个下标</span><br><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $i (<span class="hljs-number">0</span> .. $#arr) &#123;<br>    <span class="hljs-keyword">say</span> $i . <span class="hljs-string">&#x27;:&#x27;</span> . $arr[$i] . <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment"># keys 函数返回 Hash 的所有 key，用来迭代 hash</span><br><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $key (<span class="hljs-keyword">keys</span> %idol) &#123;<br>    <span class="hljs-keyword">say</span> $key . <span class="hljs-string">&#x27;:&#x27;</span> . $idol&#123;$key&#125; . <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># name:haruka...</span><br>&#125;<br><br><span class="hljs-comment"># 开始魔法/约定——如果不给定迭代的变量（这玩意似乎叫迭代器），使用$_作为迭代变量：</span><br><span class="hljs-keyword">foreach</span> (@arr) &#123;<br>    <span class="hljs-keyword">say</span> $_;<br>&#125; <span class="hljs-comment"># 12345</span><br><span class="hljs-comment"># 如果循环里只有一条语句……可以使用下面的语法……omg</span><br><span class="hljs-keyword">say</span> $_ <span class="hljs-keyword">foreach</span> @arr;<br><br><span class="hljs-comment"># next 和 last，相当于 continue 和 break</span><br><br><span class="hljs-comment"># 比如，找到数组中特定的数，并执行操作</span><br><span class="hljs-keyword">my</span> @arr = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>);<br><span class="hljs-keyword">my</span> $toFind = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-number">0</span> .. $#arr) &#123;<br>    <span class="hljs-keyword">my</span> $value = $arr[$_];<br>    <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> $value != $toFind;<br>    <span class="hljs-keyword">say</span> $value. <span class="hljs-string">&#x27;...got it! index: &#x27;</span>. $_;<br>    <span class="hljs-keyword">last</span><br>&#125; <br></code></pre></div></td></tr></table></figure><h1 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h1><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> strict;<br><span class="hljs-keyword">use</span> warnings;<br><span class="hljs-keyword">use</span> <span class="hljs-number">5.010</span>; <span class="hljs-comment"># 指定最低兼容版本，目的是为了开启 say 函数</span><br><br><span class="hljs-comment"># 和 js 的假设一样，数组头部是队列头部，尾部是栈尾部</span><br><span class="hljs-keyword">my</span> @stack = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">say</span> @stack; <span class="hljs-comment"># 123</span><br><span class="hljs-keyword">push</span> @stack, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>;<br><span class="hljs-keyword">say</span> @stack; <span class="hljs-comment"># 123456</span><br><br><span class="hljs-comment"># 注意函数调用的优先级，不是像 haskell 一样左结合，而是某种右结合</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">pop</span> @stack; <span class="hljs-comment"># 6</span><br><br><span class="hljs-keyword">say</span> @stack; <span class="hljs-comment"># 12345</span><br><br><span class="hljs-keyword">unshift</span> @stack, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>; <br><span class="hljs-keyword">say</span> @stack; <span class="hljs-comment"># -1012345</span><br><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">shift</span> @stack; <span class="hljs-comment"># -1</span><br><span class="hljs-keyword">say</span> @stack; <span class="hljs-comment"># 012345</span><br><br><span class="hljs-comment"># 它们都是 splice 的特例，splice 将数组中特定范围的切片捞出来，替换为另一个数组，并返回捞出来的数组</span><br><span class="hljs-keyword">my</span> @arr = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">say</span> <span class="hljs-keyword">splice</span> @arr; <span class="hljs-comment"># 只有 1 个参数，清空数组，并返回清空前的值即 (1,2,3,4)</span><br><br><span class="hljs-keyword">my</span> @arr = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">say</span> <span class="hljs-keyword">splice</span> @arr, <span class="hljs-number">2</span>; <span class="hljs-comment"># 2 是要删除的范围的开头，这里会删除原数组的 (3, 4)，并返回 (3, 4)</span><br><span class="hljs-keyword">say</span> @arr; <span class="hljs-comment"># 12</span><br><br><span class="hljs-keyword">my</span> @arr = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-comment"># 1,2 是要删除的范围的开头和删除的数量</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">splice</span> @arr, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>;  <span class="hljs-comment"># 23</span><br><span class="hljs-keyword">say</span> @arr; <span class="hljs-comment"># 14</span><br><br><span class="hljs-comment"># 隔壁 substr 入参形式也是一样的，从下标 2 开始，取 2 个字符</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">substr</span> <span class="hljs-string">&#x27;hello, world&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>; <span class="hljs-comment"># ll</span><br><br><span class="hljs-keyword">my</span> @arr = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-comment"># 第四个以后的参数为要用来替换的数组，为什么不需要扩起来？hint：函数参数也是列表</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">splice</span> @arr, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>; <span class="hljs-comment"># 3</span><br><span class="hljs-keyword">say</span> @arr; <span class="hljs-comment"># 122003004</span><br><br><span class="hljs-comment"># 另外一些列表操作。..join, reverse, map, grep</span><br><span class="hljs-keyword">my</span> @arr = (<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>);<br><span class="hljs-keyword">say</span> @arr; <span class="hljs-comment"># hellotheworld</span><br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;@arr&quot;</span>;<br><span class="hljs-keyword">say</span> <span class="hljs-keyword">join</span> <span class="hljs-string">&#x27;, &#x27;</span>, @arr; <span class="hljs-comment"># hello, the, world</span><br><br><span class="hljs-comment"># reverse，列表上下文下反转数组，标量上下文下反转字符串</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">reverse</span> <span class="hljs-string">&#x27;hello&#x27;</span>; <span class="hljs-comment"># hello（默认就是列表上下文，只有一个元素也是列表上下文，</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">reverse</span> <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>; <span class="hljs-comment"># worldhello</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">reverse</span> @arr; <span class="hljs-comment"># worldthehello</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">scalar</span> <span class="hljs-keyword">reverse</span> @arr; <span class="hljs-comment"># dlrowehtolleh，注意 scalar 不能当成函数来看待，行为和函数不一样，它直接影响了 reverse 的行为</span><br><br><span class="hljs-comment"># map，不用解释，当前元素为 $_</span><br><span class="hljs-comment"># 注意 map 里函数和数组之间没有逗号，不知为何，不知这是如何定义的</span><br><span class="hljs-keyword">my</span> @arr = <span class="hljs-string">qw(hello the world)</span>; <span class="hljs-comment"># qw,quote word, 等价于 (&#x27;hello&#x27;, &#x27;the&#x27;, &#x27;world&#x27;)</span><br><span class="hljs-keyword">say</span> @arr; <span class="hljs-comment"># hellotheworld</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">join</span> <span class="hljs-string">&#x27;, &#x27;</span>, @arr; <span class="hljs-comment"># hello, the, world</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">join</span> <span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-keyword">map</span> &#123;<span class="hljs-keyword">uc</span> $_&#125; @arr; <span class="hljs-comment"># HELLO, THE, WORLD，uc 是 upperCase，$_是当前 map 的元素，可以省略</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">join</span> <span class="hljs-string">&#x27;, &#x27;</span>, @arr; <span class="hljs-comment"># hello, the, world，无副作用</span><br><br><span class="hljs-comment"># grep，filter</span><br><span class="hljs-keyword">my</span> @lst = <span class="hljs-keyword">qw</span>/<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>/;<br><span class="hljs-keyword">say</span> <span class="hljs-keyword">grep</span> &#123;$_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125; @lst; <span class="hljs-comment"># 2468</span><br><br><span class="hljs-comment"># 结合 grep，eq/== 和 scalar 可以用来判定数组中是否包含特定元素</span><br><span class="hljs-keyword">my</span> @fruits = <span class="hljs-keyword">qw</span>/apple orange banana/;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;love banana&#x27;</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">scalar</span> <span class="hljs-keyword">grep</span> &#123;$_ eq <span class="hljs-string">&#x27;banana&#x27;</span>&#125; @fruits; <span class="hljs-comment"># love banana</span><br><span class="hljs-keyword">say</span> @fruits; <span class="hljs-comment"># appleorangebanana，grep 无副作用</span><br><span class="hljs-comment"># sort，默认是使用字符串的比较方式，这很多时候不是我们想要的</span><br><span class="hljs-comment"># sort 无副作用</span><br><span class="hljs-keyword">my</span> @elevations = (<span class="hljs-number">19</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">23</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">29666</span>);<br><span class="hljs-keyword">say</span> <span class="hljs-keyword">join</span> <span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-keyword">sort</span> @elevations; <span class="hljs-comment"># -2, 0, 1, 100, 19, 23, 29666, 7</span><br><span class="hljs-comment"># sort 第二个参数可以传递一个代码块作为 comparator，其中比较的两个元素分别为 $a，$b，这是常见的约定</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">join</span> <span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-keyword">sort</span> &#123;$a &lt;=&gt; $b&#125; @elevations; <span class="hljs-comment"># -2, 0, 1, 7, 19, 23, 100, 29666，这里的$a，$b 不可省略</span><br><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">map</span> <span class="hljs-keyword">uc</span> $_, <span class="hljs-string">qw(1 2 3 4 5 6 hello)</span>;<br></code></pre></div></td></tr></table></figure><h1 id="子例程"><a href="#子例程" class="headerlink" title="子例程"></a>子例程</h1><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> strict;<br><span class="hljs-keyword">use</span> warnings;<br><span class="hljs-keyword">use</span> <span class="hljs-number">5.010</span>; <span class="hljs-comment"># 指定最低兼容版本，目的是为了开启 say 函数</span><br><br><span class="hljs-comment"># 子例程，用户定义的子例程总是接受列表，但内置的函数各有各的行为。</span><br><span class="hljs-comment"># ！！！！！！！！！！！ 子例程是引用传递，引用传递！不是值传递，不是引用的值传递，是引用传递，这和所有编程语言都不一样</span><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">inc</span> </span>&#123;<br>    <span class="hljs-comment"># 函数参数保存在 @_</span><br>    $_[<span class="hljs-number">0</span>]++<br>&#125;<br><span class="hljs-keyword">my</span> $v = <span class="hljs-number">1</span>;<br>inc $v;<br><span class="hljs-keyword">say</span> $v; <span class="hljs-comment"># 2</span><br><span class="hljs-comment"># inc 2; # error, Modification of a read-only value </span><br><br><span class="hljs-comment"># 取参数可以使用 shift 函数</span><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">pureInc</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $v = <span class="hljs-keyword">shift</span>; <span class="hljs-comment"># 等价于 shift @_</span><br>    <span class="hljs-keyword">return</span> $v + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">say</span> pureInc <span class="hljs-number">2</span>; <span class="hljs-comment"># 3</span><br><br><span class="hljs-comment"># 多个参数可以使用某种“解构”语法</span><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">add3Num</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> ($a, $b, $c) = @_;<br>    <span class="hljs-keyword">return</span> $a + $b + $c;<br>&#125;<br><span class="hljs-keyword">say</span> add3Num <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>; <span class="hljs-comment"># 6</span><br><span class="hljs-comment"># 更多的参数？传 hash 吧</span><br><br><span class="hljs-comment"># 能够使用 wantarray 函数来检查当前的上下文是否是列表上下文</span><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">contextualSubroutine</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">if</span> <span class="hljs-keyword">wantarray</span>; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment"># scalar 上下文</span><br>&#125;<br><span class="hljs-keyword">say</span> contextualSubroutine; <span class="hljs-comment"># 123，say 和 print 是列表上下文</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">scalar</span> contextualSubroutine; <span class="hljs-comment"># 1</span><br></code></pre></div></td></tr></table></figure><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> strict;<br><span class="hljs-keyword">use</span> warnings;<br><span class="hljs-keyword">use</span> <span class="hljs-number">5.010</span>; <span class="hljs-comment"># 指定最低兼容版本，目的是为了开启 say 函数</span><br><br><span class="hljs-comment"># 定义一个 trim，后面用</span><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">trim</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $string = <span class="hljs-keyword">shift</span>;<br>    $string =~ <span class="hljs-regexp">s/^\s+//</span>;  <span class="hljs-comment"># 去除开头的空白符</span><br>    $string =~ <span class="hljs-regexp">s/\s+$//</span>;  <span class="hljs-comment"># 去除结尾的空白符</span><br>    <span class="hljs-keyword">return</span> $string;<br>&#125;<br><br><span class="hljs-comment"># tip：程序返回给系统的返回码是 16 位，高 8 位是我们认知中的返回码，0 表示正常退出，低 8 位不用关心</span><br><br><span class="hljs-comment"># perl 能够通过 exit 函数来退出，接受参数为返回给系统的 0-255 的返回码</span><br><span class="hljs-keyword">exit</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>; <span class="hljs-comment"># 别！</span><br><br><span class="hljs-comment"># system 函数允许进行系统调用，参数列表为所有参数，返回值为 16 位返回码，标准输出会打印到控制台</span><br><span class="hljs-comment"># 返回码同时也会保存在$? 中，为 16 位，需要右移 8 位</span><br><span class="hljs-keyword">system</span> <span class="hljs-string">&#x27;ls&#x27;</span>, <span class="hljs-string">&#x27;-alh&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>;<br>$? &gt;&gt;= <span class="hljs-number">8</span>;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;ls return code: $?&quot;</span>;<br><br><span class="hljs-comment"># 使用反引号也可以执行命令，返回值在标量上下文下为命令标准输出的字符串形式，列表上下文则按行分割</span><br><span class="hljs-comment"># 若报错，会打印到错误流（应该</span><br><span class="hljs-keyword">my</span> $path = <span class="hljs-string">&#x27;/a/b/c&#x27;</span>;<br><span class="hljs-keyword">my</span> @rootFiles = <span class="hljs-string">`ls $path`</span>;<br>$? &gt;&gt;= <span class="hljs-number">8</span>;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;return code: $?, res: &quot;</span>, <span class="hljs-keyword">join</span> <span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-keyword">map</span> &#123;trim $_&#125; @rootFiles;<br><br><span class="hljs-comment"># 文件句柄也是标量</span><br><span class="hljs-comment"># 打开文件，读模式，文件句柄保存在$fn，open 若打开成功返回 true，打开失败返回 false，并将错误信息置于 $!</span><br><span class="hljs-keyword">my</span> $file = <span class="hljs-string">&#x27;/Users/yuuki/code/tmp/a.js&#x27;</span>;<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fn, <span class="hljs-string">&#x27;&lt;&#x27;</span>, $file <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot open $file, reason: $!&quot;</span>;<br><span class="hljs-comment"># readline 函数能读取文件的每一行（显然当前读取位置保存在句柄里面</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">my</span> $line = <span class="hljs-keyword">readline</span> $fn;<br>    <span class="hljs-keyword">last</span> <span class="hljs-keyword">unless</span> <span class="hljs-keyword">defined</span> $line; <span class="hljs-comment"># 读取完成后返回 undef，也可以使用 eof 函数检查是否到末尾</span><br>    <span class="hljs-keyword">chomp</span> $line; <span class="hljs-comment"># 移除末尾可能的换行符，注意这个方法有副作用</span><br>&#125;<br><span class="hljs-comment"># 文件句柄会在离开作用域后自己关闭</span><br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fn, <span class="hljs-string">&#x27;&lt;&#x27;</span>, $file <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot open $file, reason: $!&quot;</span>;<br><span class="hljs-comment"># while (my $line = readline $fn) 看上去很诱人，但它遇到&quot;0&quot;，空字符串也会停止！不要这么做！</span><br><span class="hljs-comment"># &lt;&gt;运算符可以避免该问题，可以认为&lt;&gt;在底层读取一行后会保存到$_，并使用 defined 检查当前是否是 undef，可以认为底层是 while (defined(my $_ = readline $fn))</span><br><span class="hljs-keyword">while</span> (&lt;$fn&gt;) &#123;<br>    <span class="hljs-keyword">chomp</span> $_; <span class="hljs-comment"># 移除末尾换行符</span><br>    <span class="hljs-keyword">say</span> $_;<br>&#125;<br><span class="hljs-comment"># &lt;&gt;运算符可以更酷，它赋值到标量会读一行，赋值给数组，可以读取全部内容到数组中，比如下面统计行号</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fn, <span class="hljs-string">&#x27;&lt;&#x27;</span>, $file <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot open $file, reason: $!&quot;</span>;<br><span class="hljs-keyword">my</span> $firstLine = &lt;$fn&gt;;<br><span class="hljs-keyword">print</span> $firstLine; <span class="hljs-comment"># 它自带换行符</span><br><span class="hljs-keyword">my</span> @lastLines = &lt;$fn&gt;;<br><span class="hljs-keyword">chomp</span> <span class="hljs-keyword">foreach</span> @lastLines; <span class="hljs-comment"># 为每一行都去掉末尾的换行符</span><br><span class="hljs-keyword">say</span> @lastLines; <span class="hljs-comment"># 会发现它们全扭在一起了</span><br><span class="hljs-keyword">say</span> <span class="hljs-keyword">scalar</span> @lastLines; <span class="hljs-comment"># 剩下的行数，22 行</span><br><br><span class="hljs-comment"># &lt;&gt; 如果没有参数，会使用标准输入流。</span><br><span class="hljs-comment"># 更更更酷的是，unix 管道也可以当作文件句柄——</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $rootLs, <span class="hljs-string">&quot;ls / |&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;execute ls / failed, $!&quot;</span>;<br><span class="hljs-keyword">my</span> @rootFiles = &lt;$rootLs&gt;;<br><span class="hljs-keyword">chomp</span> <span class="hljs-keyword">foreach</span> @rootFiles;<br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;total count: &quot;</span> . <span class="hljs-keyword">scalar</span> @rootFiles . <span class="hljs-string">&quot;, files: @rootFiles&quot;</span>;<br><br><span class="hljs-comment"># 如何写入文件呢？print 打印内容到输出流，默认是标准输出流，so……</span><br><span class="hljs-comment"># &lt;, &gt;, &gt;&gt;, 和 linux 的习惯一致</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $writeFile, <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;/Users/yuuki/code/tmp/helloworld.txt&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> $!;<br><span class="hljs-keyword">say</span> $writeFile <span class="hljs-string">&#x27;Hello&#x27;</span>; <span class="hljs-comment"># 注意不能逗号分隔，一逗号分隔 say 就选择打印该文件句柄了</span><br><span class="hljs-keyword">say</span> $writeFile <span class="hljs-string">&#x27;World&#x27;</span>; <span class="hljs-comment"># 用户不能自定义这样的函数，只能暂且认为这里 say $writeFile 是一个整体</span><br><br><span class="hljs-comment"># 且慢！在函数参数里定义变量是什么操作？因为 perl 是引用传递，所以定义的变量能直接被函数所修改，这里就像 C#的 out</span><br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">lastElem</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $pointer = \$_[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">my</span> ($ignore, @last) = @_;<br>    $$pointer = $last[-<span class="hljs-number">1</span>];<br>&#125;<br>lastElem <span class="hljs-keyword">my</span> $last, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">say</span> $last; <span class="hljs-comment"># 3</span><br><br><span class="hljs-comment"># 数组解构</span><br><span class="hljs-keyword">my</span> ($a, $b, @c) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-keyword">say</span> $a; <span class="hljs-comment"># 1</span><br><span class="hljs-keyword">say</span> $b; <span class="hljs-comment"># 2</span><br><span class="hljs-keyword">say</span> @c; <span class="hljs-comment"># 345</span><br><br><span class="hljs-comment"># 咳咳，回到正题</span><br><span class="hljs-comment"># 检查文件是否存在的一些函数是和 shell 习惯一致的，</span><br><span class="hljs-comment"># -e 文件是否存在</span><br><span class="hljs-comment"># -d 文件是目录，ef 文件是文件</span><br><span class="hljs-comment"># 查询这些函数的文档需要搜 “perl file test”，因为-X 是不搜索 X</span><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">fileExist</span> </span>&#123; <span class="hljs-comment"># 屁话</span><br>    <span class="hljs-keyword">return</span> -e <span class="hljs-keyword">shift</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Perl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GLSL 学习笔记</title>
    <link href="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <url>/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/myGo.gif" alt="其实我也在迷路"></p><h1 id="为啥学这玩意？"><a href="#为啥学这玩意？" class="headerlink" title="为啥学这玩意？"></a>为啥学这玩意？</h1><p>翻伊月クロ老师的本子时，发现他上调子完全只使用墨汁（纯黑）和网点，没有任何灰度，发现这种方式能很快出效果且很有味道，又意识到网点对打印机友好，将来要是打印自己的作品的话会很方便，不需要很好的打印机。</p><p>然后找到一个网点的笔刷，绘制时发现难以保证纯黑白的基础上做渐变（就像刮刀），下面是最终得到的效果和实现方式的说明，基本原理是对网点的滤镜应用一个有明显渐变的纯黑白的不透明度蒙版（在 ps 里是剪切蒙版？），即做一个减法。</p><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/before.jpg" alt="before"></p><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/after.jpg" alt="after"></p><ol><li>绘制网点</li><li>在网点下方建立一个图层，填充一个颜色</li><li>应用噪声滤镜，级别调到最高，生成就像电视没台时的噪声图</li><li>在噪声图层上创建一个图层，混合模式调整为线性光 Linear Light，它是线性减淡（相加）和线性加深（相乘、正片叠底）的混合，在亮度大于 0.5 时使用相加，小于 0.5 时使用线性加深</li><li>修改前景色为纯黑，背景色为纯白，在该图层拉一个前景色到背景色的渐变</li><li>合并这两个图层，做一个阈值滤镜，调整至边缘位置合适；渐变的拉的方式和阈值的设置会影响边缘的位置和柔软程度</li><li>将该图层转换为不透明度蒙版，置于网点图层下，bingo</li></ol><p>将图层中的每一个像素看作一个 0-1 之间的数字，将阈值看作布尔化（变为 0，1），将相加和相乘模式看作数字的相加相减，上述的过程是非常容易理解的。</p><p>现在还是放弃了研究网点的想法了，原因是这玩意更适用于打印，在屏幕上缩放级别的不同会影响灰度，而显然后者现在是更主要的受众。但不能说白费功夫了，研究实现该效果的过程中熟悉了图层，蒙版，混合模式等概念并建立了相应心智模型，同时意识到我以前光把着画笔工具不放的想法和行为是多么睿智。</p><p>然后发现 krita 允许通过 SeExpr 这门脚本语言进行绘图，其中有两个效果超级炫酷的示例（第一张简直壮观），引起了我很强烈的兴趣：</p><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seexprExp0.png" alt="SeExpr example 1"></p><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seexprExp1.png" alt="SeExpr example 2"></p><p>要是能在背景，材质等地方使用这样酷炫的材质岂不美哉？于是就来到这里了。然而 SeExpr 的学习材料实在太少（全互联网有 10 篇吗？），这里只得去拿和它思想一致的 glsl 来动手动脚。这里跟随 <a href="https://thebookofshaders.com/?lan=ch">https://thebookofshaders.com/?lan=ch</a> 进行学习。SeExpr 的用法应当参考 <a href="https://docs.krita.org/zh_CN/reference_manual/seexpr.html">https://docs.krita.org/zh_CN/reference_manual/seexpr.html</a>（Krita 的官方文档是好东西，值得反反复复看 10 遍）。本打算每个例子都用 SeExpr 实现一下，但是懒了。先把画画画好再说！</p><h1 id="glsl-是什么"><a href="#glsl-是什么" class="headerlink" title="glsl 是什么"></a>glsl 是什么</h1><p>glsl 与其说是编程语言，不如说是 DSL；glsl 语法和数据类型类似 C，glsl 脚本被交付给 GPU，在每一个像素上执行，用于修改该像素的颜色。可以认为 glsl 是一个接受像素坐标（和一些其他参数，称为 uniform；根据 GPU 的架构的性质，<strong>对每一个像素，uniform 的值均一致且不可变</strong>）的函数，返回像素颜色的函数，在这里，像素坐标是二元组，分别为 x，y 轴坐标（其实是四元组，但我们只看二维），其中<strong>原点在左下角</strong>；像素颜色为四元组，分别为 rgba 通道上的值。在 glsl 中，rgba 均使用 0-1 的浮点数表示，这种表示似乎称为 normalize 表示，它们乘以 255 会得到我们熟知的表示法。</p><p>下面是一个最简单的 glsl 脚本，它给整个画面从左到右做了一个黑白渐变：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 注释和 C 一样，行注释和块注释</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">样板代码，定义 float 的精度，这里定义为 medium 精度，还有 lowp 和 highp</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// uniforn 变量需定义出来</span><br><span class="hljs-comment">// 按照约定，uniform 变量使用 u_开头，gl 提供的内置的变量使用 gl_开头</span><br><span class="hljs-comment">// vec2 是二元向量，用来表示点或者向量，每个分量类型均为 float</span><br><span class="hljs-comment">// 此外，glsl 还提供了 vec3，vec4</span><br>uniform vec2 u_resolution; <span class="hljs-comment">// u_resolution 是画布的宽高，以像素为单位</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  能够从浮点数构造向量，如 vec3(1., 1., 1.)，它等价于 vec3(1.)，也能从向量构造向量，如 vec4(vec3(1.), 1) 得到 vec4(1., 1., 1., 1.)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  从向量中获取它的分量是十分符合直觉的，比如下面的 st.x 获取 st 的第一个分量，st.y 获取第二个分量，st.xy 获取 vec2(st.x, st.y)：</span><br><span class="hljs-comment">    vec2(st.x, st.y) = st.xy = st.rg = vec2(st[0], st[1]) = st</span><br><span class="hljs-comment">    vec4(st.y, st.y, st.x, st.x) = st.yyxx = st.ggrr</span><br><span class="hljs-comment">  具体使用什么表示法，看这个向量的语义和上下文，合法的表示法有：xyzw，rgba，stpq，他们之间不能混用</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 像 c 一样，脚本的“入口”</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同维数的向量能够做运算，这里是逐维度的除法</span><br>    <span class="hljs-comment">// gl_FragCoord 是四维的坐标信息，前两个分量为 x，y 轴的坐标</span><br>    vec2 st = gl_FragCoord.xy / u_resolution; <span class="hljs-comment">// st 是 gl_FragCoord 的标准化表示，它的 x，y 落在 0-1 之间</span><br>gl_FragColor = vec4(vec3(st.x), <span class="hljs-number">1.</span>); <span class="hljs-comment">// 输出的颜色通过修改变量 gl_FragColor 来实现</span><br>    <span class="hljs-comment">// 在这里，输出颜色和 y 轴无关，x 越大，像素越亮，在画面最右亮度最大</span><br>    <span class="hljs-comment">// 也可以：gl_FragColor = vec4(vec3(1), st.x)，但这样如果屏幕有刷新，上次的结果</span><br>    <span class="hljs-comment">// 此外，glsl 支持 if-else，while，for（循环次数必须在“编译期”确定），三目表达式，但复杂语句可能会影响着色器性能，应尽量使用 glsl 提供的函数来完成功能，这些函数很多都是可以直接在硬件上执行的</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/blackWhiteGradient.jpg" alt="黑白渐变"></p><p>此外，glsl 支持 if-else，while，for（循环次数必须在“编译期”确定），三目表达式，但复杂语句可能会影响着色器性能，应尽量使用 glsl 提供的函数来完成功能，这些函数很多都是可以直接在硬件上执行的。</p><p>注意 glsl 很少会进行自动的类型转换，写浮点数时加上<code>.</code>是好习惯。</p><p>下面是另一个脚本，其使用了 distance 函数，绘制从中心开始的圆形渐变：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>vec2 coor = gl_FragCoord.xy/u_resolution;<br>    <span class="hljs-type">float</span> dist = distance(vec2(<span class="hljs-number">.5</span>), coor) * <span class="hljs-number">2.</span>;<br>    <span class="hljs-comment">// 各边中点处亮度为 1</span><br>    gl_FragColor = vec4(vec3(dist), <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/centerGradient.png" alt="中心渐变"></p><p>教程关卡结束了！该来点烧脑子的东西了。下面的所有代码都有一个很大的问题——只考虑了画布为正方形的情况；但懒得研究了。</p><h1 id="绘制函数汗背景"><a href="#绘制函数汗背景" class="headerlink" title="绘制函数汗背景"></a>绘制函数汗背景</h1><p>在 glsl 中，函数可视化有两种方式——使用灰度来表达 y 轴，或者使用 y 轴来表达 y 轴，前者就是绘制像上面第一个例子的黑白渐变，其就是通过灰度绘制了 y&#x3D;x 的图像，后者就是在图像中实际绘制出函数曲线。</p><p>现在有个数学函数<code>y=x^2</code>，如何将它作为一条线绘制在画面上？具体来说就是，如何绘制这样的图像，它的大多数地方亮度为 0，该函数周围区域亮度为 1？</p><p>第一印象是，对每一个点，可以计算它到函数的距离，小于一定距离，则认为它在线上，绘制亮度为 1，否则绘制为 0，这里为了实现简单，只比较 y 轴方向的距离；代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br><span class="hljs-comment">// 检查点 st 是否在函数 y=x^2 上，即检查点 (st.x, st.y) 和 (st.x, st.x * st.x) 的距离是否小于定值</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isOnLine</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-comment">// 是的，这个距离直接做减法就行：D</span><br>    <span class="hljs-type">float</span> dist = distance(st, vec2(st.x, st.x * st.x));<br>    <span class="hljs-keyword">return</span> dist &lt; <span class="hljs-number">0.01</span>;<br>    <span class="hljs-comment">// 可以使用阶跃函数 step 来处理 dist，step 函数在入参小于特定值时返回 0，大于特定值时返回 1，这样就能避免这个三目运算符了，但是……可读性降低了，这真的好吗？</span><br>    <span class="hljs-comment">// return -step(0.01, dist) + 1.;</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>vec2 st = gl_FragCoord.xy/u_resolution;<br>gl_FragColor = vec4(vec3(isOnLine(st) ? <span class="hljs-number">1.</span> : <span class="hljs-number">0.</span>), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/drawFn.png" alt="画函数"></p><p>这种方法有两个缺点，第一是函数导数大时函数会画得更细，反之会画得更粗；第二是绘制出来的线条的边缘会非常硬——从 1 直接跃迁到 0 了，中间没有任何渐变。</p><p>第一个问题先不考虑，看第二个问题，如何把它画的更平滑一些？我们需要一个类似阶梯函数但中间要有一个平滑但微小的过渡的东西，让它在距离大于特定值时返回 0，距离小于该特定值时返回 0-1 之间的数，更小时返回 1（处理这个“更小”和“特定值”就是处理函数边缘的硬度）。<a href="https://thebookofshaders.com/glossary/?search=smoothstep">smoothstep 函数</a> 满足我们的需求——它需要用户给定阶梯的开始和结束位置，通过某种插值法在中间生成平滑的过渡，下面是使用 smoothstep 函数来做的实现：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br><span class="hljs-comment">// 若点在曲线上，返回 0-1 的值，否则返回 0</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">plot</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> dist = distance(st, vec2(st.x, st.x * st.x));<br>    <span class="hljs-keyword">return</span> smoothstep(<span class="hljs-number">0.002</span>, <span class="hljs-number">0.</span>, dist);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>vec2 st = gl_FragCoord.xy/u_resolution;<br>gl_FragColor = vec4(vec3(plot(st)), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/drawSmoothFn.png" alt=".. 还是尖锐一点好"></p><p>然后下一步，这函数的背景有点寡淡了，想给它加个背景，该怎么办？</p><p>考虑<code>plot(st)</code>的返回值，在大多数时候它返回 0，只有在函数附近时它才返回 1，我们的需求是，在 plot(st) 返回 0 的时候，显示背景色，在 plot(st) 返回 1 的时候显示前景色……在 plot(st) 在 0-1 之间的时候，返回前景色和背景色的混合……混合，混合……混合？</p><p>混合！答案实际上呼之欲出了——</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">gl_FragColor = plot * lineColor + (<span class="hljs-number">1</span> - plot) * background; <span class="hljs-comment">// 使用特定算法来混合前景色和背景色</span><br></code></pre></div></td></tr></table></figure><p>背景色当然也可以是计算出来的，这里同时使用背景色和曲线来可视化<code>y=x^2</code>，下面使用功能相同的 mix 函数来进行混合：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br><span class="hljs-comment">// 若点在曲线上，返回 0-1 的值，否则返回 0</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">plot</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> dist = distance(st, vec2(st.x, st.x * st.x)); <span class="hljs-comment">// 这里的 st.x * st.x，即要画的函数，也可以通过参数传进来</span><br>    <span class="hljs-keyword">return</span> smoothstep(<span class="hljs-number">0.02</span>, <span class="hljs-number">0.</span>, dist);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>vec2 st = gl_FragCoord.xy/u_resolution;<br>    vec3 background = vec3(st.x * st.x);<br>    vec3 lineColor = vec3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">float</span> plot = plot(st);<br>    vec3 targetColor = vec3(mix(background, lineColor, plot)); <span class="hljs-comment">// mix(x, y, a) = (1 - a) * x + a * y</span><br>gl_FragColor = vec4(targetColor, <span class="hljs-number">1.</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/fnWithBackground.png" alt="通过线和灰度来表示函数"></p><h1 id="组合图形"><a href="#组合图形" class="headerlink" title="组合图形"></a>组合图形</h1><p>就像绘画时复杂的形体可以认为是简单的几何体的组合，使用 glsl 也可以组合不同的形状来绘制复杂图形；最简单的组合显然是加法（加法需要做一个<code>clamp(0, 1)</code>来保证最终的值仍然是归一化的）和乘法，分别对应求两个图形的并集和交集，比如下面就用四个图形的交集绘制一个矩形：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>uniform vec2 u_resolution;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    vec2 st = gl_FragCoord.xy/u_resolution;<br><span class="hljs-type">float</span> color = <span class="hljs-number">1.</span>;<br>    <span class="hljs-type">float</span> left = step(<span class="hljs-number">.25</span>, st.x); <span class="hljs-comment">// 绘制左边框</span><br>    <span class="hljs-type">float</span> bottom = step(<span class="hljs-number">.25</span>, st.y); <span class="hljs-comment">// 绘制下边框</span><br>    <span class="hljs-type">float</span> right =  step(st.x, <span class="hljs-number">.75</span>); <span class="hljs-comment">// 绘制右边框（step(x, .5) = 1 - step(.5, x)）</span><br>    <span class="hljs-type">float</span> top =  step(st.y, <span class="hljs-number">.75</span>); <span class="hljs-comment">// 绘制下边框</span><br>    color *= left; <span class="hljs-comment">// 求四个图形的交集</span><br>    color *= bottom;<br>    color *= right;<br>    color *= top;<br>    gl_FragColor = vec4(vec3(color),<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rectangle.png"></p><p>该流程可以抽象成返回 float 的函数，返回 1 时表示需要绘制该图形，返回 0 时表示需要绘制背景，结合这样的函数和 mix 函数，就可以绘制多层的图像了，下面使用该方法临摹一幅抽象画：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>uniform vec2 u_resolution;<br><span class="hljs-comment">// 使用 floor 实现 step，just for practice</span><br>vec2 <span class="hljs-title function_">myStep</span><span class="hljs-params">(vec2 threshold, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">floor</span>(st - threshold) + <span class="hljs-number">1.</span>;<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">rectangle</span><span class="hljs-params">(vec2 start, vec2 end, vec2 st)</span> &#123;<br>vec2 realStart = vec2(min(start.x, end.x), min(start.y, end.y)); <span class="hljs-comment">// 找到实际左下角的点</span><br>    vec2 realEnd = vec2(max(start.x, end.x), max(start.y, end.y)); <span class="hljs-comment">// 找到实际右上角的点</span><br>    vec2 bl = step(realStart, st); <span class="hljs-comment">// bottom left, 在起始点的左边时，x=0，否则 x=1；在起始点点下边时，y=0，否则 y=1</span><br>vec2 tr = <span class="hljs-number">1.</span> - step(realEnd, st); <span class="hljs-comment">// top right, 在终止点的右边时，x=0，否则 x=1，在终止点上面时，y=0，否则 y=1</span><br>    <span class="hljs-keyword">return</span> bl.x * bl.y * tr.x * tr.y;<br>&#125;<br><br><span class="hljs-comment">// 画一幅抽象画</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    vec2 st = gl_FragCoord.xy/u_resolution.xy;<br>    vec3 background = vec3(<span class="hljs-number">247.</span>, <span class="hljs-number">239.</span>, <span class="hljs-number">220.</span>) / <span class="hljs-number">255.</span>;<br>    vec3 red = vec3(<span class="hljs-number">170.</span>, <span class="hljs-number">40.</span>, <span class="hljs-number">40.</span>) / <span class="hljs-number">255.</span>;<br>    vec3 orange = vec3(<span class="hljs-number">250.</span>, <span class="hljs-number">195.</span>, <span class="hljs-number">68.</span>) / <span class="hljs-number">255.</span>;<br>    vec3 skyBlue = vec3(<span class="hljs-number">17.</span>, <span class="hljs-number">83.</span>, <span class="hljs-number">140.</span>) / <span class="hljs-number">255.</span>;<br>    vec3 black = vec3(<span class="hljs-number">19.</span>, <span class="hljs-number">19.</span>, <span class="hljs-number">24.</span>) / <span class="hljs-number">255.</span>;<br><br>    vec3 color = background;<br>    <span class="hljs-comment">// 色块</span><br>    color = mix(color, red, rectangle(vec2(<span class="hljs-number">0.</span>,<span class="hljs-number">1.</span>), vec2(<span class="hljs-number">0.260</span>,<span class="hljs-number">0.590</span>), st));<br>    color = mix(color, orange, rectangle(vec2(<span class="hljs-number">0.920</span>,<span class="hljs-number">0.590</span>), vec2(<span class="hljs-number">1.</span>), st));<br>    color = mix(color, skyBlue, rectangle(vec2(<span class="hljs-number">0.730</span>,<span class="hljs-number">-1.000</span>), vec2(<span class="hljs-number">1.000</span>,<span class="hljs-number">0.120</span>), st));<br>    <span class="hljs-comment">// 竖线</span><br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.220</span>,<span class="hljs-number">0.000</span>), vec2(<span class="hljs-number">0.260</span>,<span class="hljs-number">1.0</span>), st));<br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.730</span>,<span class="hljs-number">-0.010</span>), vec2(<span class="hljs-number">0.77</span>,<span class="hljs-number">1.0</span>), st));<br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.910</span>,<span class="hljs-number">-0.020</span>), vec2(<span class="hljs-number">0.95</span>,<span class="hljs-number">1.0</span>), st));<br>    <span class="hljs-comment">// 横线</span><br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.</span>,<span class="hljs-number">0.590</span>), vec2(<span class="hljs-number">1.000</span>,<span class="hljs-number">0.640</span>), st));<br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.</span>, <span class="hljs-number">0.790</span>), vec2(<span class="hljs-number">1.000</span>,<span class="hljs-number">0.840</span>), st));<br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.220</span>,<span class="hljs-number">0.090</span>), vec2(<span class="hljs-number">1.000</span>,<span class="hljs-number">0.140</span>), st));<br>    gl_FragColor = vec4(color,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/abstractPaint.png" alt="还蛮抽象的"></p><h1 id="二维变换"><a href="#二维变换" class="headerlink" title="二维变换"></a>二维变换</h1><p>首先定义一个在原点处绘制坐标系和绘制一个描边矩形的函数，方便后面做示例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159265359</span><br>uniform vec2 u_resolution;<br><span class="hljs-type">float</span> <span class="hljs-title function_">rectangle</span><span class="hljs-params">(vec2 start, vec2 end, vec2 st)</span> &#123;<br>vec2 realStart = vec2(min(start.x, end.x), min(start.y, end.y)); <span class="hljs-comment">// 找到实际左下角的点</span><br>    vec2 realEnd = vec2(max(start.x, end.x), max(start.y, end.y)); <span class="hljs-comment">// 找到实际右上角的点</span><br>    vec2 bl = step(realStart, st); <span class="hljs-comment">// bottom left, 在起始点的左边时，x=0，否则 x=1；在起始点点下边时，y=0，否则 y=1</span><br>vec2 tr = <span class="hljs-number">1.</span> - step(realEnd, st); <span class="hljs-comment">// top right, 在终止点的右边时，x=0，否则 x=1，在终止点上面时，y=0，否则 y=1</span><br>    <span class="hljs-keyword">return</span> bl.x * bl.y * tr.x * tr.y;<br>&#125;<br>vec2 <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">float</span> angle, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> mat2(<span class="hljs-built_in">cos</span>(angle),-<span class="hljs-built_in">sin</span>(angle),<br>                <span class="hljs-built_in">sin</span>(angle),<span class="hljs-built_in">cos</span>(angle)) * st;<br>&#125;<br><span class="hljs-comment">// 在原点处绘制坐标系</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">coorSys</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> xAxis = rectangle(vec2(<span class="hljs-number">-1.</span>, <span class="hljs-number">-.01</span>), vec2(<span class="hljs-number">1.25</span>, <span class="hljs-number">.01</span>), st) + rectangle(vec2(<span class="hljs-number">.49</span>, <span class="hljs-number">-.05</span>), vec2(<span class="hljs-number">.51</span>, <span class="hljs-number">.05</span>), st) + rectangle(vec2(<span class="hljs-number">.99</span>, <span class="hljs-number">-.1</span>), vec2(<span class="hljs-number">1.01</span>, <span class="hljs-number">.1</span>), st);<br>    <span class="hljs-type">float</span> yAxis = rectangle(vec2(<span class="hljs-number">-.01</span>, <span class="hljs-number">-1.</span>), vec2(<span class="hljs-number">.01</span>, <span class="hljs-number">1.25</span>), st) + rectangle(vec2(<span class="hljs-number">-.05</span>, <span class="hljs-number">.49</span>), vec2(<span class="hljs-number">.05</span>, <span class="hljs-number">.51</span>), st) + rectangle(vec2(<span class="hljs-number">-.1</span>, <span class="hljs-number">.99</span>), vec2(<span class="hljs-number">.1</span>, <span class="hljs-number">1.01</span>), st);<br>    vec2 arrowX = rotate(PI / <span class="hljs-number">-4.</span>, st - vec2(<span class="hljs-number">1.2</span>, <span class="hljs-number">0.</span>));<br>    vec2 arrowY = rotate(PI / <span class="hljs-number">4.</span>, st - vec2(<span class="hljs-number">0.</span>, <span class="hljs-number">1.2</span>));<br>    <span class="hljs-keyword">return</span> clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, xAxis + yAxis + rectangle(vec2(<span class="hljs-number">0.</span>), vec2(<span class="hljs-number">0.1</span>), arrowX)+ rectangle(vec2(<span class="hljs-number">0.</span>), vec2(<span class="hljs-number">0.1</span>), arrowY));<br>&#125;<br><span class="hljs-comment">// 中心在原点处，长宽均为 0.25 的描边矩形</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">box</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, rectangle(vec2(<span class="hljs-number">-.26</span>), vec2(<span class="hljs-number">.26</span>), st) - rectangle(vec2(<span class="hljs-number">-.24</span>), vec2(<span class="hljs-number">.24</span>), st));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>每次对坐标进行修改时，我们就是在进行二维变换，最简单的二维变换包括平移，旋转，缩放，工业上这玩意应该是用齐次矩阵做的，但这里图简单。</p><p>如何理解二维变换？可以认为，每次对原坐标做映射，得到一个新坐标时，就是创建了一个对画布（后面把它称为世界坐标系）的新的<strong>视图</strong>坐标系（就像对数组或表的视图）。前面的学习中，其实也是在视图坐标系中绘制，只是它们正巧和世界坐标系一致罢了。当然，也可以以视图去建立视图，前者会成为后者的世界坐标系，相对和绝对嘛。</p><p>对每个像素，我们首先拿到的是它的世界坐标系的位置，我们需要找到这个像素在视图中的位置，并从视图的角度检查需要绘制何种内容。比如，将整个坐标系向右上角移动 (1, 1)。我们尝试在 (0, 0) 处绘制方块时，实际上就是在问，世界坐标系的哪里是我们的 (0, 0)？</p><p>为此，需要找到<strong>世界坐标系到视图的映射</strong>，下面的几种二维变换，实际上都是根据相应参数找到这样一个映射。</p><p>这个心智模型颇有些奇怪，第一印象是找到视图到世界坐标系的映射，但在这里似乎不适用，因为 glsl 做的是对世界坐标系的每一个坐标，检查它要画什么，而不是我要在（视图的）某个坐标画什么。前者的话，坐标的变换流程就会是 世界坐标系 -&gt; 视图 1 -&gt; 视图 2 -&gt; 当前视图，后者的话就是当前视图 -&gt; 视图 2 -&gt; 视图 1 -&gt; 世界坐标系。</p><p>实现了二维变换后，编写新的图形绘制函数的时候，只需要实现它在原点处的“单位”形状即可，后面的通过二维变换操作就行。</p><h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>要将坐标系平移到 (1, 2)，就需要以 (1, 2) 为原点建立一个坐标系，并始终在该坐标系下进行绘制，这样，代码在视图的 (0, 0) 处绘制时，实际上就是在世界坐标系的 (1, 2) 处绘制。</p><p>容易发现这样的对应关系：</p><table><thead><tr><th align="center">世界坐标系</th><th align="center">视图</th></tr></thead><tbody><tr><td align="center">(0, 0)</td><td align="center">(-1, -2)</td></tr><tr><td align="center">(1, 2)</td><td align="center">(0, 0)</td></tr></tbody></table><p>实现很显然了：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// dir：平移方向</span><br><span class="hljs-comment">// st: 世界坐标系</span><br><span class="hljs-comment">// return: 视图坐标系</span><br>vec2 <span class="hljs-title function_">translate</span><span class="hljs-params">(vec2 dir, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st - dir;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面的代码中利用平移在 (1, 1) 处绘制了一个矩形，并绘制了此时的视图坐标系。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 样板代码和上面引用的函数均省略，只写 main</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">但实现个函数包装一下 mix，避免重复</span><br><span class="hljs-comment">原本绘制多层的时候，遵循这样的模式：</span><br><span class="hljs-comment">vec3 color = background;</span><br><span class="hljs-comment">color = mix(color, newColor, shape(..., st))</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">考虑 color 通过引用传进去，避免反复赋值，可惜没闭包</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(inout vec3 background, vec3 color, <span class="hljs-type">float</span> pct)</span> &#123;<br>    background = mix(background, color, pct);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>vec2 st = gl_FragCoord.xy/u_resolution;<br>    <span class="hljs-comment">// 先 remap 一下空间（这其实也是创建了一个视图）</span><br>    st = st * <span class="hljs-number">4.</span> - <span class="hljs-number">1.</span>;<br>    vec3 c = vec3(<span class="hljs-number">0.</span>); <span class="hljs-comment">// 背景，纯黑</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), coorSys(st)); <span class="hljs-comment">// 原点处绘制纯白坐标系表示世界坐标系</span><br><br>    vec2 viewSt1 = translate(vec2(<span class="hljs-number">1.</span>), st); <span class="hljs-comment">// (1, 1) 处创建视图 1</span><br>    draw(c, vec3(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>), coorSys(viewSt1)); <span class="hljs-comment">// 视图 1 原点处绘制一个绿色坐标系表示视图</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), box(viewSt1)); <span class="hljs-comment">// 视图 1 原点处绘制矩形</span><br><br>    vec2 viewSt2 = translate(vec2(<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>), viewSt1); <span class="hljs-comment">// 从视图 1 处向 x 轴平移 1 再创建一个视图</span><br>    draw(c, vec3(<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">.5</span>), coorSys(viewSt2)); <span class="hljs-comment">// 视图 2 原点处绘制一个坐标系表示视图</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), box(viewSt2)); <span class="hljs-comment">// 视图 2 原点处绘制矩形</span><br><br>gl_FragColor = vec4(c,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/translateExample.png" alt="示例"></p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转直接抄作业，总之是视图坐标系的旋转（恼），用初高中的知识应该就能推导出来，但我已经失掉这个能力了。实现和示例如下，移动到 (1, 1)，然后再随时间旋转。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">vec2 <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">float</span> angle, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> mat2(<span class="hljs-built_in">cos</span>(angle),-<span class="hljs-built_in">sin</span>(angle),<br>                <span class="hljs-built_in">sin</span>(angle),<span class="hljs-built_in">cos</span>(angle)) * st; <span class="hljs-comment">// st 应该是当作列向量看待了</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>vec2 st = gl_FragCoord.xy/u_resolution;<br>    st = st * <span class="hljs-number">4.</span> - <span class="hljs-number">1.</span>;<br>    vec3 c = vec3(<span class="hljs-number">0.</span>); <span class="hljs-comment">// 背景，纯黑</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), coorSys(st)); <span class="hljs-comment">// 原点处绘制纯白坐标系表示世界坐标系</span><br><br>    vec2 viewSt1 = translate(vec2(<span class="hljs-number">1.</span>), st); <span class="hljs-comment">// (1, 1) 处创建视图 1</span><br>    vec2 viewSt2 = rotate(u_time, viewSt1); <span class="hljs-comment">// 旋转视图 1，得到视图 2</span><br>    draw(c, vec3(<span class="hljs-number">.3</span>, <span class="hljs-number">.3</span>, <span class="hljs-number">.5</span>), coorSys(viewSt2)); <span class="hljs-comment">// 视图 2 原点处绘制一个绿色坐标系表示视图</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), box(viewSt2)); <span class="hljs-comment">// 在视图 2 原点处绘制一个矩形</span><br>gl_FragColor = vec4(c,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rotateExample.gif" alt="旋转示例"></p><h3 id="平移和旋转"><a href="#平移和旋转" class="headerlink" title="平移和旋转"></a>平移和旋转</h3><p>同时使用平移和旋转时，平移和旋转的先后顺序会影响最终效果，但使用这套心智模型的话很容易理解它们的差异。</p><p>假设随时间旋转。先平移再旋转时，就是先向前走 10 步，然后原地转圈圈；先旋转再平移，就是在当前位置旋转，然后对每个角度，都向前走 10 步，它们的差别通过下面的例子可以看到；前者就是普通的原地转圈圈，后者类似月球围绕地球运动且潮汐锁定。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>vec2 st = gl_FragCoord.xy/u_resolution;<br>    st = st * <span class="hljs-number">4.</span> - <span class="hljs-number">2.</span>;<br>    vec3 c = vec3(<span class="hljs-number">0.</span>); <span class="hljs-comment">// 背景，纯黑</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), coorSys(st)); <span class="hljs-comment">// 原点处绘制纯白坐标系表示世界坐标系</span><br><br>    <span class="hljs-comment">// 交换这两行</span><br>    <span class="hljs-comment">// 因为不再使用原来的 st 了，可以直接对它赋值了</span><br>    st = translate(vec2(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>), st); <span class="hljs-comment">// 向前走 1</span><br>    st = rotate(u_time, st); <span class="hljs-comment">// 旋转</span><br><br>    draw(c, vec3(<span class="hljs-number">.3</span>, <span class="hljs-number">.3</span>, <span class="hljs-number">.5</span>), coorSys(st)); <span class="hljs-comment">// 视图原点处绘制一个绿色坐标系表示视图</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), box(st)); <span class="hljs-comment">// 视图原点处绘制一个矩形</span><br>gl_FragColor = vec4(c,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/translateThenRotate.gif" alt="先平移再旋转"></p><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rotateThenTranslate.gif" alt="先旋转再平移"></p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>缩放很好玩；如何把图形到原来的 2 倍呢？我们绘制图形还是同样的画，但需要这样一个效果，即我们在 (1, 0) 处绘制时，实际上要在 (2, 0) 处绘制，在 (2, 3) 处绘制时，实际上要在 (4, 6) 处绘制：</p><table><thead><tr><th align="center">世界坐标系</th><th align="center">视图</th></tr></thead><tbody><tr><td align="center">(2, 0)</td><td align="center">(1, 0)</td></tr><tr><td align="center">(4, 6)</td><td align="center">(2, 3)</td></tr></tbody></table><p>很显然了，实现和示例如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// ratio：缩放倍率，为 2 表示放大 2 倍，为 0.5 表示缩小到 1/2</span><br>vec2 <span class="hljs-title function_">scale</span><span class="hljs-params">(<span class="hljs-type">float</span> ratio, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st / ratio;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>vec2 st = gl_FragCoord.xy/u_resolution;<br>    st = st * <span class="hljs-number">4.</span> - <span class="hljs-number">2.</span>;<br>    vec3 c = vec3(<span class="hljs-number">0.</span>); <span class="hljs-comment">// 背景，纯黑</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), coorSys(st)); <span class="hljs-comment">// 原点处绘制纯白坐标系表示世界坐标系</span><br>st = translate(vec2(<span class="hljs-number">1.1</span>), st);<br>    st = scale(<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">sin</span>(u_time)) * <span class="hljs-number">2.</span>, st); <span class="hljs-comment">// 做一种类似弹跳的效果</span><br>    draw(c, vec3(<span class="hljs-number">.3</span>, <span class="hljs-number">.3</span>, <span class="hljs-number">.5</span>), coorSys(st));<br>    draw(c, vec3(<span class="hljs-number">1.</span>), box(st));<br>gl_FragColor = vec4(c,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/takeAJump.gif" alt="缩放示例"></p><h1 id="距离场"><a href="#距离场" class="headerlink" title="距离场"></a>距离场</h1><p>距离场是画面上任意一点同特定点的距离相关联的场，距离可以使用亮度来表示，距离越远，亮度越大。距离场并不是特定的几何图形，它是无穷大的，通过距离场来绘制各种东西是把它当作工具，而不是绘制它本身。利用距离场，能做出非常多有趣的效果，用途包括但不限于：</p><ol><li>绘制硬边和软边圆形</li><li>绘制对称圆形，矩形，四角星</li><li>为上述的形状描边</li></ol><p>注意下面的例子中使用 abs，max，min 等函数创建的视图。这个懒得截图了。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>uniform vec2 u_resolution;<br><br><span class="hljs-comment">// 普通画圆法，并非距离场，距离场是无限的</span><br><span class="hljs-comment">// c：圆心，r：半径，在圆内时返回 1，否则返回 0</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">circle</span><span class="hljs-params">(vec2 c, <span class="hljs-type">float</span> r, vec2 st)</span> &#123;<br>    <span class="hljs-comment">// 换成 smoothstep 就能做圆形渐变，非常 soft 的渐变</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.</span> - step(r, distance(c, st)); <span class="hljs-comment">// 避免使用 sqrt 能提高性能，但我又不是做游戏，不需要考虑性能</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  vec2 st = gl_FragCoord.xy/u_resolution.xy;<br>  vec3 color = vec3(<span class="hljs-number">0.0</span>);<br>  <span class="hljs-type">float</span> d = <span class="hljs-number">0.0</span>;<br><br>  <span class="hljs-comment">// 把坐标系转换为-1,1，原点为 0,0</span><br>  st = st *<span class="hljs-number">2.</span><span class="hljs-number">-1.</span>;<br><br>  <span class="hljs-comment">// 做到原点的距离场（这书给的示例实在太少了！）</span><br>  d = length(st);<br><br>  <span class="hljs-comment">// 离散距离场，很漂亮</span><br>  d = length(<span class="hljs-built_in">floor</span>(st * <span class="hljs-number">10.</span>) / <span class="hljs-number">10.</span>);<br><br>  <span class="hljs-comment">// 各种奇怪的距离场，可以把它们考虑成先对 st 做某种变换，再求变换后的点到原点的距离并展示</span><br>  <span class="hljs-comment">// 对每个 st，向左下移动 0.3 再求到原点的距离，这样，原点处的值为 0.3*sqrt(2)，0.3 处的值为 0，即最暗；相当于整个厂向右上移动了 0.3</span><br>  <span class="hljs-comment">// d = length(st -.3 );</span><br><br>  <span class="hljs-comment">// 对 st 取绝对值并向左下移动 0.3，相当于对上一个例子，把第一象限的内容对称变换到其他象限</span><br>  <span class="hljs-comment">// d = length( abs(st)-.3 );</span><br><br>  <span class="hljs-comment">// 在第一象限时，始终为 0，第三象限时正常做圆渐变，第二象限时，只和 x 坐标相关（y 恒为 0），第四象限时，只和 y 坐标相关（x 恒为 0）（注意这种性质能造成直线</span><br>  <span class="hljs-comment">// d = length(min(st, 0.));</span><br><br>  <span class="hljs-comment">// min 沿 y=-x 的轴对称</span><br>  <span class="hljs-comment">// d = length(max(st, 0.));</span><br><br>  <span class="hljs-comment">// 在第一象限时，始终为 0，把第一象限的内容对称变换到其他象限，我是说，全为 0</span><br>  <span class="hljs-comment">// d = length(min(abs(st), 0.));</span><br><br>  <span class="hljs-comment">// 在第一象限时，正常做圆渐变，把第一象限的内容对称变换到其他象限，我是说，和 length(st) 一致</span><br>  <span class="hljs-comment">// d = length(max(abs(st), 0.));</span><br><br>  <span class="hljs-comment">// 假设 0.3, 0.3 为圆心，在第三象限，正常做圆渐变，第一象限全为 0，第二象限只和 x 相关，第四象限只和 y 相关</span><br>  <span class="hljs-comment">// d = length( min(st-.3,0.) );</span><br><br>  <span class="hljs-comment">// 对上一个例子，把第一象限的内容对称变换到其他象限，形状类似一个十字</span><br>  <span class="hljs-comment">// d = length( min(abs(st)-.3,0.) );</span><br><br>  <span class="hljs-comment">// 假设 0.3, 0.3 为圆心，在第一象限，正常做圆渐变，第三象限全为 0，第二象限只和 y 相关，第四象限只和 x 相关</span><br>  <span class="hljs-comment">// d = length( max(st-.3,0.) );</span><br><br>  <span class="hljs-comment">// 对上一个例子，把第一象限的内容对称变换到其他象限，形状类似矩形</span><br>  <span class="hljs-comment">// d = length( max(abs(st)-.3,0.) );</span><br><br>  <span class="hljs-comment">// ==========================================================================================</span><br>  <span class="hljs-comment">// 可视化距离场，这个直接用距离来作为亮度，可以用来 debug</span><br>  gl_FragColor = vec4(vec3(d),<span class="hljs-number">1.0</span>);<br><br>  <span class="hljs-comment">// 其他可视化方法</span><br>  <span class="hljs-comment">// 使用 fract 做出同心圆（漏斗）效果</span><br>  <span class="hljs-comment">// gl_FragColor = vec4(vec3(fract(d * 10.0)),1.0);</span><br><br>  <span class="hljs-comment">// 绘制硬边图像</span><br>  <span class="hljs-comment">// gl_FragColor = vec4(vec3( step(.3,d) ),1.0);</span><br><br>  <span class="hljs-comment">// 描边，利用两个 step 相乘造成一个“脉冲”的函数</span><br>  <span class="hljs-comment">// gl_FragColor = vec4(vec3( step(.3,d) * step(d,.4)),1.0);</span><br><br>  <span class="hljs-comment">// 同上，但软边缘</span><br>  <span class="hljs-comment">// gl_FragColor = vec4(vec3( smoothstep(.3,.4,d)* smoothstep(.6,.5,d)) ,1.0);</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/discreteDistanceField.png" alt="离散距离场"></p><p>下面利用距离场和二维变换绘制了开头的 MyGo!!!!!! 的罗盘 logo，写得仓促，将就看。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br>uniform <span class="hljs-type">float</span> u_time;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159265359</span><br><br>vec2 <span class="hljs-title function_">translate</span><span class="hljs-params">(vec2 dir, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st - dir;<br>&#125;<br>vec2 <span class="hljs-title function_">scale</span><span class="hljs-params">(vec2 ratio, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st / ratio;<br>&#125;<br>vec2 <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">float</span> angle, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> mat2(<span class="hljs-built_in">cos</span>(angle),-<span class="hljs-built_in">sin</span>(angle),<br>                <span class="hljs-built_in">sin</span>(angle),<span class="hljs-built_in">cos</span>(angle)) * st;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(inout vec3 background, vec3 color, <span class="hljs-type">float</span> pct)</span> &#123;<br>    background = mix(background, color, pct);<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">shape0</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-keyword">if</span> (st.x &lt; <span class="hljs-number">0.</span> || st.y &lt; <span class="hljs-number">0.</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.</span>;<br>    <span class="hljs-type">float</span> a = <span class="hljs-number">2.414</span> * st.x - <span class="hljs-number">0.589</span>;<br>    <span class="hljs-keyword">return</span> clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, sign(st.y - a) - sign(st.y - st.x));<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">dist2line</span><span class="hljs-params">(<span class="hljs-type">float</span> k, <span class="hljs-type">float</span> b, vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> x = st.x;<br>    <span class="hljs-type">float</span> y = st.y;<br>    <span class="hljs-type">float</span> A = k;<br>    <span class="hljs-type">float</span> B = <span class="hljs-number">-1.</span>;<br>    <span class="hljs-type">float</span> C = b;<br>    <span class="hljs-type">float</span> dist = <span class="hljs-built_in">abs</span>(A * x + B * y + C) / <span class="hljs-built_in">sqrt</span>(A * A + B * B) ;<br>    <span class="hljs-keyword">return</span> dist;<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">belowLine</span><span class="hljs-params">(<span class="hljs-type">float</span> k, <span class="hljs-type">float</span> b, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> step(st.y - k * st.x - b, <span class="hljs-number">0.</span>);<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">lb</span><span class="hljs-params">(vec2 x, vec2 st)</span> &#123;<br>    vec2 r = step(st, vec2(x));<br>    <span class="hljs-keyword">return</span> r.x * r.y;<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">drawPart</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> test;<br>    test += (step(<span class="hljs-number">0.691</span>, length(st)) * step(length(st), <span class="hljs-number">0.8333</span>));<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    test += belowLine(<span class="hljs-number">-15.</span> * PI / <span class="hljs-number">180.</span>, <span class="hljs-number">0.2557</span>, st);<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, belowLine(<span class="hljs-number">-15.</span> * PI / <span class="hljs-number">180.</span>, <span class="hljs-number">0.2557</span>, vec2(st.y, st.x))) + test);<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    test += shape0(st) + shape0(vec2(st.y, st.x));<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    test -= clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, belowLine(<span class="hljs-number">-15.</span> * PI / <span class="hljs-number">180.</span>, <span class="hljs-number">0.2083</span>, vec2(st.x, st.y)));<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    test += belowLine(<span class="hljs-number">60.</span> * PI / <span class="hljs-number">180.</span>, <span class="hljs-number">0.</span>, vec2(st.y, st.x)) * lb(vec2(<span class="hljs-number">.24</span>), st);<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    <span class="hljs-keyword">return</span> st.x &lt; <span class="hljs-number">0.</span> || st.y &lt; <span class="hljs-number">0.</span> ? <span class="hljs-number">0.</span> : test;<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">myGo</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> res;<br>    res += drawPart(st);<br>    st = rotate(<span class="hljs-number">90.</span> * PI / <span class="hljs-number">180.</span>, st);<br>    res += drawPart(st);<br>    st = rotate(<span class="hljs-number">90.</span> * PI / <span class="hljs-number">180.</span>, st);<br>    res += drawPart(st);<br>    st = rotate(<span class="hljs-number">90.</span> * PI / <span class="hljs-number">180.</span>, st);<br>    res += drawPart(st);<br>    st = rotate(<span class="hljs-number">90.</span> * PI / <span class="hljs-number">180.</span>, st);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>vec2 st = gl_FragCoord.xy/u_resolution;<br>    vec3 blue = vec3(<span class="hljs-number">51.</span>, <span class="hljs-number">124.</span>, <span class="hljs-number">175.</span>) / <span class="hljs-number">255.</span>;<br>    st = st * <span class="hljs-number">2.</span> - <span class="hljs-number">1.</span>;<br>    st = rotate(u_time, st);<br>    vec3 c = blue;<br>    draw(c, vec3(<span class="hljs-number">1.</span>), myGo(st));<br>gl_FragColor = vec4(c,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>很多时候需要创建重复的图案，但是又不想挨个绘制，而是期待它们能自己就重复，使用 fract 函数创建的视图允许做到这一点。fract 函数获取浮点数的小数部分，只要将浮点数乘以 10，做个 fract，就能得到重复 10 次的图像：</p><table><thead><tr><th align="center">x（世界坐标系）</th><th align="center">x * 10</th><th align="center">fract(x * 10)（视图）</th></tr></thead><tbody><tr><td align="center">0.01</td><td align="center">0.1</td><td align="center">0.1</td></tr><tr><td align="center">0.11</td><td align="center">1.1</td><td align="center">0.1</td></tr><tr><td align="center">0.21</td><td align="center">2.1</td><td align="center">0.1</td></tr></tbody></table><p>这样，只要我们在视图的 0.1 处绘图时，在 0.01，0.11，0.21 这三个坐标都能看到同样的结果，因为它们都对应着视图的 0.1。这样的每个重复的结果称为子空间。</p><p>一些例子如下。需要注意，在构造子空间前进行变换时，会对整个子空间进行变换，例子 2，3，4 都应用了这点；构造子空间后进行变换，则是分别对每个子空间进行变换。例子 4 结合了距离场做了一个渐变圆，这效果感觉画画时可以用到。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>uniform vec2 u_resolution;<br>uniform <span class="hljs-type">float</span> u_time;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159265359</span><br><br>vec2 <span class="hljs-title function_">translate</span><span class="hljs-params">(vec2 dir, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st - dir;<br>&#125;<br>vec2 <span class="hljs-title function_">scale</span><span class="hljs-params">(vec2 ratio, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st / ratio;<br>&#125;<br>vec2 <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">float</span> angle, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> mat2(<span class="hljs-built_in">cos</span>(angle),-<span class="hljs-built_in">sin</span>(angle),<br>                <span class="hljs-built_in">sin</span>(angle),<span class="hljs-built_in">cos</span>(angle)) * st;<br>&#125;<br><br><span class="hljs-comment">// 长宽为 1，边平行于坐标轴，中心在原点的正方形，测试用</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">box</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    vec2 bl = smoothstep(<span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>+<span class="hljs-number">.01</span>, st);<br>    vec2 tr = smoothstep(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span><span class="hljs-number">-.01</span>, st);<br>    <span class="hljs-keyword">return</span> bl.x * bl.y * tr.x * tr.y;<br>&#125;<br><br>vec2 <span class="hljs-title function_">tile</span><span class="hljs-params">(<span class="hljs-type">float</span> zoom, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> fract(st * zoom);<br>&#125;<br><br><span class="hljs-comment">// 展示 tile 的用法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">example0</span><span class="hljs-params">(out vec4 glFragColor, vec2 st)</span> &#123;<br>    st = tile(<span class="hljs-number">10.</span>, st);<br>    glFragColor = vec4(vec3(box(st)), <span class="hljs-number">1.</span>);<br>&#125;<br><br><span class="hljs-comment">// 通过矩阵变换操作每个子空间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">example1</span><span class="hljs-params">(out vec4 glFragColor, <span class="hljs-type">float</span> time, vec2 st)</span> &#123;<br>    <span class="hljs-comment">// 取消注释这两行，看世界旋转</span><br>    <span class="hljs-comment">// st = translate(vec2(.5), st);</span><br>    <span class="hljs-comment">// st = rotate(time, st);</span><br><br>    st = tile(<span class="hljs-number">10.</span>, st); <span class="hljs-comment">// 创建子空间</span><br>    <span class="hljs-comment">// 对每个子空间</span><br>    st = translate(vec2(<span class="hljs-number">.5</span>), st);<br>    st = scale(vec2(<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2.</span>) / <span class="hljs-number">2.</span>), st);<br>    st = rotate(time, st);<br>    glFragColor = vec4(vec3(box(st)), <span class="hljs-number">1.</span>);<br>&#125;<br><br><span class="hljs-comment">// 对子网格中的奇偶行进行不同的变换，就像砖墙上的砖块或者地砖</span><br><span class="hljs-comment">// 要知道当前是奇数行还是偶数行，需要处理 fract 之前的 st，首先 mod(2.)，然后再检查其中小于 1.0 的即为奇数行</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">example2</span><span class="hljs-params">(out vec4 glFragColor, <span class="hljs-type">float</span> time, vec2 st)</span> &#123;<br>    st /= vec2(<span class="hljs-number">2.15</span>,<span class="hljs-number">0.65</span>)/<span class="hljs-number">1.5</span>; <span class="hljs-comment">// 调整一下 st 的比例</span><br>    <span class="hljs-type">float</span> TILE_NUM = <span class="hljs-number">5.</span>;<br>    <span class="hljs-type">float</span> isOdd = step(mod(st.y * TILE_NUM, <span class="hljs-number">2.0</span>), <span class="hljs-number">1.</span>); <span class="hljs-comment">// 奇数时为 1，偶数时为 0</span><br>    <span class="hljs-comment">// 需要在 fract 之前进行偏移，注意偏移量大小要和子空间数量相关，因为子空间数量和子空间大小相关</span><br>    st = translate(vec2(isOdd * <span class="hljs-number">.5</span> / TILE_NUM, <span class="hljs-number">.0</span>), st);<br>    <span class="hljs-comment">// 大家都来动一动！</span><br>    <span class="hljs-comment">// st = translate(vec2(((isOdd * 2.) - 1.) * time, .0), st);</span><br><br>    st = tile(TILE_NUM, st);<br>    st = translate(vec2(<span class="hljs-number">.5</span>), st);<br>    st = scale(vec2(<span class="hljs-number">.9</span>), st);<br>    glFragColor = vec4(vec3(box(st)), <span class="hljs-number">1.</span>);<br>&#125;<br><br><span class="hljs-comment">// https://thebookofshaders.com/edit.php#09/marching_dots.frag</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">example3</span><span class="hljs-params">(out vec4 glFragColor, <span class="hljs-type">float</span> time, vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> TILE_NUM = <span class="hljs-number">10.</span>;<br>    <span class="hljs-comment">// 能发现，这张图有两种运动模式，因此需要分类讨论</span><br>    <span class="hljs-type">float</span> mode = step(<span class="hljs-number">1.</span>, mod(time, <span class="hljs-number">2.</span>)); <span class="hljs-comment">// 第一种模式，定义其为 x 轴运动，返回 0，否则返回 1，对应第二种模式</span><br>    <span class="hljs-comment">// 同样需要讨论为奇数还是偶数，这里要同时适应 mode 为 0 和 1 的情况，为 0 时研究 y 轴，为 1 时研究 x 轴</span><br>    <span class="hljs-type">float</span> isOdd = step(mod(st.y * TILE_NUM * (<span class="hljs-number">1.</span> - mode) + st.x * TILE_NUM * mode, <span class="hljs-number">2.0</span>), <span class="hljs-number">1.</span>);<br>    st = translate(vec2(((isOdd * <span class="hljs-number">2.</span>) - <span class="hljs-number">1.</span>) * time) * vec2(<span class="hljs-number">1.</span> - mode, mode) / TILE_NUM, st);<br>    st = tile(TILE_NUM, st);<br>    st = translate(vec2(<span class="hljs-number">.5</span>), st);<br>    st = scale(vec2(<span class="hljs-number">.5</span>), st);<br>    glFragColor = vec4(vec3(box(st)), <span class="hljs-number">1.</span>);<br>&#125;<br><br><span class="hljs-comment">// 一个渐变圆，通过黑白比例而非灰度去控制亮度</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">example4</span><span class="hljs-params">(out vec4 glFragColor, <span class="hljs-type">float</span> time, vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> TILE_NUM = <span class="hljs-number">23.</span>;<br>    <span class="hljs-comment">// 视图移动到中心</span><br>    st = translate(vec2(<span class="hljs-number">0.5</span>), st);<br>    st = rotate(time, st);<br>    <span class="hljs-comment">// 视图再移动到第一个子空间的中心（不如此的话旋转会导致沿第一个子空间的左下角位置旋转，而不是沿第一个子空间中心旋转）</span><br>    <span class="hljs-comment">// 因为子空间绘图的时候并非以子空间中心为中心</span><br>    st = translate(vec2(- <span class="hljs-number">1.</span> / TILE_NUM / <span class="hljs-number">2.</span>), st);<br>    <span class="hljs-comment">// 计算当前的子空间到中心的距离，要求子空间中每一个点得到的距离都是相同的</span><br>    <span class="hljs-type">float</span> tileDistance = length(<span class="hljs-built_in">floor</span>(st * TILE_NUM))/ TILE_NUM;<br><br>    st = tile(TILE_NUM, st);<br><br>    <span class="hljs-comment">// 对每个子空间</span><br>    st = translate(vec2(<span class="hljs-number">.5</span>), st);<br>    st = scale(vec2(clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>,<span class="hljs-number">1.</span> - tileDistance * <span class="hljs-number">2.</span>)), st);<br>    glFragColor = vec4(vec3(<span class="hljs-number">1.</span> - box(st)), <span class="hljs-number">1.</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    vec2 st = gl_FragCoord.xy/u_resolution;<br>    example0(gl_FragColor, st);<br>    example1(gl_FragColor, u_time, st);<br>    example2(gl_FragColor, u_time, st);<br>    example3(gl_FragColor, u_time, st);<br>    example4(gl_FragColor, u_time, st);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下图为例子3和例子4。</p><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/patternExp3.gif" alt="例子 3"></p><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/patternExp4.gif" alt="例子 4"></p><h1 id="圆形渐变半调子"><a href="#圆形渐变半调子" class="headerlink" title="圆形渐变半调子"></a>圆形渐变半调子</h1><p>“临摹”上面的第一张 SeExpr 作为结束。首先需要研究它们的效果。</p><p>第一张是圆形组成的半调子，能发现，每个圆形没有灰度变化，纯粹是根据每个小块黑白的比例来表示亮度的。</p><p>假设亮度从白到黑，圆形的大小从小到大的方向是 x 轴，垂直于此的方向为 y 轴，能发现 y 轴方向每一个圆形的间距都是一样的，显然，这里使用了 pattern 和距离场，x 轴方向越大就越暗。</p><p>但也能注意到，同一行中，随着 x 轴坐标变大，亮度并非是单调递增的，有时候会开一下倒车，这证明其中有一些随机性，但总体还是递增的。显然，对每一列，需要一个不同的亮度函数——想象柯里化，我们对每一列都构造一个这样的亮度函数。</p><p>但先忘记随机性，只考虑单调递增的情况。绘制这样的“单位”渐变的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 在 x=0 到 x=1 内，从 y=0 到 y=1 绘制该渐变</span><br><span class="hljs-comment">// density：0-1 内列的数量</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">magic</span><span class="hljs-params">(<span class="hljs-type">float</span> colNum, vec2 st)</span> &#123;<br>    <span class="hljs-comment">// 对每个子空间，获取该子空间的世界坐标，后面用来计算距离场</span><br>    vec2 dist = <span class="hljs-built_in">floor</span>(st * (colNum)) / colNum;<br>    <span class="hljs-comment">//创建子空间</span><br>    st = fract(st * colNum);<br>    <span class="hljs-comment">// 对每个子空间，获取它的亮度，并重映射到 (0, sqrt(2) / 2)（亮度为 1 时，对应圆的半径为 sqrt(2) / 2）</span><br>    <span class="hljs-comment">// 得到应当绘制的圆的半径</span><br>    <span class="hljs-type">float</span> r = lumaFn(dist) * <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2.</span>) / <span class="hljs-number">2.</span>;<br>    <span class="hljs-comment">// 在 (0.5, 0.5) 处绘制圆</span><br><br>    <span class="hljs-keyword">return</span> step(r, distance(st, vec2(<span class="hljs-number">0.5</span>)));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>示例如下，有点丑，或许得调整这个亮度函数，但就这样了：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159265359</span><br><br>vec2 <span class="hljs-title function_">translate</span><span class="hljs-params">(vec2 dir, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st - dir;<br>&#125;<br>vec2 <span class="hljs-title function_">scale</span><span class="hljs-params">(vec2 ratio, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st / ratio;<br>&#125;<br>vec2 <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">float</span> angle, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> mat2(<span class="hljs-built_in">cos</span>(angle),-<span class="hljs-built_in">sin</span>(angle),<br>                <span class="hljs-built_in">sin</span>(angle),<span class="hljs-built_in">cos</span>(angle)) * st;<br>&#125;<br><br><span class="hljs-comment">// 2D Random</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">random</span> <span class="hljs-params">(in vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> fract(<span class="hljs-built_in">sin</span>(dot(st.xy,<br>                         vec2(<span class="hljs-number">12.9898</span>,<span class="hljs-number">78.233</span>)))<br>                 * <span class="hljs-number">43758.5453123</span>);<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">noise</span> <span class="hljs-params">(in vec2 st)</span> &#123;<br>    vec2 i = <span class="hljs-built_in">floor</span>(st);<br>    vec2 f = fract(st);<br>    <span class="hljs-type">float</span> a = random(i);<br>    <span class="hljs-type">float</span> b = random(i + vec2(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>));<br>    <span class="hljs-type">float</span> c = random(i + vec2(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>));<br>    <span class="hljs-type">float</span> d = random(i + vec2(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>));<br>    vec2 u = f*f*(<span class="hljs-number">3.0</span><span class="hljs-number">-2.0</span>*f);<br>    <span class="hljs-keyword">return</span> mix(a, b, u.x) +<br>            (c - a)* u.y * (<span class="hljs-number">1.0</span> - u.x) +<br>            (d - b) * u.x * u.y;<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">lumaFn</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> noise = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, noise(st * <span class="hljs-number">2000.</span>));<br>    <span class="hljs-keyword">return</span> clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, st.y + (noise - <span class="hljs-number">0.4</span>) * st.y);<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">magic</span><span class="hljs-params">(<span class="hljs-type">float</span> colNum, vec2 st)</span> &#123;<br>    vec2 dist = <span class="hljs-built_in">floor</span>(st * (colNum )) / colNum;<br>    st = fract(st * colNum);<br>    <span class="hljs-type">float</span> r = lumaFn(dist) * <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2.</span>) / <span class="hljs-number">2.</span>;<br>    <span class="hljs-keyword">return</span> step(r, distance(st, vec2(<span class="hljs-number">0.5</span>)));<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    vec2 st = gl_FragCoord.xy/u_resolution.xy;<br>    <span class="hljs-type">float</span> COLNUM = <span class="hljs-number">40.</span>;<br>    st = rotate(PI / <span class="hljs-number">5.</span>, st);<br>    st = translate(vec2(<span class="hljs-number">0.</span>, <span class="hljs-number">-.5</span>), st);<br>    <span class="hljs-comment">// 对每一列，偏移 x 位置</span><br>    <span class="hljs-type">float</span> colX = <span class="hljs-built_in">floor</span>(st.x * COLNUM) / COLNUM;<br><br>    st = translate(vec2(<span class="hljs-number">0</span>, colX / <span class="hljs-number">5.</span>), st);<br>st = st * <span class="hljs-number">2.</span>;<br>    <span class="hljs-type">float</span> n = magic(COLNUM, st);<br><br>    gl_FragColor = vec4(vec3(n), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/dirtyWork.png" alt="和我的画一样糙"></p><p>当前学的东西其实非常有限，都是最基础的东西，但我意识到<strong>我不应该当前就去追求这种很“风格化”的东西，先把基础学好吧</strong>！之后或许会学一些 blender 和程序化建模来方便学习和实验，GLSL 和 SeExpr 就先这样了，已经收获足够多，必可活用于下一次。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习笔记——MLP</title>
    <link href="/2023/06-09%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94MLP.html"/>
    <url>/2023/06-09%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94MLP.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Callable</span>, <span class="hljs-type">Tuple</span><br><span class="hljs-comment"># 下面的数组均使用numpy的多维数组</span><br></code></pre></div></td></tr></table></figure><h1 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h1><p>神经元是神经网络中的基础单元，它包含输入，权重，偏置，输出，激活函数等概念；一个神经元有多个<strong>输入</strong>，每个输入端均有自己的<strong>权重</strong>，将神经元的每一个输入都和自己的权重相乘，将结果相加，最后再和<strong>偏置</strong>相加，将结果传递给<strong>激活函数</strong>，得到的便是神经元的输出；神经元可以有多个输出，它们的值相同。使用代码表达的话，神经元的输出为：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">output</span>(<span class="hljs-params">xs, ws, bs, activate_fn</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param xs: 输入，为n维实数数组</span><br><span class="hljs-string">    :param ws: 权重，为n维实数数组</span><br><span class="hljs-string">    :param bs: 偏置，为实数</span><br><span class="hljs-string">    :param activate_fn: 激活函数</span><br><span class="hljs-string">    :return:   输出值</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 将输入，权重均看作是向量，因此它们的点乘就是每一个输入和对应权重相乘并相加</span><br>    <span class="hljs-keyword">return</span> activate_fn(xs.dot(ws) + bs)<br></code></pre></div></td></tr></table></figure><p>在想象特定神经元的时候，应该想象神经元本身和它的输入，就像<strong>水母</strong>。</p><h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><p>激活函数是接受实数返回实数的一元函数，<strong>激活函数不能是线性函数</strong>（线性函数就是满足对任意a，b，有<code>f(a + b) = f(a) + f(b)</code>的函数，比如<code>f(x)=2x</code>），常用的激活函数有 sigmoid，ReLU等，它们的定义分别如下：</p><p>$$ sigmoid(x) &#x3D; \frac{1}{1 + e^{-x}} $$</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ReLU</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, x)<br></code></pre></div></td></tr></table></figure><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>神经网络由多层神经元组成，一层神经元由多个神经元组成，第一层和最后一层称为输入层和输出层。神经网络的层数有多种计数方式，这里只计数<strong>拥有权重</strong>的层。</p><p>假如上一层的输出为<code>[x1, x2, x3]</code>，当前层有两个神经元，偏置和权重分别为<code>w11, w12, w13, b1</code>，<code>w21, w22, w23, b2</code>，则两个神经元的在<strong>执行激活函数前</strong>的输出为：</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">a1</span> = <span class="hljs-built_in">x1</span> * <span class="hljs-built_in">w11</span> + <span class="hljs-built_in">x2</span> * <span class="hljs-built_in">w12</span> + <span class="hljs-built_in">x3</span> * <span class="hljs-built_in">w13</span> + b1<br><span class="hljs-symbol">a2</span> = <span class="hljs-built_in">x1</span> * <span class="hljs-built_in">w21</span> + <span class="hljs-built_in">x2</span> * <span class="hljs-built_in">w22</span> + <span class="hljs-built_in">x3</span> * <span class="hljs-built_in">w23</span> + b2<br></code></pre></div></td></tr></table></figure><p>显然，这可以使用矩阵乘法和加法来描述：</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm">[<span class="hljs-built_in">a1</span>, <span class="hljs-built_in">a2</span>] = [<span class="hljs-built_in">x1</span>, <span class="hljs-built_in">x2</span>, <span class="hljs-built_in">x3</span>] * [[<span class="hljs-built_in">w11</span>, <span class="hljs-built_in">w21</span>], + [b1,<br>                           [<span class="hljs-built_in">w12</span>, <span class="hljs-built_in">w22</span>],    b2]<br>                           [<span class="hljs-built_in">w13</span>, <span class="hljs-built_in">w23</span>]]<br></code></pre></div></td></tr></table></figure><p>只需要将<code>[a1, a2]</code>中每一个元素执行一下激活函数即可得到该层的神经元的输出。这证明，<strong>除输入层以外，每一层神经元都可以用一个权重矩阵和一个偏置矩阵来表示。权重矩阵中，每个神经元的权重作为一列并横向拼接，偏置矩阵是一个每个神经元组成的行向量。输入和输出也是行向量</strong>。输入层没有输入和偏置，它的输出由外界给定。</p><p>下面会将权重矩阵和偏置矩阵统称为权重矩阵。</p><p>输出层使用的激活函数可以与中间层不同，比如对分类问题，可以使用softmax函数，对回归问题，即根据已有的数据去<strong>预测</strong>特定输入下的输出的问题，可以使用恒等函数。softmax的实现如下，它的性质是每个输出和该层其它神经元的输出相关联，所有神经元的输出总和为1，这让我们能够赋予每个神经元的输出以“概率”的语义。</p><p>$$ softmax(k) &#x3D; \frac{e^{a_k}}{\sum_{i &#x3D; 1}^{n} e^{a_i}} &#x3D; \frac{Ce^{a_k}}{C\sum_{i &#x3D; 1}^{n} e^{a_i}} &#x3D; \frac{e^{a_k + \log_{}{C}}}{\sum_{i &#x3D; 1}^{n} e^{a_i + \log_{}{C}}} &#x3D; \frac{e^{a_k + C’}}{\sum_{i &#x3D; 1}^{n} e^{a_i + C’}} $$</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 这里对softmax的公式进行一些转换（所有值减去其中最大的），避免e^ai太大导致越界</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">x</span>):<br>    c = np.<span class="hljs-built_in">max</span>(x)<br>    exp_a = np.exp(x - c)<br>    <span class="hljs-keyword">return</span> exp_a / np.<span class="hljs-built_in">sum</span>(exp_a)<br></code></pre></div></td></tr></table></figure><h1 id="前向传播-x2F-推理"><a href="#前向传播-x2F-推理" class="headerlink" title="前向传播 &#x2F; 推理"></a>前向传播 &#x2F; 推理</h1><p>把输入丢给神经网络，去获得它的输出，就是所谓的前向传播&#x2F;推理，下面是一个三层神经网络（中间层第一、二层，输出层，这三层有权重）推理的函数：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">x, w1, b1, w2, b2, w3, b3, activate_fn, output_activate_fn = <span class="hljs-keyword">lambda</span> x: x</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param x:  输入</span><br><span class="hljs-string">    :param w1: 第一层的权重矩阵，列数为神经元的数量，行数为输入的数量</span><br><span class="hljs-string">    :param b1: 第一层的偏置行向量，大小为神经元数量</span><br><span class="hljs-string">    :param w2: 第二层的权重矩阵，列数为神经元的数量，行数为第一层的神经元的数量</span><br><span class="hljs-string">    :param b2: 第二层的偏置，大小为神经元数量</span><br><span class="hljs-string">    :param w3: 输出层的权重矩阵，列数为神经元的数量，行数为第二层的神经元的数量</span><br><span class="hljs-string">    :param b3: 输出层的偏置，大小为神经元数量</span><br><span class="hljs-string">    :param activate_fn: 中间层的激活函数</span><br><span class="hljs-string">    :param output_activate_fn: 输出层的激活函数，比如恒等函数</span><br><span class="hljs-string">    :return: 输出</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    a1 = x @ w1 + b1<br>    z1 = activate_fn(a1)<br>    a2 = z1 @ w2 + b2<br>    z2 = activate_fn(a2)<br>    a3 = z2 @ w3 + b3<br>    z3 = output_activate_fn(a3)<br>    <span class="hljs-keyword">return</span> z3<br></code></pre></div></td></tr></table></figure><h1 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h1><p>导数，即函数在特定位置上的变化程度，根据数学公式去化简求导所求得的结果称为解析解，去近似地算出的结果称为数值解，数值解是很容易求的——给定尽量小的dx，求出<code>(f(x + dx) - f(x)) / dx</code>即可：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">numerical_diff</span>(<span class="hljs-params">f, x, h=<span class="hljs-number">1e-4</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    求函数f在位置x上的导数，该操作称为数值微分 numerical differentiation</span><br><span class="hljs-string">    :param f: 一元函数</span><br><span class="hljs-string">    :param x: 函数入参</span><br><span class="hljs-string">    :param h: dx</span><br><span class="hljs-string">    :return: 函数f在x处的导数</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># (f(x + dx) - f(x)) / dx 称为前向差分，(f(x + dx) - f(x - dx)) / 2dx 称为中心差分，能减少误差</span><br>    <span class="hljs-keyword">return</span> (f(x + h) - f(x - h)) / (<span class="hljs-number">2</span> * h)<br><br><span class="hljs-comment"># 如，函数f(x) = x^2 在 x=1处的导数为：</span><br>numerical_diff(<span class="hljs-keyword">lambda</span> x: x ** <span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># 1.9999999999992246，非常接近 f&#x27;(x) = 2x, f&#x27;(1) = 2</span><br></code></pre></div></td></tr></table></figure><div class="hljs code-wrapper"><pre><code class="hljs">1.9999999999992246</code></pre></div><p>但光处理一元函数是不够的，我们需要处理多元函数的导数，即该函数对每一个参数的偏导数；求特定参数序列下任意一个参数的偏导数，就是固定其它参数，对该参数求导数，这个行为很像<strong>柯里化</strong>。所有偏导数组成的序列称为梯度。</p><p>下面是求梯度的函数：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gradient</span>(<span class="hljs-params">f, x, h=<span class="hljs-number">1e-4</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param f: 要求梯度的函数</span><br><span class="hljs-string">    :param x: 函数参数，以任意维数组的形式</span><br><span class="hljs-string">    :param h: dx</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    res = np.zeros_like(x) <span class="hljs-comment"># zeros_like返回形状和x相同，全为0的数组</span><br>    <span class="hljs-keyword">for</span> i, _ <span class="hljs-keyword">in</span> np.ndenumerate(x): <span class="hljs-comment"># ndenumerate函数能够迭代任意维数组，比如对三维数组，i会分别为(0, 0, 0), (0, 0, 1), (0, 1, 0)...</span><br>        <span class="hljs-comment"># 计算第i个参数的偏导，这里直接修改x</span><br>        ori = x[i]<br>        x[i] = ori + h<br>        f1 = f(x)<br>        x[i] = ori - h<br>        f0 = f(x)<br>        x[i] = ori<br>        res[i] = (f1 - f0) / (<span class="hljs-number">2</span> * h)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></div></td></tr></table></figure><p>显然，该方法能够尽量减少对象拷贝，移动的损失，但它同时是线程不安全的，无法并发执行，将来必须改良。</p><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>梯度表明了函数在当前“位置”上的运动的“趋势”，对每一个偏导数，当它大于0时，就意味着向该方向运动时，该方向的值会变大，小于0时，向该方向运动时，该方向的值会变小。这意味着，只要向梯度的符号相反的方向运动，值必定会减小，这意味着我们能够找到函数的（可能是局部也可能是全局的）<strong>最小值</strong>（或者最大值，这无关紧要）。根据梯度找到函数的最小值的方法称为梯度下降法。</p><p>下面的函数使用梯度下降法实现了求解平方根，思路是<strong>构造这样一个函数，它的最小值即为所求的平方根，然后找到一个初始值，不断往梯度下降的方向去移动，最终会找到函数的局部或全局的最小值</strong>：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 这个例子其实不太恰当，因为这里用的函数是不光滑的，函数值为0的位置前后的梯度有一个阶跃，但通过梯度下降法确实能求得结果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt</span>(<span class="hljs-params">x, lr=<span class="hljs-number">1e-3</span>, step_num=<span class="hljs-number">1000</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用梯度法求平方根</span><br><span class="hljs-string">    :param x: 入参</span><br><span class="hljs-string">    :param lr: learn rate，学习率</span><br><span class="hljs-string">    :param step_num: 步数</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># d的初始值不能设为0，因为函数在这里的梯度为0且前后对称，配合上中心差分，它就不动了</span><br>    <span class="hljs-comment"># d也必须是可变的，不然gradient函数无法修改d了（因为下面的trick），这里的一维数组起着box的作用</span><br>    d = np.array([<span class="hljs-number">1</span>], dtype=np.float64)<br>    <span class="hljs-comment"># 该函数即为所需函数，在d=sqrt(x)的位置下它的值为0</span><br>    <span class="hljs-comment"># 这里用了一个trick——函数通过闭包而非参数去引用d，函数的参数是无意义的，仅用于适配梯度函数中f的形式</span><br>    <span class="hljs-comment"># 在使用该函数调用梯度时，即调用 gradient(h, np.array([d])) 时，梯度函数会尝试修改 d 再执行函数 h，其行为和改变函数参数是一致的</span><br>    <span class="hljs-comment"># 这个trick特别适用于不知道函数的入参具体形式的情况下</span><br>    <span class="hljs-comment"># 这里使用这个trick，因为后面求神经网络的损失函数的时候同样使用这种操作</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">_</span>):<br>        <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">abs</span>(x - d[<span class="hljs-number">0</span>] * d[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(step_num):<br>        grad = gradient(h, d)<br>        d = d - grad * lr<br>    <span class="hljs-keyword">return</span> d[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 画点图验证一下，使用函数避免污染全局作用域</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drawSqrt</span>():<br>    xs = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">500</span>)<br>    <span class="hljs-comment"># 使用之前定义的sqrt的话性能会很差，因为它无法利用到numpy的并行计算功能，必须要使用for循环去调用</span><br>    <span class="hljs-comment"># vectorize将函数从处理单元素的函数变为numpy数组的函数，但本质上仍旧是for循环，没有提高性能</span><br><br>    <span class="hljs-comment"># 这在神经网络中无关紧要，因为计算损失函数的梯度时每趟训练只需要计算一次，不需要并发计算，但这里需要对多个位置同时计算它的梯度，这本该去并发计算</span><br>    <span class="hljs-comment"># 这里实现一个更高性能的sqrt，不使用trick，使用适应一元函数的numerical_diff，</span><br>    <span class="hljs-comment"># 它定义的形式因此能够适应numpy的并行计算，速度是上面的sqrt的百倍</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt</span>(<span class="hljs-params">x,lr,step_num</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">d</span>):<br>            <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">abs</span>(x - d * d)<br>        d = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(step_num):<br>            grad = numerical_diff(h, d)<br>            d = d - grad * lr<br>        <span class="hljs-keyword">return</span> d<br>    <span class="hljs-comment"># datas = pd.DataFrame(&#123;</span><br>    <span class="hljs-comment">#     &#x27;x&#x27;: xs,</span><br>    <span class="hljs-comment">#     &#x27;my.sqrt(lr=1e-3,step_num=1e3)&#x27;: np.vectorize(lambda x: sqrt(x, lr=1e-3,step_num=int(1e3)))(xs),</span><br>    <span class="hljs-comment">#     &#x27;my.sqrt(lr=1e-2,step_num=1e3)&#x27;: np.vectorize(lambda x: sqrt(x, lr=1e-2,step_num=int(1e3)))(xs),</span><br>    <span class="hljs-comment">#     &#x27;np.sqrt&#x27;: np.sqrt(xs)</span><br>    <span class="hljs-comment"># &#125;)</span><br>    datas = pd.DataFrame(&#123;<br>        <span class="hljs-string">&#x27;x&#x27;</span>: xs,<br>        <span class="hljs-string">&#x27;my.sqrt(lr=5e-3,step_num=1e3)&#x27;</span>: sqrt(xs, lr=<span class="hljs-number">1e-3</span>, step_num=<span class="hljs-built_in">int</span>(<span class="hljs-number">1e3</span>)),<br>        <span class="hljs-string">&#x27;my.sqrt(lr=1e-2,step_num=1e3)&#x27;</span>: sqrt(xs, lr=<span class="hljs-number">1e-2</span>, step_num=<span class="hljs-built_in">int</span>(<span class="hljs-number">1e3</span>)),<br>        <span class="hljs-string">&#x27;my.sqrt(lr=1e-2,step_num=1e4)&#x27;</span>: sqrt(xs, lr=<span class="hljs-number">1e-2</span>, step_num=<span class="hljs-built_in">int</span>(<span class="hljs-number">1e4</span>)),<br>        <span class="hljs-string">&#x27;np.sqrt&#x27;</span>: np.sqrt(xs)<br>    &#125;)<br>    sns.lineplot(data=datas.melt(<span class="hljs-string">&#x27;x&#x27;</span>), x=<span class="hljs-string">&#x27;x&#x27;</span>, y=<span class="hljs-string">&#x27;value&#x27;</span>, hue=<span class="hljs-string">&#x27;variable&#x27;</span>)<br>drawSqrt()<br></code></pre></div></td></tr></table></figure><p><img src="/2023/06-09%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94MLP/output_14_0.png" alt="png"></p><p>梯度下降法有两个<strong>超参数</strong>（超参数即非神经网络通过训练得到，而是手动设定的参数）：学习率和步数，学习率表示每次要向梯度下降的方向移动多大距离，步数表示移动的次数，学习率需要被合适地设定，过大和过小都会导致无法得到正确结果，比如上面的例子。</p><h1 id="反向传播-x2F-神经网络的学习"><a href="#反向传播-x2F-神经网络的学习" class="headerlink" title="反向传播&#x2F;神经网络的学习"></a>反向传播&#x2F;神经网络的学习</h1><p>正向传播就是把输入喂给神经网络，得到输出的过程，<strong>反向传播就是给定输入和期望的输出，根据期望的输出和实际的输出的关系去反向更新权重的过程</strong>。神经网络中，可以使用梯度下降法进行反向传播。</p><p>首先需要定义我们需要应用梯度下降法的函数。<strong>该函数的参数为权重矩阵，返回值代表期望输出和实际输出的“距离”</strong>。该函数称为<strong>损失函数</strong>，我们可以通过梯度下降法逐渐逼近损失函数的最小值，<strong>即让期望输出和实际输出最小的权重矩阵</strong>，一趟训练的一般过程如下，和sqrt的形式基本一致：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">W, x, t, lr, step_num</span>):<br>    <span class="hljs-comment"># W 是权重，x是输入，t是预测输出，lr是学习率，step_num是执行次数</span><br>    <span class="hljs-comment"># 实际操作时，损失函数使用闭包去捕获权重矩阵</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">loss</span>(<span class="hljs-params">W</span>):<br>        <span class="hljs-keyword">return</span> distance(precict(x, W), t)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(step_num):<br>        grad = gradient(loss, W)<br>        W = W - grad * lr<br>    <span class="hljs-keyword">return</span> W<br></code></pre></div></td></tr></table></figure><p>在实际操作中，我们不会对每一个训练数据都去进行梯度下降法，而是每次找到n个比如100个数据去做批处理，这既是去避免单个数据的特殊性，也能减少计算量。但同时也不会选择所有数据去进行学习，这又会增加计算量。<strong>每次随机选择特定数量的数据去训练的方法称为mini-batch，训练过程中使用梯度下降法进行反向传播，这整个称为随机梯度下降法SGD</strong>。</p><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p>损失函数需要求得期望输出和实际输出的“距离”，在处理多个输出时，损失函数需要求得每一个输出的“平均损失”，这个除以N就行。</p><p>常用的损失函数包括均方误差，交叉熵误差，它们的定义如下：</p><p>$$ mean_squared_error(y, t) &#x3D; \frac{1}{2}\sum(y_k - t_k)^2 $$</p><p>$$ cross_entropy_error(y, t) &#x3D; -\sum_{k}^{} t_{k}\log_{}{y_{k} } $$</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 注意这个定义只能处理单个数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mean_squared_error</span>(<span class="hljs-params">y, t</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    均方误差，为“距离”的平方的一半</span><br><span class="hljs-string">    :param y: 实际输出</span><br><span class="hljs-string">    :param t: 期望输出</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">sum</span>((y - t) ** <span class="hljs-number">2</span>) / <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 交叉熵误差 ，修改了使之能处理一组数据的平均损失</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy_error</span>(<span class="hljs-params">y, t</span>):<br>    <span class="hljs-keyword">if</span> y.ndim == <span class="hljs-number">1</span>:<br>        t = t.reshape(<span class="hljs-number">1</span>, t.size)<br>        y = y.reshape(<span class="hljs-number">1</span>, y.size)<br>    batch_size = y.shape[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> -np.<span class="hljs-built_in">sum</span>(t * np.log(y + <span class="hljs-number">1e-7</span>)) / batch_size<br></code></pre></div></td></tr></table></figure><h1 id="capstone-0-MNIST-识别手写数字"><a href="#capstone-0-MNIST-识别手写数字" class="headerlink" title="capstone 0: MNIST 识别手写数字"></a>capstone 0: MNIST 识别手写数字</h1><p>Hello, World! 这恐怕是最复杂的Hello World了。</p><p>MNIST数据集中的数据为28x28灰度像素表示的手写数字，其有60000条训练数据，10000条测试数据，每条数据包含该像素矩阵和对应数字值，下面拿它开刀，训练一个识别手写数字的神经网络。</p><p>数据文件从<a href="https://www.kaggle.com/datasets/hojjatk/mnist-dataset">这里</a>下载，读取数据的代码拷贝自<a href="https://www.kaggle.com/code/hojjatk/read-mnist-dataset?cellIds=1&kernelSessionId=9466282">这里</a>。</p><p>首先设计神经网络的大小，这里设计一个两层神经网络（输入层，一个有权重的隐藏层，有权重的输出层），其中输入层的大小为28x28&#x3D;784，即每个像素（这里丢掉长宽信息），第一个隐藏层为100个神经元，输出层为10个神经元，它们的输出分别表示数字为0-9的概率；隐藏层的激活函数使用sigmoid，输出层的激活函数使用softmax（这是个分类问题）。</p><p>在计算损失函数时，目标输出采用one-hot的形式，即只有一个元素为1的数组，如7会表示成<code>[0, 0, 0, 0, 0, 0, 0, 1, 0, 0]</code>。</p><p>一般流程如下：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">设置超参数（批大小，训练次数，训练集大小，学习率）<br>初始化神经网络<br><br>对每一次训练：<br><span class="hljs-code">    随机抽取mini-batch</span><br><span class="hljs-code"></span><br><span class="hljs-code">    计算这批数据的损失函数的梯度</span><br><span class="hljs-code">    根据梯度和学习率更新参数 # 每一个mini-batch只移动一次梯度！</span><br><span class="hljs-code"></span><br><span class="hljs-code">    记录当前的损失函数的返回值供统计</span><br></code></pre></div></td></tr></table></figure><p>整个代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoLayerNet</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,</span><br><span class="hljs-params">                 input_size: <span class="hljs-built_in">int</span>,</span><br><span class="hljs-params">                 hidden_size: <span class="hljs-built_in">int</span>,</span><br><span class="hljs-params">                 output_size: <span class="hljs-built_in">int</span>,</span><br><span class="hljs-params">                 activation_function: <span class="hljs-type">Callable</span> = sigmoid,</span><br><span class="hljs-params">                 loss_function: <span class="hljs-type">Callable</span> = cross_entropy_error,</span><br><span class="hljs-params">                 output_activation_function: <span class="hljs-type">Callable</span> = softmax</span>):<br>        self.loss_function = loss_function<br>        self.output_activation_function = output_activation_function<br>        self.activation_function = activation_function<br>        <span class="hljs-comment"># 权重矩阵使用标准正态分布随机取值，偏置矩阵初始全为0</span><br>        self.w1 = np.random.randn(input_size, hidden_size)<br>        self.b1 = np.zeros(hidden_size)<br>        self.w2 = np.random.randn(hidden_size, output_size)<br>        self.b2 = np.zeros(output_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        正向传播</span><br><span class="hljs-string">        :param x: 入参数组，需为二维，每一行为一个输入</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        t1 = self.activation_function(x @ self.w1 + self.b1)<br>        <span class="hljs-keyword">return</span> self.output_activation_function(t1 @ self.w2 + self.b2)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, x, t, lr=<span class="hljs-number">0.1</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        一次批训练，流程是根据输入，输出数据集去构造损失函数（它的参数是权重），然后求出此时的权重的梯度，将权重向梯度方向移动</span><br><span class="hljs-string">        需注意的是，这里对每一个mini-batch，只移动一次！</span><br><span class="hljs-string">        :param x: 输入数据集</span><br><span class="hljs-string">        :param t: 期望输出数据集</span><br><span class="hljs-string">        :param lr: 学习率</span><br><span class="hljs-string">        :return: 当前的损失，以及梯度</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">loss</span>(<span class="hljs-params">_</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            损失函数</span><br><span class="hljs-string">            :param _: 权重，这里通过闭包引入，在predict中被使用</span><br><span class="hljs-string">            :return: 当前权重下的损失</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            <span class="hljs-keyword">return</span> self.loss_function(self.predict(x), t)<br><br>        w1 = gradient(loss, self.w1) <span class="hljs-comment"># 该函数会尝试不断改变self.w1的值并调用loss函数，这里因为loss函数通过闭包引用了self.w1，即使参数没有改变/使用，输出值也会不同，因此能正常计算梯度</span><br>        b1 = gradient(loss, self.b1)<br>        w2 = gradient(loss, self.w2)<br>        b2 = gradient(loss, self.b2)<br>        self.w1 = self.w1 - w1 * lr<br>        self.b1 = self.b1 - b1 * lr<br>        self.w2 = self.w2 - w2 * lr<br>        self.b2 = self.b2 - b2 * lr<br><br>        <span class="hljs-keyword">return</span> loss(<span class="hljs-number">0</span>), (w1, b1, w2, b2)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">self, x, t</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        根据测试数据计算准确率</span><br><span class="hljs-string">        :param x: 测试数据输入</span><br><span class="hljs-string">        :param t: 测试数据期望输出</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        y = self.predict(x)<br>        y = np.argmax(y, axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># one hot转实际值</span><br>        t = np.argmax(t, axis=<span class="hljs-number">1</span>)<br>        accuracy = np.<span class="hljs-built_in">sum</span>(y == t) / <span class="hljs-built_in">float</span>(x.shape[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> accuracy<br></code></pre></div></td></tr></table></figure><p>下面加载数据集，让银河燃烧吧。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 需要将四个数据文件以及MnistDataloader.py都拷贝到 工作目录/mnist 才能执行这个cell</span><br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> mnist.MnistDataloader <span class="hljs-keyword">import</span> MnistDataloader<br><br><span class="hljs-comment"># xx_images 为三维列表，第一维为每个图像，第二维为每个图像的每一行， 第三维为每一行的每一列</span><br><span class="hljs-comment"># xx_labels 为一维列表，其表示对应图像的取值</span><br><span class="hljs-comment"># 这里把图像全部展平，让每个图像成为长度为784的一维列表，把标签全部转换为one-hot形式</span><br><span class="hljs-comment"># 同时也缓存读取的数据，避免每次都读</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">readMnist</span>() -&gt; <span class="hljs-type">Tuple</span>[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:<br>    <span class="hljs-keyword">if</span> os.path.exists(<span class="hljs-string">&#x27;mnist/data.pickle&#x27;</span>):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;mnist/data.pickle&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-keyword">return</span> pickle.load(f)<br>    (train_images, train_labels), (test_images, test_labels) = MnistDataloader(<br>        training_images_filepath = <span class="hljs-string">&#x27;mnist/train-images.idx3-ubyte&#x27;</span>,<br>        training_labels_filepath = <span class="hljs-string">&#x27;mnist/train-labels.idx1-ubyte&#x27;</span>,<br>        test_images_filepath     = <span class="hljs-string">&#x27;mnist/t10k-images.idx3-ubyte&#x27;</span>,<br>        test_labels_filepath     = <span class="hljs-string">&#x27;mnist/t10k-labels.idx1-ubyte&#x27;</span>).load_data()<br>    train_images = np.array(train_images).reshape(<span class="hljs-number">60000</span>, <span class="hljs-number">784</span>)<br>    test_images = np.array(test_images).reshape(<span class="hljs-number">10000</span>, <span class="hljs-number">784</span>)<br>    train_labels = np.eye(<span class="hljs-number">10</span>)[train_labels] <span class="hljs-comment"># np.eye(10) 生成10x10的对角数组，它的每一行正好是该行对应的one-hot表示</span><br>    test_labels = np.eye(<span class="hljs-number">10</span>)[test_labels]<br>    res = (train_images, train_labels, test_images, test_labels)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;mnist/data.pickle&#x27;</span>, <span class="hljs-string">&#x27;xb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        pickle.dump(res, f)<br>    <span class="hljs-keyword">return</span> res<br>train_images, train_labels, test_images, test_labels = readMnist()<br></code></pre></div></td></tr></table></figure><p>先检查一下是否正确读取了，读取一下第一张图片看看效果：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">img_show</span>(<span class="hljs-params">img</span>):<br>    <span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    pil_img = Image.fromarray(np.uint8(img))<br>    plt.imshow(pil_img)<br>    plt.axis(<span class="hljs-string">&#x27;on&#x27;</span>) <span class="hljs-comment"># 关掉坐标轴为 off</span><br>    plt.title(<span class="hljs-string">&#x27;image&#x27;</span>) <span class="hljs-comment"># 图像题目</span><br>    plt.show()<br><span class="hljs-built_in">print</span>(np.argmax(train_labels[<span class="hljs-number">0</span>])) <span class="hljs-comment"># argmax 函数返回最大值的下标，使用其可以从one-hot还原到数字表示</span><br>img_show(train_images[<span class="hljs-number">0</span>].reshape(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>))<br></code></pre></div></td></tr></table></figure><div class="hljs code-wrapper"><pre><code class="hljs">5</code></pre></div><p><img src="/2023/06-09%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94MLP/output_22_1.png" alt="png"></p><p>开干！下面的代码同样做了缓存，保证每次测试都能用上上一次的结果。</p><p>在执行该代码时，会发现其执行速率是极为缓慢的，瓶颈可能在计算梯度时，计算梯度的时候会对每一个参数进行两次前向传播，在这里每一次计算梯度需要进行 <code>(w1.size + w2.size + b1.size + b2.size) * 2 = (784 * 100 + 100 * 10 + 100 + 10) * 2 = 159020</code>次前向传播……这效率是令人崩溃的。因此这里修改了隐藏层神经元的数量到10，把计算量基本降低了一个数量级，但好像仍然跑的通？？</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 诸超参数</span><br>train_size = train_images.shape[<span class="hljs-number">0</span>] <span class="hljs-comment"># 训练集大小</span><br>batch_size = <span class="hljs-number">200</span> <span class="hljs-comment"># mini-batch大小</span><br>iter_num = <span class="hljs-number">500</span> <span class="hljs-comment"># 迭代次数</span><br>learn_rate = <span class="hljs-number">0.1</span> <span class="hljs-comment"># 学习率</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">doTraining</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">createNet</span>():<br>        <span class="hljs-keyword">if</span> os.path.exists(<span class="hljs-string">&#x27;mnist/net.pickle&#x27;</span>):<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;mnist/net.pickle&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                <span class="hljs-keyword">return</span> pickle.load(f)<br>        net = TwoLayerNet(<span class="hljs-number">784</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">return</span> net<br><br>    net = createNet()<br><br>    train_loss_list = []<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iter_num):<br>        <span class="hljs-comment"># 每次从训练集中随意抽出batch_size个下标，获取对应图片和需求输出</span><br>        idxs = np.random.choice(train_size, batch_size)<br>        imgs = train_images[idxs]<br>        labels = train_labels[idxs]<br>        start = time.time()<br>        (loss, *_) = net.train(imgs, labels, learn_rate)<br>        end = time.time()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>/<span class="hljs-subst">&#123;iter_num&#125;</span>: <span class="hljs-subst">&#123;end - start:<span class="hljs-number">.2</span>f&#125;</span>s, loss: <span class="hljs-subst">&#123;loss:<span class="hljs-number">.3</span>f&#125;</span>, acc: <span class="hljs-subst">&#123;net.accuracy(test_images, test_labels):<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;mnist/net.pickle&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                pickle.dump(net, f)<br><span class="hljs-comment"># doTraining()</span><br></code></pre></div></td></tr></table></figure><p>这种全连接的，稀松平常的神经网络似乎称为MLP（多层感知机）。而这篇笔记或许就到这里了，因为下一章会对当前架构大改……看来这个是出不了成果了。但知识留着了。</p><p>最后的最后，必须得拿真实的数据去实践一下，无论效果如何，下面是一张28x112的png文件，内容是手写的2026，看看我们的人工智障会输出什么东西。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 实现来自chatGPT</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">split_image</span>(<span class="hljs-params">image_path</span>):<br>    <span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>    img = Image.<span class="hljs-built_in">open</span>(image_path)<br>    width, height = img.size<br>    result = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, height, <span class="hljs-number">28</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, width, <span class="hljs-number">28</span>):<br>            box = (j, i, j+<span class="hljs-number">28</span>, i+<span class="hljs-number">28</span>)<br>            gray_pixels = []<br>            <span class="hljs-keyword">for</span> pixel <span class="hljs-keyword">in</span> img.crop(box).getdata():<br>                gray = <span class="hljs-built_in">round</span>(<span class="hljs-number">0.299</span> * pixel[<span class="hljs-number">0</span>] + <span class="hljs-number">0.587</span> * pixel[<span class="hljs-number">1</span>] + <span class="hljs-number">0.114</span> * pixel[<span class="hljs-number">2</span>])<br>                gray_pixels.append(gray)<br>            result.append(<span class="hljs-number">255</span> - np.array(gray_pixels))<br>    <span class="hljs-keyword">return</span> np.array(result)<br><br>images = split_image(<span class="hljs-string">&#x27;mnist/2026.png&#x27;</span>)<br>img_show(np.concatenate(images.reshape(<span class="hljs-number">4</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>), axis=<span class="hljs-number">1</span>))<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;mnist/net.pickle&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    net = pickle.load(f)<br><span class="hljs-built_in">print</span>(np.argmax(net.predict(images), axis=<span class="hljs-number">1</span>))<br></code></pre></div></td></tr></table></figure><p><img src="/2023/06-09%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94MLP/output_26_0.png" alt="png"></p><div class="hljs code-wrapper"><pre><code class="hljs">[2 7 2 5]</code></pre></div><p>哈哈哈哈哈哈哈哈哈哈哈哈哈</p>]]></content>
    
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绘制任意深度的线条——路米斯的方法</title>
    <link href="/2023/06-03%E7%BB%98%E5%88%B6%E4%BB%BB%E6%84%8F%E6%B7%B1%E5%BA%A6%E7%9A%84%E7%BA%BF%E6%9D%A1%E2%80%94%E2%80%94%E8%B7%AF%E7%B1%B3%E6%96%AF%E6%96%B9%E6%B3%95.html"/>
    <url>/2023/06-03%E7%BB%98%E5%88%B6%E4%BB%BB%E6%84%8F%E6%B7%B1%E5%BA%A6%E7%9A%84%E7%BA%BF%E6%9D%A1%E2%80%94%E2%80%94%E8%B7%AF%E7%B1%B3%E6%96%AF%E6%96%B9%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<p>除了画头颅，连透视也要强迫我按你说的做吗？路米斯，现在的你，很靓仔！</p><p>之前学习了基于平面作图的 n 等分点、倍增画法，以及基于线和消失点比例的 n 等分点、倍增的画法，但这两个方法都没有路米斯在《素描基础课》中所教授的方法全能和实用——<strong>它不止能绘制 n 等分点，甚至能绘制任意长度的线段</strong>（当然，对每个消失点都需要规定一个基准，因为<strong>指向消失点的线段的所看到的长度是随焦距和相机距离改变的</strong>），路米斯的方法均能胜任，而它只需要在平面的一条直线上找比例即可。</p><p>一个交互式示例见下：</p><p><a href="/file/loomis_perspective.html">CLICK ME!</a></p><p><img src="/2023/06-03%E7%BB%98%E5%88%B6%E4%BB%BB%E6%84%8F%E6%B7%B1%E5%BA%A6%E7%9A%84%E7%BA%BF%E6%9D%A1%E2%80%94%E2%80%94%E8%B7%AF%E7%B1%B3%E6%96%AF%E6%96%B9%E6%B3%95/a.gif"></p><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>路米斯关于该画法的描述如下：</p><p><img src="/2023/06-03%E7%BB%98%E5%88%B6%E4%BB%BB%E6%84%8F%E6%B7%B1%E5%BA%A6%E7%9A%84%E7%BA%BF%E6%9D%A1%E2%80%94%E2%80%94%E8%B7%AF%E7%B1%B3%E6%96%AF%E6%96%B9%E6%B3%95/book.jpeg"></p><p>上面的交互式示例展示的已经足够清楚了，这里只提一下可能需要注意的地方&#x2F;诀窍：</p><ol><li>上面的图没有展示倍增线段的画法，但这玩意很明显 w</li><li>路米斯说测量点需要在视平线上，这个限制是没必要的，<strong>测量点可以在任意位置，只需要在做标尺的时候让标尺和测量点和消失点的连线平行</strong>；将测量点置于视平线上的话，测量点和消失点的连线就是水平的，因此标尺同样是水平的了</li><li>调整测量点的位置，让测量点和标尺上的线锁造成的三角形角度尽量正常，角度太小或太大会影响测量</li><li>可以尝试找多个测量点同时进行测量来避免误差</li><li>如果绘制对象过于复杂，建议 3d 辅助绘画</li></ol><h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><p>证明个头，实践出真知！该交互式示例中测量点在任意位置时都能通过在标尺上找点来做任意比例，这对使用者来说已经足够。</p>]]></content>
    
    
    
    <tags>
      
      <tag>绘画</tag>
      
      <tag>透视</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透视中 n 等分点和倍增线段的直接画法</title>
    <link href="/2023/06-01%E9%80%8F%E8%A7%86%E4%B8%ADn%E7%AD%89%E5%88%86%E7%82%B9%E5%92%8C%E5%80%8D%E5%A2%9E%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%9B%B4%E6%8E%A5%E7%94%BB%E6%B3%95.html"/>
    <url>/2023/06-01%E9%80%8F%E8%A7%86%E4%B8%ADn%E7%AD%89%E5%88%86%E7%82%B9%E5%92%8C%E5%80%8D%E5%A2%9E%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%9B%B4%E6%8E%A5%E7%94%BB%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<p>之前学习了任意 n 等分点的画法，该方法虽能绘制任意等分点，但对程序作图不太适合，最近研究发现，其实有一些更直接的方式来找 n 等分点，<strong>其不需要做任何辅助线，只需要做测量即可</strong>。</p><h1 id="n-等分点，倍增线段"><a href="#n-等分点，倍增线段" class="headerlink" title="n 等分点，倍增线段"></a>n 等分点，倍增线段</h1><p>直入主题，有这样的结论：</p><p>任意指向某消失点的线段，它的 n 等分点的位置仅和线段在画布上的长度，以及线段和消失点在画布上的距离相关。</p><p>假设该线段离消失点较远的点和消失点的距离为 a，离消失点较近的点和消失点的距离为 b，则该线段的第 i 个 n 等分点<strong>和消失点</strong>的距离是：</p><p><code>d(n, i, a, b) = nab / (ia + (n - i)b)</code></p><p>比如，当<code>a = 6</code>，<code>b = 2</code>时，它的 2 等分点距离消失点的距离是 <code>2 * 6 * 2 / (6 + 2) = 3</code>，如下图：</p><p><img src="/2023/06-01%E9%80%8F%E8%A7%86%E4%B8%ADn%E7%AD%89%E5%88%86%E7%82%B9%E5%92%8C%E5%80%8D%E5%A2%9E%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%9B%B4%E6%8E%A5%E7%94%BB%E6%B3%95/2split.jpg" alt="二等分"></p><p>比如，当<code>a = 6</code>，<code>b = 2</code>时，它的三等分点距离消失点的距离分别为 <code>3 * 6 * 2 / (6 + 2 * 2) = 3.6</code>, <code>3 * 6 * 2 / (2 * 6 + 2) = 2.57</code>，如下图：</p><p><img src="/2023/06-01%E9%80%8F%E8%A7%86%E4%B8%ADn%E7%AD%89%E5%88%86%E7%82%B9%E5%92%8C%E5%80%8D%E5%A2%9E%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%9B%B4%E6%8E%A5%E7%94%BB%E6%B3%95/3split.jpg" alt="三等分"></p><p><strong>倍增线段</strong>，假设该线段离消失点较远的点和消失点的距离为 a，离消失点较近的点和消失点的距离为 b，则它的倍增点距离该线段<strong>离消失点较远的点</strong>的距离为：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">d</span>(a, b) = (<span class="hljs-number">2</span>a^<span class="hljs-number">2</span> - <span class="hljs-number">2</span>ab) / (<span class="hljs-number">2</span>a - b)<br></code></pre></div></td></tr></table></figure><p>比如，当<code>a = 5</code>, <code>b = 3</code>时，它的倍增线段距离离消失点较远的点的距离是 <code>(2 * 5 * 5 - 2 * 5 * 3) / (2 * 5 - 3) = 2.85</code>，如下图：</p><p><img src="/2023/06-01%E9%80%8F%E8%A7%86%E4%B8%ADn%E7%AD%89%E5%88%86%E7%82%B9%E5%92%8C%E5%80%8D%E5%A2%9E%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%9B%B4%E6%8E%A5%E7%94%BB%E6%B3%95/double.jpg" alt="倍增线段"></p><p>n 等分点代码实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据一条指向消失点的直线的近处和远处到消失点的长度，获取它的 n 等分点距直线近处的位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n 要求几等分点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> longToDim 在画布上直线近处到消失点的大小</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> shortToDim 在画布上直线远处到消失点的大小</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 画布上各等分点到直线近处的长度，数组大小为 n - 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">nSplit</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span>, longToDim: <span class="hljs-built_in">number</span>, shortToDim: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span> || longToDim &lt;= <span class="hljs-number">0</span> || shortToDim &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> []<br>  <span class="hljs-keyword">if</span> (longToDim &lt; shortToDim) [shortToDim, longToDim] = [longToDim, shortToDim] <span class="hljs-comment">// swap</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">number</span>[] = []<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; a &lt;= n - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> toDim = n * longToDim * shortToDim / (i * longToDim + (n - i) * shortToDim)<br>    res.<span class="hljs-title function_">push</span>(longToDim - toDim)<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="一个交互式示例"><a href="#一个交互式示例" class="headerlink" title="一个交互式示例"></a>一个交互式示例</h1><p>下面是一个利用 p5.js 来展示该算法的交互式示例，可以拖动 A，C 点和两个消失点，代码实现就在 html 文件中：</p><p><a href="/file/nsplit.html">CLICK ME!</a></p><p><img src="/2023/06-01%E9%80%8F%E8%A7%86%E4%B8%ADn%E7%AD%89%E5%88%86%E7%82%B9%E5%92%8C%E5%80%8D%E5%A2%9E%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%9B%B4%E6%8E%A5%E7%94%BB%E6%B3%95/example0.png" alt="100 等分"></p><p><img src="/2023/06-01%E9%80%8F%E8%A7%86%E4%B8%ADn%E7%AD%89%E5%88%86%E7%82%B9%E5%92%8C%E5%80%8D%E5%A2%9E%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%9B%B4%E6%8E%A5%E7%94%BB%E6%B3%95/example1.png" alt="example"></p><h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><p>因为画图麻烦所以这里不画图了 w</p><h2 id="n-等分点"><a href="#n-等分点" class="headerlink" title="n 等分点"></a>n 等分点</h2><p>考虑一个左手坐标系中的三个点 P0，P1，P2，其中<code>P0 = (x, y, z, P1 = (x, y, z + l), P2 = (x, y, z + 2)</code>，相机在原点，viewport 为<code>z=d</code>。</p><p>显然，P0，P1，P2 是同一个线段上 3 个点，P1 为 P0P2 的中点。这三个点向相机方向投影，在 viewport 上分别为<code>P0&#39; = (x * d / z, y * d / z, d), P1&#39; = (x * d / (z + l), y * d / (z + l), d), P2&#39; = (x * d / (z + 2l), y * d / (z + 2l), d)</code>。</p><p><strong>现在只看 viewport 这个平面，我们要知道二等分点和线段、消失点的关系，就是要看 |P0’O|，|P1’O|，和 |P2’O| 的关系，其中 |P0’O| 和 |P2’O| 对我们是可知的</strong>。这三个点显然都在一条斜率等于 y &#x2F; x 的线性函数上，其中 P0’距原点最远，P2’最近。</p><p>我们能得到<code>|P0&#39;O| = (d / z) * sqrt(x^2 + y^2)</code>，<code>|P1&#39;O| = (d / (z + l)) * sqrt(x^2 + y^2)</code>，<code>|P2&#39;O| = (d / (z + 2l)) * sqrt(x^2 + y^2)</code>，不太容易得到的是，<code>|P1&#39;O| = 2 * |P0&#39;O| * |P2&#39;O| / (|P0&#39;O| + |P2&#39;O|)</code>。</p><p>再研究三等分点，增加一个点 P3，使用上面相同的方式，研究<code>|P0&#39;O|, |P1&#39;O|, |P3&#39;O|</code>和<code>|P0&#39;O|, |P2&#39;O|, |P3&#39;O|</code>的关系，其中<code>|P0&#39;O|</code> 和 <code>|P3&#39;O|</code> 对我们是可知的，后面的以此类推。</p><h2 id="倍增线段"><a href="#倍增线段" class="headerlink" title="倍增线段"></a>倍增线段</h2><p>仍旧是像二等分点一样，先三个点 P0，P1，P2，但这次可知的是<code>|P0&#39;O|</code> 和 <code>|P1&#39;O|</code>，需要求得 <code>|P2&#39;O|</code>，这里只需要对上面得到的关系 <code>|P1&#39;O| = 2 * |P0&#39;O| * |P2&#39;O| / (|P0&#39;O| + |P2&#39;O|)</code> 化简一下就能得到结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>绘画</tag>
      
      <tag>透视</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Computer Graphics from Scratch》学习笔记——绘制三角形</title>
    <link href="/2023/05-30%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2.html"/>
    <url>/2023/05-30%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2.html</url>
    
    <content type="html"><![CDATA[<p>光线追踪器很美，但光栅器更加实用，学习光栅器对学习游戏引擎以及透视（对于透视，光线追踪只能给我们一些偏向感性的东西，如近大远小，不同焦距，相机角度的影响等，但光栅器能够给我们更理性的一些概念，规律，公式等，让我们不仅能感觉，而且能证明一些东西……应该吧？）都是有很大意义的，该继续学习了。</p><p>如果说光线追踪器就是对屏幕上的每一个像素，询问这个像素应该是什么颜色，那么<strong>光栅器就是对要场景中的每一个对象，问它要展示在画布的哪个部分</strong>。</p><p>下面简单封装一下对画布的操作，后续均在此基础上进行抽象。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Pen</span> = &#123;<br>  <span class="hljs-title function_">putPixel</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>, color?: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]): <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Canvas</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">canvas</span>: <span class="hljs-title class_">HTMLCanvasElement</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">elem: HTMLElement</span>) &#123;<br>    <span class="hljs-keyword">if</span> (elem <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">HTMLCanvasElement</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span> = elem<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>)<br>      elem.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">width</span>():<span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">width</span><br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">width</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">width</span> = n<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">height</span>():<span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">height</span><br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">height</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-property">height</span> = n<br>  &#125;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 对每个 pixel，坐标原点为左上</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> fn </span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">forEachPixel</span>(<span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> halfW = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">const</span> halfH = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = -halfW; x &lt; halfW; x++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = -halfH; y &lt; halfH; y++) &#123;<br>        <span class="hljs-title function_">fn</span>(x, y)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">draw</span>(<span class="hljs-attr">body</span>: <span class="hljs-function">(<span class="hljs-params">pen: Pen</span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span><br>    <span class="hljs-keyword">const</span> canvasContext = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>)!;<br>    <span class="hljs-keyword">const</span> canvasBuffer = canvasContext.<span class="hljs-title function_">getImageData</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>)<br>    <span class="hljs-keyword">const</span> canvasPitch = canvasBuffer.<span class="hljs-property">width</span> * <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">pen</span>: <span class="hljs-title class_">Pen</span> = &#123;<br>      <span class="hljs-title function_">putPixel</span>(<span class="hljs-params">x, y, color = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span>) &#123;<br>        x = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(canvas.<span class="hljs-property">width</span>/<span class="hljs-number">2</span> + x);<br>        y = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(canvas.<span class="hljs-property">height</span>/<span class="hljs-number">2</span> - y - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= canvas.<span class="hljs-property">width</span> || y &lt; <span class="hljs-number">0</span> || y &gt;= canvas.<span class="hljs-property">height</span>) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> offset = <span class="hljs-number">4</span>*x + canvasPitch*y;<br>        canvasBuffer.<span class="hljs-property">data</span>[offset++] = color[<span class="hljs-number">0</span>];<br>        canvasBuffer.<span class="hljs-property">data</span>[offset++] = color[<span class="hljs-number">1</span>];<br>        canvasBuffer.<span class="hljs-property">data</span>[offset++] = color[<span class="hljs-number">2</span>];<br>        canvasBuffer.<span class="hljs-property">data</span>[offset++] = <span class="hljs-number">255</span>; <span class="hljs-comment">// Alpha = 255 (full opacity)</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-title function_">body</span>(pen)<br>    canvasContext.<span class="hljs-title function_">putImageData</span>(canvasBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="画直线"><a href="#画直线" class="headerlink" title="画直线"></a>画直线</h1><p>在编写光线追踪器的时候，处理的原子是画布上的像素，因此只需要 putPixel 这一个操作即可，但光栅器则需要将对象映射到 viewport 上，这要求提供一些更复杂的绘制操作，第一个要实现的是直线。</p><p>首先需要表示直线，最常见的直线表示法有<code>y = kx + b</code>，<code>ax + by + c = 0</code>等。如果我们使用<code>y = kx + b</code>表示直线，则可能会写出这样的绘制直线的方法（先不考虑垂直线情况）：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">putLine</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: Pen, p0: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>], p1: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>], color: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]</span>) &#123;<br>  <span class="hljs-keyword">if</span> (p0[<span class="hljs-number">0</span>] &gt; p0[<span class="hljs-number">0</span>]) [p0, p1] = [p1, p0]<br>  <span class="hljs-keyword">const</span> [x0, y0] = p0<br>  <span class="hljs-keyword">const</span> [x1, y1] = p1<br>  <span class="hljs-keyword">const</span> k = (y1 - y0) / (x1 - x0)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = x0, y = y0; x &lt;= x1; x++, y += k) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">putPixel</span>(x, y, color)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>看着很美好，下面绘制了<code>y = 0.1x + 10</code>，<code>y = 0.5x + 10</code>和<code>y = 10x + 10</code>，看看效果：</p><p><img src="/2023/05-30%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/draw_line_ver_0.png" alt="draw line, ver 0"></p><p><code>k = 0.5</code>的时候，效果看起来还不错，但<code>k = 10</code>的时候，线看上去就不连续了。问题是很明显的——画布的像素是离散的，这里在每个 x 下仅绘制一个像素，当直线偏向 y 轴（k 大于 1 或小于-1）的时候，x 每增加 1，y 增加会大于 1，这就导致中间会出现空隙。有两个简单的处理方式：x 不递增 1，而是递增一个更小的数，这能够增加点的密度；去递增 y 而非递增 x。这里使用后者。</p><p>这里定义一个所谓的线性插值函数，<strong>它无所谓 x，y，只关心一个因变量 i 和一个自变量 d</strong>（仍旧是一个一次函数），它的逻辑仍旧和 drawLine 一致，但返回所有坐标。该插值函数要求 i 为整数，d 为实数。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 该插值法对所有线性关系都会有用途！</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">interpolate</span>(<span class="hljs-params">p0: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>], p1: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]</span>): [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>][] &#123;<br>  <span class="hljs-keyword">if</span> (p0[<span class="hljs-number">0</span>] &gt; p0[<span class="hljs-number">0</span>]) [p0, p1] = [p1, p0]<br>  <span class="hljs-keyword">const</span> [i0, d0] = p0<br>  <span class="hljs-keyword">const</span> [i1, d1] = p1<br>  <span class="hljs-keyword">if</span> (i0 === i1) <span class="hljs-keyword">return</span> [p0]<br>  <span class="hljs-keyword">const</span> k = (d1 - d0) / (i1 - i0)<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">values</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>][] = []<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = i0, d = d0; i &lt;= i1; i++, d += k) &#123;<br>    values.<span class="hljs-title function_">push</span>([i, d])<br>  &#125;<br>  <span class="hljs-keyword">return</span> values<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后，在 drawLine 中我们只需要处理直线倾向情况即可：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">putLine</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: Pen, p0: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>], p1: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>], color: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]</span>) &#123;<br>  <span class="hljs-keyword">const</span> [x0, y0] = p0<br>  <span class="hljs-keyword">const</span> [x1, y1] = p1<br>  <span class="hljs-comment">// 直线偏向 x 轴</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x1 - x0) &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(y1 - y0)) &#123;<br>    <span class="hljs-title function_">interpolate</span>([x0, y0], [x1, y1]).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[x, y]</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">putPixel</span>(x, y, color)<br>    &#125;)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 直线偏向 y 轴</span><br>    <span class="hljs-title function_">interpolate</span>([y0, x0], [y1, x1]).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[y, x]</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">putPixel</span>(x, y, color)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/05-30%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/draw_line_ver_1.png" alt="draw line, ver 1"></p><h2 id="another-approach"><a href="#another-approach" class="headerlink" title="another approach"></a>another approach</h2><p>直线有另一种表示法，其使用一个点和一个方向向量来描述，比如有点 P0，P1，则直线为：</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">P = <span class="hljs-symbol">P0</span> + <span class="hljs-built_in">t</span>(<span class="hljs-symbol">P1</span> - <span class="hljs-symbol">P0</span>)<br>=&gt; (x, y) = (<span class="hljs-symbol">x0</span>, <span class="hljs-symbol">y0</span>) + <span class="hljs-built_in">t</span>(<span class="hljs-symbol">x1</span> - <span class="hljs-symbol">x0</span>, <span class="hljs-symbol">y1</span> - <span class="hljs-symbol">y0</span>)<br>=&gt; x = <span class="hljs-symbol">x0</span> + <span class="hljs-built_in">t</span>(<span class="hljs-symbol">x1</span> - <span class="hljs-symbol">x0</span>), y = <span class="hljs-symbol">y0</span> + <span class="hljs-built_in">t</span>(<span class="hljs-symbol">y1</span> - <span class="hljs-symbol">y0</span>)<br></code></pre></div></td></tr></table></figure><p>我们能得到 x 和 y 关于 t 的方程，能否使用 t 来作为自变量，x，y 作为因变量来进行插值？问题现在在于 t 如何取递增值最合适，显然该递增值需要让增长最快的那个方向每次增加 1，即<code>t * maxD = 1</code>，其中<code>maxD = Math.max(x1 - x0, y1 - y0)</code>，然后可以发现，这里的效果恐怕和上面的方法是一样的。</p><p>但是仍旧有不同——使用 t 当自变量时，我们无法保证 x 和 y 均是整数（因为浮点数误差，可能两个都会不是整数），这导致在某些情况下在绘制上可能会出错。</p><h1 id="填充三角形"><a href="#填充三角形" class="headerlink" title="填充三角形"></a>填充三角形</h1><p>下一个需要的工具是填充三角形（为什么是三角形？因为三个点可以表示一个面，任何复杂多面体都是可以由无数个三角形组成的）。首先是绘制三角形的轮廓，这是容易的：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">putTriangleWireframe</span>(<span class="hljs-params">p0, p1, p2, color = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">putLine</span>(p0, p1, color)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">putLine</span>(p1, p2, color)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">putLine</span>(p2, p0, color)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如何填充三角形呢？可以把<strong>三角形想象成多个水平线段的组合</strong>（就像排线！），对每一个 y，我们要找到该处的这条线段的 x 的起始值和终止值并划线即可。</p><p>为此，我们只需要使用插值函数（使用 x 作为自变量，因此 y 是实数）获取三条边上的每一个点，按照 x 去分组，并对每一个 x，找到对应的 y 并作线段即可。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">drawFilledTriangle</span>(<span class="hljs-params">p0, p1, p2, color = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">allPoints</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>][] = [...<span class="hljs-title function_">interpolate</span>(p0, p1), ...<span class="hljs-title function_">interpolate</span>(p1, p2), ...<span class="hljs-title function_">interpolate</span>(p2, p0)]<br>  <span class="hljs-keyword">const</span> x2Points = <span class="hljs-title function_">groupBy</span>(allPoints, <span class="hljs-function">(<span class="hljs-params">[x, y]</span>) =&gt;</span> x)<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(x2Points).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[x, ps]</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (ps.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">const</span> ys = ps.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[x, y]</span>) =&gt;</span> y).<span class="hljs-title function_">sort</span>()<br>    <span class="hljs-keyword">const</span> yBottom = ys[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">const</span> yTop = ys[ys.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">putLine</span>([+x, yBottom], [+x, yTop], color)<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/05-30%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/triangle.png" alt="triangle"></p><h1 id="三角形着色"><a href="#三角形着色" class="headerlink" title="三角形着色"></a>三角形着色</h1><p>填充三角形实现完了，填充的本质实际上就是绘制无数个水平或垂直线段。现在来点更好玩的事情——给三角形着色（shading）。对三角形的每一个顶点，给定一个颜色值，并在填充时做出渐变的效果。</p><p>首先需要确定边上的特定点的颜色，考虑一条边 AB，点 A 的颜色为 a，点 b 的颜色为 b，对边上任意点 X，可以简单让这时的颜色<code>x = a * |XB| / |AB| + b * |XA| / |AB|</code>（还会有其它方法吧？），实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getColor</span>(<span class="hljs-params">a: Point, b: Point, c0: RGB, c1: RGB, x: Point</span>): <span class="hljs-variable constant_">RGB</span> &#123;<br>  <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> c0<br>  <span class="hljs-keyword">if</span> (t &gt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> c1<br>  <span class="hljs-comment">// x = a * |XB| / |AB| + b * |XA| / |AB|</span><br>  <span class="hljs-keyword">const</span> xbDist = <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">dist</span>(x, b)<br>  <span class="hljs-keyword">const</span> abDist = <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">dist</span>(a, b)<br>  <span class="hljs-keyword">const</span> xaDist = <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">dist</span>(x, a)<br>  <span class="hljs-keyword">return</span> c0.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> c0[i] * xbDist / abDist + c1[i] * xaDist / abDist).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(x)) <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">RGB</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>借助该方法，编写一个 putGradientLine 函数，该函数仅在 putLine 函数的基础上修改了获取像素颜色的部分，这个函数其实没有什么必要，因为我们只画竖直的渐变线段：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">putGradientLine</span>(<span class="hljs-params">p0, p1, c0, c1</span>) &#123;<br>  <span class="hljs-keyword">const</span> [x0, y0] = p0<br>  <span class="hljs-keyword">const</span> [x1, y1] = p1<br>  <span class="hljs-comment">// 直线偏向 x 轴</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x1 - x0) &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(y1 - y0)) &#123;<br>    <span class="hljs-title function_">interpolate</span>([x0, y0], [x1, y1]).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[x, y]</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">putPixel</span>(x, y, <span class="hljs-title function_">getColor</span>(p0, p1, c0, c1, [x, y]))<br>    &#125;)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 直线偏向 y 轴</span><br>    <span class="hljs-title function_">interpolate</span>([y0, x0], [y1, x1]).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[y, x]</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">putPixel</span>(x, y, <span class="hljs-title function_">getColor</span>([y0, x0], [y1, x1], c0, c1, [y, x]))<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用该方法，我们能绘制一下灰阶（从 000 到 fff），这里做一个极端的角度，品尝一下锯齿：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-number">300</span>; y++) &#123;<br>  pen.<span class="hljs-title function_">putGradientLine</span>([<span class="hljs-number">0</span>, y], [<span class="hljs-number">100</span>, y - <span class="hljs-number">500</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/05-30%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/grayScale.png" alt="grey scale"></p><p>然后我们对每一个 x，找到它上面的点 yTop 和下面的点 yBottom 的颜色，绘制像素时同样使用该算法即可。代码为填充三角形的修改。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">drawGradientTriangle</span>(<span class="hljs-params">p0, p1, p2, c0, c1, c2</span>) &#123;<br>  <span class="hljs-comment">// x 和 rgb 的关系其实也可以直接使用 interpolate 计算，只需要将 rgb 转换为一个整数作为因变量即可</span><br>  <span class="hljs-keyword">const</span> p01s = <span class="hljs-title function_">interpolate</span>(p0, p1).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> color = <span class="hljs-title function_">getColor</span>(p0, p1, c0, c1, x)<br>    <span class="hljs-keyword">return</span> [x, color] <span class="hljs-keyword">as</span> [<span class="hljs-title class_">Point</span>, <span class="hljs-variable constant_">RGB</span>]<br>  &#125;)<br>  <span class="hljs-keyword">const</span> p02s = <span class="hljs-title function_">interpolate</span>(p0, p2).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> color = <span class="hljs-title function_">getColor</span>(p0, p2, c0, c2, x)<br>    <span class="hljs-keyword">return</span> [x, color] <span class="hljs-keyword">as</span> [<span class="hljs-title class_">Point</span>, <span class="hljs-variable constant_">RGB</span>]<br>  &#125;)<br>  <span class="hljs-keyword">const</span> p12s = <span class="hljs-title function_">interpolate</span>(p1, p2).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> color = <span class="hljs-title function_">getColor</span>(p1, p2, c1, c2, x)<br>    <span class="hljs-keyword">return</span> [x, color] <span class="hljs-keyword">as</span> [<span class="hljs-title class_">Point</span>, <span class="hljs-variable constant_">RGB</span>]<br>  &#125;)<br>  <span class="hljs-keyword">const</span> x2Points = <span class="hljs-title function_">groupBy</span>([...p01s, ...p02s, ...p12s], <span class="hljs-function">(<span class="hljs-params">[[x, y]]</span>) =&gt;</span> x)<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(x2Points).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[x, ps]</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (ps.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">const</span> ys = ps.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">[[,y0]], [[,y1]]</span>) =&gt;</span> y0 - y1)<br>    <span class="hljs-keyword">const</span> [[, yBottom], cBottom] = ys[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">const</span>  [[, yTop], cTop] = ys[ys.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">putGradientLine</span>([+x, yBottom], [+x, yTop], cBottom, cTop)<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">pen.<span class="hljs-title function_">drawGradientTriangle</span>([-<span class="hljs-number">300</span>, <span class="hljs-number">200</span>], [<span class="hljs-number">10</span>, -<span class="hljs-number">300</span>], [<span class="hljs-number">120</span>, <span class="hljs-number">370</span>], [<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>])<br></code></pre></div></td></tr></table></figure><p><img src="/2023/05-30%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/rgbTriangle.png" alt="RGB Triangle"></p>]]></content>
    
    
    
    <tags>
      
      <tag>CG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于透视</title>
    <link href="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86.html"/>
    <url>/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86.html</url>
    
    <content type="html"><![CDATA[<p>该笔记记录了关于透视的心智模型，一些绘制透视图的准则，并简述了倍增线条、二等分、四等分、任意等分和透视中画圆的方法。</p><h1 id="关于透视的心智模型"><a href="#关于透视的心智模型" class="headerlink" title="关于透视的心智模型"></a>关于透视的心智模型</h1><p>没看过多少材料，也不懂数学，这一节全程胡诌，注意甄别！例子均使用 blender 绘制。</p><p>透视是在二维的画布上展示三维物体的技术，可以通过计算机图形学（以及摄影？不知道呢）中的抽象来理解透视，并建立对透视的心智模型。</p><p>这里有三个概念：相机（camera），视口（viewport），对象（object）；相机不用解释，视口可以认为是相机的可视范围，也是我们的画面本身，它在这里是一个和相机有一定距离的矩形，其中相机在视口的投影为视口的中心。视口可以不是平面，通过改变平面的形状，我们可以得到其它类型的透视比如鱼眼透视，人眼是鱼眼透视。改变视口和相机的距离和视口的宽高比，我们就能得到不同的焦距；对象即为我们想绘制的对象，如立方体，球，少女等。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/camera,viewport,object.jpg" alt="camera, viewport, object"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/first.png" alt="first"></p><p><strong>我们要绘制特定对象，就是做对象到相机在视口上的投影</strong>，具体来说，就是对对象的每个部分，做它和相机的连线，找到连线在视口上的交点。方法类似于下图（中心），<strong>但是投影面 P 在点和对象之间</strong>。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E6%8A%95%E5%BD%B1.png" alt="中心投影"></p><p>就是这么简单，只需要投影这一道工序，近大远小，消失点，一二三点透视，一切透视图的性质都自动地得到了。</p><h2 id="近大远小"><a href="#近大远小" class="headerlink" title="近大远小"></a>近大远小</h2><p>同一个对象，如果它正好在视口上，则它的投影大小（绘制的大小）和它本身一致；它离视口越远，它向相机在视口上的投影就会越小，这是符合直觉的。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E8%BF%91%E5%A4%A7%E8%BF%9C%E5%B0%8F_%E7%BC%A9%E7%95%A5.png" alt="近大远小_缩略"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E8%BF%91%E5%A4%A7%E8%BF%9C%E5%B0%8F_%E9%95%9C%E5%A4%B4.png" alt="近大远小_镜头"></p><h2 id="畸变"><a href="#畸变" class="headerlink" title="畸变"></a>畸变</h2><p>但一个很有趣的点是，如果这个物体始终在平行于视口的平面上运动，则（只要还在可视范围内，）它的投影大小是不会缩短的，甚至有可能会变大！下图是一个很明显的例子，这些球体的球心均在同一个平面上且半径相同，但形状完全不同：</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E7%95%B8%E5%8F%98_%E7%BC%A9%E7%95%A5.png" alt="畸变_缩略"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E7%95%B8%E5%8F%98_%E9%95%9C%E5%A4%B4.png" alt="畸变_镜头"></p><p>是谁说球在任何角度都是球的？</p><h2 id="焦距：远处的变化小，近处的变化大"><a href="#焦距：远处的变化小，近处的变化大" class="headerlink" title="焦距：远处的变化小，近处的变化大"></a>焦距：远处的变化小，近处的变化大</h2><p>摄影中有所谓的长焦镜头，他们说，长焦镜头有“空间压缩”效果，变形幅度小，近大远小的感觉不明显。<strong>通过调整视口的大小，可以模拟长焦镜头的效果</strong>。</p><p>固定视口的宽高比和相机到视口的距离，则视场角（FOV，水平方向可视角度，常用在游戏里）和焦距成反比，下面展示了各视场角下同一个场景：</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/FOV_120.jpg" alt="FOV=120"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/FOV_60.jpg" alt="FOV=60"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/FOV_20.jpg" alt="FOV=20"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/FOV_5.jpg" alt="FOV=5"></p><p>可以认为，不同视场角（焦距）下所看到的场景，就是去裁剪“原图”中间的部分并放大到原图的大小。</p><p><strong>通过固定物体平行于视口方向的大小，并调整远离视口方向的大小，我们能够模拟不同焦距下的画面，这个可以应用在绘画中</strong>，它也证明，比较指向不同消失点的线段的长度是不可能的，因为它会随着焦距的大小而改变。</p><p>下面是不同焦距看同一张椅子：</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/FOV_60_chair.jpg" alt="FOV=60"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/FOV_20_chair.jpg" alt="FOV=20，注意该图的“地面”并非无限大的，所以椅子的上部会在“地平线”（视平线）之上，这实际上是不可能的"></p><p>也能认识到，当镜头距离物体非常远的时候，物体看起来就会像正视图一样了。</p><h2 id="一点透视"><a href="#一点透视" class="headerlink" title="一点透视"></a>一点透视</h2><p><strong>当六面体的一个面平行于视口的时候，得到的就是一点透视</strong>，下面展示了低焦距和高焦距下的一些一点透视的正方体，其中高焦距将相机移远了。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E4%B8%80%E7%82%B9%E9%80%8F%E8%A7%86_%E7%BC%A9%E7%95%A5.png" alt="一点透视_缩略"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E4%B8%80%E7%82%B9%E9%80%8F%E8%A7%86_%E4%BD%8E%E7%84%A6%E8%B7%9D.png" alt="一点透视_低焦距"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E4%B8%80%E7%82%B9%E9%80%8F%E8%A7%86_%E9%AB%98%E7%84%A6%E8%B7%9D.png" alt="一点透视_高焦距"></p><h2 id="平行于视口的线总是平行的"><a href="#平行于视口的线总是平行的" class="headerlink" title="平行于视口的线总是平行的"></a>平行于视口的线总是平行的</h2><p>如果我们沿远离镜头的轴旋转一个六面体，则该六面体背后的面的边的方向如何确定？和面前的面的边平行。因为这两条边和视口平行且相互平行，因此投影到视口上仍旧是平行的。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E5%B9%B3%E8%A1%8C%E4%BA%8Eviewport%E7%9A%84%E7%BA%BF%E4%BE%9D%E6%97%A7%E5%B9%B3%E8%A1%8C.png" alt="平行于 viewport 的线依旧平行"></p><h2 id="二点透视"><a href="#二点透视" class="headerlink" title="二点透视"></a>二点透视</h2><p><strong>如果六面体只有一条边平行于视口，则我们得到二点透视</strong>。</p><p>下面的立方体均沿垂直方向旋转了 45 度：</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E4%BA%8C%E7%82%B9%E9%80%8F%E8%A7%86.png" alt="二点透视"></p><h2 id="三点透视"><a href="#三点透视" class="headerlink" title="三点透视"></a>三点透视</h2><p><strong>如果六面体没有任何面和边平行于视口，则得到三点透视</strong>。三点透视通常出现在非平视的情况，下面的图示在二点透视的基础上将相机的角度向下调整了 20 度，并向上移动了相机。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E4%B8%89%E7%82%B9%E9%80%8F%E8%A7%86.png" alt="三点透视"></p><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><ol><li>使用下面的画法的时候尽量减少测量次数以减少错误的累计，比如画等分时尽量把问题转化为画 2 的 n 次方等分</li><li>始终关心视平线高度</li><li>垂直消失点比水平消失点更重要（因为不同对象一般水平消失点不同，但垂直消失点相同）</li><li>把要画的事物当成六面体（盒子）去看待</li><li>始终使用近大远小的常识去检查画面是否正确，比如二分事物时，靠近镜头的部分会比远离对象的部分更大，猜测等分线的位置时也可以使用此种手段</li><li>指向不同消失点的线段的长度是无法比较的，会随着相机的距离和 FOV（焦距）发生改变，因此选一个合适的比例并假定它们等长即可</li><li>不要追求完全徒手绘画，该依赖工具就依赖工具，无论是透视尺还是 3d 辅助绘画，内容和效率最重要</li><li><strong>不要追求完全正确的透视，要为内容服务</strong>，如果画面需要夸张和扭曲，那就夸张和扭曲</li></ol><h1 id="一些透视画法"><a href="#一些透视画法" class="headerlink" title="一些透视画法"></a>一些透视画法</h1><p>下面的透视画法中均依赖这样的假设：<strong>在平面作图中仅使用连线来进行的作图方法，在透视图中仍然适用，无论一点，二点，还是三点透视</strong>。无论这个假设是否为真，至少下面的画法的效果都还蛮符合直觉。</p><p>下面的画法均使用一个二点透视图做例子（这些画法都是在面上操作的，一个面显然最多是二点透视）。</p><p>要将这些画法应用到一点透视，把“做点到消失点的连线”修改为“过该点的边的平行线”即可。</p><h2 id="二等分"><a href="#二等分" class="headerlink" title="二等分"></a>二等分</h2><p>因为倍增线段也需要用到二等分，这里先描述二等分画法。二等分就是将一个指向某消失点的线段分为等长的两段。</p><p>要进行二等分，只需对要操作的面的相对交点做连线，找两条连线的交点和消失线做直线，该直线即为等分线，其和面的边的交点即为等分点。</p><p>比如，要二等分 CD，则先连接 AC，BD，找到交点 E，直线 EY 即为二等分线，EY 和 AB，CD 的交点为二等分点；垂直方向的二等分点同理。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E4%BA%8C%E7%AD%89%E5%88%86.gif" alt="二等分"></p><p>这个很容易证明，不表了。</p><h2 id="倍增线段"><a href="#倍增线段" class="headerlink" title="倍增线段"></a>倍增线段</h2><p>倍增线段，该画法将一条指向消失点的线段长度增加一倍。它常用于“拷贝”等分点。</p><p>要做 DC 的倍增线段，需要找到 BC 的中点 E（在垂直方向上应用二等分），连接和延长 AE，AE 和 DC 的延长线交点为 F，则 DC &#x3D; CF。 </p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E5%80%8D%E5%A2%9E%E7%BA%BF%E6%AE%B5.gif" alt="倍增线段"></p><p>要证明 DC&#x3D;CF，只需要证明三角形 BEA 和三角形 CEF 全等即可，这是容易证的。</p><h2 id="四等分"><a href="#四等分" class="headerlink" title="四等分"></a>四等分</h2><p>四等分是容易的——做二等分后，前后再各做一次二等分即可。任意 2 的 n 次方等分均可如此。</p><h2 id="任意等分"><a href="#任意等分" class="headerlink" title="任意等分"></a>任意等分</h2><p>偶数等分在网络上都能查到很多资料，现在该来点魔法喽——精确地画出任意 n 等分，即使 n 是质数或任意奇数，这里直接给出规律——<strong>要找到 n 等分点，若 n 为偶数，则需要先找到 n&#x2F;2 等分点（n 等分点可以在找到 n&#x2F;2 等分点后再在前后进行一次二等分得到），若 n 为奇数，则需要先找到 n-1 等分点</strong>。这个方法是如此地机械化，以至于可以编程实现，下面是几种使用该方式的示例，分别使用 p5.js，geogebra，turtle 绘制。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/17%E7%AD%89%E5%88%86.gif" alt="17等分"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/1xx%E7%AD%89%E5%88%86.jpg" alt="1xx等分"></p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/11%E7%AD%89%E5%88%86.jpg" alt="11等分"></p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>现在试着证明，如果已经得到了 n 等分线，能仅通过连线（在平面情况下是做平行线，透视情况下是连接点和消失点）和找交点找到 n+1 等分线。</p><p>考虑下面的平面矩形，我们已经找到 n 等分线（EF），现在要找 n+1 等分点。连接 BD，AF，它们的交点在 n+1 等分线上，证明如下（不会 latex，手写了）：</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E4%BB%8En%E5%88%B0n_p_1.png" alt="从n到 n+1"></p><h3 id="三等分"><a href="#三等分" class="headerlink" title="三等分"></a>三等分</h3><p>要找到三等分点，我们首先需要找到二等分线 EF，然后连接 AF，AF 和 BD 交点就在三等分线上。做完第一个三等分线后，可以使用倍增来找到第二个，或者对后三分之二这个矩形找二等分。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E4%B8%89%E7%AD%89%E5%88%86.gif" alt="三等分"></p><h3 id="五等分"><a href="#五等分" class="headerlink" title="五等分"></a>五等分</h3><p>要找到五等分点，我们首先需要找到四等分线 EF（这是容易做的），然后连接 AF，AF 和 BD 交点就在五等分线上。做完第一个五等分线后，可以对后五分之四的矩形做四等分。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E4%BA%94%E7%AD%89%E5%88%86.gif" alt="五等分"></p><h3 id="七等分"><a href="#七等分" class="headerlink" title="七等分"></a>七等分</h3><p>要找到七等分点，首先需要找到六等分线，要找到六等分线，首先要找到三等分线……以此类推。做完第一个七等分线后，对后七分之六点矩形做六等分即可，或者使用倍增法一步步推。</p><h3 id="十一等分"><a href="#十一等分" class="headerlink" title="十一等分"></a>十一等分</h3><p>剩余无论多少等分都是一样的操作，比如对十一等分，我们需要先找到十等分点，因此需要先找到五等分点，因此需要先找到四等分点……找到第一个十一等分线后，对后十一分之十的矩形做十等分即可。</p><h2 id="透视圆的画法"><a href="#透视圆的画法" class="headerlink" title="透视圆的画法"></a>透视圆的画法</h2><p>不想写了，感觉这个没啥实践意义，留张图。</p><p><img src="/2023/05-25%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86/%E5%9C%86.jpg" alt="透视圆的画法"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Computer Graphics from Scratch》</li><li><a href="https://coloso.global/en/products/illustrator_mogoon_us">https://coloso.global/en/products/illustrator_mogoon_us</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>绘画</tag>
      
      <tag>透视</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Computer Graphics from Scratch》学习笔记——光线追踪器</title>
    <link href="/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8.html"/>
    <url>/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8.html</url>
    
    <content type="html"><![CDATA[<p><img src="/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8/title.png"></p><p>为了更好地绘画，为了能扩宽职业方向（技术美术），学点计算机图形学是很必要的。</p><p>想要在屏幕中展示 3d 图形，归根结底有两种方式：光栅化和光线追踪，这里跟随此书步调，从光线追踪技术开始计算机图形学的学习。下面的描述中，均使用左手坐标系（大拇指指向自己，食指指向上方，此时大拇指，食指，中指分别为 x，y，z），并且镜头位置固定在<code>(0, 0, 0)</code>，且指向 z 轴正方向，上方为 y 轴正方向（关于任意位置和角度的镜头的算法，待学习光栅化时再学习）。</p><h1 id="从-canvas-到-viewport"><a href="#从-canvas-到-viewport" class="headerlink" title="从 canvas 到 viewport"></a>从 canvas 到 viewport</h1><p>首先是 canvas 和 viewport 的概念，为什么同时需要 canvas 和 viewport 这两个抽象？因为 canvas 对应显示屏或应用的窗口，它的单位是像素，是离散的，viewport 是 3d 坐标系下的一个面（或许不是平面），它的单位是真实世界单位比如米，它是连续的，考虑到 viewport 和 canvas 的量纲的差别，他们的比例也可以有不同，viewport 甚至可以不是平面…将它们做区分是有理由的。</p><p>算法的第一步是根据 canvas 的像素去找到 viewport 的对应位置（为什么不是从 viewport 开始？因为 viewport 是连续的，而且可能会有多个 viewport 上的点会对应到 canvas 上同一个像素，这时候如何确认这个像素使用哪个点？），考虑到当前的 canvas 和 viewport 均是矩形，做映射是容易的，下面是各变量及意义，及相关映射的方程：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 常量：</span><br>d  <span class="hljs-comment">// 相机和 viewport 的距离</span><br>Vw <span class="hljs-comment">// viewport 的宽度（米）</span><br>Vh <span class="hljs-comment">// viewport 的高度（米）</span><br>Cw <span class="hljs-comment">// canvas 的宽度（像素）</span><br>Ch <span class="hljs-comment">// canvas 的高度（像素）</span><br><br><span class="hljs-comment">// 变量：</span><br>Cx <span class="hljs-comment">// canvas 像素的 x 轴坐标（原点为 canvas 中心）</span><br>Cy <span class="hljs-comment">// canvas 像素的 y 轴坐标（原点为 canvas 中心）</span><br><br><span class="hljs-comment">// 求出 viewport 上的点</span><br>Vx = Cx * Vw / Cw   <span class="hljs-comment">// 向 z 轴方向看，canvas 和 viewport 的 x 轴方向一致，y 轴相反，原点也一致，这里直接做缩放即可</span><br>Vy = - Cy * Vy / <span class="hljs-type">Cw</span><br><span class="hljs-variable">Vz</span> <span class="hljs-operator">=</span> d <span class="hljs-comment">// 规定如此</span><br></code></pre></div></td></tr></table></figure><h1 id="直线的表示法"><a href="#直线的表示法" class="headerlink" title="直线的表示法"></a>直线的表示法</h1><p>直到绘制像素点之前，后面的步骤不再需要使用 canvas 了。第二步需要做相机到该位置的射线（这和实际光线的运动方式是相反的，但实现起来更容易），这需要对射线建模，假设相机位置为 O，viewport 上的点为 V，则从 O 到 V 的向量为 V-O，直线上任何一点 P 可以表示为：</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">P = O + <span class="hljs-built_in">t</span>(V - O) // 其中 <span class="hljs-built_in">t</span> 为自变量<br></code></pre></div></td></tr></table></figure><p>在这里，V-O 的大小显然是可以任意放缩的，这里令 V-O&#x3D;D，则有：</p><figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">P</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">O</span> <span class="hljs-operator">+</span> <span class="hljs-variable">tD</span> <span class="hljs-operator">//</span> <span class="hljs-built_in">D</span> 为 <span class="hljs-variable">V</span><span class="hljs-operator">-</span><span class="hljs-built_in">O</span> 方向上的矢量<br></code></pre></div></td></tr></table></figure><h1 id="检查直线和球体相交"><a href="#检查直线和球体相交" class="headerlink" title="检查直线和球体相交"></a>检查直线和球体相交</h1><p>第三步是检查射线是否和球体相交，方法如下：</p><p>假设球的球心为 C，半径为 r，则球上任意一点 P 满足：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">distance</span><span class="hljs-params">(C, P)</span></span> = r<br></code></pre></div></td></tr></table></figure><p>即：</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">|<span class="hljs-type">P</span> - C| <span class="hljs-type">= r</span><br></code></pre></div></td></tr></table></figure><p>即：</p><figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">C</span><span class="hljs-operator">,</span> <span class="hljs-variable">P</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-variable">r</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>这里要求 P 也在射线上，带入 P &#x3D; O + tD，同时令 O - C &#x3D; CO：</p><figure class="highlight fix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fix"><span class="hljs-attr">(CO + tD, CO + tD) </span>=<span class="hljs-string"> r^2</span><br></code></pre></div></td></tr></table></figure><p>点乘满足分配律，即 (a + b, c) &#x3D; ac + bc，应用此，得到：</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode"><span class="hljs-comment">(CO + tD, CO)</span> + <span class="hljs-comment">(CO + tD, tD)</span> = r^<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>再次应用，得到：</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode"><span class="hljs-comment">(CO, CO)</span> + <span class="hljs-comment">(tD, CO)</span> + <span class="hljs-comment">(CO, tD)</span> + <span class="hljs-comment">(tD, tD)</span> = r^<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>点乘满足交换律，即 (a, b) &#x3D; (b, a)，且满足 (ta, b) &#x3D; t(a, b) &#x3D; (a, tb)，带入得到：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">t</span>^<span class="hljs-number">2</span>(D, D) + <span class="hljs-number">2</span>t(D, CO) + (CO, CO) - r^<span class="hljs-number">2</span> = <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>可以看到，这是一个一元二次方程，且 D，CO，r 均已知，可以据此求出结果方程：</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">令 <span class="hljs-comment">(D, D)</span> = a, <span class="hljs-number">2</span><span class="hljs-comment">(D, CO)</span> = b, <span class="hljs-comment">(CO, CO)</span> - r^<span class="hljs-number">2</span> = c，有：<br><br>t<span class="hljs-number">1</span>, t<span class="hljs-number">2</span> = <span class="hljs-comment">(-b ± sqrt(b^2 - 4ac)</span> / <span class="hljs-number">2</span>a)<br></code></pre></div></td></tr></table></figure><p>能够意识到，只消允许 O 为任意点，可以求出任意射线和任意球体的交线。</p><p>可以发现这里使用的完全是向量，没有将它解构成坐标。代码实现如下，这里返回 t 而非具体的交点，因为 t 可以用来判断点是在 viewport 前还是在 viewport 后：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取特定射线 O + t * direction 和任意球体的相交时的 t</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> O 射线的起点</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> direction 射线的方向向量，长度随意；但若 O + direction 在 viewport 上，通过 t 可以检查交点在 viewport 前面或者后面</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> C 球体的球心</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> r 球体的半径</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns</span> t 的集合，大小可以为 0,1,2</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLineSphereIntersections</span>(<span class="hljs-params">O: Vector, direction: Vector, C: Vector, r: number</span>): number[] &#123;<br>  <span class="hljs-keyword">const</span> D = direction<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CO</span> = O.<span class="hljs-title function_">plus</span>(C.<span class="hljs-property">reverse</span>)<br>  <span class="hljs-keyword">const</span> a = D.<span class="hljs-title function_">dotProduct</span>(D)<br>  <span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span> * D.<span class="hljs-title function_">dotProduct</span>(<span class="hljs-variable constant_">CO</span>)<br>  <span class="hljs-keyword">const</span> c = <span class="hljs-variable constant_">CO</span>.<span class="hljs-title function_">dotProduct</span>(<span class="hljs-variable constant_">CO</span>) - r * r<br><br>  <span class="hljs-keyword">const</span> ts = evalQuad(a, b, c)<br>  <span class="hljs-keyword">if</span> (ts.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ts<br>  <span class="hljs-keyword">const</span> [t1, t2] = ts<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPoint</span>(<span class="hljs-params">t: number</span>): <span class="hljs-title class_">Vector</span> &#123;<br>    <span class="hljs-keyword">return</span> O.<span class="hljs-title function_">plus</span>(D.<span class="hljs-title function_">multiply</span>(t))<br>  &#125; <br>  <span class="hljs-keyword">return</span> [t1, t2]<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1><p>剩下的逻辑就简单了，做射线后，找到和每个球的交点，找到最近的且在 viewport 外的交点，找到对应的球，渲染它的颜色，总的实现使用伪代码表示就是：</p><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">for</span> 像素 <span class="hljs-keyword">in</span> canvas 的每个像素：<br>    找到 view<span class="hljs-keyword">port</span> 上对应位置<br>    做相机到该位置的射线<br>    找到射线和所有物体交点<br>    相交物体 = 最近的交点的物体<br>    <span class="hljs-keyword">if</span> 相交物体 != null: <br>        打印物体固有色<br></code></pre></div></td></tr></table></figure><p>最后的效果就像一张二维图片，因为这个世界没有光（更实际地说，是只有白色的泛光），因此物体只有固有色，没有立体感，下一步是定义光源的概念，对每一个位置，将物体的固有色乘以此处光源强度得到此处颜色。</p><p><img src="/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8/start.png" alt="start"></p><p>注意处在画面边缘的球体的畸变，这个非常有意思。</p><h1 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h1><p>物体在画面中所占的大小，就是物体向镜头方向在 viewport 上的投影的大小。这种抽象可以自动地表达平放的六面体的一点，二点透视；三点透视需要能够修改镜头的俯仰角。</p><p>首先是一点透视，六面体若有一个面平行于 viewport，则它是一点透视的，它的特性是如果这个六面体在平行于 viewport 的这个面上竖直方向移动，则水平方向的线的长度是固定的，竖直方向会有透视；水平方向移动则反之。这是很不符合直觉的，甚至如果是球体，则竖直移动时，竖直方向会变得更长，最后简直像纺锤形了，但可以通过平面作图证明这一点。</p><p>二点透视发生在六面体没有面平行于 viewport，但有线平行于 viewport，后面不表了。</p><p>四点，五点透视需要 viewport 非平面。</p><h1 id="焦距，视场角"><a href="#焦距，视场角" class="headerlink" title="焦距，视场角"></a>焦距，视场角</h1><p>FOV，视场角，它是水平方向的视野范围，单位是度，可以使用 FOV 和 D（viewport 和镜头的距离）来计算 viewport 的长宽：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FOV</span> = <span class="hljs-number">120</span><br><span class="hljs-keyword">const</span> D = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">const</span> H = D / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-variable constant_">FOV</span> / <span class="hljs-number">2</span> / <span class="hljs-number">180</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Vw</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(H * H - D * D) * <span class="hljs-number">2</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Vh</span> = <span class="hljs-title class_">Vw</span> * <span class="hljs-title class_">Ch</span> / <span class="hljs-title class_">Cw</span><br></code></pre></div></td></tr></table></figure><p>FOV 和镜头的焦距成反比，短焦镜头的 FOV 大，能看到更多内容，空间变形幅度大，长焦镜头 FOV 小，看到内容更少，空间会有种压缩感，近大远小不明显，下面是 FOV 不同时的例子：</p><p><img src="/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8/FOV_120.jpg" alt="FOV=120"></p><p><img src="/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8/FOV_60.jpg" alt="FOV=60"></p><p><img src="/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8/FOV_20.jpg" alt="FOV=20"></p><p><img src="/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8/FOV_5.jpg" alt="FOV=5"></p><p>这点可以利用到画画中，只需要调整远离镜头的线的长度，便能够表现出不同的镜头感。</p><p><img src="/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8/FOV_60_chair.jpg" alt="FOV=60"></p><p><img src="/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8/FOV_20_chair.jpg" alt="FOV=20，注意该图的“地面”并非无限大的，所以椅子的上部会在“地平线”（视平线）之上，这实际上是不可能的"></p><h1 id="光"><a href="#光" class="headerlink" title="光"></a>光</h1><p>可以简单定义三种光源：点光（如灯泡），直射光（如太阳，镭射灯），环境光（天光，暗面的反射光），为了简单起见，光均是白光，因此只需要一个维度 i：intensity 表示亮度（色光用 3 个维度 rgb）；不考虑大气透视。</p><p>对场景中任意点为 P，光线到 P 点的向量 L（大小任意，因为没有大气透视），则对点光，光源为 Q，L &#x3D; Q - P；对直射光，L 直接给定；反射光是光在其它物体上的反射所造成，为此，我们需要让每个物体都成为光源，这复杂过了头，对其的抽象则是所谓的环境光，它对每个点都施加同样的亮度，这又简化过了头（就像古早的 3d 游戏），但不是不能用。一个场景只能有一个环境光（不同环境光可以直接组合），可以有任意点光和直射光，任意点上的光量为所有光在该处光量的和（现实如此）。</p><p>光打到物体后，物体的反射光打到眼睛里，我们才能看到物体；物体反射光的能力书中将它们分为 matte 和 shiny，这里把他们称为调子和高光。任何物体都一定会既有调子也有高光，无论是石膏还是金属，只不过高光的程度各有差异罢了。</p><p>一般来说，对特定物体，光打到它后会均匀向各个方向反射，因此从各个角度看来，它的特定位置的亮度是一样的，不随人的视线方向为转移；这时候。特定位置的亮度就取决于光和物体表面的夹角了，垂直于光的部分亮度最高，夹角越小，单位面积就会接受越少的光，亮度就越小。</p><p>假设单位光强度为 I，光打到的面积为 A，则此时的单位面积上的光强度为 kI&#x2F;A；规定当 I 垂直于点所在平面的时候，kI&#x2F;A&#x3D;1，问题就变成，光和点的法线呈一个角度 a 的时候，此时的 kI&#x2F;A 的值是什么？只从二维来看，把 A 当成线段的长度的话，在某角度 a 下，kI&#x2F;A &#x3D; cos(a)，假设平面的法向量为 N，光向量为 L，根据点乘规律 (N, L) &#x3D; |N||L|cos(a)，就可以求得 cos(a) 了。对某个点，我们只需要计算面在该点上的法向量，然后对每一个光源获取它在该点处的光强度，将所有结果加和即可，即下面的公式：</p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">I = I 环境光 + I0<span class="hljs-symbol">*</span>(N, L0)/|<span class="hljs-string">N</span>||<span class="hljs-string">L0</span>|<span class="hljs-string"> + I1*(N, L1)/</span>|<span class="hljs-string">N</span>||<span class="hljs-string">L1</span>|<span class="hljs-string"> + ... + In*(N, Ln)/</span>|<span class="hljs-string">N</span>||<span class="hljs-string">Ln</span>|<br></code></pre></div></td></tr></table></figure><p>上面当 (N, L0) 小于 0 的时候需要返回 0，此时为物体在光线的背部。</p><p>我不懂微积分，不知道这种推导过程是否正确，但最后效果不错就好。</p><p>需要注意的是，I 的上限是无限的，我们需要做好“曝光”，这里简单要求所有光源 intensity 的和极限为 1.0，然后对于某点的颜色，直接用总的 intensity 乘以球体的固有色 rgb 即可；这效果会非常土就是了……</p><p><img src="/2023/05-17%E3%80%8AComputer%20Graphics%20from%20Scratch%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%99%A8/light.jpg" alt="light"></p><h1 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h1><p>上面的算法没有考虑阴影，但加入阴影也是简单的。只需要在计算某点来自特定光源的I的时候，检查该点和光源之间是否有其它物体存在即可。遍历物体时第一想法是把当前物体排除掉（不然会得到 t&#x3D;0 的结果），这在只有球体的情况下还算可用，但无法处理复杂物体自己遮挡自己的情况（比如用手在眼睛上挡住太阳），考虑将出发点的位置从该点往外偏移一些，或者限制一下t的值。</p><h1 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h1><p>少女祈祷中……</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>核心是递归操作——第一趟是做镜头到viewport上某点的射线，检查对所有物体的交点，第二趟就是从交点开始，按反射的方向去做射线，不断递归，直到什么物体都没打到，或者达到设计的反射次数的上限（一般3次就足够了）。</p><p>少女祈祷中……</p>]]></content>
    
    
    
    <tags>
      
      <tag>CG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程模式——单线程执行，保护性暂挂</title>
    <link href="/2023/03-15%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E6%8C%82.html"/>
    <url>/2023/03-15%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E6%8C%82.html</url>
    
    <content type="html"><![CDATA[<p>最近学很多并发，是时候该开始做一些笔记了，跟随《图解 Java 多线程设计模式》一书，把所学的东西在设计模式的角度下统筹一下。我疑心这些模式究竟能否称为设计模式，它们所涉及的其实并非架构，而是一些更特定，细节，具体的东西，或许叫编程模式更为适当？但管他呢。</p><p>这篇笔记学习它的 Single Threaded Execution，Guarded Suspension 模式，Immutable 模式已近乎本能，不需要特地学习。</p><h1 id="Single-Threaded-Execution-模式"><a href="#Single-Threaded-Execution-模式" class="headerlink" title="Single Threaded Execution 模式"></a>Single Threaded Execution 模式</h1><p>Single Threaded Execution，其实就是单线程执行。这通常出现在需要把对某些资源的操作<strong>原子化</strong>时，即需要<strong>让其它线程要么看到该操作未开始，要么看到该操作完成，不能看到其中的中间状态</strong>；一个非常典型的例子是<strong>条件失效（Slipped Conditions）</strong>，它是说<strong>代码赖以执行的条件在进行检查时满足，其后执行时却不满足</strong>了，这在单线程环境下是不可能的（下面这个例子仍是可能的，考虑其它进程也在操作文件）。</p><p>条件失效是 Race Condition 竞态条件的一种实例。</p><h2 id="锁，资源，原子化"><a href="#锁，资源，原子化" class="headerlink" title="锁，资源，原子化"></a>锁，资源，原子化</h2><p>考虑这样一个函数，它尝试创建一个文件，倘若文件存在，就先删除该文件，再创建和返回文件：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> File <span class="hljs-title function_">createFile</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br>    <span class="hljs-keyword">if</span> (file.exists()) &#123; <span class="hljs-comment">// check and act</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> file.delete(); <br>        <span class="hljs-keyword">if</span> (!res) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(String.format(<span class="hljs-string">&quot;文件 %s 删除失败&quot;</span>, path));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        file.createNewFile();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); &#125;<br>    <span class="hljs-keyword">return</span> file;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>这个例子中的文件虽然是局部变量，但是其是从文件系统中获取的，这个文件系统对所有线程都是可见、共享的</p></blockquote><p>对这个函数，只要有相应权限，无论文件存在与否，对同一个路径连续调用两次 getFile 也是没问题的，但在多线程环境下呢？<code>file.delete</code>可能会返回 false，因此抛出异常，这表示，<code>file.delete</code>赖以执行的条件<code>file.exists</code>失效了——<strong>在试图删除这个文件时，这个文件已经不存在了</strong>。为此，<strong>就需要保证检查文件是否存在和删除文件这个过程是原子的</strong>以避免这个问题。</p><p>想要保证这个过程是原子的，仅对它本身加锁是不够的，在执行锁中的过程时，文件的状态仍旧可能被改变，也就是说<code>file.createNewFile</code>会被执行；我们<strong>需要保证对文件进行的每一个操作都是原子的，才能保证这个过程是原子的</strong>（当然，大可直接把锁加到整个方法上）。</p><p>或者说，<strong>锁保护的是资源</strong>，而非是过程，总是去明确锁保护哪些资源，是否在某些地方遗漏了保护（这等于没有保护），是重要的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> File <span class="hljs-title function_">getFile</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br>    <span class="hljs-keyword">synchronized</span> (path.intern()) &#123; <span class="hljs-comment">// 这里可以换成双重检查锁以提高性能</span><br>        <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> file.delete(); <br>            <span class="hljs-keyword">if</span> (!res) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(String.format(<span class="hljs-string">&quot;文件 %s 删除失败&quot;</span>, path));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (path.intern()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            file.createNewFile();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); &#125;<br>        <span class="hljs-keyword">return</span> file;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="共享资源，临界区"><a href="#共享资源，临界区" class="headerlink" title="共享资源，临界区"></a>共享资源，临界区</h2><p>这便是 Single Threaded Execution 模式，其只有一个角色，即 Shared Resource 共享资源，其用于供多线程去并发访问。例子中的文件便是共享资源。对共享资源的读写必须得到正确同步，否则共享资源的状态可能被损坏。Single Threaded Execution 保证对共享资源的单线程访问。</p><p>只允许单个线程执行的程序<strong>范围</strong>称为临界区。</p><p>下列情况下，需要使用 Single Threaded Execution 模式：</p><ol><li>多个线程同时访问共享资源</li><li>共享资源的状态会发生变化，若使用 Immutable 模式，就能避免这一条</li><li>安全性需要被确保；如果有时候安全性是可以违背的，比如允许某计数器有一定偏差，不进行同步也不是不行。</li></ol><p>并且，即使共享资源的所有方法都是线程安全的，也不保证对其进行组合操作是线程安全的，比如考虑一个可变的 Point（不要这么干！）：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-comment">// 这个锁没意义，因为 32 位赋值本来就是原子的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setX</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setY</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br>    <span class="hljs-comment">// getters...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>倘若某个线程要将某 point 置为<code>(1, 1)</code>，某线程要将该 point 置为<code>(-1, -1)</code>，最后根据线程调度顺序的不同，该 point 最后的值可能为<code>(1, -1)</code>, <code>(-1, 1)</code>；若要同步这两个线程，需要为元组<code>(x, y)</code>加锁，亦即对 point 本身加锁：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">thread1</span><span class="hljs-params">(Point point)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(point) &#123;<br>        point.setX(<span class="hljs-number">1</span>)<br>        point.setY(<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">thread2</span><span class="hljs-params">(Point point)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(point) &#123;<br>        point.setX(-<span class="hljs-number">1</span>)<br>        point.setY(-<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>与其这样操作，不如把 Point 变成不可变对象，每次去创建新 Point，然后修改引用。</p><h1 id="Guarded-Suspension-模式"><a href="#Guarded-Suspension-模式" class="headerlink" title="Guarded Suspension 模式"></a>Guarded Suspension 模式</h1><p>Guarded Suspension 保护性暂挂模式，是利用 wait&#x2F;notify 机制去让某线程去等待直到满足再去执行操作，其既是为了保证安全性，也是<strong>一种线程之间协同的机制</strong>。</p><p>Guarded Suspension 模式应用在某些操作需要满足条件才能去执行的情况，其中若条件满足则直接执行，若条件不满足则<strong>等待条件满足</strong>后再执行。</p><p>考虑一个无限长度的阻塞队列，提供一个 offer 和 take 方法去向队列中放入元素和取出元素，其中要求 take 方法在队列为空时等待直到非空才去获取。</p><blockquote><p>这种 take 在单线程的时候是没意义的——如果当前队列为空，则在之后它不可能自动变为非空，因为没有其它线程去操作它。</p></blockquote><p>如果不知道 wait&#x2F;notify 机制的存在的话，可能会想到使用轮询去检查队列是否非空：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;T&gt;();<br>    <span class="hljs-comment">// 需要加锁以同步对 queue 的访问</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T t)</span> &#123;<br>        queue.offer(t);<br>    &#125;<br><br>    <span class="hljs-comment">// 不能给方法外部加锁，这会导致无法 offer，必然死锁</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>                <span class="hljs-keyword">if</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-keyword">return</span> queue.remove();<br>                &#125;<br>            &#125;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这能满足需求，但并不优雅且性能可能极差，idea 也会警告说可能 busy-waiting。解决方法是使用 java 所提供的线程协同机制 wait&#x2F;notify 去进行同步，而非用轮询去进行同步。</p><h2 id="Java-的线程协同机制：wait-x2F-notify"><a href="#Java-的线程协同机制：wait-x2F-notify" class="headerlink" title="Java 的线程协同机制：wait&#x2F;notify"></a>Java 的线程协同机制：wait&#x2F;notify</h2><p>wait&#x2F;notify 是一种通知机制，当某线程持有锁并 wait 时，其将<strong>释放锁</strong>并挂起，直到被中断，或其它线程持有锁时调用 notify&#x2F;notifyAll 方法；某线程持有锁并执行 notify 时，其会将 wait 的一个或所有线程重新加入锁的等待队列（<strong>此时并不释放锁</strong>），并继续执行。执行 wait 和 notify 时必须持有锁。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Thread1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            System.out.println(<span class="hljs-string">&quot;t1: before wait&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.wait();<br>                System.out.println(<span class="hljs-string">&quot;t1: after await&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Thread2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            System.out.println(<span class="hljs-string">&quot;t2: before notify&quot;</span>);<br>            lock.notify();<br>            <span class="hljs-keyword">try</span> &#123;<br>                 Thread.sleep(<span class="hljs-number">10</span>); <span class="hljs-comment">// 即使 sleep，也不会有改变</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>            System.out.println(<span class="hljs-string">&quot;t2: after notify&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(WaitNotifyTest::Thread1).start();<br>        Thread.sleep(<span class="hljs-number">10</span>); <span class="hljs-comment">// notify 必须在 wait 之后执行才有效果</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(WaitNotifyTest::Thread2).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后输出结果必定如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-symbol">t1:</span> <span class="hljs-keyword">before </span><span class="hljs-keyword">wait </span>    -- 首先是 <span class="hljs-built_in">t1</span> 开始执行<br><span class="hljs-symbol">t2:</span> <span class="hljs-keyword">before </span>notify   -- <span class="hljs-built_in">t1</span> 遇到 <span class="hljs-keyword">wait，释放锁并挂起（变为 </span><span class="hljs-keyword">waiting），t2 </span>拿到锁，开始执行<br><span class="hljs-symbol">t2:</span> after notify    -- <span class="hljs-built_in">t2</span> 执行 notifyAll 之后，释放锁之前，这一行必定在 <span class="hljs-built_in">t1</span>: after await 之前输出<br><span class="hljs-symbol">t1:</span> after await     -- <span class="hljs-built_in">t2</span> 释放锁，<span class="hljs-built_in">t1</span> 拿到锁，执行之后的工作<br></code></pre></div></td></tr></table></figure><h2 id="使用-wait-x2F-notify-实现互斥锁"><a href="#使用-wait-x2F-notify-实现互斥锁" class="headerlink" title="使用 wait&#x2F;notify 实现互斥锁"></a>使用 wait&#x2F;notify 实现互斥锁</h2><p>这个例子介绍了 wait&#x2F;notify 的性质，下面是一个更有趣的实例——用 wait&#x2F;notify 机制实现 Mutex，即不可重入的互斥锁：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span> &#123;<br>    <span class="hljs-comment">// 该字段存储持有锁的线程的 id，通过 Thread.currentThread().getId() 获取，为线程的唯一标识符</span><br>    <span class="hljs-comment">// 因为 currentId 只在 synchronized 块中被访问，所以不需要 volatile</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Long</span> <span class="hljs-variable">currentId</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(currentId != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>        &#125;<br>        currentId = Thread.currentThread().getId();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentId == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;锁未被持有&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!currentId.equals(Thread.currentThread().getId())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;当前线程未持有锁&quot;</span>);<br>        &#125;<br>        currentId = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.notify();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>locked 字段表示该锁是否被持有。其机制是，当某线程调用 lock 方法时，检查锁是否被持有，若已持有，则等待并释放锁，否则持有锁，标记当前 id 为自身；解锁时，检查是否是自己持有锁，并释放锁，通知所有 wait 的线程继续执行。</p><p>这里有一个问题，为什么要在 while 中进行 wait 而非 if？假设我们把这里改成 if，假设锁已被占有时，两个线程同时调用了 lock 方法，并在 wait 处挂起；这时，当持有锁的线程解锁时，两个线程会先后从 wait 处开始执行，而他们都会修改 currentId，这意味着锁会被后来者抢走，出现了 bug。而若使用 while 做判断时，先执行的线程设置完 currentId 后，后执行的线程会在 while 中再次检查 currentId（记住，这两个线程执行的过程都是在 synchronized 块里的，不会有冲突），它发现 currentId 仍旧不是 null，因此会继续 wait。</p><p>总而言之，不使用 while 做判断的话，会存在这样的情况，即<strong>线程被唤醒了，但它等待的条件却并未满足</strong>（这种情况似乎称为虚假唤醒），while 负责让这样的线程再次检查条件是否满足。</p><h2 id="使用-wait-x2F-notify-实现无界阻塞队列"><a href="#使用-wait-x2F-notify-实现无界阻塞队列" class="headerlink" title="使用 wait&#x2F;notify 实现无界阻塞队列"></a>使用 wait&#x2F;notify 实现无界阻塞队列</h2><p>使用 wait&#x2F;notify 机制，上面的阻塞队列就可以更优雅地实现了：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;T&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T t)</span> &#123;<br>        queue.offer(t);<br>        notify();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e); &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.remove();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="使用-ReentrantLock-和-Condition-实现有界阻塞队列"><a href="#使用-ReentrantLock-和-Condition-实现有界阻塞队列" class="headerlink" title="使用 ReentrantLock 和 Condition 实现有界阻塞队列"></a>使用 ReentrantLock 和 Condition 实现有界阻塞队列</h2><p>ReentrantLock 为可重入锁，可以用于实现 synchronized 代码块，ReentrantLock::newCondition 用于创建对应该锁的条件变量，其可用于实现 wait&#x2F;notify 机制，其相较于synchronized更加灵活，包括但不限于：</p><ol><li>ReentrantLock使用lock和unlock方法显式地加锁解锁，并有tryLock，lockInterruptibly等方法，允许可中断，可超时地获取锁，功能更强大（bug也更多）</li><li>ReentrantLock允许创建多个信号变量对应同一把锁</li></ol><p>使用ReentrantLock，我们可以实现有界的阻塞队列，其包含两个信号变量notEmpty和notFull，用于在队列非空时通知消费者，队列非满时通知生产者。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxQueueSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;T&gt; queue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> maxQueueSize)</span> &#123;<br>        <span class="hljs-keyword">assert</span> maxQueueSize &gt; <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.maxQueueSize = maxQueueSize;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 尝试把值入队列，若满则阻塞</span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> t</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T t)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(queue.size() == maxQueueSize) &#123;<br>                notFull.await();<br>            &#125;<br>            queue.offer(t);<br>            notEmpty.signalAll();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 移除和返回队列头部，无值则阻塞</span><br><span class="hljs-comment">        * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(queue.size() == <span class="hljs-number">0</span>) &#123;<br>                notEmpty.await();<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> queue.remove();<br>            notFull.signalAll();<br>            <span class="hljs-keyword">return</span> res;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当前对绘画的练习方式</title>
    <link href="/%E5%BD%93%E5%89%8D%E5%AF%B9%E7%BB%98%E7%94%BB%E7%9A%84%E7%BB%83%E4%B9%A0%E6%96%B9%E5%BC%8F.html"/>
    <url>/%E5%BD%93%E5%89%8D%E5%AF%B9%E7%BB%98%E7%94%BB%E7%9A%84%E7%BB%83%E4%B9%A0%E6%96%B9%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<h1 id="inking"><a href="#inking" class="headerlink" title="inking"></a>inking</h1><p>没有色块，没有网点，只有线条，排线和纯黑，博老师的感觉…这个恐怕很难驾驭。</p><h1 id="动漫黑白薄涂"><a href="#动漫黑白薄涂" class="headerlink" title="动漫黑白薄涂"></a>动漫黑白薄涂</h1><p>练习线条，神态，人体，褶皱，构图……工作量小，容易出效果，能够做能力的检验，和作为原型，但更高阶和抽象，练习效果可能不好。</p><p>草稿使用darken或者multiply的笔刷模拟铅笔质感（草稿中可以包含调子，如果调子复杂可以考虑另起图层），其后用normal笔刷另起图层勾线。</p><h1 id="黑白厚涂"><a href="#黑白厚涂" class="headerlink" title="黑白厚涂"></a>黑白厚涂</h1><p>练习shading，光影，人体，褶皱，材质……</p><!--**对下面任何练习，如果对原创的结果不满意，考虑进行各种试验，以及寻找参照后重画，以图切实地解决问题**。# 各角度大头练习把各角度的大头都能画好是必要的，需要熟悉正面，15度，45度，75度，90度的头的（轮廓）画法，以及各个角度的俯视，仰视。练习方式主要是临摹漫画中的大头，以及根据想象去绘制各角度。该练习可以考虑同时练习头颈肩关系。# 五官，表情神态练习练习各种形态的眼睛，以及各种形态的表情，练习方式同样为临摹和根据想象绘制。该练习应当在大头练习有一定效果后再开始。# 头发练习练习如何绘制出头发的体积感，如何绘制细节丰富的头发，以及各种发型，各种发色在各种画材、画风下的上调子的方式练习方式是临摹（并总结），以及根据想象绘制。# shading练习练习上调子的能力，练习方式是画照片，实物，以及使用黑白、厚涂法去进行临摹。当前仅注重调子，专心value和shape，texture，color等后期再专门练习，先要发展抽象形状的能力。# 起形练习练习明确形状的能力，练习方式是画照片，实物，以及临摹，素材任意，使用铅笔或类铅笔笔刷。# 线条练习TODO -->]]></content>
    
    
    
    <tags>
      
      <tag>画画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 js 中使用 generator 模拟 do 语法</title>
    <link href="/2023/01-30%E5%9C%A8js%E4%B8%AD%E4%BD%BF%E7%94%A8generator%E6%A8%A1%E6%8B%9Fdo%E8%AF%AD%E6%B3%95.html"/>
    <url>/2023/01-30%E5%9C%A8js%E4%B8%AD%E4%BD%BF%E7%94%A8generator%E6%A8%A1%E6%8B%9Fdo%E8%AF%AD%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>该特性仅供玩耍，有诸多限制，且在 Typescript 中不可用</p></blockquote><p>Haskell 的 do 语法糖用于将 Monad 的组合计算扁平化，下面是一个对 List 的组合计算，以及在 js 中的等价代码：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">do</span><br>  a &lt;- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>  b &lt;- [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>  return $ a + b<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <br>  [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <br>    [a + b])) <span class="hljs-comment">// return 函数对 List 即为 x =&gt; [x]</span><br></code></pre></div></td></tr></table></figure><p>在编写这种麻烦的嵌套代码的时候，总幻想着有没有方法将其扁平化以方便编写和阅读（确实有，见<a href="https://gcanti.github.io/fp-ts/guides/do-notation.html">https://gcanti.github.io/fp-ts/guides/do-notation.html</a>）；最近发现 js 的 generator 能够去模拟 do 语法，这里做一下记录。</p><p>generator 既能让它往外输出值，也能给它喂值，这里利用后者：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">yield</span><br>  <span class="hljs-keyword">const</span> b = <span class="hljs-keyword">yield</span><br>  <span class="hljs-keyword">return</span> a + b <br>&#125;<br><br><span class="hljs-keyword">const</span> g = <span class="hljs-title function_">gen</span>()<br>g.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// 第一次执行 next，使开始执行，在第一个 yield 阻塞</span><br>g.<span class="hljs-title function_">next</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 喂一个值，继续执行到第二个 yield</span><br><span class="hljs-keyword">const</span> res = g.<span class="hljs-title function_">next</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 再喂一个值，这时走到了 return，可以直接拿到返回值了</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// &#123; value: 3, done: true &#125;</span><br></code></pre></div></td></tr></table></figure><p>考虑下面 Haskell 代码：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">do</span><br>  a &lt;- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>  b &lt;- [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>  [a + b, a * b]<br></code></pre></div></td></tr></table></figure><p>其可以描述为，对任意<code>[1, 2, 3]</code>中的值 a，对任意<code>[1, 2, 3]</code>中的值 b，获取所有 a+b 和 a*b 的值，将所有结果组成列表，最后结果为<code>[1 + 2, 1 * 2, 1 + 3, 1 * 3, 1 + 4, 1 * 4, 2 + 2, 2 * 2, 2 + 3, 2 * 3, 2 + 4, 2 * 4, 3 + 2, 3 * 2, 3 + 3, 3 * 3, 3 + 4, 3 * 4]</code>；</p><p>如何做到这样呢？显然我们只需要获取<code>[1, 2, 3]</code>和<code>[2, 3, 4]</code>的笛卡尔积即可，然后对结果集合中的每个值，都去创建 generator 并把值喂给他。一个例子见下面：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">yield</span><br>  <span class="hljs-keyword">const</span> b = <span class="hljs-keyword">yield</span><br>  <span class="hljs-keyword">return</span> [a + b] <span class="hljs-comment">// do 的返回值是上下文中的，所以这里（及之后都）用数组形式</span><br>&#125;<br><br><span class="hljs-comment">// 首先构造 [1, 2, 3] 和 [2, 3, 4] 的笛卡尔积</span><br><span class="hljs-keyword">const</span> allInputs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <br>  [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">j</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> [i, j]<br>  &#125;))<br><br><span class="hljs-comment">// 对每个笛卡尔积，将其</span><br>allInputs.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function">(<span class="hljs-params">[a, b]</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> g = <span class="hljs-title function_">gen</span>()<br>  g.<span class="hljs-title function_">next</span>() <br>  <span class="hljs-comment">// 下面的代码可以抽象成使用 for 的形式去适配更多个 yield</span><br>  g.<span class="hljs-title function_">next</span>(a)<br>  <span class="hljs-keyword">return</span> g.<span class="hljs-title function_">next</span>(b).<span class="hljs-property">value</span><br>&#125;) <span class="hljs-comment">// [ 3, 4, 5, 4, 5, 6, 5, 6, 7 ]</span><br></code></pre></div></td></tr></table></figure><p>但显然 yield 不一定只有两个，我们需要支持任意个 yield 的情况，因此根据需求，这里编写一个获取任意数量列表的笛卡尔积的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// crossJoin() = []</span><br><span class="hljs-comment">// crossJoin([1, 2, 3]) = [[1], [2], [3]]</span><br><span class="hljs-comment">// crossJoin([1, 2], [3, 4, 5]) = [ [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5] ]</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">crossJoin</span>(<span class="hljs-params">...arrs</span>) &#123;<br>  <span class="hljs-keyword">if</span> (arrs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> []<br>  <span class="hljs-keyword">if</span> (arrs.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arrs[<span class="hljs-number">0</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> [i])<br>  <span class="hljs-keyword">const</span> [x, ...xs] = arrs<br>  <span class="hljs-keyword">const</span> lasts = <span class="hljs-title function_">crossJoin</span>(...xs)<br>  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> lasts.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">js</span> =&gt;</span> [i, ...js]))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后就可以做抽象了：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">listDo</span>(<span class="hljs-params">generator, ...arrs</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">crossJoin</span>(...arrs).<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">elems</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generator</span>()<br>        g.<span class="hljs-title function_">next</span>()<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elems.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>            g.<span class="hljs-title function_">next</span>(elems[i])<br>        &#125;<br>        <span class="hljs-keyword">return</span> g.<span class="hljs-title function_">next</span>(elems[elems.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]).<span class="hljs-property">value</span><br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>玩耍一下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">listDo</span>(<span class="hljs-keyword">function</span>*()&#123;<br>    <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">const</span> b = <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">const</span> sum = a + b<br>    <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [] <span class="hljs-comment">// 筛选掉结果的所有偶数</span><br>    <span class="hljs-keyword">return</span> [sum]<br>&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) <span class="hljs-comment">// [ 3, 5, 5, 5, 7 ]</span><br></code></pre></div></td></tr></table></figure><p>再来考虑另一个典型的 Monad——Maybe，简单抽象一波并实现 map 和 flatMap：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Maybe</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value, tag</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span> || value === <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Nothing</span>()<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(value)<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title class_">Just</span>(value) &#123;<br>        <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span> || value === <span class="hljs-literal">undefined</span>) <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;?&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Maybe</span>(value, <span class="hljs-string">&quot;Just&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title class_">Nothing</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Maybe</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&quot;Nothing&quot;</span>)<br>    &#125;<br>    <span class="hljs-title function_">match</span>(<span class="hljs-params">onJust, onNothing</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> === <span class="hljs-string">&quot;Just&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">onJust</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">onNothing</span>()<br>    &#125;<br>    <span class="hljs-title function_">flatMap</span>(<span class="hljs-params">f</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">match</span>( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title function_">f</span>(x), <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span> )<br>    &#125;<br>    <span class="hljs-title function_">map</span>(<span class="hljs-params">f</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">match</span>( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Maybe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-title function_">f</span>(x)), <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span> )<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>考虑下面的 Haskell 代码：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">do</span><br>  a &lt;- <span class="hljs-type">Just</span> <span class="hljs-number">1</span><br>  b &lt;- <span class="hljs-type">Just</span> <span class="hljs-number">2</span><br>  return $ a + b<br></code></pre></div></td></tr></table></figure><p>对应的 generator 和 flatMap 的形式是：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <br>  <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span><br>    <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(a + b))) <span class="hljs-comment">// // return 函数对 Maybe 即为 Just</span><br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">yield</span><br>  <span class="hljs-keyword">const</span> b = <span class="hljs-keyword">yield</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(a + b)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么，如何去使用这个 generator 呢？考虑 Maybe 的特性——这里有两个 Maybe 值，其中任何一个为 Nothing 时，结果就为 Nothing；若两个都为 Just，则我们把它们的值取出来，应用给这个 generator，具体流程如下（注意该代码与上面数组这样操作的异同）：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> input = <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <br>  <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">j</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> [i, j]<br>  &#125;)) <span class="hljs-comment">// 得到 Just([1, 2])</span><br><br>allInputs.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function">(<span class="hljs-params">[a, b]</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> g = <span class="hljs-title function_">gen</span>()<br>  g.<span class="hljs-title function_">next</span>() <br>  g.<span class="hljs-title function_">next</span>(a)<br>  <span class="hljs-keyword">return</span> g.<span class="hljs-title function_">next</span>(b).<span class="hljs-property">value</span><br>&#125;) <br></code></pre></div></td></tr></table></figure><p>于是和数组一样的问题——如果有多个 yield 怎么办呢？我们需要某种方法去接受一个<code>Array&lt;Maybe&lt;A&gt;&gt;</code>，返回一个<code>Maybe&lt;Array&lt;A&gt;&gt;</code>，它的实现和数组的实现基本相同：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 容易注意到，这就是 sequence 的定义；于是，嵌套列表的 sequence 的行为就是对其中所有子列表做笛卡尔积喽？</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sequenceMaybe</span>(<span class="hljs-params">...maybes</span>) &#123;<br>    <span class="hljs-keyword">if</span> (maybes.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>([])<br>    <span class="hljs-keyword">if</span> (maybes.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> maybes[<span class="hljs-number">0</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x])<br>    <span class="hljs-keyword">const</span> [x, ...xs] = maybes<br>    <span class="hljs-keyword">const</span> lasts = <span class="hljs-title function_">sequenceMaybe</span>(...xs)<br>    <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> lasts.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">js</span> =&gt;</span> [i, ...js]))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后便可以实现 maybe 的 do，它的实现和数组的版本完全相同，除了 sequence 的实例不同：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maybeDo</span>(<span class="hljs-params">generator, ...arrs</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">sequenceMaybe</span>(...arrs).<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">elems</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generator</span>()<br>        g.<span class="hljs-title function_">next</span>()<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elems.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>            g.<span class="hljs-title function_">next</span>(elems[i])<br>        &#125;<br>        <span class="hljs-keyword">return</span> g.<span class="hljs-title function_">next</span>(elems[elems.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]).<span class="hljs-property">value</span><br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>看来这个形式可能可以适用于所有 Monad，但观察这个抽象的形式，它显然有一个限制，就是后面的Monad无法利用前面计算的结果，这让它的实用性大打折扣。but why so serious？</p><p>玩耍一下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maybeDo</span>(<span class="hljs-keyword">function</span>*()&#123;<br>    <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">const</span> b = <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">const</span> c = <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(a + b + c)<br>&#125;, <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(<span class="hljs-number">1</span>), <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(<span class="hljs-number">2</span>), <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(<span class="hljs-number">3</span>))) <span class="hljs-comment">// Maybe &#123; value: 6, tag: &#x27;Just&#x27; &#125;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maybeDo</span>(<span class="hljs-keyword">function</span>*()&#123;<br>    <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">const</span> b = <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">const</span> c = <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(a + b + c)<br>&#125;, <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(<span class="hljs-number">1</span>), <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Nothing</span>(), <span class="hljs-title class_">Maybe</span>.<span class="hljs-title class_">Just</span>(<span class="hljs-number">3</span>))) <span class="hljs-comment">// Maybe &#123; value: undefined, tag: &#x27;Nothing&#x27; &#125;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Monoid 和 Foldable</title>
    <link href="/2023/01-26Monoid,Foldable.html"/>
    <url>/2023/01-26Monoid,Foldable.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>又要工作了……</p></blockquote><h1 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h1><p>Monoid 在 Haskell 中有很多应用，且和折叠操作比较相关，值得学习。</p><p>幺半群 Monoid，或者说半群 with 幺元，那首先得了解半群和幺元是什么玩意。</p><p>半群 Semigroup 是这样一种数学结构，对非空集合 S，对 S 上的二元运算<code>·: S x S -&gt; S</code>，其满足结合律（即对集合 S 上的元素 a，b，c，有<code>a · (b · c) = (a · b) · c</code>），则二元组<code>(S, ·)</code>为半群；幺半群则在半群的基础上添加了一个幺元 identity element——任何元素对其作运算·仍旧得到它自身，这是说假如令幺元为 e，则对 S 上任意元素 a，有<code>a · e = a = e · a</code>，三元组<code>(S, ·, e)</code>为幺半群。</p><p>数学定义抽象且无聊，但幺半群的几个实例是非常明显的：</p><ol><li><code>（Int，+, 0)</code>是幺半群——结合律：<code>1 + (2 + 3) = (1 + 2) + 3</code>, 幺元：<code>1 + 0 = 0 + 1 = 1</code></li><li><code>（Int，*, 1)</code>是幺半群——结合律：<code>1 * (2 * 3) = (1 * 2) * 3</code>, 幺元：<code>2 * 1 = 1 * 2 = 2</code></li><li><code>([a], ++, [])</code>是幺半群——结合律：<code>[1,2] ++ ([3] ++ [4]) = ([1,2] ++ [3]) ++ [4]</code>，幺元：<code>[1,2] ++ [] = [] ++ [1,2] = [1,2]</code></li><li><code>（String，++, &quot;&quot;)</code>是幺半群，同上</li></ol><blockquote><p>结合律允许以任意顺序去执行这样的运算，这允许对其去并行计算。</p></blockquote><p>Haskell 中定义了相应的 typeclass 用来表示幺半群：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- | The class of monoids (types with an associative binary operation that</span><br><span class="hljs-comment">-- has an identity).  Instances should satisfy the following:</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- [Right identity] @x &#x27;&lt;&gt;&#x27; &#x27;mempty&#x27; = x@</span><br><span class="hljs-comment">-- [Left identity]  @&#x27;mempty&#x27; &#x27;&lt;&gt;&#x27; x = x@</span><br><span class="hljs-comment">-- [Associativity]  @x &#x27;&lt;&gt;&#x27; (y &#x27;&lt;&gt;&#x27; z) = (x &#x27;&lt;&gt;&#x27; y) &#x27;&lt;&gt;&#x27; z@ (&#x27;Semigroup&#x27; law)</span><br><span class="hljs-comment">-- [Concatenation]  @&#x27;mconcat&#x27; = &#x27;foldr&#x27; (&#x27;&lt;&gt;&#x27;) &#x27;mempty&#x27;@</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- The method names refer to the monoid of lists under concatenation,</span><br><span class="hljs-comment">-- but there are many other instances.</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Some types can be viewed as a monoid in more than one way,</span><br><span class="hljs-comment">-- e.g. both addition and multiplication on numbers.</span><br><span class="hljs-comment">-- In such cases we often define @newtype@s and make those instances</span><br><span class="hljs-comment">-- of &#x27;Monoid&#x27;, e.g. &#x27;Data.Semigroup.Sum&#x27; and &#x27;Data.Semigroup.Product&#x27;.</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- __NOTE__: &#x27;Semigroup&#x27; is a superclass of &#x27;Monoid&#x27; since /base-4.11.0.0/.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Semigroup</span> a =&gt; <span class="hljs-type">Monoid</span> a <span class="hljs-keyword">where</span></span><br>        <span class="hljs-comment">-- | Identity of &#x27;mappend&#x27;</span><br>        <span class="hljs-comment">--</span><br>        <span class="hljs-comment">-- &gt;&gt;&gt; &quot;Hello world&quot; &lt;&gt; mempty</span><br>        <span class="hljs-comment">-- &quot;Hello world&quot;</span><br>        mempty  :: a<br><br>        <span class="hljs-comment">-- | An associative operation</span><br>        <span class="hljs-comment">--</span><br>        <span class="hljs-comment">-- __NOTE__: This method is redundant and has the default</span><br>        <span class="hljs-comment">-- implementation @&#x27;mappend&#x27; = (&#x27;&lt;&gt;&#x27;)@ since /base-4.11.0.0/.</span><br>        <span class="hljs-comment">-- Should it be implemented manually, since &#x27;mappend&#x27; is a synonym for</span><br>        <span class="hljs-comment">-- (&#x27;&lt;&gt;&#x27;), it is expected that the two functions are defined the same</span><br>        <span class="hljs-comment">-- way. In a future GHC release &#x27;mappend&#x27; will be removed from &#x27;Monoid&#x27;.</span><br>        mappend :: a -&gt; a -&gt; a<br>        mappend = (&lt;&gt;)<br>        <span class="hljs-meta">&#123;-# INLINE mappend #-&#125;</span><br><br>        <span class="hljs-comment">-- | Fold a list using the monoid.</span><br>        <span class="hljs-comment">--</span><br>        <span class="hljs-comment">-- For most types, the default definition for &#x27;mconcat&#x27; will be</span><br>        <span class="hljs-comment">-- used, but the function is included in the class definition so</span><br>        <span class="hljs-comment">-- that an optimized version can be provided for specific types.</span><br>        <span class="hljs-comment">--</span><br>        <span class="hljs-comment">-- &gt;&gt;&gt; mconcat [&quot;Hello&quot;, &quot; &quot;, &quot;Haskell&quot;, &quot;!&quot;]</span><br>        <span class="hljs-comment">-- &quot;Hello Haskell!&quot;</span><br>        mconcat :: [a] -&gt; a<br>        mconcat = foldr mappend mempty<br>        <span class="hljs-meta">&#123;-# INLINE mconcat #-&#125;</span><br>        <span class="hljs-comment">-- INLINE in the hope of fusion with mconcat&#x27;s argument (see !4890)</span><br></code></pre></div></td></tr></table></figure><p>实现其只需要指定二元运算（在半群实例中）和幺元即可，下面定义数字加法幺半群：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Plus</span> = <span class="hljs-type">Plus</span> <span class="hljs-type">Int</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Semigroup</span> <span class="hljs-type">Plus</span> <span class="hljs-keyword">where</span></span><br>  (&lt;&gt;) :: <span class="hljs-type">Plus</span> -&gt; <span class="hljs-type">Plus</span> -&gt; <span class="hljs-type">Plus</span><br>  (<span class="hljs-type">Plus</span> a) &lt;&gt; (<span class="hljs-type">Plus</span> b) = <span class="hljs-type">Plus</span> $ a + b<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> <span class="hljs-type">Plus</span> <span class="hljs-keyword">where</span></span><br>  mempty :: <span class="hljs-type">Plus</span><br>  mempty = <span class="hljs-type">Plus</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>Monoid 的实例需要满足下面的定律：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">(x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) <span class="hljs-comment">-- associativity</span><br><span class="hljs-title">mempty</span> &lt;&gt; x = x               <span class="hljs-comment">-- left identity</span><br><span class="hljs-title">x</span> &lt;&gt; mempty = x               <span class="hljs-comment">-- right identity</span><br></code></pre></div></td></tr></table></figure><p>容易发现，<code>(Bool, &amp;&amp;, True)</code>和<code>(Bool, ||, False)</code>也是幺半群：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- 在标准库中，这里的 And 名称为 All，Or 名称为 Any</span><br><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">And</span> = <span class="hljs-type">And</span> <span class="hljs-type">Bool</span></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Semigroup</span> <span class="hljs-type">And</span> <span class="hljs-keyword">where</span></span><br>  (&lt;&gt;) :: <span class="hljs-type">And</span> -&gt; <span class="hljs-type">And</span> -&gt; <span class="hljs-type">And</span><br>  (<span class="hljs-type">And</span> a) &lt;&gt; (<span class="hljs-type">And</span> b) = <span class="hljs-type">And</span> $ a &amp;&amp; b<br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> <span class="hljs-type">And</span> <span class="hljs-keyword">where</span></span><br>  mempty :: <span class="hljs-type">And</span><br>  mempty = <span class="hljs-type">And</span> <span class="hljs-type">True</span><br><br><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Or</span> = <span class="hljs-type">Or</span> <span class="hljs-type">Bool</span></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Semigroup</span> <span class="hljs-type">Or</span> <span class="hljs-keyword">where</span></span><br>  (&lt;&gt;) :: <span class="hljs-type">Or</span> -&gt; <span class="hljs-type">Or</span> -&gt; <span class="hljs-type">Or</span><br>  (<span class="hljs-type">Or</span> a) &lt;&gt; (<span class="hljs-type">Or</span> b) = <span class="hljs-type">Or</span> $ a || b<br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> <span class="hljs-type">Or</span> <span class="hljs-keyword">where</span></span><br>  mempty :: <span class="hljs-type">Or</span><br>  mempty = <span class="hljs-type">Or</span> <span class="hljs-type">False</span><br></code></pre></div></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Monoid 的定义很简单，但其的使用的地方还是很多的，下面列一些可能常用的：</p><ol start="0"><li><p>列表是 Monoid。</p></li><li><p>Data.Text 是更高性能的字符串，其也是 Monoid 的实例，其无法像<code>[Char]</code>一样使用++去拼接，因此需要使用半群的<code>&lt;&gt;</code>去进行拼接：</p></li></ol><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">str</span> = (<span class="hljs-string">&quot;Hello, &quot;</span> :: <span class="hljs-type">Text</span>) &lt;&gt; <span class="hljs-string">&quot;World!&quot;</span><br></code></pre></div></td></tr></table></figure><ol start="2"><li>Data.Monoid 包下定义了 newtype <code>First</code> 和 <code>Last</code>，用于将<code>Maybe m</code>视为 Monoid，二元运算为取第一个或最后一个 Just 值，取不到则为 Nothing（Nothing 为幺元）；其特别适用于“取变量 x，如果 x 为 null，取变量 y”的需求（更抽象地说，对于变量 a,b,c,d,e…，从前往后或从后往前取第一个非 null 的变量）：</li></ol><blockquote><p>注意，Data.Semigroup 包下也定义了 First 和 Last，但其行为和 Data.Monoid 包下的同名 newtype 不同，Semigroup 包下的 First 和 Last 仅是半群且和 Maybe 无关，二元运算为取前者或后者！（坑啊！</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-type">First</span> (<span class="hljs-type">Just</span> <span class="hljs-number">234</span>) &lt;&gt; <span class="hljs-type">First</span> (<span class="hljs-type">Just</span> <span class="hljs-number">123</span>) = <span class="hljs-type">First</span> (<span class="hljs-type">Just</span> <span class="hljs-number">234</span>)<br><span class="hljs-type">Last</span> (<span class="hljs-type">Just</span> <span class="hljs-number">234</span>) &lt;&gt; <span class="hljs-type">Last</span> (<span class="hljs-type">Just</span> <span class="hljs-number">123</span>) = <span class="hljs-type">Last</span> (<span class="hljs-type">Just</span> <span class="hljs-number">123</span>)<br><span class="hljs-type">Last</span> (<span class="hljs-type">Just</span> <span class="hljs-number">234</span>) &lt;&gt; <span class="hljs-type">Last</span> <span class="hljs-type">Nothing</span> = <span class="hljs-type">Last</span> (<span class="hljs-type">Just</span> <span class="hljs-number">234</span>)<br></code></pre></div></td></tr></table></figure><p>First 也可以直接用类型类<code>Alternative</code>中的<code>&lt;|&gt;</code>替代，这样更清晰些：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-type">Just</span> <span class="hljs-number">234</span> &lt;|&gt; <span class="hljs-type">Just</span> <span class="hljs-number">123</span> = <span class="hljs-type">Just</span> <span class="hljs-number">234</span><br></code></pre></div></td></tr></table></figure><p>顺便，对于<code>Maybe m</code>，若类型变量 m 是 Semigroup，则<code>Maybe m</code>为 Monoid，二元运算行为是将包含的值进行拼接，其中 <code>Nothing</code> 为幺元：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-type">Nothing</span> &lt;&gt; <span class="hljs-type">Just</span> <span class="hljs-string">&quot;Hello&quot;</span> = <span class="hljs-type">Just</span> <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-type">Just</span> <span class="hljs-string">&quot;Hello&quot;</span> &lt;&gt; <span class="hljs-type">Just</span> <span class="hljs-string">&quot;, World!&quot;</span> = <span class="hljs-type">Just</span> <span class="hljs-string">&quot;Hello, World!&quot;</span> <br></code></pre></div></td></tr></table></figure><ol start="3"><li><code>Ordering</code> 类型，即 compare 函数的返回值类型，也是 Monoid，其幺元是<code>EQ</code>，二元运算的行为类似 First，其非常适合这种需求——先比较 x，如果 x 相等，比较 y。比如这里写一个函数比较两个字符串的长度大小，其中规定若两个字符串等长，则比较两个字符串内容：</li></ol><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">lengthCompare</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Ordering</span><br><span class="hljs-title">lengthCompare</span> a b = (length a `compare` length b) &lt;&gt; (a `compare` b)<br></code></pre></div></td></tr></table></figure><h2 id="同态"><a href="#同态" class="headerlink" title="同态"></a>同态</h2><p>乘法有一个所谓的分配律，这是说对实数 a，b，c，有 <code>a * (b + c) = a * b + a * c</code>，定义<code>f(x) = a * x</code>，有<code>f(b + c) = f(b) + f(c)</code>，又能看到，<code>f(0) = 0</code>，这时称函数 f 是一个加法幺半群到加法幺半群上的同态 Homomorphism，抽象地说，对于 Monoid a 和 b，有：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">f</span> :: (<span class="hljs-type">Monoid</span> a, <span class="hljs-type">Monoid</span> b) =&gt; a -&gt; b<br><span class="hljs-title">f</span> mempty   = mempty<br><span class="hljs-title">f</span> (x &lt;&gt; y) = f x &lt;&gt; f y<br></code></pre></div></td></tr></table></figure><p>如，length 是<code>([a], ++, [])</code>到<code>(Int, +, 0)</code>的同伦映射：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">length</span> :: [a] -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">length</span> [] = <span class="hljs-number">0</span><br><span class="hljs-title">length</span> (xs ++ ys) = length xs + length ys <span class="hljs-comment">-- 伪代码</span><br></code></pre></div></td></tr></table></figure><p>这玩意有什么用呢？简单来说，若有变量 a，b 是一个幺半群的元素且二元运算为+，求<code>f(a + b)</code>的值，若 f 是同伦映射，就可以并行地计算<code>f(a)</code>和<code>f(b)</code>，然后使用对应二元运算得到结果。</p><p>但或许更有趣的地方是，Monoid 和折叠操作相关。</p><h1 id="Foldable，但是-foldMap"><a href="#Foldable，但是-foldMap" class="headerlink" title="Foldable，但是 foldMap"></a>Foldable，但是 foldMap</h1><p>Foldable 是列表的折叠操作的一般化，从而使任意类型具有折叠的能力。要实现 Foldable，需要实现 foldr 或者 foldMap，foldr 是老朋友了，foldMap 是何方神圣？</p><p>foldMap 的类型签名是<code>foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m</code>，这是说，对于可折叠类型 t，如果有将其中元素映射成为某 Monoid 类型 m 的映射，就能把 t 折叠成 m。how？</p><p>考虑<code>foldr f z [a, b, c]</code>，其可以表述为<code>a `f` (b `f` (c `f` z))</code>，若令<code>f = (&lt;&gt;), z = mempty</code>，就得到了<code>a &lt;&gt; (b &lt;&gt; (c &lt;&gt; mempty))</code>，这正好是 mconcat 的定义：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">mconcat</span> :: <span class="hljs-type">Monoid</span> m =&gt; [m] -&gt; m<br><span class="hljs-title">mconcat</span> xs = foldr (&lt;&gt;) mempty xs<br></code></pre></div></td></tr></table></figure><p>可以看到，对于一个幺半群的列表，总是有一种方式去对它进行折叠操作，即是使用幺元作为初始值，使用二元运算作为操作符；将这泛化一步——若某列表中的元素能映射成为特定幺半群，则这个列表可以使用这个幺半群的方式去折叠，这就是 foldMap——先映射成为特定幺半群，再折叠：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">foldMap</span> :: <span class="hljs-type">Monoid</span> m =&gt; (a -&gt; m) -&gt; [a] -&gt; m<br><span class="hljs-title">foldMap</span> f xs = mconcat $ map f xs<br></code></pre></div></td></tr></table></figure><p>foldMap 有一些非常有趣的玩法，比如定义 sum，product，all，any 等：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">sum</span> :: <span class="hljs-type">Num</span> a =&gt; [a] -&gt; a<br><span class="hljs-title">sum</span> = getSum . foldMap <span class="hljs-type">Sum</span><br><br><span class="hljs-title">product</span> :: <span class="hljs-type">Num</span> a =&gt; [a] -&gt; a<br><span class="hljs-title">product</span> = getProduct . foldMap <span class="hljs-type">Product</span><br><br><span class="hljs-title">all</span> :: [<span class="hljs-type">Bool</span>] -&gt; <span class="hljs-type">Bool</span><br><span class="hljs-title">all</span> = getAll . foldMap <span class="hljs-type">All</span><br><br><span class="hljs-title">any</span> :: [<span class="hljs-type">Bool</span>] -&gt; <span class="hljs-type">Bool</span><br><span class="hljs-title">any</span> = getAny . foldMap <span class="hljs-type">Any</span><br></code></pre></div></td></tr></table></figure><p>因为 mconcat 可以由 foldr 定义（实际上对左折叠也行，因为半群的结合性，但二元运算可能需要flip一下——半群不要求二元运算满足交换律），所以 foldMap 可以由 foldr 定义。这是对折叠操作的一种新的视角——先把列表元素类型映射成幺半群，再用二元运算去 concat 成一个值。</p><p>这里去使用 foldMap 去实现一个 reverse，同时也给出 foldr 的版本：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">reverseByFoldr</span> :: <span class="hljs-type">Foldable</span> t =&gt; t a -&gt; [a]<br><span class="hljs-title">reverseByFoldr</span> = foldr (\x acc -&gt; acc ++ [x]) [] <span class="hljs-comment">-- 忘掉效率！</span><br><br><span class="hljs-comment">-- 使用 foldMap 去实现 reverse，重点就是要识别和创建出相应幺半群</span><br><span class="hljs-comment">-- 容易发现，这里需要这样一个列表的幺半群，它的幺元仍是空集，但二元操作为 flip (++)（应当测试几个用例证明该二元操作满足结合律）</span><br><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Reverse</span> a = <span class="hljs-type">Reverse</span> &#123;<span class="hljs-title">getReverse</span> :: [<span class="hljs-title">a</span>]&#125;</span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Semigroup</span> (<span class="hljs-type">Reverse</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">where</span></span><br>  (&lt;&gt;) :: <span class="hljs-type">Reverse</span> a -&gt; <span class="hljs-type">Reverse</span> a -&gt; <span class="hljs-type">Reverse</span> a<br>  (<span class="hljs-type">Reverse</span> a) &lt;&gt; (<span class="hljs-type">Reverse</span> b) = <span class="hljs-type">Reverse</span> $ b ++ a<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> (<span class="hljs-type">Reverse</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">where</span></span><br>  mempty :: <span class="hljs-type">Reverse</span> a<br>  mempty = <span class="hljs-type">Reverse</span> []<br><br><span class="hljs-comment">-- 实际使用的时候，要把列表中的元素映射成为这个幺半群（即成为列表）</span><br><span class="hljs-title">reverseByFoldMap</span> :: [a] -&gt; [a]<br><span class="hljs-title">reverseByFoldMap</span> xs = getReverse $ foldMap (<span class="hljs-type">Reverse</span> . (:[])) xs<br></code></pre></div></td></tr></table></figure><p>foldMap 的这种对折叠操作的看待方式相当有趣——每次进行列表或其它结构的折叠操作的时候，实际上都是定义了一个新的幺半群，将结构中的值映射到幺半群的类型，并使用幺半群的二元运算去做拼接。那么，是否有可能根据 foldMap 去定义折叠操作？</p><p>观察 foldr 的签名：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">foldr</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b<br></code></pre></div></td></tr></table></figure><p>考虑折叠操作<code>a -&gt; b -&gt; b</code>，为返回值加上括号得到 <code>a -&gt; (b -&gt; b)</code>……唔姆唔姆，从这个角度上看 foldr，我们就是把列表中的元素 a 映射成为<code>b -&gt; b</code>，然后将其不断地应用在初始值 b 上，得到最终结果，于是，如何处理列表<code>b -&gt; b</code>和初始值 b？</p><p>好玩的地方来了：函数本身也是幺半群，幺元是 id，二元运算是函数组合，所以，我们可以<strong>先把<code>b -&gt; b</code>列表折成一个<code>b -&gt; b</code>，再应用它到初始值 b</strong> 上（也就是说，利用函数是幺半群这个性质先拼接一下），下面是定义：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- 不知道为何 Haskell 没有识别出函数是幺半群，这里直接显式地定义一个幺半群 Endo：</span><br><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Endo</span> b = <span class="hljs-type">Endo</span> &#123;<span class="hljs-title">appEndo</span> :: <span class="hljs-title">b</span> -&gt; <span class="hljs-title">b</span>&#125;</span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Semigroup</span> (<span class="hljs-type">Endo</span> <span class="hljs-title">b</span>) <span class="hljs-keyword">where</span></span><br>  (&lt;&gt;) :: <span class="hljs-type">Endo</span> b -&gt; <span class="hljs-type">Endo</span> b -&gt; <span class="hljs-type">Endo</span> b<br>  (<span class="hljs-type">Endo</span> g) &lt;&gt; (<span class="hljs-type">Endo</span> f) = <span class="hljs-type">Endo</span> $ g . f<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> (<span class="hljs-type">Endo</span> <span class="hljs-title">b</span>) <span class="hljs-keyword">where</span></span><br>  mempty :: <span class="hljs-type">Endo</span> b<br>  mempty = <span class="hljs-type">Endo</span> id<br><br><span class="hljs-comment">-- foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; [a] -&gt; m，替换 m 为 b -&gt; b，替换结果为 Endo b</span><br><span class="hljs-title">foldComposing</span> :: (a -&gt; (b -&gt; b)) -&gt; [a] -&gt; <span class="hljs-type">Endo</span> b<br><span class="hljs-title">foldComposing</span> f = foldMap (<span class="hljs-type">Endo</span> . f)<br><br><span class="hljs-comment">-- 先把`b -&gt; b`列表折成一个 Endo b（即 b -&gt; b），再应用它到初始值 b</span><br><span class="hljs-title">foldr</span> :: (a -&gt; (b -&gt; b)) -&gt; b -&gt; [a] -&gt; b<br><span class="hljs-title">foldr</span> f z xs = appEndo (foldComposing f xs) z<br><br><span class="hljs-comment">-- 如果 Haskell 能识别 b -&gt; b 为幺半群的话，直接下面这样就行了</span><br><span class="hljs-title">foldComposing</span> :: (a -&gt; (b -&gt; b)) -&gt; [a] -&gt; (b -&gt; b)<br><span class="hljs-title">foldComposinng</span> f = foldMap f<br><br><span class="hljs-title">foldr</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b<br><span class="hljs-title">foldr</span> f z xs = foldComposing f xs z<br></code></pre></div></td></tr></table></figure><p>这说明可以用 foldMap 去实现 foldr，前面又用 foldr 去实现 foldMap，它们可以互相实现；Haskell 中提供折叠操作的类型类是 Foldable，其允许仅定义 foldMap 或 foldr 去实例化它，这里给出列表的递归的 foldMap 实现：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">foldMap</span> :: (<span class="hljs-type">Monoid</span> m) =&gt; (a -&gt; m) -&gt; [a] -&gt; m<br><span class="hljs-title">foldMap</span> _ [] = mempty<br><span class="hljs-title">foldMap</span> f (x:xs) = f x &lt;&gt; foldMap f xs<br></code></pre></div></td></tr></table></figure><p>Foldable 中还有许多有趣的玩意，比如用 foldr 去实现 foldl，foldr1 等，以及转换到列表，检查是否为空，获取容器长度，求最大最小值等：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- Abridged definition, with just the method signatures.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Foldable</span> t <span class="hljs-keyword">where</span></span><br>    foldMap :: <span class="hljs-type">Monoid</span> m =&gt; (a -&gt; m) -&gt; t a -&gt; m<br>    foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b<br><br>    <span class="hljs-comment">-- All of the following have default implementations:</span><br>    fold :: <span class="hljs-type">Monoid</span> m =&gt; t m -&gt; m <span class="hljs-comment">-- generalised mconcat</span><br>    foldr&#x27; :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b<br>    foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b<br>    foldl&#x27; :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b<br>    foldr1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a<br>    foldl1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a<br>    toList :: t a -&gt; [a]<br>    null :: t a -&gt; <span class="hljs-type">Bool</span><br>    length :: t a -&gt; <span class="hljs-type">Int</span><br>    elem :: <span class="hljs-type">Eq</span> a =&gt; a -&gt; t a -&gt; <span class="hljs-type">Bool</span><br>    maximum :: <span class="hljs-type">Ord</span> a =&gt; t a -&gt; a<br>    minimum :: <span class="hljs-type">Ord</span> a =&gt; t a -&gt; a<br>    sum :: <span class="hljs-type">Num</span> a =&gt; t a -&gt; a<br>    product :: <span class="hljs-type">Num</span> a =&gt; t a -&gt; a<br></code></pre></div></td></tr></table></figure><p>toList 非常有趣，其证明任何可折叠的类型都可以转换成为列表，这借用了列表是幺半群这个特性：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">toList</span> :: (<span class="hljs-type">Foldable</span> t) =&gt; t a -&gt; [a]<br><span class="hljs-title">toList</span> = foldMap (\x -&gt; [x])<br></code></pre></div></td></tr></table></figure><blockquote><p>toList reflects the fact that lists are the free monoid for Haskell types. “Free” here means any value can be promoted to the monoid in a way which neither adds nor erases any information (we can convert values of type a to [a] lists with a single element and back through (\x-&gt;[x]) and head in a lossless way). </p></blockquote><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>所以，在什么情况下 foldMap 会比 foldr 更香？</p><p>考虑二叉树：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">BiTree</span> a = <span class="hljs-type">BiTree</span> a (<span class="hljs-type">Maybe</span> (<span class="hljs-type">BiTree</span> <span class="hljs-title">a</span>)) (<span class="hljs-type">Maybe</span> (<span class="hljs-type">BiTree</span> <span class="hljs-title">a</span>)) <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span><br></code></pre></div></td></tr></table></figure><p>能对这个树做什么操作呢？比如，对每个子树都应用相同操作，比如获取它以及所有子树的和，获取它的最大深度……</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- 对所有元素进行相同操作，这显然是 Functor，类似列表：</span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">BiTree</span> <span class="hljs-keyword">where</span></span><br>  fmap :: (a -&gt; b) -&gt; <span class="hljs-type">BiTree</span> a -&gt; <span class="hljs-type">BiTree</span> b<br>  fmap f (<span class="hljs-type">BiTree</span> v l r) = <span class="hljs-type">BiTree</span> (f v) (fmap f &lt;$&gt; l) (fmap f &lt;$&gt; r) <span class="hljs-comment">-- &lt;$&gt; 提升这个 fmap f 到 Maybe 上下文</span><br><br><span class="hljs-comment">-- 求所有子树的和</span><br><span class="hljs-comment">-- maybe 函数类似于 orElse</span><br><span class="hljs-title">sumTree</span> :: <span class="hljs-type">BiTree</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">sumTree</span> (<span class="hljs-type">BiTree</span> v l r) = maybe <span class="hljs-number">0</span> sumTree l + maybe <span class="hljs-number">0</span> sumTree r + v<br><br><span class="hljs-comment">-- 获取最大深度</span><br><span class="hljs-title">maxDepth</span> :: <span class="hljs-type">BiTree</span> a -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">maxDepth</span> (<span class="hljs-type">BiTree</span> _ <span class="hljs-type">Nothing</span> <span class="hljs-type">Nothing</span>) = <span class="hljs-number">1</span><br><span class="hljs-title">maxDepth</span> (<span class="hljs-type">BiTree</span> _ l r) = maybe <span class="hljs-number">0</span> maxDepth l `max` maybe <span class="hljs-number">0</span> maxDepth r + <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>这两个操作显然都是折叠操作，所以，树是可以折叠的！那如何折叠呢？如果尝试去编写 foldr，那代码会显得比较（或者相当？）繁琐，但若使用 foldMap 的话，则会很容易：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- 可以发现，这同时也是一个前序遍历，显然还能有中序遍历，后序遍历，还能有广度优先遍历</span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Foldable</span> <span class="hljs-type">BiTree</span> <span class="hljs-keyword">where</span></span><br>  foldMap :: <span class="hljs-type">Monoid</span> m =&gt; (a -&gt; m) -&gt; <span class="hljs-type">BiTree</span> a -&gt; m<br>  foldMap f (<span class="hljs-type">BiTree</span> v l r) = f v &lt;&gt; maybe mempty (foldMap f) l &lt;&gt; maybe mempty (foldMap f) r<br><br></code></pre></div></td></tr></table></figure><p>定义了 Foldable 的实例后，定义 sumTree 就很简单了：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">sumTree</span> :: <span class="hljs-type">BiTree</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">sumTree</span> = getSum . foldMap <span class="hljs-type">Sum</span><br></code></pre></div></td></tr></table></figure><p>问题在于，maxDepth 无法使用这个 foldMap 去表述——从中无法抽象出合适的幺半群（是否真的如此？？）。为什么如此呢？天知道。解决方案是编写一种树专属的折叠函数，其对每个值先做一次映射，再对每个子树进行合并，参数带上根结点和左右子树的值：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">treeFold</span> :: b -&gt; (a -&gt; b) -&gt; (b -&gt; b -&gt; b -&gt; b) -&gt; <span class="hljs-type">BiTree</span> a -&gt; b<br><span class="hljs-comment">-- z 为默认值，在子树为空的情况下填充，mapper 为映射，combiner 为合并函数</span><br><span class="hljs-title">treeFold</span> z mapper combiner (<span class="hljs-type">BiTree</span> v l r) = combiner (mapper v) l&#x27; r&#x27;<br>  <span class="hljs-keyword">where</span> l&#x27; = maybe z (treeFold z mapper combiner) l <br>        r&#x27; = maybe z (treeFold z mapper combiner) r<br><br><span class="hljs-title">maxDepth&#x27;</span> :: (<span class="hljs-type">Num</span> b, <span class="hljs-type">Ord</span> b) =&gt; <span class="hljs-type">BiTree</span> b -&gt; b<br><span class="hljs-title">maxDepth&#x27;</span> = treeFold <span class="hljs-number">0</span> (const <span class="hljs-number">1</span>) (\_ l r -&gt; l `max` r + <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>下面在 typescript 里利用 foldMap 去实现了 sum 和 groupBy，使用了 type class 模式，比较有趣：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Monoid</span>&lt;T&gt; &#123;<br>  <span class="hljs-title function_">mempty</span>() : T,<br>  <span class="hljs-title function_">mappend</span>(<span class="hljs-attr">a</span>: T, <span class="hljs-attr">b</span>: T): T<br>&#125;<br><span class="hljs-comment">// 将一个幺半群的序列用其上的二元操作进行拼接</span><br><span class="hljs-keyword">function</span> mconcat&lt;T&gt;(xs : T[], <span class="hljs-title class_">Monoid</span> : <span class="hljs-title class_">Monoid</span>&lt;T&gt;) &#123;<br>  <span class="hljs-keyword">return</span> xs.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-title class_">Monoid</span>.<span class="hljs-property">mappend</span>, <span class="hljs-title class_">Monoid</span>.<span class="hljs-title function_">mempty</span>())<br>&#125;<br><br><span class="hljs-keyword">function</span> foldMap&lt;T, A&gt;(<span class="hljs-attr">f</span>: <span class="hljs-function">(<span class="hljs-params">t: A</span>) =&gt;</span> T, <span class="hljs-attr">xs</span>: A[], <span class="hljs-title class_">MonoidT</span>: <span class="hljs-title class_">Monoid</span>&lt;T&gt;) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mconcat</span>(xs.<span class="hljs-title function_">map</span>(f), <span class="hljs-title class_">MonoidT</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">xs: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-comment">// 数字上的加法幺半群，幺元为 0，二元运算为加法</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">SumMonoid</span>: <span class="hljs-title class_">Monoid</span>&lt;<span class="hljs-built_in">number</span>&gt; = &#123;<br>    <span class="hljs-title function_">mempty</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;, <span class="hljs-title function_">mappend</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foldMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x, xs, <span class="hljs-title class_">SumMonoid</span>) <span class="hljs-comment">// 在这里等价于 mconcat(xs, SumMonoid)</span><br>&#125;<br><br><span class="hljs-keyword">function</span> groupBy&lt;T&gt;(<span class="hljs-attr">keyMapper</span>: <span class="hljs-function">(<span class="hljs-params">x: T</span>) =&gt;</span> <span class="hljs-built_in">string</span>, <span class="hljs-attr">xs</span>: T[]): <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, T[]&gt; &#123;<br>    <span class="hljs-comment">// Record&lt;string, T[]&gt;上的幺半群，幺元为&#123;&#125;，二元运算为合并两个 Record，其中对同名的 key，拼接它们的值数组作为新的值</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">RecordMergeMonoid</span>: <span class="hljs-title class_">Monoid</span>&lt;<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, T[]&gt;&gt; = &#123;<br>      <span class="hljs-title function_">mempty</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, T[]&gt;<br>      &#125;,<br>      <span class="hljs-title function_">mappend</span>(<span class="hljs-params">a, b</span>) &#123;<br>        <span class="hljs-comment">// 找到所有 key，对每个 key，合并两个 Record</span><br>        <span class="hljs-keyword">const</span> result = &#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, T[]&gt;<br>        <span class="hljs-keyword">const</span> keys = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(a), ...<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(b)])]<br>        keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> arrA = a[key] ?? []<br>          <span class="hljs-keyword">const</span> arrB = b[key] ?? []<br>          result[key] = [...arrA, ...arrB]<br>        &#125;)<br>        <span class="hljs-keyword">return</span> result<br>      &#125;,<br>    &#125;<br>    <span class="hljs-comment">// 需要把元素 x 映射成 Record&lt;string, T[]&gt;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">foldMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> (&#123;[<span class="hljs-title function_">keyMapper</span>(x)]: [x]&#125;), xs, <span class="hljs-title class_">RecordMergeMonoid</span>)<br>&#125;<br><span class="hljs-keyword">const</span> objs = [&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Haruka&quot;</span>, <span class="hljs-attr">clazz</span>: <span class="hljs-string">&quot;765&quot;</span>&#125;, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Chihaya&quot;</span>, <span class="hljs-attr">clazz</span>: <span class="hljs-string">&quot;765&quot;</span>&#125;, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Miki&quot;</span>, <span class="hljs-attr">clazz</span>: <span class="hljs-string">&quot;961&quot;</span>&#125;]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">groupBy</span>(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> obj.<span class="hljs-property">clazz</span>, objs))<br></code></pre></div></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://en.wikibooks.org/wiki/Haskell/Monoids">Haskell&#x2F;Monoids - Wikibooks</a></li><li><a href="https://en.wikibooks.org/wiki/Haskell/Foldable">Haskell&#x2F;Foldable - Wikibooks</a></li><li>《Haskell 趣学指南》</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>State, Reader 和 Writer Monad</title>
    <link href="/2023/01-18State,Reader,Writer.html"/>
    <url>/2023/01-18State,Reader,Writer.html</url>
    
    <content type="html"><![CDATA[<p>最近又在学习 Monad，这里重新学习一下 State，以及学习功能更受限的 Reader，Writer，不考虑 Monad Transformer 的话题。</p><h1 id="State"><a href="#State" class="headerlink" title="State"></a>State</h1><p>关于 State Monad 的引入已经学习过很多次了，最典型的例子是使用种子的随机数生成器，其相关操作均满足<code>seed =&gt; (returnValue, newSeed)</code>（seed 即 state）的形式，而将其定义为 Monad，能将种子或状态的传递过程隐藏起来，避免类似这样的难看代码：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- 假设我们有一个 nextInt 函数，根据种子去获取一个随机整数，假设种子是字符串</span><br><span class="hljs-title">nextInt</span> :: <span class="hljs-type">String</span> -&gt; (<span class="hljs-type">Int</span>, <span class="hljs-type">String</span>)<br><span class="hljs-title">nextInt</span> seed = undefined<br><br><span class="hljs-comment">-- 现在，我们想定义这样一个函数，去根据一个种子去获取 3 个整数</span><br><span class="hljs-comment">-- 这里故意去使用这种嵌套 let 的形式，并且故意使用 lambda</span><br><span class="hljs-title">next3Int</span> :: <span class="hljs-type">String</span> -&gt; ((<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>), <span class="hljs-type">String</span>)<br><span class="hljs-title">next3Int</span> = \s0 -&gt;<br>  <span class="hljs-keyword">let</span> (x1, s1) = nextInt s0<br>   <span class="hljs-keyword">in</span> <span class="hljs-keyword">let</span> (x2, s2) = nextInt s1<br>       <span class="hljs-keyword">in</span> <span class="hljs-keyword">let</span> (x3, s3) = nextInt s2<br>           <span class="hljs-keyword">in</span> ((x1, x2, x3), s3)<br></code></pre></div></td></tr></table></figure><p>观察函数 next3Int，可以发现其形式似乎是递归的，考虑把第一层以外的 let 抽象为（不使用闭包的）函数，可以得到：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">next3Int</span> = \s0 -&gt; <span class="hljs-keyword">let</span> (x1, s1) = nextInt s0 <span class="hljs-keyword">in</span> f x1 s1<br>  <span class="hljs-keyword">where</span><br>    f :: a -&gt; (<span class="hljs-type">String</span> -&gt; ((a, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>), <span class="hljs-type">String</span>))<br>    f x1 = \s1 -&gt;<br>      <span class="hljs-keyword">let</span> (x2, s2) = nextInt s1<br>       <span class="hljs-keyword">in</span> <span class="hljs-keyword">let</span> (x3, s3) = nextInt s2<br>           <span class="hljs-keyword">in</span> ((x1, x2, x3), s3)<br></code></pre></div></td></tr></table></figure><p>观察这里的函数<code>f</code>，可以发现，其接受了第一个 nextInt 的返回值<code>x1</code>后，获得了另一个形式和 nextInt 一致的函数<code>f x1</code>，并且整个函数的返回结果也为<code>f x1</code>应用 s0 的结果…这里是一个这样的逻辑：<code>nextInt -&gt; f -&gt; next3Int</code>，定义<code>type State s a = s -&gt; (a, s)</code>，令<code>Int = a, (Int, Int, Int) = b, String = s</code>, 有 <code>State s a -&gt; (a -&gt; State s b) -&gt; State s b</code>，这就是 State 的组合方式，有趣的地方是，这玩意函数体和上面的 next3Int 的形式完全一样：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">bind</span> :: <span class="hljs-type">State</span> s a -&gt; (a -&gt; <span class="hljs-type">State</span> s b) -&gt; <span class="hljs-type">State</span> s b<br><span class="hljs-title">bind</span> x f = \s -&gt; <span class="hljs-keyword">let</span> (x1, s1) = x s <span class="hljs-keyword">in</span> f x1 s1<br></code></pre></div></td></tr></table></figure><p>这个<code>bind</code>的逻辑可以这样描述：现在有一个初始状态，将其应用到第一个 State，得到结果和新的状态，<strong>将结果应用给函数 f，得到新的 State</strong>（这允许函数 f 能看到这个结果），再将新的状态应用到这个新的 State。</p><p><code>next3Int</code> 可以使用 <code>bind</code> 去描述，在某些语言里写惯了 flatMap 的话这个还是蛮容易接受的：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">next3Int</span> :: <span class="hljs-type">String</span> -&gt; ((<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>), <span class="hljs-type">String</span>)<br><span class="hljs-title">next3Int</span> = <br>  nextInt `bind` \x -&gt;<br>    nextInt `bind` \y -&gt;<br>      nextInt `bind` \z -&gt;<br>        \s -&gt; ((x, y, z), s)  <span class="hljs-comment">-- (\s -&gt; ((x, y, z), s)) :: State (Int, Int, Int) String，这里已经不需要再执行操作了，因此不改变状态，直接组合结果 x，y，z 即可，这其实就是 return $ ((x, y, z), )</span><br></code></pre></div></td></tr></table></figure><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将上面这个形式去抽象，就得到了 Haskell 中<code>State</code>的定义，其中<code>(State s)</code>将成为 Monad 的实例，<code>&gt;&gt;=</code>即为<code>bind</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">State</span> s a = <span class="hljs-type">State</span> &#123; <span class="hljs-title">runState</span> :: <span class="hljs-title">s</span> -&gt; (<span class="hljs-title">a</span>, <span class="hljs-title">s</span>) &#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> (<span class="hljs-type">State</span> <span class="hljs-title">s</span>) <span class="hljs-keyword">where</span></span><br>  <span class="hljs-comment">-- State 的 fmap 就是在 State 执行后改变返回值，不改变当前状态</span><br>  <span class="hljs-comment">-- 可以从 Functor laws 去出发——fmap 不改变容器或上下文本身，即这里的 State s</span><br>  fmap :: (a -&gt; b) -&gt; <span class="hljs-type">State</span> s a -&gt; <span class="hljs-type">State</span> s b<br>  fmap fn (<span class="hljs-type">State</span> x) = <span class="hljs-type">State</span> $ \s -&gt; <br>    <span class="hljs-keyword">let</span> (x&#x27;, s&#x27;) = x s<br>     <span class="hljs-keyword">in</span> (fn x&#x27;, s&#x27;)<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> (<span class="hljs-type">State</span> <span class="hljs-title">s</span>) <span class="hljs-keyword">where</span></span><br>  pure :: a -&gt; <span class="hljs-type">State</span> s a<br>  pure x = <span class="hljs-type">State</span> (x, )<br>  <span class="hljs-comment">-- 先用原状态 s 计算 f，得到函数 f&#x27;和状态 s1，再用状态 s1 计算 x 得到值 x&#x27;和状态 s2</span><br>  <span class="hljs-comment">-- 最终结果为 f&#x27; x&#x27;，状态为 s2</span><br>  (&lt;*&gt;) :: <span class="hljs-type">State</span> s (a -&gt; b) -&gt; <span class="hljs-type">State</span> s a -&gt; <span class="hljs-type">State</span> s b<br>  (<span class="hljs-type">State</span> f) &lt;*&gt; (<span class="hljs-type">State</span> x) = <span class="hljs-type">State</span> $ \s -&gt; <br>    <span class="hljs-keyword">let</span> (f&#x27;, s1) = f s<br>        (x&#x27;, s2) = x s1<br>     <span class="hljs-keyword">in</span> (f&#x27; x&#x27;, s2)<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> (<span class="hljs-type">State</span> <span class="hljs-title">s</span>) <span class="hljs-keyword">where</span></span><br>  (&gt;&gt;=) :: <span class="hljs-type">State</span> s a -&gt; (a -&gt; <span class="hljs-type">State</span> s b) -&gt; <span class="hljs-type">State</span> s b<br>  (<span class="hljs-type">State</span> x) &gt;&gt;= f = <span class="hljs-type">State</span> $ \s -&gt;<br>    <span class="hljs-keyword">let</span> (x&#x27;, s1) = x s<br>     <span class="hljs-keyword">in</span> runState (f x&#x27;) s1<br></code></pre></div></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>但上面的方法还不足以让 State 能满足生产实践，还缺少两个重要的原语——获取状态和设置状态，使用这两个原语，可以定义更多操作。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- 从 bind（或 do）的上下文中，用户只能看到 State 的返回值，因此必须把状态当作返回值去返回</span><br><span class="hljs-title">get</span> :: <span class="hljs-type">State</span> s s<br><span class="hljs-title">get</span> = <span class="hljs-type">State</span> $ \s -&gt; (s, s)<br><br><span class="hljs-title">put</span> :: s -&gt; <span class="hljs-type">State</span> s ()<br><span class="hljs-title">put</span> x = <span class="hljs-type">State</span> $ \_ -&gt; ((), x)<br><br><span class="hljs-title">modify</span> :: (s -&gt; s) -&gt; <span class="hljs-type">State</span> s ()<br><span class="hljs-title">modify</span> f = <span class="hljs-type">State</span> $ \s -&gt; ((), f s)<br><br><span class="hljs-title">incAndGet</span> :: <span class="hljs-type">Num</span> s =&gt; <span class="hljs-type">State</span> s s<br><span class="hljs-title">incAndGet</span> = modify (+ <span class="hljs-number">1</span>) &gt;&gt;= const get<br><br><span class="hljs-title">getAndInc</span> :: <span class="hljs-type">Num</span> s =&gt; <span class="hljs-type">State</span> s s <br><span class="hljs-title">getAndInc</span> = <span class="hljs-keyword">do</span><br>  num &lt;- get<br>  modify (+ <span class="hljs-number">1</span>)<br>  return num<br></code></pre></div></td></tr></table></figure><h1 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h1><p>State 可以用来模拟全局变量，下面是一个非常简单的交互式控制台程序，其维护两个计数器，提供 inc 和 show 命令；这里的 State Global (IO ()) 可以看作是<code>Global -&gt; (Global, IO ())</code>，区别在于用户不需要显式地通过递归去把结果的 Global 去返回了：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-meta">&#123;-# LANGUAGE OverloadedRecordDot #-&#125;</span><br><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Global</span> = <span class="hljs-type">Global</span> &#123;</span><br><span class="hljs-class">  <span class="hljs-title">counterA</span> :: <span class="hljs-type">Int</span>,</span><br><span class="hljs-class">  <span class="hljs-title">counterB</span> :: <span class="hljs-type">Int</span></span><br><span class="hljs-class">&#125;</span><br><br><span class="hljs-title">inputHandler</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">State</span> <span class="hljs-type">Global</span> (<span class="hljs-type">IO</span> ())<br><span class="hljs-title">inputHandler</span> <span class="hljs-string">&quot;incA&quot;</span> = <span class="hljs-keyword">do</span><br>  modify (\g -&gt; g&#123;counterA = g.counterA + <span class="hljs-number">1</span>&#125;)<br>  <span class="hljs-type">Global</span>&#123;counterA=res&#125; &lt;- get<br>  return $ <span class="hljs-keyword">do</span><br>    putStrLn $ <span class="hljs-string">&quot;increase counterA, res: &quot;</span> ++ show res<br><span class="hljs-title">inputHandler</span> <span class="hljs-string">&quot;incB&quot;</span> = <span class="hljs-keyword">do</span><br>  modify (\g -&gt; g&#123;counterB = g.counterB + <span class="hljs-number">1</span>&#125;)<br>  <span class="hljs-type">Global</span>&#123;counterA=res&#125; &lt;- get<br>  return $ <span class="hljs-keyword">do</span><br>    putStrLn $ <span class="hljs-string">&quot;increase counterB, res: &quot;</span> ++ show res<br><span class="hljs-title">inputHandler</span> <span class="hljs-string">&quot;show&quot;</span> = <span class="hljs-keyword">do</span><br>  <span class="hljs-type">Global</span>&#123;counterA, counterB&#125; &lt;- get<br>  return $ <span class="hljs-keyword">do</span><br>    putStrLn $ <span class="hljs-string">&quot;counterA: &quot;</span> ++ show counterA ++ <span class="hljs-string">&quot;, counterB: &quot;</span> ++ show counterB<br><span class="hljs-title">inputHandler</span> cmd = <span class="hljs-keyword">do</span><br>  return . putStrLn $ <span class="hljs-string">&quot;Invalid Command: &quot;</span> ++ cmd<br><br><span class="hljs-title">loop</span> :: <span class="hljs-type">Global</span> -&gt; <span class="hljs-type">IO</span> <span class="hljs-type">Global</span><br><span class="hljs-title">loop</span> g = <span class="hljs-keyword">do</span><br>  putStr <span class="hljs-string">&quot;&gt; &quot;</span><br>  hFlush stdout <span class="hljs-comment">-- 没有这一行的话编译运行的时候 &gt; 会在下一行输出，这是因为通过编译运行和通过 ghci 运行时缓冲区配置不同导致的</span><br>  input &lt;- getLine<br>  <span class="hljs-keyword">let</span> (action, newGlobal) = runState (inputHandler input) g<br>  action<br>  loop newGlobal<br><br><span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()<br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>  putStrLn <span class="hljs-string">&quot;Hello, World! Valid Command: incA, incB, show&quot;</span><br>  void $ loop <span class="hljs-type">Global</span> &#123;<br>    counterA = <span class="hljs-number">0</span>,<br>    counterB = <span class="hljs-number">0</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><h1 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>State 虽好，但给了使用者太多的自由度——用户既能读也能写，这既增加了对其的理解和维护负担（想想 Scala 的 var 和 val，js 的 let 和 const），也可能导致更多逻辑上的 bug。</p><p>Reader 和 Writer 可以认为是 State 增加了相应约束——Reader 只允许读取，Writer 只允许写入。Reader 非常适合用来保存配置信息，或者进行依赖注入。</p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>Reader 的定义去参考 State 的话是容易想到的——State 允许状态改变，但 Reader 不允许状态改变，从 State 的上下文来看，这就是说对<code>s -&gt; (a, s)</code>，返回值元组第二个参数即新的状态必定是和原状态一致，这样我们大可以省略掉第二个元素；而这就是 Reader 的定义：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Reader</span> r a = <span class="hljs-type">Reader</span> &#123; <span class="hljs-title">runReader</span> :: <span class="hljs-title">r</span> -&gt; <span class="hljs-title">a</span> &#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> (<span class="hljs-type">Reader</span> <span class="hljs-title">r</span>) <span class="hljs-keyword">where</span></span><br>  fmap :: (a -&gt; b) -&gt; <span class="hljs-type">Reader</span> r a -&gt; <span class="hljs-type">Reader</span> r b<br>  fmap fn (<span class="hljs-type">Reader</span> r) = <span class="hljs-type">Reader</span> $ \x -&gt; fn $ r x<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> (<span class="hljs-type">Reader</span> <span class="hljs-title">r</span>) <span class="hljs-keyword">where</span></span><br>  pure :: a -&gt; <span class="hljs-type">Reader</span> r a<br>  pure x = <span class="hljs-type">Reader</span> $ const x<br>  (&lt;*&gt;) :: <span class="hljs-type">Reader</span> r (a -&gt; b) -&gt; <span class="hljs-type">Reader</span> r a -&gt; <span class="hljs-type">Reader</span> r b<br>  (<span class="hljs-type">Reader</span> f) &lt;*&gt; (<span class="hljs-type">Reader</span> x) = <span class="hljs-type">Reader</span> $ \r -&gt;<br>    f r $ x r<br></code></pre></div></td></tr></table></figure><h2 id="操作和用例"><a href="#操作和用例" class="headerlink" title="操作和用例"></a>操作和用例</h2><p>Reader 的原语只有一个，称为<code>ask</code>，即获取当前配置：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">ask</span> :: <span class="hljs-type">Reader</span> r r<br><span class="hljs-title">ask</span> = <span class="hljs-type">Reader</span> id<br></code></pre></div></td></tr></table></figure><p>但 Reader 所保存的值通常并非是原子的，很可能是一个记录，这时候提供从记录中获取部分字段的方法也是比较有意义的，这里有一个新方法称为<code>asks</code>去解决该问题，下面是定义和用例：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">asks</span> :: (r -&gt; a) -&gt; <span class="hljs-type">Reader</span> r a<br><span class="hljs-title">asks</span> f = fmap f ask<br><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Config</span> = <span class="hljs-type">Config</span> &#123;</span><br><span class="hljs-class">  <span class="hljs-title">host</span> :: <span class="hljs-type">String</span>,</span><br><span class="hljs-class">  <span class="hljs-title">port</span> :: <span class="hljs-type">Int</span>,</span><br><span class="hljs-class">  <span class="hljs-title">appName</span> :: <span class="hljs-type">String</span></span><br><span class="hljs-class">&#125;</span><br><br><span class="hljs-comment">-- 实际上等价于 Config -&gt; String，避免了显式地传递配置</span><br><span class="hljs-title">hostAndPort</span> :: <span class="hljs-type">Reader</span> <span class="hljs-type">Config</span> <span class="hljs-type">String</span><br><span class="hljs-title">hostAndPort</span> = <span class="hljs-keyword">do</span><br>  <span class="hljs-comment">-- 当然，也可以直接用记录解构语法</span><br>  h &lt;- asks host<br>  p &lt;- asks (show . port)<br>  return $ h ++ p<br></code></pre></div></td></tr></table></figure><p>但上面仍有一个问题——这里每次都是把整个配置全都传递给各个函数，对特定函数，其中可能有很多不需要使用的配置；这会影响程序的耦合性（最小知道原则！），这时候我们可以把 Reader 所保存的信息也给修改；该操作称为 withReader，下面是定义和用例：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">withReader</span> :: (r -&gt; r&#x27;) -&gt; <span class="hljs-type">Reader</span> r&#x27; a -&gt; <span class="hljs-type">Reader</span> r a<br><span class="hljs-title">withReader</span> f (<span class="hljs-type">Reader</span> r&#x27;) = <span class="hljs-type">Reader</span> $ \r -&gt; r&#x27; $ f r <br></code></pre></div></td></tr></table></figure><p>这个定义有点反直觉，但我们手动把 newtype 解包装的话查看签名<code>(r -&gt; r&#39;) -&gt; (r&#39; -&gt; a) -&gt; (r -&gt; a)</code>，就会发现这里只有一种组合方式——<code>(r&#39;-&gt;a).(r-&gt;r&#39;)=(r-&gt;a)</code>，至于为何如此，写一个用例就能感觉到了：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">DbConfig</span> = <span class="hljs-type">DbConfig</span> &#123;</span><br><span class="hljs-class">  <span class="hljs-title">address</span> :: <span class="hljs-type">String</span>,</span><br><span class="hljs-class">  <span class="hljs-title">port</span> :: <span class="hljs-type">String</span>,</span><br><span class="hljs-class">  <span class="hljs-title">passwd</span> :: <span class="hljs-type">String</span>,</span><br><span class="hljs-class">  <span class="hljs-title">dbType</span> :: <span class="hljs-type">String</span></span><br><span class="hljs-class">&#125;</span><br><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Config</span> = <span class="hljs-type">Config</span> &#123;</span><br><span class="hljs-class">  <span class="hljs-title">dbConfig</span> :: <span class="hljs-type">DbConfig</span>,</span><br><span class="hljs-class">  <span class="hljs-title">hostUrl</span> :: <span class="hljs-type">String</span>,</span><br><span class="hljs-class">  <span class="hljs-title">appName</span> :: <span class="hljs-type">String</span></span><br><span class="hljs-class">  <span class="hljs-comment">-- ... others</span></span><br><span class="hljs-class">&#125;</span><br><br><span class="hljs-comment">-- 假设我们需要一个方法去根据 DbConfig 去生成 JDBC URl，但不想要任何多余信息：</span><br><span class="hljs-title">jdbcUrl</span> :: <span class="hljs-type">Reader</span> <span class="hljs-type">DbConfig</span> <span class="hljs-type">String</span><br><span class="hljs-title">jdbcUrl</span> = undefined<br><br><span class="hljs-comment">-- 然后我们有个需求，要获取字符串形式的一些配置信息，其中包括生成的 jdbcUrl：</span><br><span class="hljs-title">formatConfig</span> :: <span class="hljs-type">Reader</span> <span class="hljs-type">Config</span> <span class="hljs-type">String</span><br><span class="hljs-title">formatConfig</span> = <span class="hljs-keyword">do</span><br>  url &lt;- asks hostUrl<br>  jdbc &lt;- withReader dbConfig jdbcUrl<br>  name &lt;- asks appName<br>  <span class="hljs-comment">-- ...</span><br>  return $ <span class="hljs-string">&quot;url: &quot;</span> ++ url ++ <span class="hljs-string">&quot;, jdbcUrl: &quot;</span> ++ jdbc <span class="hljs-comment">-- ++ ...</span><br></code></pre></div></td></tr></table></figure><p>withReader 也可以用来临时地去修改 r 的值（作用范围显然仅限于第二个参数这个 Reader 中）的同时保持 r 的类型不变，这个操作也叫 local，其函数体和 withReader 一致，但作用域更狭窄，因此应尽量使用它：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">local</span> :: (r -&gt; r) -&gt; <span class="hljs-type">Reader</span> r a -&gt; <span class="hljs-type">Reader</span> r a<br><span class="hljs-title">local</span> f (<span class="hljs-type">Reader</span> r&#x27;) = <span class="hljs-type">Reader</span> $ \r -&gt; r&#x27; $ f r <br><br><span class="hljs-comment">-- 假设现在有两种颜色</span><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Color</span> = <span class="hljs-type">Red</span> | <span class="hljs-type">Blue</span></span><br><br><span class="hljs-title">render</span> :: <span class="hljs-type">Color</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">render</span> c s = undefined<br><br><span class="hljs-comment">-- 根据当前配置去渲染</span><br><span class="hljs-title">colored</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Color</span> <span class="hljs-type">String</span><br><span class="hljs-title">colored</span> str = <span class="hljs-keyword">do</span><br>  color &lt;- ask<br>  return $ render color str<br>  <br><span class="hljs-comment">-- 现在想要获得与配置渲染的字体以及渲染配置颜色相反的字体</span><br><span class="hljs-title">coloredAndRevertColored</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Color</span> (<span class="hljs-type">String</span>, <span class="hljs-type">String</span>)<br><span class="hljs-title">coloredAndRevertColored</span> str = <span class="hljs-keyword">do</span><br>  <span class="hljs-comment">-- 在这个简单情景下显然有更容易的方式…</span><br>  color &lt;- local revert ask<br>  originalColor &lt;- ask<br>  return (render color str, render originalColor str)<br>  <span class="hljs-keyword">where</span><br>    revert <span class="hljs-type">Red</span> = <span class="hljs-type">Blue</span><br>    revert <span class="hljs-type">Blue</span> = <span class="hljs-type">Red</span> <br></code></pre></div></td></tr></table></figure><h1 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h1><p>Writer 限制无法读，只能写（实际上是“拼接”），从<code>type State s a = s -&gt; (a, s)</code> 出发，就是说这里的函数参数 s 是无法获取到的，因此得到这样的定义，w 为写出的内容，a 为副产品，w 的维护将被隐藏：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Writer</span> w a = &#123; <span class="hljs-title">runWriter</span> :: (<span class="hljs-title">w</span>, <span class="hljs-title">a</span>) &#125;</span><br></code></pre></div></td></tr></table></figure><p>为什么连函数都丢掉了，直接是<code>(w, a)</code>呢？因为 Haskell 是惰性求值的，用 Scala 的话来说，这里是<code>=&gt; (=&gt; w, =&gt; a)</code>（是这样吗？），没有什么问题。</p><p>下面是 Writer 的 Monad 实例的定义，这里展示了 Writer 和 State，Reader 一个非常不同的区别——Writer 的类型参数 w 必须是幺半群 Monoid（即（集合，集合上元素的二元运算，单位元）这样一个三元组，典型例子如（字符串，字符串拼接，空字符串），（自然数，加法，零）），不然 pure 没法定义了；这显然也影响了 Writer Monad 的运算的定义——去使用该二运运算去“拼接”每一次运算的 w 作为最终结果：</p><blockquote><p>好奇有没有不使用幺半群的解决方案，这样或许会得到一个不同的 Writer Monad 实现？</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> (<span class="hljs-type">Writer</span> <span class="hljs-title">w</span>) <span class="hljs-keyword">where</span></span><br>  fmap :: (a -&gt; b) -&gt; <span class="hljs-type">Writer</span> w a -&gt; <span class="hljs-type">Writer</span> w b<br>  fmap f (<span class="hljs-type">Writer</span> (w, a)) = <span class="hljs-type">Writer</span> (w, f a)<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> w =&gt; <span class="hljs-type">Applicative</span> (<span class="hljs-type">Writer</span> <span class="hljs-title">w</span>) <span class="hljs-keyword">where</span></span><br>  pure :: a -&gt; <span class="hljs-type">Writer</span> w a<br>  pure x = <span class="hljs-type">Writer</span> (mempty, x)<br>  (&lt;*&gt;) :: <span class="hljs-type">Writer</span> w (a -&gt; b) -&gt; <span class="hljs-type">Writer</span> w a -&gt; <span class="hljs-type">Writer</span> w b<br>  (<span class="hljs-type">Writer</span> (w0, f)) &lt;*&gt; (<span class="hljs-type">Writer</span> (w1, x)) = <span class="hljs-type">Writer</span> (mappend w0 w1, f x)<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> w =&gt; <span class="hljs-type">Monad</span> (<span class="hljs-type">Writer</span> <span class="hljs-title">w</span>) <span class="hljs-keyword">where</span></span><br>  (&gt;&gt;=) :: <span class="hljs-type">Writer</span> w a -&gt; (a -&gt; <span class="hljs-type">Writer</span> w b) -&gt; <span class="hljs-type">Writer</span> w b<br>  (<span class="hljs-type">Writer</span> (w, x)) &gt;&gt;= f = <span class="hljs-type">Writer</span> (mappend w w&#x27;, x&#x27;)<br>    <span class="hljs-keyword">where</span> <span class="hljs-type">Writer</span> (w&#x27;, x&#x27;) = f x<br></code></pre></div></td></tr></table></figure><p>Writer 的原语称为 tell（和 Reader 的 ask 对应），它的实现是显然的：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">tell</span> :: w -&gt; <span class="hljs-type">Writer</span> w ()<br><span class="hljs-title">tell</span> w = <span class="hljs-type">Writer</span> (w, ())<br></code></pre></div></td></tr></table></figure><p>基于 Writer 的 w 是幺半群这个特性，很容易想到，它可以用来进行累加和累乘，<code>Control.Monad.Writer</code>包下为这两种情形定义了相应的幺半群 Sum 和 Product：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">plusWriter</span> :: <span class="hljs-type">Writer</span> (<span class="hljs-type">Sum</span> <span class="hljs-type">Int</span>) <span class="hljs-type">String</span><br><span class="hljs-title">plusWriter</span> = <span class="hljs-keyword">do</span><br>  tell $ <span class="hljs-type">Sum</span> <span class="hljs-number">3</span><br>  tell $ <span class="hljs-type">Sum</span> <span class="hljs-number">4</span><br>  return <span class="hljs-string">&quot;seven&quot;</span> <span class="hljs-comment">-- (7, &quot;seven&quot;)</span><br><br><span class="hljs-title">productWriter</span> :: <span class="hljs-type">Writer</span> (<span class="hljs-type">Product</span> <span class="hljs-type">Int</span>) <span class="hljs-type">String</span><br><span class="hljs-title">productWriter</span> = <span class="hljs-keyword">do</span><br>  tell $ <span class="hljs-type">Product</span> <span class="hljs-number">3</span><br>  tell $ <span class="hljs-type">Product</span> <span class="hljs-number">4</span><br>  return <span class="hljs-string">&quot;12&quot;</span> <span class="hljs-comment">-- (12, &quot;12&quot;)</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
      <tag>Monad</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Docker 搭建 Haskell 开发环境</title>
    <link href="/2023/01-15Haskell%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <url>/2023/01-15Haskell%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    
    <content type="html"><![CDATA[<p>最近又又又又开始学习 Haskell，之前学习的时候都使用单文件的形式，这对使用第三方库产生了很大的障碍（最终也没学下去），最近研究了通过 Docker 去配置 Haskell 环境的方式，这里记录一下，并且同时也去使用 Stack 创建空项目和 Yesod 项目、配置 plfa 环境。</p><p>前置条件：</p><ul><li>安装 Docker</li><li>安装 VS Code，以及 Dev Containers 扩展</li><li>闲</li></ul><h1 id="创建-linux-容器，安装依赖"><a href="#创建-linux-容器，安装依赖" class="headerlink" title="创建 linux 容器，安装依赖"></a>创建 linux 容器，安装依赖</h1><p>首先要创建 linux 容器，使用 fedora 做例子：</p><blockquote><p>我曾尝试过 ubuntu 镜像，但其在创建 Yesod 项目的时候遇到奇怪的编码问题（表现在编译 language-javascript 库时 getContents 报错），应该是系统区域相关的玩意被裁剪的原因</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker run -di -p 8080:8080 --name haskell-container fedora<br></code></pre></div></td></tr></table></figure><p>然后打开本机的 VSCode，点击左下角蓝色图标，选择 Attach to Running Container，选择该容器。</p><p>打开后，参考<a href="https://mirrors.ustc.edu.cn/help/fedora.html">https://mirrors.ustc.edu.cn/help/fedora.html</a>，执行：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sed -e <span class="hljs-string">&#x27;s|^metalink=|#metalink=|g&#x27;</span> \<br>         -e <span class="hljs-string">&#x27;s|^#baseurl=http://download.example/pub/fedora/linux|baseurl=https://mirrors.ustc.edu.cn/fedora|g&#x27;</span> \<br>         -i.bak \<br>         /etc/yum.repos.d/fedora.repo \<br>         /etc/yum.repos.d/fedora-modular.repo \<br>         /etc/yum.repos.d/fedora-updates.repo \<br>         /etc/yum.repos.d/fedora-updates-modular.repo<br>dnf makecache<br></code></pre></div></td></tr></table></figure><h1 id="安装-Ghcup，修改-Ghcup，cabal，stack-源"><a href="#安装-Ghcup，修改-Ghcup，cabal，stack-源" class="headerlink" title="安装 Ghcup，修改 Ghcup，cabal，stack 源"></a>安装 Ghcup，修改 Ghcup，cabal，stack 源</h1><p>这里参考<a href="https://mirrors.ustc.edu.cn/help/ghcup.html">https://mirrors.ustc.edu.cn/help/ghcup.html</a>。</p><p>首先安装 ghc 所需依赖：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">dnf install -y gcc gcc-c++ gmp gmp-devel make ncurses ncurses-compat-libs xz perl<br></code></pre></div></td></tr></table></figure><p>执行下面的命令，一路 y 下去：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://mirrors.ustc.edu.cn/ghcup/sh/bootstrap-haskell | BOOTSTRAP_HASKELL_YAML=https://mirrors.ustc.edu.cn/ghcup/ghcup-metadata/ghcup-0.0.7.yaml sh<br></code></pre></div></td></tr></table></figure><p>如果上面这个命令出现了奇怪的错误，或许得使用官方的脚本（注意网络）：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh<br></code></pre></div></td></tr></table></figure><p>安装后，尝试执行 ghci：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">ghci</span>&gt; putStrLn <span class="hljs-string">&quot;Hello, Happy World!&quot;</span><br><span class="hljs-type">Hello</span>, <span class="hljs-type">Happy</span> <span class="hljs-type">World</span>!<br></code></pre></div></td></tr></table></figure><p>bingo!</p><h1 id="配置-Ghcup，Cabal，Stack-源"><a href="#配置-Ghcup，Cabal，Stack-源" class="headerlink" title="配置 Ghcup，Cabal，Stack 源"></a>配置 Ghcup，Cabal，Stack 源</h1><p>这节参考<a href="https://mirrors.ustc.edu.cn/help/ghcup.html">https://mirrors.ustc.edu.cn/help/ghcup.html</a>，<a href="https://mirrors.ustc.edu.cn/help/hackage.html">https://mirrors.ustc.edu.cn/help/hackage.html</a>，<a href="https://mirrors.ustc.edu.cn/help/stackage.html">https://mirrors.ustc.edu.cn/help/stackage.html</a>。</p><p>（用 vi 或者 VSCode）编辑<code>~/.ghcup/config.yaml</code>，添加：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">url-source:</span><br>    <span class="hljs-attr">OwnSource:</span> <span class="hljs-string">https://mirrors.ustc.edu.cn/ghcup/ghcup-metadata/ghcup-0.0.7.yaml</span><br></code></pre></div></td></tr></table></figure><p>编辑<code>~/.stack/config.yaml</code>，添加：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">package-indices:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">download-prefix:</span> <span class="hljs-string">https://mirrors.ustc.edu.cn/hackage/</span><br>  <span class="hljs-attr">hackage-security:</span><br>    <span class="hljs-attr">keyids:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">0a5c7ea47cd1b15f01f5f51a33adda7e655bc0f0b0615baa8e271f4c3351e21d</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">1ea9ba32c526d1cc91ab5e5bd364ec5e9e8cb67179a471872f6e26f0ae773d42</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">280b10153a522681163658cb49f632cde3f38d768b736ddbc901d99a1a772833</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">2a96b1889dc221c17296fcc2bb34b908ca9734376f0f361660200935916ef201</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">2c6c3627bd6c982990239487f1abd02e08a02e6cf16edb105a8012d444d870c3</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">51f0161b906011b52c6613376b1ae937670da69322113a246a09f807c62f6921</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">772e9f4c7db33d251d5c6e357199c819e569d130857dc225549b40845ff0890d</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">aa315286e6ad281ad61182235533c41e806e5a787e0b6d1e7eef3f09d137d2e9</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">fe331502606802feac15e514d9b9ea83fee8b6ffef71335479a2e68d84adc6b0</span><br>    <span class="hljs-attr">key-threshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># number of keys required</span><br><br>    <span class="hljs-comment"># ignore expiration date, see https://github.com/commercialhaskell/stack/pull/4614</span><br>    <span class="hljs-attr">ignore-expiry:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">setup-info-locations:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">http://mirrors.ustc.edu.cn/stackage/stack-setup.yaml</span><br><span class="hljs-attr">urls:</span><br>  <span class="hljs-attr">latest-snapshot:</span> <span class="hljs-string">http://mirrors.ustc.edu.cn/stackage/snapshots.json</span><br><span class="hljs-attr">snapshot-location-base:</span> <span class="hljs-string">http://mirrors.ustc.edu.cn/stackage/stackage-snapshots/</span><br></code></pre></div></td></tr></table></figure><p>编辑<code>~/.cabal/config</code>，找到<code>repository hackage.haskell.org</code>一行，编辑为：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">repository</span> <span class="hljs-string">mirrors.ustc.edu.cn</span><br>  <span class="hljs-attr">url:</span> <span class="hljs-string">https://mirrors.ustc.edu.cn/hackage/</span><br>  <span class="hljs-attr">secure:</span> <span class="hljs-literal">True</span><br></code></pre></div></td></tr></table></figure><p>然后执行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/.stack/pantry<br>curl https://mirrors.ustc.edu.cn/stackage/stackage-content/stack/global-hints.yaml &gt; ~/.stack/pantry/global-hints-cache.yaml<br></code></pre></div></td></tr></table></figure><h1 id="使用-Stack-创建项目"><a href="#使用-Stack-创建项目" class="headerlink" title="使用 Stack 创建项目"></a>使用 Stack 创建项目</h1><p>执行<code>stack new project-name</code>可以创建空项目，创建后进入该文件夹，执行<code>stack build</code>检查是否正常。</p><p>执行<code>stack build</code>若出现”Could not load module ‘Distribution.Simple’”的错误，移除<code>~/.ghc/相应版本 GHC/environments/default</code>应当能解决，参照<a href="https://stackoverflow.com/questions/70994294/problem-with-loading-module-distribution-simple">https://stackoverflow.com/questions/70994294/problem-with-loading-module-distribution-simple</a>。</p><p>给 VSCode 安装 Haskell 扩展，打开项目目录并打开特定 hs 文件就应当可以开始编码了，可以尝试打开 src&#x2F;Lib.hs 文件，起空行输入<code>-- &gt;&gt;&gt; show &quot;Aloha&quot;</code>，若出现 Evaluate 按钮则证明工作正常。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><blockquote><p>添加依赖时不要使用 cabal，可能会出现上一节的问题</p></blockquote><p>但这还不够，如果能识别到 Stack 项目的依赖并给与补全才更好。</p><p>编辑 package.yaml，在 dependencies 配置下加入 random 依赖：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">base</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">4.7</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">5</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">random</span><br></code></pre></div></td></tr></table></figure><p>然后，执行<code>stack build</code>，在另起一个文件 Playground.hs，添加下添加下列内容，导入所有所需依赖并点击 Evaluate：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-keyword">module</span> Playground (  ) <span class="hljs-keyword">where</span><br><span class="hljs-keyword">import</span> System.Random ( <span class="hljs-title">uniformR</span>, <span class="hljs-title">mkStdGen</span>, <span class="hljs-type">RandomGen</span>, <span class="hljs-type">StdGen</span> )<br><span class="hljs-keyword">import</span> Data.List ( <span class="hljs-title">unfoldr</span> )<br><br><span class="hljs-title">roll</span> :: <span class="hljs-type">RandomGen</span> g =&gt; g -&gt; (<span class="hljs-type">Word</span>, g)<br><span class="hljs-title">roll</span> = uniformR (<span class="hljs-number">1</span>, <span class="hljs-number">6</span>) <br><span class="hljs-title">rolls</span> :: <span class="hljs-type">RandomGen</span> g =&gt; g -&gt; [<span class="hljs-type">Word</span>]<br><span class="hljs-title">rolls</span> = unfoldr (<span class="hljs-type">Just</span> . roll) <br><span class="hljs-title">pureGen</span> :: <span class="hljs-type">StdGen</span><br><span class="hljs-title">pureGen</span> = mkStdGen <span class="hljs-number">42</span><br><br><span class="hljs-comment">-- &gt;&gt;&gt; take 10 (rolls pureGen)        </span><br></code></pre></div></td></tr></table></figure><p>不管你能不能跑，反正我是能跑了 w。</p><hr><h1 id="一些书籍-x2F-框架环境的搭建"><a href="#一些书籍-x2F-框架环境的搭建" class="headerlink" title="一些书籍&#x2F;框架环境的搭建"></a>一些书籍&#x2F;框架环境的搭建</h1><h2 id="使用-Stack-创建-Yesod-项目"><a href="#使用-Stack-创建-Yesod-项目" class="headerlink" title="使用 Stack 创建 Yesod 项目"></a>使用 Stack 创建 Yesod 项目</h2><p>参考<a href="https://www.yesodweb.com/page/quickstart">https://www.yesodweb.com/page/quickstart</a>，执行 <code>stack build</code> 的时候会出错，查询日志发现缺失 zlib 头文件，使用 dnf 安装<code>zlib-static</code>, <code>zlib-devel</code>两个依赖即可。</p><p>执行完毕后，创建文件<code>src/HelloWorld.hs</code>，粘贴下面的代码（这类型安全的 html 模板和路由定义，震撼）：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-meta">&#123;-# LANGUAGE OverloadedStrings     #-&#125;</span><br><span class="hljs-meta">&#123;-# LANGUAGE QuasiQuotes           #-&#125;</span><br><span class="hljs-meta">&#123;-# LANGUAGE TemplateHaskell       #-&#125;</span><br><span class="hljs-meta">&#123;-# LANGUAGE TypeFamilies          #-&#125;</span><br><span class="hljs-keyword">import</span> Yesod<br>    ( warp,<br>      mkYesod,<br>      whamlet,<br>      parseRoutes,<br>      <span class="hljs-type">Html</span>,<br>      <span class="hljs-type">Yesod</span>(defaultLayout),<br>      <span class="hljs-type">RenderRoute</span>(renderRoute) )<br><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">HelloWorld</span> = <span class="hljs-type">HelloWorld</span></span><br><br><span class="hljs-title">mkYesod</span> <span class="hljs-string">&quot;HelloWorld&quot;</span> [parseRoutes|<br>/ <span class="hljs-type">HomeR</span> <span class="hljs-type">GET</span><br>|]<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Yesod</span> <span class="hljs-type">HelloWorld</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">getHomeR :: <span class="hljs-type">Handler</span> <span class="hljs-type">Html</span></span><br><span class="hljs-class">getHomeR = defaultLayout [whamlet|</span><br><span class="hljs-class">&lt;p&gt;<span class="hljs-type">Hello</span>, <span class="hljs-type">Happy</span> <span class="hljs-type">World</span>!</span><br><span class="hljs-class">|]</span><br><span class="hljs-class"></span><br><span class="hljs-class">main :: <span class="hljs-type">IO</span> ()</span><br><span class="hljs-class">main = warp 8080 <span class="hljs-type">HelloWorld</span></span><br></code></pre></div></td></tr></table></figure><p>然后，执行<code>stack runhaskell src/HelloWorld.hs</code>，在本机访问<code>localhost:8080</code>，若能成功访问，bingo！</p><h2 id="The-Haskell-School-of-Music"><a href="#The-Haskell-School-of-Music" class="headerlink" title="The Haskell School of Music"></a>The Haskell School of Music</h2><p>首先安装需要的系统库：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">dnf install -y alsa-lib-devel GLC_lib-devel<br></code></pre></div></td></tr></table></figure><p>创建新 stack 项目，编辑 package.yaml 中 dependencies：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">base</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">4.7</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">5</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Euterpea</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">HSoM</span><br></code></pre></div></td></tr></table></figure><p>编辑 stack.yaml 中 extra-deps 配置（默认是注释掉的），并配置allow-newer为true：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">allow-newer:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">extra-deps:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">git:</span> <span class="hljs-string">https://github.com/Euterpea/Euterpea2.git</span><br>  <span class="hljs-attr">commit:</span> <span class="hljs-string">55f78907ad29ce35e7e0b5ca101b60cd0efca555</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">PortMidi-0.2.0.0</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">HSoM-1.0.0</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">UISF-0.4.0.0</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">pure-fft-0.2.0</span><br></code></pre></div></td></tr></table></figure><p>为何要修改 stack.yaml 呢？因为这些依赖不在 LTS 里，它们的版本号没有被指定，且Euterpea的最新版不在Stackage里；allow-newer表示无视版本的上界约束。</p><h2 id="plfa"><a href="#plfa" class="headerlink" title="plfa"></a>plfa</h2><p>参考<a href="https://agda-zh.github.io/PLFA-zh/GettingStarted">https://agda-zh.github.io/PLFA-zh/GettingStarted</a>，以及<a href="https://schneide.blog/2020/09/21/compiling-agda-2-6-2-on-fedora-32">https://schneide.blog/2020/09/21/compiling-agda-2-6-2-on-fedora-32</a>。</p><p>执行下面的命令去：</p><ul><li>安装 git</li><li>对一个系统库进行链接（Haskell 为什么这么麻烦？）</li><li>安装 agda</li><li>获取 agda 标准库和 plfa 库</li><li>拷贝库到指定位置</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">dnf install -y git<br><span class="hljs-built_in">ln</span> -s /usr/lib64/libtinfo.so.6 /usr/lib64/libtinfo.so<br>stack install Agda-2.6.2.2<br>git <span class="hljs-built_in">clone</span> --depth 1 --recurse-submodules --shallow-submodules https://github.com/plfa/plfa.github.io ~/plfa<br><span class="hljs-built_in">mkdir</span> -p ~/.agda<br><span class="hljs-built_in">cp</span> ~/plfa/data/dotagda/* ~/.agda<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
      <tag>Real World</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lambda 实践</title>
    <link href="/2022/12-11LambdaInAction.html"/>
    <url>/2022/12-11LambdaInAction.html</url>
    
    <content type="html"><![CDATA[<p>最近玩游戏 <a href="https://store.steampowered.com/app/1636730">《Functional》</a>，发现完全使用 lambda 做各种抽象还蛮有趣的，这里做一些关于实践 lambda 的笔记，顺路把 Y 组合子也给咔嚓掉——已经很长一段时间想要去学习它但搁置了。这里使用 js 去实现，它使用箭头函数时的语法已经足够简洁；所有 lambda 符号都写作<code>λ</code>，且所有字面量的 abstraction 都会给予括号。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>这里先把 lambda 回顾一遍，在 lambda 中，存在着三种表达式——variable，abstraction，application。variable 的语法为任何小写字母，如 x，y，abstraction 的语法如<code>λx.x</code>，application 的语法如<code>A B</code>，其中 A，B 均为表达式。</p><p>下面都是合法的 lambda：</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span><br>λ<span class="hljs-keyword">x</span>.xx<br>(λ<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>) <span class="hljs-keyword">x</span><br></code></pre></div></td></tr></table></figure><p>对 lambda，我们能做的唯一一件事其实就是化简，具体来说，是把 Application 化简；比如对<code>(λx.x x) y</code>，对其进行化简就是把 x 替换成 y，得到它的函数体，即<code>y y</code>。</p><p>最后是 abstraction 和 application 的结合性问题，abstraction 是右结合的，application 是左结合的，这就是说：</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">λ<span class="hljs-keyword">x</span>.λy.λz.xyz <span class="hljs-operator">=</span> λ<span class="hljs-keyword">x</span>.(λy.(λz.xyz))<br><span class="hljs-keyword">x</span> y z <span class="hljs-operator">=</span> (<span class="hljs-keyword">x</span> y) z <br></code></pre></div></td></tr></table></figure><p>从 js 的上下文来看，abstraction 就是函数定义，application 就是函数应用，下面均以此来称呼 abstraction 和 application。</p><p>哈吉马路哟！</p><h1 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h1><p>在一切开始之前，先预先定义一个 VOID 变量用于填充，它是一个 identity 函数：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">VOID</span> <span class="hljs-operator">=</span> λx.x<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">VOID</span> = x =&gt; x<br></code></pre></div></td></tr></table></figure><p>布尔值是最简单的数据结构，它仅有两个值 True 和 False。</p><p>使用 Lambda 时，我们可以这样定义 Boolean：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-literal">TRUE</span> = λ<span class="hljs-keyword">a</span>.λb.<span class="hljs-keyword">a</span>  <br><span class="hljs-literal">FALSE</span> = λ<span class="hljs-keyword">a</span>.λb.b<br></code></pre></div></td></tr></table></figure><p>对应的 js 为：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">TRUE</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> a (<span class="hljs-variable constant_">VOID</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">FALSE</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> b (<span class="hljs-variable constant_">VOID</span>)<br></code></pre></div></td></tr></table></figure><p>这里其实我并不明确这里的 a 和 b 为何需要是函数，可能是为延迟求值，也可能是为统一“模式匹配”的形式（见下面的 <a href="#%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93">部分总结</a>），下面有些地方使用了这个形式，有些地方也没有。</p><p>它们的含义都很明确——TRUE 表示一个两参数的函数，返回第一个参数，FALSE 表示一个两参数的函数，返回第二个参数。可以认为，我们把 boolean 通过 lambda 去“编码”了。至于为何要这样编码，去问丘奇吧 hh。</p><p>这样抽象后，我们能够实现 if，if 是这样的结构——它接受三个参数，其中第一个参数是布尔值，若其为真，返回第二个参数，否则返回第三个参数，它的实现是显然的。</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">IF = λc.λ<span class="hljs-selector-tag">a</span>.λ<span class="hljs-selector-tag">b</span>. c <span class="hljs-selector-tag">a</span> b<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">IF</span> = cond =&gt; <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">cond</span>(a)(b)<br></code></pre></div></td></tr></table></figure><p>可以做一下演算，假设 1 和 2 是合法的 lambda 变量：</p><p>对其的使用类似这样：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-variable constant_">IF</span> (<span class="hljs-variable constant_">TRUE</span>) (<span class="hljs-function">() =&gt;</span> <span class="hljs-number">1</span>) (<span class="hljs-function">() =&gt;</span> <span class="hljs-number">2</span>)<br>)<br></code></pre></div></td></tr></table></figure><p>在这里，由于 javascript 的弱类型，可以注意到，IF 其实就是 identity 函数<code>x =&gt; x</code>——<code>IF(TRUE)(1)(2) = TRUE(1)(2) = 1</code>，<code>IF(TRUE) = TRUE</code>。</p><p>实现 AND 和 OR 也是简单的，它们的参数均为布尔值，返回值也为布尔值：</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">AND</span> = λa.λb. IF a (IF b <span class="hljs-literal">TRUE</span> <span class="hljs-literal">FALSE</span>) <span class="hljs-literal">FALSE</span><br><span class="hljs-attr">OR</span> = λa.λb. IF a <span class="hljs-literal">TRUE</span> (IF b <span class="hljs-literal">TRUE</span> <span class="hljs-literal">FALSE</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">AND</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-variable constant_">IF</span> (a) (<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">IF</span> (b) (<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">TRUE</span>) (<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">FALSE</span>)) (<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">FALSE</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">OR</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-variable constant_">IF</span> (a) (<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">TRUE</span>) (<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">IF</span> (b) (<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">TRUE</span>) (<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">FALSE</span>))<br></code></pre></div></td></tr></table></figure><h1 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h1><p>Cons 的实现如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">CONS = λ<span class="hljs-selector-tag">a</span>.λ<span class="hljs-selector-tag">b</span>.λn.λf<span class="hljs-selector-class">.f</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span><br>NIL = λn.λf<span class="hljs-selector-class">.e</span><br>CAR = λ<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.p</span> VOID (λ<span class="hljs-selector-tag">a</span>.λ<span class="hljs-selector-tag">b</span>.a)<br>CDR = λ<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.p</span> VOID (λ<span class="hljs-selector-tag">a</span>.λ<span class="hljs-selector-tag">b</span>.b)<br>IS_NIL = λ<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.p</span> TRUE FALSE<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">CONS</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">onNil</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">onCons</span> =&gt;</span> onCons (a) (b)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">NIL</span> = onNil =&gt; <span class="hljs-function"><span class="hljs-params">onCons</span> =&gt;</span> onNil (<span class="hljs-variable constant_">VOID</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">CAR</span> = cons =&gt; cons (<span class="hljs-variable constant_">VOID</span>) (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> a)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">CDR</span> = cons =&gt; cons (<span class="hljs-variable constant_">VOID</span>) (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> b)<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pairInstance = <span class="hljs-variable constant_">CONS</span> (<span class="hljs-number">1</span>) (<span class="hljs-number">2</span>)<br><span class="hljs-keyword">const</span> car = <span class="hljs-variable constant_">CAR</span> (pairInstance) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure><p>Cons 的这个定义<code>a =&gt; b =&gt; onNil =&gt; onCons =&gt; onCons (a) (b)</code>十分有趣，我们可以给它加点括号来更突出这有趣之处：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">CONS</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> (<span class="hljs-function"><span class="hljs-params">onNil</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">onCons</span> =&gt;</span> onCons (a) (b))<br></code></pre></div></td></tr></table></figure><p><strong>可以建立这样的心智模型，即 CONS 是这样一个函数，它接受两个参数，去返回一个数据结构，而我们通过去传递给它一个“Matcher”（模式匹配）去获取该数据结构中的值</strong>。同时也可以注意到，NIL 的结构和调用 CONS 返回的数据结构是一致的。</p><p>然后，显然需要实现一个检查 PAIR 是否是 NIL 的函数，这个函数的实现同样很 trick 但能找到模式：</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">IS_NIL</span> = λp. p <span class="hljs-literal">TRUE</span> (λa.λb. <span class="hljs-literal">FALSE</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">IS_NIL</span> = p =&gt; p (<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">TRUE</span>) (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-variable constant_">FALSE</span>)<br></code></pre></div></td></tr></table></figure><p>为何这么实现？推导一下就行了：</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">IS_NIL NIL<br>=&gt; IS_NIL NOTHING<br>=&gt; IS_NIL (λe.λf.e)<br>=&gt; (λe.λf.e) <span class="hljs-built_in">TRUE</span> (λa.λb. <span class="hljs-built_in">FALSE</span>)<br>=&gt; (λf. <span class="hljs-built_in">TRUE</span>) (λa.λb. <span class="hljs-built_in">FALSE</span>)<br>=&gt; <span class="hljs-built_in">TRUE</span><br></code></pre></div></td></tr></table></figure><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">IS_NIL (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>=&gt; IS_NIL (CONS <span class="hljs-number">1</span> <span class="hljs-number">2</span>)<br>=&gt; IS_NIL (λe.λf. f <span class="hljs-number">1</span> <span class="hljs-number">2</span>)<br>=&gt; (λe.λf. <span class="hljs-number">1</span> <span class="hljs-number">2</span>) <span class="hljs-built_in">TRUE</span> (λa.λb. <span class="hljs-built_in">FALSE</span>)<br>=&gt; (λf.f <span class="hljs-number">1</span> <span class="hljs-number">2</span>) (λa.λb. <span class="hljs-built_in">FALSE</span>)<br>=&gt; (λa.λb. <span class="hljs-built_in">FALSE</span>) <span class="hljs-number">1</span> <span class="hljs-number">2</span><br>=&gt; <span class="hljs-built_in">FALSE</span><br></code></pre></div></td></tr></table></figure><p>这很像模式匹配——只不过我们必须通过函数参数的形式去绑定所有值就是了，比如这个 IS_NIL 函数可以看成这样（使用 Scala 的模式匹配语法）：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">match</span> cons &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">NIL</span> -&gt; <span class="hljs-type">TRUE</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">CONS</span>(a, b) -&gt; <span class="hljs-type">FALSE</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h1><p>照葫芦画瓢，我们可以尝试去抽象 Maybe：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- haskell syntax</span><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Maybe</span> a = <span class="hljs-type">Nothing</span> | <span class="hljs-type">Just</span> a</span><br></code></pre></div></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">NOTHING</span> <span class="hljs-operator">=</span> λe.λf. e<br><span class="hljs-attribute">JUST</span> <span class="hljs-operator">=</span> λa.λe.λf. f a<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">NOTHING</span> = onNothing =&gt; <span class="hljs-function"><span class="hljs-params">onJust</span> =&gt;</span> onNothing (<span class="hljs-variable constant_">VOID</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">JUST</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">onNothing</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">onJust</span> =&gt;</span> onJust (a)<br></code></pre></div></td></tr></table></figure><p>map 的操作如 map，flatMap，orElse 也可以定义出来：</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">IS_NOTHING</span> = λm. m <span class="hljs-literal">TRUE</span> (λa.<span class="hljs-literal">FALSE</span>)<br><span class="hljs-attr">FLATMAP</span> = λf.λm. m m (λa. f a)<br><span class="hljs-attr">MAP</span> = λf.λm. m m (λa. JUST (f a))<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">IS_NOTHING</span> = maybe =&gt; maybe (<span class="hljs-variable constant_">TRUE</span>) (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable constant_">FALSE</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">FLATMAP</span> = f =&gt; <span class="hljs-function"><span class="hljs-params">maybe</span> =&gt;</span> maybe (<span class="hljs-function">() =&gt;</span> maybe) (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> f (a))<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MAP</span> = f =&gt; <span class="hljs-function"><span class="hljs-params">maybe</span> =&gt;</span> maybe (<span class="hljs-function">() =&gt;</span> maybe) (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable constant_">JUST</span> (f (a)))<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">OR_ELSE</span> = maybe =&gt; <span class="hljs-function"><span class="hljs-params">defaultValue</span> =&gt;</span> maybe (defaultValue) (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a)<br></code></pre></div></td></tr></table></figure><p>使用类似这样：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-variable constant_">JUST</span> (<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> b = <span class="hljs-variable constant_">MAP</span> (<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>) (a)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>    <span class="hljs-variable constant_">OR_ELSE</span> (b) (-<span class="hljs-number">1000</span>)<br>)<br></code></pre></div></td></tr></table></figure><h1 id="部分总结"><a href="#部分总结" class="headerlink" title="部分总结"></a>部分总结</h1><p>在 haskell 中，Bool，Cons，Maybe，Either，Tree（二叉树）的类型定义分别如下：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Bool</span> = <span class="hljs-type">True</span> | <span class="hljs-type">False</span></span><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">List</span> a = <span class="hljs-type">Cons</span> a (<span class="hljs-type">List</span> <span class="hljs-title">a</span>) | <span class="hljs-type">Nil</span></span><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Maybe</span> a = <span class="hljs-type">Just</span> a | <span class="hljs-type">Nothing</span></span><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Either</span> a b = <span class="hljs-type">Left</span> a | <span class="hljs-type">Right</span> b</span><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree</span> a = <span class="hljs-type">Empty</span> | <span class="hljs-type">Node</span> a (<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>) (<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>) </span><br></code></pre></div></td></tr></table></figure><p>使用 lambda 对其的抽象如下：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">TRUE</span>  <span class="hljs-operator">=</span> λa.λb. a<br><span class="hljs-attribute">FALSE</span> <span class="hljs-operator">=</span> λa.λb. b<br><br><span class="hljs-attribute">CONS</span> <span class="hljs-operator">=</span> λa.λb.λn.λf. f a b<br><span class="hljs-attribute">NIL</span>  <span class="hljs-operator">=</span>       λn.λf. n<br><br><span class="hljs-attribute">JUST</span>    <span class="hljs-operator">=</span> λa.λn.λf. f a<br><span class="hljs-attribute">NOTHING</span> <span class="hljs-operator">=</span>    λn.λf. n<br><br><span class="hljs-attribute">LEFT</span>  <span class="hljs-operator">=</span> λa.λl.λr. l a<br><span class="hljs-attribute">RIGHT</span> <span class="hljs-operator">=</span> λb.λl.λr. r b<br><br><span class="hljs-attribute">NODE</span>  <span class="hljs-operator">=</span> λa.λb.λc.λe.λn. n a b c<br><span class="hljs-attribute">EMPTY</span> <span class="hljs-operator">=</span>          λe.λn.e<br></code></pre></div></td></tr></table></figure><p><strong>可以发现，对任何 ADT，它似乎都能通过 lambda 去抽象，其中，每一个值构造器对应一个函数，其接受值构造器的参数，去构造相应数据结构；然后，我们传递给这个数据结构一个 Matcher，对其进行“模式匹配”并获得值</strong>。</p><h1 id="丘奇数"><a href="#丘奇数" class="headerlink" title="丘奇数"></a>丘奇数</h1><p>通过上面的观念，我们尝试操作一下自然数，<strong>皮亚诺自然数</strong>的 Haskell 定义是这样的：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Nat</span> = <span class="hljs-type">Zero</span> | <span class="hljs-type">Succ</span> <span class="hljs-type">Nat</span></span><br></code></pre></div></td></tr></table></figure><p>定义相应 lambda，并去推演 ONE，TWO，THREE……</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">ZERO =    λx.λf. x<br>SUCC = λa.λx.λf. f a<br><br>ONE <br><span class="hljs-section">= SUCC ZERO</span><br><span class="hljs-section">= (λa.λx.λf. f a) (λx.λf. x)</span><br><span class="hljs-section">= (λx.λf. f (λx.λf. x))</span><br><br>TWO <br><span class="hljs-section">= SUCC ONE</span><br><span class="hljs-section">= (λa.λx.λf. f a) (λx.λf. f (λx.λf. x))</span><br><span class="hljs-section">= (λx.λf. f (λx.λf. f (λx.λf. x)))</span><br></code></pre></div></td></tr></table></figure><p>但这样的自然数定义实在有点难以形容，这时候就来了<strong>丘奇数</strong>，它修改了 SUCC，把“Matcher”提前应用给了它的“值”：</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">ZERO =    λx.λf. x<br>SUCC = λa.λx.λf. f (a x f)<br><br>ONE<br><span class="hljs-section">= SUCC ZERO</span><br><span class="hljs-section">= (λa.λx.λf. f (a x f)) (λx.λf. x)</span><br><span class="hljs-section">= (λx.λf. f x)</span><br><br>TWO<br><span class="hljs-section">= SUCC ONE</span><br><span class="hljs-section">= (λa.λx.λf. f (a x f)) (λx.λf. f x)</span><br><span class="hljs-section">= (λx.λf. f ((λx.λf. f x) x f)) </span><br><span class="hljs-section">= (λx.λf. f (f x))</span><br><br>THREE<br><span class="hljs-section">= SUCC ONE</span><br><span class="hljs-section">= (λa.λx.λf. f (a x f)) (λx.λf. f (f x))</span><br><span class="hljs-section">= (λx.λf. f ((λx.λf. f (f x)) x f)) </span><br><span class="hljs-section">= (λx.λf. f (f (f x)))</span><br></code></pre></div></td></tr></table></figure><p>可以发现，自然数的值就是 f 应用的次数，f 应用 n 次，则对应的自然数的值就是 n；其 js 表述如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ZERO</span> = x =&gt; <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> x<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">SUCC</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f (a (x) (f))<br></code></pre></div></td></tr></table></figure><p>根据丘奇数的形式，可以很容易地将丘奇数转换为 js 的数字：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inc</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">(λx.λf. f (f (f (f (x))))) 0 inc<br><span class="hljs-section">= inc (inc (inc (inc (0))))</span><br><span class="hljs-section">= 4</span><br></code></pre></div></td></tr></table></figure><p>这种形式非常有趣，它像某种 reduce，其中 x 为初始值，f 为 step 函数，我们可以把 f 换成不同的函数（只要它的签名满足<code>A =&gt; A</code>），把 x 换成不同的值（即这里的类型<code>A</code>），比如我们可以去构造一个同这个自然数大小相同长度的列表：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">push0</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>, ...x]<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">(λx.λf. f (f (f (f (x))))) [] push0<br><span class="hljs-section">= push0 (push0 (push0 (push0 ([]))))</span><br><span class="hljs-section">= [0, 0, 0, 0]</span><br></code></pre></div></td></tr></table></figure><p>这个性质对定义四则运算非常重要，比如考虑加法，<strong>对任意自然数 n，我们将其加 a，就是将其应用 a 次 SUCC</strong>，形式化地来说，就是：</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">PLUS <span class="hljs-built_in">n</span> a = SUCC^a <span class="hljs-built_in">n</span><br></code></pre></div></td></tr></table></figure><p>那么，如何在 n 上应用 a 次 SUCC 呢？答案很明白了：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">PLUS</span> <span class="hljs-operator">=</span> λn.λa. a n SUCC<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">PLUS</span> = n =&gt; <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a (n) (<span class="hljs-variable constant_">SUCC</span>)<br></code></pre></div></td></tr></table></figure><p>测试一下：</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">PLUS (SUCC (SUCC (SUCC ZERO))) (SUCC (SUCC ZERO))<br>= (λn.λa. a <span class="hljs-built_in">n</span> SUCC) (SUCC (SUCC (SUCC ZERO))) (SUCC (SUCC ZERO))<br>= (SUCC (SUCC ZERO)) (SUCC (SUCC (SUCC ZERO))) SUCC<br>= (λx.λf.f (f x)) (SUCC (SUCC (SUCC ZERO))) SUCC<br>= SUCC (SUCC (SUCC (SUCC (SUCC ZERO))))<br>= <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>乘法也很简单——自然数 n 乘以自然数 a，就是<code>0 + n + n + ... + n</code>，其中 n 的个数为 a，我们只需要让 f 的值变为<code>λx. PLUS x n</code>即可，一个简单的闭包罢了：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">MULTIPLY = λn.λ<span class="hljs-keyword">a</span>. <span class="hljs-keyword">a</span> <span class="hljs-literal">ZERO</span> (λx. PLUS x n)<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">MULTIPLY</span> = n =&gt; <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a (<span class="hljs-variable constant_">ZERO</span>) (<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-variable constant_">PLUS</span> (x) (n))<br></code></pre></div></td></tr></table></figure><p>测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">MULTIPLY</span> (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>)) (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>)))<br>= (λn.λa. a <span class="hljs-variable constant_">ZERO</span> (λx. <span class="hljs-variable constant_">PLUS</span> x n)) (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>)) (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>)))<br>= (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))) <span class="hljs-variable constant_">ZERO</span> (λx. <span class="hljs-variable constant_">PLUS</span> x (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>)))<br>= (λx.λf.<span class="hljs-property">f</span> (f (f x))) <span class="hljs-variable constant_">ZERO</span> (λx. <span class="hljs-variable constant_">PLUS</span> x (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>)))<br>= (λx. <span class="hljs-variable constant_">PLUS</span> x (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))) ((λx. <span class="hljs-variable constant_">PLUS</span> x (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))) ((λx. <span class="hljs-variable constant_">PLUS</span> x (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))) (<span class="hljs-variable constant_">ZERO</span>)))<br>= (λx. <span class="hljs-variable constant_">PLUS</span> x (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))) ((λx. <span class="hljs-variable constant_">PLUS</span> x (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))) (<span class="hljs-variable constant_">PLUS</span> <span class="hljs-variable constant_">ZERO</span> (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))))<br>= (λx. <span class="hljs-variable constant_">PLUS</span> x (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))) (<span class="hljs-variable constant_">PLUS</span> (<span class="hljs-variable constant_">PLUS</span> <span class="hljs-variable constant_">ZERO</span> (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))) (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>)))<br>= <span class="hljs-variable constant_">PLUS</span> (<span class="hljs-variable constant_">PLUS</span> (<span class="hljs-variable constant_">PLUS</span> <span class="hljs-variable constant_">ZERO</span> (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))) (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))) (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">SUCC</span> <span class="hljs-variable constant_">ZERO</span>))<br>= + (+ (+ (<span class="hljs-number">0</span> <span class="hljs-number">2</span>) <span class="hljs-number">2</span>) <span class="hljs-number">2</span>)<br>= <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure><p>要定义减法，我们需要先定义 PRED 即前驱，减一操作，即从<code>λx.λf. f (f x)</code> 到<code>λx.λf.f x</code>。这个操作对皮亚诺自然数来说是非常容易的，但对丘奇数（，对我）来说完全不 trival，这里参考 <a href="https://www.zhihu.com/question/64274105/answer/218978613">如何理解丘奇计数的减法？ - Thomas Lin 的回答 - 知乎</a>。</p><p>我们可以去尝试构造这样一个 PAIR 的序列，其中对每一个元素，它的第一个元素是第二个元素的后继，且对序列中后一个元素，它的第一个元素为前一个元素的第一个元素的后继，第二个元素为前一个元素的第二个元素；定义<code>PRED ZERO = ZERO</code>，依此定义这个序列的起始值为<code>(ZERO, ZERO)</code>；</p><p><img src="https://picx.zhimg.com/80/v2-90fa9b7c1888aef7bc0566b68e9e49d9_1440w.webp?source=1940ef5c"></p><p>根据示意图能发现，对任意自然数 n，只要找到这个序列中第 n 个值，它的第二个元素就是它的前驱。</p><p>因此，能够定义起始元素以及步进函数：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">PAIR = λ<span class="hljs-selector-tag">a</span>.λ<span class="hljs-selector-tag">b</span>.λf<span class="hljs-selector-class">.f</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span><br>FST = λ<span class="hljs-selector-tag">p</span>. <span class="hljs-selector-tag">p</span> (λ<span class="hljs-selector-tag">a</span>.λ<span class="hljs-selector-tag">b</span>.a)<br>SND = λ<span class="hljs-selector-tag">p</span>. <span class="hljs-selector-tag">p</span> (λ<span class="hljs-selector-tag">a</span>.λ<span class="hljs-selector-tag">b</span>.b)<br><br>START = PAIR ZERO ZERO<br>STEP = λ<span class="hljs-selector-tag">p</span>. PAIR (SUCC (FST p)) (FST p)<br></code></pre></div></td></tr></table></figure><p>根据上面的把自然数转换成 js 数字，列表的操作，我们同样可以把自然数直接转换成这个序列中的元素，只消 x，f 的值确定即可，其中 x 为 START（类型为<code>(Nat, Nat)</code>），f 为 STEP（类型为<code>(Nat, Nat) =&gt; (Nat, Nat)</code>），因此，要获取自然数的前驱，我们得到这样的代码：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">PRED</span> <span class="hljs-operator">=</span> λn. SND (n START STEP)<br></code></pre></div></td></tr></table></figure><p>这里做一些测试：</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">PRED ZERO<br><span class="hljs-section">= SND (ZERO START STEP)</span><br><span class="hljs-section">= SND ((λx.λf.x) START STEP)</span><br><span class="hljs-section">= SND START</span><br><span class="hljs-section">= SND (ZERO, ZERO)</span><br><span class="hljs-section">= ZERO</span><br><br>PRED (SUCC ZERO)<br><span class="hljs-section">= SND ((SUCC ZERO) START STEP)</span><br><span class="hljs-section">= SND ((λx.λf.f x) START STEP)</span><br><span class="hljs-section">= SND (STEP START)</span><br><span class="hljs-section">= SND (STEP (ZERO, ZERO))</span><br><span class="hljs-section">= SND (SUCC ZERO, ZERO)</span><br><span class="hljs-section">= ZERO</span><br><br>PRED (SUCC (SUCC ZERO))<br><span class="hljs-section">= SND ((SUCC (SUCC ZERO)) START STEP)</span><br><span class="hljs-section">= SND ((λx.λf.f (f x)) START STEP)</span><br><span class="hljs-section">= SND (STEP (STEP START))</span><br><span class="hljs-section">= SND (STEP (SUCC ZERO, ZERO))</span><br><span class="hljs-section">= SND (SUCC (SUCC ZERO), SUCC ZERO)</span><br><span class="hljs-section">= SUCC ZERO</span><br></code></pre></div></td></tr></table></figure><p>老实说，它的纯 lambda 形式我实在化简不下去了，这里直接开摆，把上面的 PRED 用 js 实现：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">PAIR</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f (a) (b)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">FST</span> = p =&gt; p (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> a)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">SND</span> = p =&gt; p (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> b)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">START</span> = <span class="hljs-variable constant_">PAIR</span> (<span class="hljs-variable constant_">ZERO</span>) (<span class="hljs-variable constant_">ZERO</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">STEP</span> = p =&gt; <span class="hljs-variable constant_">PAIR</span> (<span class="hljs-variable constant_">SUCC</span> (<span class="hljs-variable constant_">FST</span> (p))) (<span class="hljs-variable constant_">FST</span> (p))<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">PRED</span> = n =&gt; <span class="hljs-variable constant_">SND</span> (n (<span class="hljs-variable constant_">START</span>) (<span class="hljs-variable constant_">STEP</span>))<br></code></pre></div></td></tr></table></figure><p>有了 PRED，我们能够定义减法了，自然数 n 减去自然数 a，就是 n 减去 a 次 1，即执行 n 次 PRED</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">MINUS</span> <span class="hljs-operator">=</span> λn.λa. a n PRED<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">MINUS</span> = n =&gt; <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a (n) (<span class="hljs-variable constant_">PRED</span>)<br></code></pre></div></td></tr></table></figure><h1 id="Y-组合子"><a href="#Y-组合子" class="headerlink" title="Y 组合子"></a>Y 组合子</h1><p>这一节参考了<a href="https://stackoverflow.com/a/6713431">https://stackoverflow.com/a/6713431</a>和<a href="https://stackoverflow.com/a/6714066">https://stackoverflow.com/a/6714066</a>。</p><p>递归，也就是自己引用自己，比如下面的阶乘函数 fact，在其函数体中引用了自己：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">return</span> n === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : (n * fact (n - <span class="hljs-number">1</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但在 lambda 演算中我们无法这样做，因为在 lambda 演算中不存在所谓的“名字”，因此无法直接去编写递归的函数；而通过 Y 组合子，我们便能在不引用自身的情况下编写递归函数，放到 js 的语境下，就是说我们能编写匿名的递归函数。</p><p>但在研究 Y 组合子之前，先来思考一下，怎样的情况下我们能让一个函数去不通过名字来引用自己？显然，这时候要拿到自己只<strong>可</strong>能通过两种方式——去捕获上层变量，或者去从函数参数中拿；其中后者的实现还是比较容易想到的——<strong>调用函数的时候，把自身传递过去就好了</strong>！比如这里编写一个 fib 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">FIB</span> = f =&gt; <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> num<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(f)(num - <span class="hljs-number">1</span>) + <span class="hljs-title function_">f</span>(f)(num - <span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">FIB</span>(<span class="hljs-variable constant_">FIB</span>)(<span class="hljs-number">10</span>))<br></code></pre></div></td></tr></table></figure><p>虽然乍一眼看起来有点作弊，但这是 lambda 可以实现出来的。我们考虑再来一个阶乘函数：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">FACT</span> = f =&gt; <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(f)(num - <span class="hljs-number">1</span>) * num<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">FACT</span>(<span class="hljs-variable constant_">FACT</span>)(<span class="hljs-number">10</span>)) <span class="hljs-comment">// 3628800</span><br></code></pre></div></td></tr></table></figure><p>容易注意到，这玩意调用的时候是有特定的模式的——<code>F(F)(...args)</code>，我们将这个模式抽象一波：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">MAGIC</span> = f =&gt; <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-title function_">f</span>(<span class="hljs-title function_">f</span>(f))(n)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FIB</span> = <span class="hljs-title function_">MAGIC</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> num<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(f)(num - <span class="hljs-number">1</span>) + <span class="hljs-title function_">f</span>(f)(num - <span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">FIB</span>(<span class="hljs-number">10</span>)) <span class="hljs-comment">// 55</span><br></code></pre></div></td></tr></table></figure><p>可以看到，这玩意已经部分能满足需求了，但蛋疼的一点是，在编写该递归函数的时候，每次调用自己都得写<code>f(f)(...)</code>，这比较麻烦，这种思考方式不可行。</p><p>现在回到递归函数，第一步，来写一个递归的 fact 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">return</span> n === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>) * n<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第二步，我们可以把这个函数变成“Supplier”，这种形式和上面的显然是等价的，其中参数<code>_</code>显然被直接扔掉了：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">_</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-title function_">fact</span>(_)(n - <span class="hljs-number">1</span>) * n<br>&#125;<br><br><span class="hljs-keyword">const</span> factorial = <span class="hljs-title function_">fact</span>(_) <span class="hljs-comment">// _为任何值</span><br></code></pre></div></td></tr></table></figure><p>第三步：直到上一步，事情还是 trival 的，函数仍旧引用了自己，为了解决这个问题，再抽象一层，我们可以把函数体里的<code>fact(_)</code>通过参数去传入，这要求<code>_ = fact(_)</code>，这里令<code>_ = recur</code>，得到<code>recur = fact(recur)</code>，将参数<code>_</code>替换为<code>recur</code>，将函数体中的<code>fact(_)</code>替换为<code>fact(recur)</code>，替换为<code>recur</code>，得到：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fact</span> = recur =&gt; <br>  <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-title function_">recur</span>(n - <span class="hljs-number">1</span>) * n<br></code></pre></div></td></tr></table></figure><p>而 recur 的定义其实就是这个：<code>recur = fact(recur)</code>，这里引用了自己，所以必须要使用递归函数去定义；而且这不是 haskell，所以不能用 point-free 风格，这里必须要知道 recur 的类型，而这是容易看出来的：<code>number =&gt; number</code>，下面便是结果：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fact</span>(recur)(x)<br>&#125;<br><br><span class="hljs-keyword">const</span> factorial = <span class="hljs-title function_">fact</span>(recur)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">10</span>))<br></code></pre></div></td></tr></table></figure><p>好的，现在 fact 不是递归函数了，但我们又引入了一个新的递归函数 recur（欣慰的是，所有递归函数最后都能抽象成无显式递归的“body”和这样一个 recur 函数。</p><p>我们对 recur 采用和第一步到第二步同样的手段，即给它包一层 Supplier：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">_</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title function_">fact</span>(<span class="hljs-title function_">recur</span>(_))(x)<br>&#125;<br><span class="hljs-keyword">const</span> factorial = <span class="hljs-title function_">fact</span>(<span class="hljs-title function_">recur</span>())<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">10</span>))<br></code></pre></div></td></tr></table></figure><!-- TODO：这一步怎么来的--><p>然后，问题就在于如何处理<code>_</code>和<code>recur(_)</code>了，我实在弄不明白，把答案列出来：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">recur</span> = f =&gt;<br>  <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title function_">fact</span>(<span class="hljs-title function_">f</span>(f))(x)<br></code></pre></div></td></tr></table></figure><p><strong>虽然有点跳跃，但这里的 f，它就是 recur 本身</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> factorial = <span class="hljs-title function_">recur</span>(recur)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">10</span>))<br></code></pre></div></td></tr></table></figure><p>现在，所有的显式递归都已经移除，把最终的代码都列出来：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fact</span> = recur =&gt; <br>  <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-title function_">recur</span>(n - <span class="hljs-number">1</span>) * n<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">recur</span> = f =&gt;<br>  <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title function_">fact</span>(<span class="hljs-title function_">f</span>(f))(x)<br>  <br><span class="hljs-keyword">const</span> factorial = <span class="hljs-title function_">recur</span>(recur)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">10</span>))<br></code></pre></div></td></tr></table></figure><p>容易发现，这里只有 fact 是“变”量，换成其它的递归函数，只有 fact 会改变，因此，我们将这个模式抽象出来，就得到了 Y 组合子：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Y</span> = fn =&gt; (<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title function_">fn</span>(<span class="hljs-title function_">f</span>(f))(x))(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title function_">fn</span>(<span class="hljs-title function_">f</span>(f))(x))<br></code></pre></div></td></tr></table></figure><p>它很容易使用 lambda 去表述：</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">Y <span class="hljs-operator">=</span> λfn. (λf.λ<span class="hljs-keyword">x</span>. fn (f f) <span class="hljs-keyword">x</span>) (λf.λ<span class="hljs-keyword">x</span>. fn (f f) <span class="hljs-keyword">x</span>)<br></code></pre></div></td></tr></table></figure><p>这形式比想象中简单多了 hhh，可惜它的发明过程怕是值几篇博士论文吧？</p><h1 id="Lazy-List"><a href="#Lazy-List" class="headerlink" title="Lazy List"></a>Lazy List</h1><p>有了 Y 组合子，现在可以自由地耍花活了，该操作操作列表了，但在此之前先和皮亚诺自然数过两招，不然列表存啥元素呢？这里首先给出皮亚诺自然数的定义，以及其到 javascript 数字类型的转换函数：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Nat = Zero | Succ Nat</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">ZERO</span> = z =&gt; <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> z<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">SUCC</span> = n =&gt; <span class="hljs-function"><span class="hljs-params">z</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> <span class="hljs-title function_">s</span>(n)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TO_NUMBER</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">nat</span> =&gt;</span> <span class="hljs-title function_">nat</span>(<span class="hljs-number">0</span>)(<span class="hljs-function"><span class="hljs-params">pred</span> =&gt;</span> <span class="hljs-number">1</span> + <span class="hljs-title function_">f</span>(pred)))<br></code></pre></div></td></tr></table></figure><p>皮亚诺自然数的加法也是简单的——对两个自然数<code>a</code>，<code>b</code>相加，检查<code>a</code>是否是<code>ZERO</code>，若是，则返回<code>b</code>，若不是，则令<code>a</code>为<code>(SUCC c)</code>，对<code>c</code>，<code>(SUCC b)</code>相加；乘法同样简单，对两个自然数<code>a</code>，<code>b</code>相乘，检查<code>a</code>是否是<code>ZERO</code>，若是，则返回<code>ZERO</code>，若不是，则令<code>a</code>为<code>(SUCC c)</code>，求<code>c</code>，<code>b</code>的乘积和<code>b</code>的和：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PLUS</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">plus</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">a</span>(b)(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-title function_">plus</span>(c)(<span class="hljs-title function_">SUCC</span>(b))))<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MULTIPLY</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">multiply</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">a</span>(<span class="hljs-variable constant_">ZERO</span>)(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-title function_">plus</span>(b)(<span class="hljs-title function_">multiply</span>(c)(b))))<br></code></pre></div></td></tr></table></figure><p>这就足够了，下面实现列表相关操作，这里要求列表是惰性的，即 b 为返回 CDR 的函数，下面实现一下 map-filter-reduce，并实现 take 和 iterate，最终去实现一个自然数列表，取前 10 项奇数（本想取前 100 项，然而发现这爆栈了）的和；其中因为布尔值和自然数都未使用上面那种非严格求值的形式，这里定义了一个<code>LAZY_IF</code>来保证 if 为“短路”操作：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">TRUE</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> a <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">FALSE</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> b <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">IF</span> = cond =&gt; <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">cond</span>(a)(b)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">AND</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">IF</span>(a)(<span class="hljs-title function_">IF</span>(b)(<span class="hljs-variable constant_">TRUE</span>)(<span class="hljs-variable constant_">FALSE</span>))(<span class="hljs-variable constant_">FALSE</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">OR</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">IF</span>(a)(<span class="hljs-variable constant_">TRUE</span>)(<span class="hljs-title function_">IF</span>(b)(<span class="hljs-variable constant_">TRUE</span>)(<span class="hljs-variable constant_">FALSE</span>))<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">NOT</span> = a =&gt; <span class="hljs-title function_">IF</span>(a)(<span class="hljs-variable constant_">FALSE</span>)(<span class="hljs-variable constant_">TRUE</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Y</span> = fn =&gt; (<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title function_">fn</span>(<span class="hljs-title function_">f</span>(f))(x))(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title function_">fn</span>(<span class="hljs-title function_">f</span>(f))(x))<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">ZERO</span> =      z =&gt; <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> z<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">SUCC</span> = n =&gt; <span class="hljs-function"><span class="hljs-params">z</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> <span class="hljs-title function_">s</span>(n)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">PRED</span> = nat =&gt; <span class="hljs-title function_">nat</span>(<span class="hljs-variable constant_">ZERO</span>)(<span class="hljs-function"><span class="hljs-params">pred</span> =&gt;</span> pred)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">IS_ZERO</span> = nat =&gt; <span class="hljs-title function_">nat</span>(<span class="hljs-variable constant_">TRUE</span>)(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">FALSE</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TO_NUMBER</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">nat</span> =&gt;</span> <span class="hljs-title function_">nat</span>(<span class="hljs-number">0</span>)(<span class="hljs-function"><span class="hljs-params">pred</span> =&gt;</span> <span class="hljs-number">1</span> + <span class="hljs-title function_">f</span>(pred)))<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PLUS</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">plus</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">a</span>(b)(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-title function_">plus</span>(c)(<span class="hljs-title function_">SUCC</span>(b))))<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MULTIPLY</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">multiply</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">a</span>(<span class="hljs-variable constant_">ZERO</span>)(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-title function_">PLUS</span>(b)(<span class="hljs-title function_">multiply</span>(c)(b))))<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">EQUAL</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">equal</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <br>  <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(<span class="hljs-variable constant_">TRUE</span>)(<span class="hljs-function"><span class="hljs-params">predB</span> =&gt;</span> <span class="hljs-variable constant_">FALSE</span>))(<span class="hljs-function"><span class="hljs-params">predA</span> =&gt;</span> <span class="hljs-title function_">b</span>(<span class="hljs-variable constant_">FALSE</span>)(<span class="hljs-function"><span class="hljs-params">predB</span> =&gt;</span> <span class="hljs-title function_">equal</span>(predA)(predB))))<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">LAZY_IF</span> = cond =&gt; <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">cond</span>(a)(b)()<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">EQUAL1</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">equal</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <br>  <span class="hljs-variable constant_">IF</span> (<span class="hljs-title function_">IS_ZERO</span>(a)) <br>    (<span class="hljs-variable constant_">IF</span> (<span class="hljs-title function_">IS_ZERO</span>(b)) (<span class="hljs-variable constant_">TRUE</span>) (<span class="hljs-variable constant_">FALSE</span>)) <br>    (<span class="hljs-variable constant_">LAZY_IF</span> (<span class="hljs-title function_">IS_ZERO</span>(b)) (<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">FALSE</span>) (<span class="hljs-function">() =&gt;</span> equal (<span class="hljs-variable constant_">PRED</span> (a)) (<span class="hljs-variable constant_">PRED</span> (b))))) <br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ONE</span> = <span class="hljs-title function_">SUCC</span>(<span class="hljs-variable constant_">ZERO</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TWO</span> = <span class="hljs-title function_">SUCC</span>(<span class="hljs-variable constant_">ONE</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">THREE</span> = <span class="hljs-title function_">SUCC</span>(<span class="hljs-variable constant_">TWO</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FOUR</span> = <span class="hljs-title function_">SUCC</span>(<span class="hljs-variable constant_">THREE</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FIVE</span> = <span class="hljs-title function_">SUCC</span>(<span class="hljs-variable constant_">FOUR</span>)<br><br><span class="hljs-comment">// 展示一波互调递归</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IS_EVEN_</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">isEven</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">isOdd</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">nat</span> =&gt;</span> <span class="hljs-title function_">LAZY_IF</span>(<span class="hljs-title function_">IS_ZERO</span>(nat))(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">TRUE</span>)(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">isOdd</span>(isEven)(<span class="hljs-title function_">PRED</span>(nat))))<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IS_ODD_</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">isOdd</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">isEven</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">nat</span> =&gt;</span> <span class="hljs-title function_">LAZY_IF</span>(<span class="hljs-title function_">IS_ZERO</span>(nat))(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">FALSE</span>)(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">isEven</span>(isOdd)(<span class="hljs-title function_">PRED</span>(nat))))<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IS_ODD</span> = <span class="hljs-title function_">IS_ODD_</span>(<span class="hljs-variable constant_">IS_EVEN_</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IS_EVEN</span> = <span class="hljs-title function_">IS_EVEN_</span>(<span class="hljs-variable constant_">IS_ODD_</span>)<br><br><span class="hljs-comment">// List a = Nil | Cons a (List a)</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">NIL</span> =            n =&gt; <span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> n<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">CONS</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-title function_">c</span>(a)(b)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">CAR</span> = lst =&gt; <span class="hljs-title function_">lst</span>()(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> a)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">CDR</span> = lst =&gt; <span class="hljs-title function_">lst</span>()(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">b</span>())<br><br><span class="hljs-comment">// js 数组到 List</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TO_JS_ARRAY</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">lst</span> =&gt;</span> <span class="hljs-title function_">lst</span>([])(<span class="hljs-function"><span class="hljs-params">head</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">tail</span> =&gt;</span> [head, ...<span class="hljs-title function_">f</span>(<span class="hljs-title function_">tail</span>())]))<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAP</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">map</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">lst</span> =&gt;</span> <span class="hljs-title function_">lst</span>(<span class="hljs-variable constant_">NIL</span>)(<span class="hljs-function"><span class="hljs-params">head</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">tail</span> =&gt;</span> <span class="hljs-title function_">CONS</span>(<span class="hljs-title function_">fn</span>(head))(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">map</span>(fn)(<span class="hljs-title function_">tail</span>()))))<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FILTER</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">filter</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">lst</span> =&gt;</span> <span class="hljs-title function_">lst</span>(<span class="hljs-variable constant_">NIL</span>)(<span class="hljs-function"><span class="hljs-params">head</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">tail</span> =&gt;</span> <br>  <span class="hljs-title function_">LAZY_IF</span>(<span class="hljs-title function_">fn</span>(head))<br>    (<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">CONS</span>(head)(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">filter</span>(fn)(<span class="hljs-title function_">tail</span>())))<br>    (<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">filter</span>(fn)(<span class="hljs-title function_">tail</span>()))))<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ITERATE</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">iterate</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">seed</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">CONS</span>(seed)(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">iterate</span>(<span class="hljs-title function_">fn</span>(seed))(fn)))<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NAT_LIST</span> = <span class="hljs-title function_">ITERATE</span>(<span class="hljs-variable constant_">ZERO</span>)(<span class="hljs-variable constant_">SUCC</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ODD_LIST</span> = <span class="hljs-title function_">FILTER</span>(<span class="hljs-variable constant_">IS_ODD</span>)(<span class="hljs-variable constant_">NAT_LIST</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">EVEN_LIST</span> = <span class="hljs-title function_">FILTER</span>(<span class="hljs-variable constant_">IS_EVEN</span>)(<span class="hljs-variable constant_">NAT_LIST</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FOLDL</span> = <span class="hljs-title function_">Y</span>(<span class="hljs-function"><span class="hljs-params">foldl</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">zero</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">lst</span> =&gt;</span> <span class="hljs-title function_">lst</span>(zero)(<span class="hljs-function"><span class="hljs-params">head</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">tail</span> =&gt;</span> <span class="hljs-title function_">foldl</span>(<span class="hljs-title function_">fn</span>(zero)(head))(fn)(<span class="hljs-title function_">tail</span>())))<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SUM</span> = <span class="hljs-title function_">FOLDL</span>(<span class="hljs-variable constant_">ZERO</span>)(<span class="hljs-variable constant_">PLUS</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">TAKE</span> = nat =&gt; <span class="hljs-function"><span class="hljs-params">lst</span> =&gt;</span> <span class="hljs-title function_">LAZY_IF</span>(<span class="hljs-title function_">IS_ZERO</span>(nat))(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">NIL</span>)(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">lst</span>(<span class="hljs-variable constant_">NIL</span>)(<span class="hljs-function"><span class="hljs-params">head</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">tail</span> =&gt;</span> <span class="hljs-title function_">CONS</span>(head)(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">TAKE</span>(<span class="hljs-title function_">PRED</span>(nat))(<span class="hljs-title function_">tail</span>()))))<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TEN</span> = <span class="hljs-title function_">MULTIPLY</span>(<span class="hljs-variable constant_">TWO</span>)(<span class="hljs-variable constant_">FIVE</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FIRST_TEN_ODD</span> = <span class="hljs-title function_">TAKE</span>(<span class="hljs-variable constant_">TEN</span>)(<span class="hljs-variable constant_">ODD_LIST</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">TO_JS_ARRAY</span>(<span class="hljs-title function_">MAP</span>(<span class="hljs-variable constant_">TO_NUMBER</span>)(<span class="hljs-variable constant_">FIRST_TEN_ODD</span>))) <span class="hljs-comment">// [ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">TO_NUMBER</span>(<span class="hljs-title function_">SUM</span>(<span class="hljs-variable constant_">FIRST_TEN_ODD</span>))) <span class="hljs-comment">// 100</span><br><br></code></pre></div></td></tr></table></figure><p>就这样了，之后预备看《The Little Schemer》，多去了解一下递归，以及深入了解 Y 组合子。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.zhihu.com/question/64274105">https://www.zhihu.com/question/64274105</a></li><li><a href="https://zhuanlan.zhihu.com/p/298996358">https://zhuanlan.zhihu.com/p/298996358</a></li><li><a href="https://zhuanlan.zhihu.com/p/312895562">https://zhuanlan.zhihu.com/p/312895562</a></li><li><a href="https://matt.might.net/articles/js-church/">https://matt.might.net/articles/js-church/</a></li><li><a href="https://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/">https://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn Vexflow By Example</title>
    <link href="/2022/11-13learnVexflowByExample.html"/>
    <url>/2022/11-13learnVexflowByExample.html</url>
    
    <content type="html"><![CDATA[<script src="https://cdn.jsdelivr.net/npm/vexflow@4.0.3/build/cjs/vexflow.js"></script><script>const { Accidental, Dot, Formatter, RenderContext, Renderer, Stave, StaveNote, Voice, Clef } = Vex.Flow;</script><p>vexflow 是一个 html 渲染五线谱的库，它有两套 API，一套是 low-level 的，一套是 high-level 的，考虑到我的需求实际上并非是去渲染乐谱，这里去学习它的 low-level API，下面全部用 vexflow 去指代它 low-level 的 API。</p><p>学习这些概念及其相关操作、相互关系就是学习 vexflow，这里学习一下vexflow的如下概念：</p><ol><li>Renderer</li><li>Context</li><li>Stave</li><li>StaveNote</li><li>Formatter</li></ol><h1 id="Renderer-Context"><a href="#Renderer-Context" class="headerlink" title="Renderer, Context"></a>Renderer, Context</h1><p>参考：<a href="https://github.com/0xfe/vexflow/wiki/Understanding-Renderer-&amp;-Context">https://github.com/0xfe/vexflow/wiki/Understanding-Renderer-&amp;-Context</a></p><p>使用 vexflow 时，一般会有这样的样板代码，它引用一个 div 或 canvas 元素设置相应空间，并获取 context，其用于渲染五线谱。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Renderer</span>, <span class="hljs-title class_">Stave</span> &#125; = <span class="hljs-title class_">Vex</span>.<span class="hljs-property">Flow</span>;<br><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;some-div&quot;</span>)<br><span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Renderer</span>(div, <span class="hljs-title class_">Renderer</span>.<span class="hljs-property">Backends</span>.<span class="hljs-property">SVG</span>);<br>renderer.<span class="hljs-title function_">resize</span>(<span class="hljs-number">500</span>, <span class="hljs-number">200</span>);<br><span class="hljs-keyword">const</span> context = renderer.<span class="hljs-title function_">getContext</span>();<br><span class="hljs-comment">// vexflow 的接口都是 fluent 的，也就是说可以链式调用</span><br><span class="hljs-comment">// 比如这里直接初始化 renderer 并获取 context，反正 renderer 之后也不会再用了</span><br><span class="hljs-comment">// const context = new Renderer(div, Renderer.Backends.SVG)</span><br><span class="hljs-comment">//   .resize(500, 250)</span><br><span class="hljs-comment">//   .getContext();</span><br></code></pre></div></td></tr></table></figure><p>Renderer 对应渲染五线谱的空间，其可调整渲染方式：svg 或 canvas。Renderer 只有两个方法——调整大小或获取 context。</p><p>context 提供了大量进行图形绘制的方法，它抽象了底层细节，使同一套接口能适用于 SVG 和 canvas。但 context 的方法太过底层，一般没有需要直接使用 context，而是利用 Stave，Note，Voice 等类的接口进行绘制。比如 Stave 可能会这样调用<code>stave.setContext(context).draw()</code>，这暗示了它会利用 context 的方法进行绘制。</p><p>Renderer 使用 svg 作为渲染方式时需要注意，其会在引用的 div 下新建一个 svg 元素，而如果这个元素下面原来就存在其它 Renderer，其不会受影响。这导致在 React 的 StrictMode 下会渲染重复的元素，因此需要在清理函数中删除 div 下所有子元素。canvas 似乎无此影响，但尚不知是否有其它 bug。这里只使用 svg。</p><p>上面的代码会得到下面的结果，这里加上一个 border 方便查看：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;some-div&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:1px solid red; max-width: 500px; background-color: white;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><div id="some-div" style="border:1px solid red; max-width: 500px; background-color: white;"></div><script defer>(() => {  const div = document.getElementById("some-div")  const context = new Renderer(div, Renderer.Backends.SVG)    .resize(500, 200)    .getContext();})()</script><p>白如纸，得加点东西上去。</p><h1 id="五线谱"><a href="#五线谱" class="headerlink" title="五线谱"></a>五线谱</h1><p>Stave 即五线谱，StaveNote，Voice 等实体需要依赖 Stave 进行绘制（它们都继承一个 Element 类）。</p><p>创建五线谱是 trival 的：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 模板代码</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;stave-example0&quot;</span>)<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Renderer</span>(div, <span class="hljs-title class_">Renderer</span>.<span class="hljs-property">Backends</span>.<span class="hljs-property">SVG</span>)<br>  .<span class="hljs-title function_">resize</span>(<span class="hljs-number">500</span>, <span class="hljs-number">200</span>)<br>  .<span class="hljs-title function_">getContext</span>();<br><br><span class="hljs-comment">// 创建 Stave，其在画布上的 x，y 轴分别偏移 10，40，长度位 400</span><br><span class="hljs-keyword">const</span> stave = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stave</span>(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">400</span>)<br>  .<span class="hljs-title function_">addClef</span>(<span class="hljs-string">&quot;treble&quot;</span>) <span class="hljs-comment">// 添加调号，treble 是 G 谱号</span><br>  .<span class="hljs-title function_">addTimeSignature</span>(<span class="hljs-string">&quot;4/4&quot;</span>) <span class="hljs-comment">// 拍号，4/4 拍</span><br>  .<span class="hljs-title function_">addKeySignature</span>(<span class="hljs-string">&#x27;G&#x27;</span>) <span class="hljs-comment">// 调号，G 调</span><br>  .<span class="hljs-title function_">setContext</span>(context) <span class="hljs-comment">// 注入 context</span><br>  .<span class="hljs-title function_">draw</span>(); <span class="hljs-comment">// 然后进行绘制</span><br></code></pre></div></td></tr></table></figure><div id="stave-example0" style="border:1px solid red; max-width: 500px; background-color: white;"></div><script defer>(() => {  // 模板代码  const div = document.getElementById("stave-example0")  const context = new Renderer(div, Renderer.Backends.SVG)    .resize(500, 200)    .getContext();  // 创建 Stave，其在画布上的 x，y 轴分别偏移 10，40，长度 400  const stave = new Stave(10, 40, 400)    .addClef("treble") // 添加调号，treble 是 G 谱号    .addKeySignature('G') // 调号，G 调    .addTimeSignature("4/4") // 拍号，4/4 拍    .setContext(context) // 注入 context    .draw(); // 然后进行绘制})()</script><p>Stave 的构造器接受三个参数——x，y 轴的偏移量和长度，其中 y 轴偏移量即使设置为 0，其也不会真正地挨着顶部，这是为上加线&#x2F;间的音符预留的空间。</p><p><code>addClef</code>方法去设置谱号，可选项颇多，但常用的顶多 treble 汗 bass。</p><p><code>addTimeSignature</code>设置拍号，语法如<code>6/8</code>，表示八分音符为一拍，一小节六拍。</p><p><code>addKeySignature</code>设置调号，<strong>调号按大调来</strong>，比如 G 表示 G 大调，在 F 上有升号。</p><p>一个严重需要注意的地方是，<strong>Stave 的谱号，拍号，调号等属性，在业务逻辑上是没有影响的，只用于绘图</strong>！比如我设置拍号为四四拍，但完全可以在一个小节里塞上 10 个全音符；比如我设置谱号为低音谱号，绘制一个 C4，它仍旧会绘制在下加一线上！它们的配置都在它们自己身上，并不依赖 Stave 的配置。</p><h1 id="音符，Formatter"><a href="#音符，Formatter" class="headerlink" title="音符，Formatter"></a>音符，Formatter</h1><p>有了五线谱，该来点音符了，StaveNote 类抽象音符，使用其的方法如下：</p><div id="staveNote-example0" style="border:1px solid red; max-width: 500px; background-color: white;"></div><script defer>(() => {  // 模板代码  const div = document.getElementById("staveNote-example0")  const context = new Renderer(div, Renderer.Backends.SVG)    .resize(500, 200)    .getContext();  // 创建 Stave，其在画布上的 x，y 轴分别偏移 10，40，长度 400  const stave = new Stave(10, 40, 400)    .addClef("treble") // 添加调号，treble 是 G 谱号    .setContext(context) // 注入 context    .draw(); // 然后进行绘制  const cNote = new StaveNote({ keys: ["C/4"], duration: "2" }) // C4，2 分音符  const restNote = new StaveNote({ keys: ['B/4'],  duration: '2rdd' }) // 二分复附点休止符，B/4 用于标识休止符的位置  const cMajorTraid = new StaveNote({ keys: ['C/4', 'E/4', 'G/4'], duration: '4'}) // C 大三和弦，四分  Formatter.FormatAndDraw(context, stave, [cNote, restNote, cMajorTraid]);})()</script><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 模板代码</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;staveNote-example0&quot;</span>)<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Renderer</span>(div, <span class="hljs-title class_">Renderer</span>.<span class="hljs-property">Backends</span>.<span class="hljs-property">SVG</span>)<br>  .<span class="hljs-title function_">resize</span>(<span class="hljs-number">500</span>, <span class="hljs-number">200</span>)<br>  .<span class="hljs-title function_">getContext</span>();<br><span class="hljs-comment">// 创建 Stave，其在画布上的 x，y 轴分别偏移 10，40，长度 400</span><br><span class="hljs-keyword">const</span> stave = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stave</span>(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">400</span>)<br>  .<span class="hljs-title function_">addClef</span>(<span class="hljs-string">&quot;treble&quot;</span>) <span class="hljs-comment">// 添加调号，treble 是 G 谱号</span><br>  .<span class="hljs-title function_">setContext</span>(context) <span class="hljs-comment">// 注入 context</span><br>  .<span class="hljs-title function_">draw</span>(); <span class="hljs-comment">// 然后进行绘制</span><br><br><span class="hljs-keyword">const</span> cNote = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaveNote</span>(&#123; <span class="hljs-attr">keys</span>: [<span class="hljs-string">&quot;C/4&quot;</span>], <span class="hljs-attr">duration</span>: <span class="hljs-string">&quot;2&quot;</span> &#125;) <span class="hljs-comment">// C4，2 分音符</span><br><span class="hljs-keyword">const</span> restNote = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaveNote</span>(&#123; <span class="hljs-attr">keys</span>: [<span class="hljs-string">&#x27;B/4&#x27;</span>], <span class="hljs-attr">duration</span>: <span class="hljs-string">&#x27;2rdd&#x27;</span> &#125;) <span class="hljs-comment">// 二分复附点休止符，B/4 用于标识休止符的位置</span><br><span class="hljs-keyword">const</span> cMajorTraid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaveNote</span>(&#123; <span class="hljs-attr">keys</span>: [<span class="hljs-string">&#x27;C/4&#x27;</span>, <span class="hljs-string">&#x27;E/4&#x27;</span>, <span class="hljs-string">&#x27;G/4&#x27;</span>], <span class="hljs-attr">duration</span>: <span class="hljs-string">&#x27;4&#x27;</span>&#125;) <span class="hljs-comment">// C 大三和弦，四分</span><br><span class="hljs-title class_">Formatter</span>.<span class="hljs-title class_">FormatAndDraw</span>(context, stave, [cNote, restNote, cMajorTraid]);<br></code></pre></div></td></tr></table></figure><p>音符的构造器接受一个复杂对象，常用的或许有这些配置：keys，duration，clef，auto_stem。</p><ul><li>keys 即音符名集合，如 C&#x2F;4 代表 C4，E&#x2F;5 代表 E5；形如 G#&#x2F;4 这样带上变音符的音符也是合法的，但似乎没有效果，而变音号需要使用 Modifier 去表示；<strong>key 会决定音符的位置，即使是休止符也不例外</strong>；<strong>全休止符的位置为 D&#x2F;5，二分休止符为 B&#x2F;4，四分休止符为 B&#x2F;4</strong>。</li><li>duration 即音符时值，1 表示全音符，2 和 h（half）表示二分音符，4 和 q 表示 4 分音符，8，16，32 表示对应分数音符，加上 r 表示休止符，加上 d 表示附点，比如 2rdd 表示二分复附点休止符（<strong>附点会影响（声部的）时值的计算，但渲染上没有影响</strong>）。</li><li>clef 同 Stave 的 clef，影响音符位置，默认 clef 是 treble。</li><li>auto_stem 是布尔值，表示是否自动调整符干朝向，默认关闭。</li></ul><p>这里，输出音符使用了 Formatter 这个类的静态方法，其中参数包括 context，stave，以及要输出的 Note；能够猜测，需要 context 的原因是需要利用其方法去绘图，需要 stave 的原因是因为需要知道五线谱的位置，这样才能计算出要绘制的音符的位置。</p><h1 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h1><p>想要让 vexflow 给音符渲染升降号或附点，需要使用所谓的 Modifier，Modifier 应用在 StateNote 上，具体使用见代码和注释。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 模板代码</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;modifier-example0&quot;</span>)<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Renderer</span>(div, <span class="hljs-title class_">Renderer</span>.<span class="hljs-property">Backends</span>.<span class="hljs-property">SVG</span>).<span class="hljs-title function_">resize</span>(<span class="hljs-number">500</span>, <span class="hljs-number">200</span>).<span class="hljs-title function_">getContext</span>();<br><span class="hljs-keyword">const</span> stave = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stave</span>(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">400</span>).<span class="hljs-title function_">addClef</span>(<span class="hljs-string">&quot;treble&quot;</span>) .<span class="hljs-title function_">setContext</span>(context) .<span class="hljs-title function_">draw</span>(); <br><br><span class="hljs-keyword">const</span> notes = [<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaveNote</span>(&#123;<span class="hljs-attr">keys</span>: [<span class="hljs-string">&#x27;C#/4&#x27;</span>], <span class="hljs-attr">duration</span>: <span class="hljs-string">&#x27;4dd&#x27;</span>&#125;) <span class="hljs-comment">// 四分复附点 C#4，这里的升号和附点对渲染没有影响</span><br>    .<span class="hljs-title function_">addModifier</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Accidental</span>(<span class="hljs-string">&#x27;#&#x27;</span>)) <span class="hljs-comment">// 添加升号</span><br>    .<span class="hljs-title function_">addModifier</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dot</span>()) <span class="hljs-comment">// 添加附点</span><br>    .<span class="hljs-title function_">addModifier</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dot</span>()), <span class="hljs-comment">// 再加一个</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaveNote</span>(&#123;<span class="hljs-attr">keys</span>: [<span class="hljs-string">&#x27;D/4&#x27;</span>, <span class="hljs-string">&#x27;F#/4&#x27;</span>, <span class="hljs-string">&#x27;A/4&#x27;</span>], <span class="hljs-attr">duration</span>: <span class="hljs-string">&#x27;4&#x27;</span>&#125;) <span class="hljs-comment">// D 大三和弦，有一个 F#</span><br>    .<span class="hljs-title function_">addModifier</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Accidental</span>(<span class="hljs-string">&#x27;#&#x27;</span>), <span class="hljs-number">1</span>) <span class="hljs-comment">// 给数组中下标为 1 的音符添加升号</span><br>]<br><span class="hljs-title class_">Formatter</span>.<span class="hljs-title class_">FormatAndDraw</span>(context, stave, notes);<br></code></pre></div></td></tr></table></figure><div id="modifier-example0" style="border:1px solid red; max-width: 500px; background-color: white;"></div><script defer>(() => {  // 模板代码  const div = document.getElementById("modifier-example0")  const context = new Renderer(div, Renderer.Backends.SVG).resize(500, 200).getContext();  const stave = new Stave(10, 40, 400).addClef("treble") .setContext(context) .draw();     const notes = [    new StaveNote({keys: ['C#/4'], duration: '4dd'}) // 四分复附点 C#4，这里的升号和附点对渲染没有影响      .addModifier(new Accidental('#')) // 添加升号      .addModifier(new Dot()) // 添加附点      .addModifier(new Dot()), // 再加一个    new StaveNote({keys: ['D/4', 'F#/4', 'A/4'], duration: '4'}) // D 大三和弦，有一个 F#      .addModifier(new Accidental('#'), 1) // 给数组中下标为 1 的音符添加升号  ]  Formatter.FormatAndDraw(context, stave, notes);})()</script><hr><p>虽然并没有学到多少东西，但我发现目前的进度好像已经能满足我的需要了！这个框架显然是专注渲染的，至于渲染的东西是否正确或合法，它并不怎么关心（但至少使用声部Voice的时候它会保证时值正确）；将来若有需要的话再进一步学习（这时候估计是去专注相关样式），现在该对其进行封装了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>乐理</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五线谱练习应用开发笔记 1——需求以及技术选型</title>
    <link href="/2022/11-13staffTrainingNote_1.html"/>
    <url>/2022/11-13staffTrainingNote_1.html</url>
    
    <content type="html"><![CDATA[<p>最近写博客实在没啥动力，感觉不到必要性。最近考虑捡起吉他时，突然意识到我需要去学习识别五线谱中各音位置，音程，各种调号等，而开源的应用非常少，难以找到符合我需求的，于是就考虑自己去编写相关应用以满足我练习的需要。</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>于是首先需要确定需求：</p><ol><li>识别各个调下各个位置上的音名（虽然我的需求仅限于 G 谱号，但考虑到某种通用性，也要能够涉及到其它谱号）</li><li>识别各个调下两个音之间的音程</li><li>识别各个调下的和弦</li><li>识别调号</li><li>识别特定调号（大小调）下各个位置的唱名</li><li>……一些相关吉他的需求，但这个之后再说</li><li>对上述的各种功能，需要对任何作答都做出记录以在之后进行统计</li></ol><p>这些需求都是根据符号去获取其意义，也可能有与其相反的需求，比如根据音名，和弦名去在五线谱上标识出来，这要求需要学习（开发）对五线谱的交互，会更复杂一些。</p><p>拍号，以及时值，重复记号等符号先暂且不涉及，这些东西更适合使用 ear master 去学习。上述的内容都能够熟练后，我也能更加轻松地去使用 ear master，可以说这是预科了。</p><p>每个需求都单独分个模块是合理的，而它们都需要去先能够渲染五线谱以及音符，该功能需要首先去实现（这个使用外部框架，对相关乐理的抽象也需要围绕该框架）。</p><h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>该项目显然并不需要后端，因此是纯前端项目，其中语言 typescript，框架仍使用 react（香！），但具体使用什么 ui 框架，抑或是不使用任何 ui 框架还不确定，我还是有点想要自己大展拳脚一番的，如果不使用 ui 框架的话，一定要去使用 styled-component。</p><p>至于五线谱的渲染，使用 <a href="https://github.com/0xfe/vexflow">vexflow</a>，它的效果看起来还不错，但使用似乎比较复杂，需要专门去学习，至少把我的需求需要使用的部分都涉及到。</p><p>关于乐理库，本打算自己去实现，但发现要考虑的东西很多，没有那种精力（和能力！当前我的乐理知识也是半斤八两，虽然实现当前所需的功能还是绰绰有余就是了），考虑使用现成的库，当前考虑使用 <a href="https://github.com/tonaljs/tonal">tonal</a>。</p><p>一个需要注意的地方是，这个框架整体是命令式的，需要将其抽象为声明式的React组件，这可能需要弄点底层的玩意了。</p><p>于是，第一步是很明显的，先去学习vexflow，将其封装成为react组件（只需能够展示一行，或者一个小节五线谱即可），并为相关乐理建模，这之后才能正式开始。</p><p>fight！一切哲学家都用自己的方式去解释世界，而问题在于改变世界。</p>]]></content>
    
    
    
    <tags>
      
      <tag>饼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn Nest 1: Controller</title>
    <link href="/2022/11-02Learn-Nest-1-controller.html"/>
    <url>/2022/11-02Learn-Nest-1-controller.html</url>
    
    <content type="html"><![CDATA[<p>Nest is a framework for building efficient and scalable Nodejs server-side applications, It supports Typescript, and combines with OOP, FP and FRP paradigm. Nest is based on low-level HTTP Server framework (Express or Fastify), but provides a higher level of abstraction and many interesting features like Dependency Injection, module (for better responsibility division), controller definement (based on decorator) and etc for better biz coding.</p><p>There are several concept in Nest—Controller, Provider, Module, Middleware, Exception Filter, Pipe, Custom Decorator, Guard, Interceptor—To learn these concept (and relationships between them) is to learn Nest.</p><hr><p>Controllers are responsible for handling incoming requests and returning response to the client, just like RESTful Controller in Spring MVC. <strong>Routing</strong> mechanism will controls which controller handle which requests. Frequently each controller has multiple routes and different routes can perform different actions.</p><p><img src="https://docs.nestjs.com/assets/Controllers_1.png"></p><h1 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h1><p><code>@Controller()</code> decorator is required to define a basic controller, it can accept a optional string as prefix to group a set of related routes. We can use decorators like <code>@Get()</code>, <code>@Post()</code>(named HTTP request method decorator) to define endpoint for HTTP request, which corresponds HTTP request method and route paths, such a route path is determined by concatenating controller’s prefix and path specified in method’s decorator. method decorated by such HTTP request method decorator is called request handler.</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Post</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><br><span class="hljs-meta">@Controller</span>(<span class="hljs-string">&#x27;cats&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CatsController</span> &#123;<br>  <span class="hljs-meta">@Get</span>() <span class="hljs-comment">// mapping GET /cats</span><br>  <span class="hljs-title function_">findAll</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;This action returns all cats&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Post</span>(<span class="hljs-string">&#x27;add&#x27;</span>) <span class="hljs-comment">// mapping POST /cats/add</span><br>  <span class="hljs-title function_">addCat</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;This action add new cat&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="two-ways-to-manipulating-response"><a href="#two-ways-to-manipulating-response" class="headerlink" title="two ways to manipulating response"></a>two ways to manipulating response</h1><p>When a request is made to this endpoint(such like ‘&#x2F;cats’), Nest will route the request to the user-defined method <code>findAll()</code>. Method name is completely arbitrary.</p><p>This method will return 200 status code and the plain response <code>&#39;This action returns all cats&#39;</code>, It may seems strange from the viewpoint of low-level HTTP framework like Express. It’s because that Nest employs two different option to manipulating response: Standard (recommended) or Library-specific.</p><p>Standard approach make use of request handler’s return value. when it returns a javascript object or array, it will be automatically serialized to JSON. when it returns primitive types like string, number, boolean, Nest will send just the value. status code is always 200 and POST requests will use 201, but this behavior can be modified by <code>@HttpCode(...)</code> decorator at handler-level (i.e. method level, <code>@Controller</code> is class-level).</p><p>If request handler use either <code>@Res()</code> or <code>@Next()</code>, Library-specific option will be chosen. Library-specific option use library’s native response object to handle response, which can be injected using <code>@Res()</code> decorator (e.g. <code>findAll(@Res() response: Response)</code>). With this approach, you have the ability to use native response handling methods exposed by the object, like <code>response.status(200).send()</code>.</p><p><strong>Return value also can be either Promise or Observable</strong>, It means that Nest supports and works well with Javascript asynchronous programming model.</p><h1 id="request-object"><a href="#request-object" class="headerlink" title="request object"></a>request object</h1><p>It’s often to access request details like query param and request body, we can access the request directly by instructing Nest to inject request object using <code>@Req()</code> decorator.</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Req</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Request</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-meta">@Controller</span>(<span class="hljs-string">&#x27;cats&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CatsController</span> &#123;<br>  <span class="hljs-meta">@Get</span>()<br>  <span class="hljs-title function_">findAll</span>(<span class="hljs-meta">@Req</span>() <span class="hljs-attr">request</span>: <span class="hljs-title class_">Request</span>): <span class="hljs-built_in">object</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">query</span>: request.<span class="hljs-property">query</span>,<br>      <span class="hljs-attr">body</span>: request.<span class="hljs-property">body</span>,<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>There are several dedicating decorators to grab specific properties from request object, It should be mentioned that request body is deserialized as JSON by default, and header name is case insensitive:</p><table><thead><tr><th align="left">Decorator</th><th align="left">corresponding object&#x2F;field</th><th align="center">type</th></tr></thead><tbody><tr><td align="left"><code>@Request()</code>,<code>@Req()</code></td><td align="left"><code>req</code></td><td align="center"><code>Request</code></td></tr><tr><td align="left"><code>@Response()</code>, <code>@Res()</code></td><td align="left"><code>res</code></td><td align="center"><code>Response</code></td></tr><tr><td align="left"><code>@Nest()</code></td><td align="left"><code>next</code></td><td align="center"><code>Function</code></td></tr><tr><td align="left"><code>@Session()</code></td><td align="left"><code>req.session</code></td><td align="center"></td></tr><tr><td align="left"><code>@Param()</code></td><td align="left"><code>req.params</code></td><td align="center"><code>Record&lt;string, string&gt;</code></td></tr><tr><td align="left"><code>@Param(key: string)</code></td><td align="left"><code>req.params[key]</code></td><td align="center"><code>undefined | string</code></td></tr><tr><td align="left"><code>@Body()</code></td><td align="left"><code>req.body</code></td><td align="center"><code>object</code></td></tr><tr><td align="left"><code>@Body(key: string)</code></td><td align="left"><code>req.body[key]</code></td><td align="center"><code>unknown</code></td></tr><tr><td align="left"><code>@Query()</code></td><td align="left"><code>req.query</code></td><td align="center"><code>Record&lt;string, string | string[]&gt;</code></td></tr><tr><td align="left"><code>@Query(key: string)</code></td><td align="left"><code>req.query[key]</code></td><td align="center"><code>undefined | string | string[]</code></td></tr><tr><td align="left"><code>@Headers()</code></td><td align="left"><code>req.headers</code></td><td align="center"><code>Record&lt;string, string&gt;</code></td></tr><tr><td align="left"><code>@Headers(key: string)</code></td><td align="left"><code>req.headers</code></td><td align="center"><code>undefined | string</code></td></tr><tr><td align="left"><code>@Ip()</code></td><td align="left"><code>req.ip</code></td><td align="center"><code>string</code></td></tr><tr><td align="left"><code>@HostParam()</code></td><td align="left"><code>req.hosts</code></td><td align="center"><code>object</code></td></tr></tbody></table><p>There is a tiny example below, It should be warned that type signature of parameters of request handler makes nonsense at runtime, thus type constraint should be guaranteed by programmers themselves (But we can use <code>ValidationPipe</code> to do this declaratively):</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Body</span>, <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Param</span>, <span class="hljs-title class_">Query</span>, <span class="hljs-title class_">Req</span>, <span class="hljs-title class_">Res</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Request</span>, <span class="hljs-title class_">Response</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; z &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;zod&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AppService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.service&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Numeric</span>, <span class="hljs-title class_">ZodValidator</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./configuration/ZodValidator&#x27;</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">SomeBody</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br><br><span class="hljs-meta">@Controller</span>(<span class="hljs-string">&#x27;/learn&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppController</span> &#123;<br>  <span class="hljs-comment">// constructor injection</span><br>  <span class="hljs-comment">// can use @Inject to indicate Token</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> appService: AppService</span>) &#123;&#125;<br><br>  <span class="hljs-comment">// Get, Post, Delete...</span><br>  <span class="hljs-comment">// return primitive value</span><br>  <span class="hljs-meta">@Get</span>()<br>  <span class="hljs-title function_">getHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/hello&#x27;</span>) <span class="hljs-comment">// define subroute</span><br>  <span class="hljs-title function_">anotherHello</span>(): <span class="hljs-built_in">any</span>[] &#123;<br>    <span class="hljs-comment">// array and object return as JSON</span><br>    <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;hello&#x27;</span>];<br>  &#125;<br>  <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/req&#x27;</span>)<br>  <span class="hljs-comment">// use Req, Request to inject Request Object, use Res, Response to inject Response Object</span><br>  <span class="hljs-title function_">getReq</span>(<span class="hljs-meta">@Req</span>() <span class="hljs-attr">req</span>: <span class="hljs-title class_">Request</span>): <span class="hljs-built_in">object</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">params</span>: req.<span class="hljs-property">query</span> &#125;;<br>  &#125;<br>  <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/res&#x27;</span>)<br>  <span class="hljs-title function_">getRes</span>(<span class="hljs-meta">@Res</span>() <span class="hljs-attr">res</span>: <span class="hljs-title class_">Response</span>): <span class="hljs-built_in">string</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;send data by hand&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ss&#x27;</span>; <span class="hljs-comment">// will be ignore cause it&#x27;s library-specific option now</span><br>  &#125;<br>  <span class="hljs-comment">// other Decorator: Next, Session, Param, Body, Query, Headers, Ip...</span><br>  <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/param/:name&#x27;</span>)<br>  <span class="hljs-comment">// typesafe should be maintained by hand</span><br>  <span class="hljs-title function_">param</span>(<br>    <span class="hljs-meta">@Param</span>(<span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-attr">param</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-meta">@Query</span>() <span class="hljs-attr">allQueryParam</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[]&gt;, <span class="hljs-comment">// get All Query Param</span><br>    <span class="hljs-meta">@Query</span>(<span class="hljs-string">&#x27;param&#x27;</span>) name?: <span class="hljs-built_in">string</span>,<br>  ): <span class="hljs-built_in">object</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123; param, name, allQueryParam &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// NO TYPE VALIDATION! It will accept any JSON object</span><br>  <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/body&#x27;</span>)<br>  <span class="hljs-title function_">body</span>(<span class="hljs-params"><span class="hljs-meta">@Body</span>() body: SomeBody</span>) &#123;<br>    <span class="hljs-keyword">return</span> body;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-title class_">BodySchema</span> = z.<span class="hljs-title function_">object</span>(&#123;<br>    <span class="hljs-attr">name</span>: z.<span class="hljs-title function_">string</span>(),<br>    <span class="hljs-attr">age</span>: <span class="hljs-title class_">Numeric</span>(),<br>  &#125;);<br>  <span class="hljs-comment">// use pipe as Validation</span><br>  <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/validBody&#x27;</span>)<br>  <span class="hljs-title function_">validBody</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-meta">@Body</span>(ZodValidator(AppController.BodySchema))</span><br><span class="hljs-params">    body: z.infer&lt;<span class="hljs-keyword">typeof</span> AppController.BodySchema&gt;,</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-keyword">return</span> body;<br>  &#125;<br><br>  <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/id/:id&#x27;</span>)<br>  <span class="hljs-comment">// it will accept param like &#x27;123abc&#x27;</span><br>  <span class="hljs-title function_">paramType</span>(<span class="hljs-params"><span class="hljs-meta">@Param</span>(<span class="hljs-string">&#x27;id&#x27;</span>) id: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> id + <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// promise and rxjs is supported</span><br>  <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/async&#x27;</span>)<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">2000</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;rua&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>With the above controller fully defined, Nest still doesn’t know that CatsController exists and as a result won’t create an instance of this class. There is no such a <code>@ComponentScan</code> in Nest :).</p><p>In Nest, Controllers always belong to a module, which is included in <code>controllers</code> array within <code>@Module()</code> decorator and we should include <code>CatsController</code> in any Modules as below.</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Module</span>, <span class="hljs-title class_">NestModule</span>, <span class="hljs-title class_">MiddlewareConsumer</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CatsController</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./cats.controller&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">LoggerMiddleware</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./LoggerMiddleware&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">CatsController</span>],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CatsModule</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NestModule</span> &#123;<br>  <span class="hljs-title function_">configure</span>(<span class="hljs-params">consumer: MiddlewareConsumer</span>) &#123;<br>    consumer.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">LoggerMiddleware</span>).<span class="hljs-title function_">forRoutes</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用英语写笔记是一个尝试，最开始的时候肯定是大范围地照抄文档，但也要不断学习更多表述，并不断尝试复述，先把量堆上去。</p><ul><li>is responsible for, 负责</li></ul><p>Controller is responsible for handling incoming request and returning responses to the client.</p><ul><li>sth’s purpose is to do sth, …的用途是…</li></ul><p>A controller’s purpose is to receive specific requests for the application.</p><ul><li>The main idea of … is that …，……的用途&#x2F;意义&#x2F;特点是……</li></ul><p>The main idea of Provider is that it can be injected as a dependency.</p><ul><li>sth is required to do sth, …对…是必需的</li></ul><p><code>@Controller</code> decorator is required to define a basic controller.</p><ul><li>perform action, 执行操作</li><li>corresponds to&#x2F;with, 同…相一致</li><li>corresponding，对应的</li><li>is determined by, 由什么决定&#x2F;得出</li><li>sth specified in, 在…里给定的，同 given from&#x2F;by？</li></ul><p>Route path is determined by concatenating controller’s prefix and path specified in method’s decorator.</p><ul><li>employ, 采用（观点），对应 adopt（采用方法）？</li></ul><p>Nest will employ two different option to manipulating response.</p><ul><li>behavior，行为；feature，特性；mechanism，机制；function，功能</li><li>with this approach, 使用这种方式&#x2F;在这种情况下……</li><li>with …，随着，之后</li></ul><p>with the above controller fully defined, …</p><ul><li>as a result …，因此，thus</li><li>have the ability to，有能力做某事</li><li>instruct，命令，要求</li></ul><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><a href="https://docs.nestjs.com/controllers">https://docs.nestjs.com/controllers</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS全栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客项目开发笔记 1——技术选型</title>
    <link href="/2022/10-08blogDevNote_1.html"/>
    <url>/2022/10-08blogDevNote_1.html</url>
    
    <content type="html"><![CDATA[<p>今天解决了 mdx 的依赖问题，考虑可以正式开始设计和编写博客项目了，再次重申，写博客既是增长项目经验，也是熟悉 js 全栈，<strong>更是作为我的门面</strong>。</p><p>为了尽可能考虑到接触到 js 全栈，该项目应当<strong>从视图层到持久层均具备</strong>，也就是说需要有后端，其中应当<strong>分离业务 model 到独立项目</strong>供前后端共用。</p><p>该项目也是进行阶段性演进，首先完成带后端的博客最主要的功能，即<strong>查看文章</strong>，<strong>评论</strong>，以及<strong>文章管理</strong>的功能（需要有一个后台界面去管理乃至编写文章），然后再完成 tag，category，查询文章，统计等功能……前端考虑能支持主题的切换。</p><p>前后端均使用 typescript，前端使用 React 框架以及 charkaUI 框架，其中前后端交互使用 useHttpRequest Hook；后端使用 <strong>Nestjs</strong> 作为 web 框架，<strong>Prisma</strong> 作为 ORM 框架（之后一定有鉴权需要，考虑选择一个 OAuth2 框架）。</p><p>后端的选择有一些考量，虽然<strong>在远程工作中 express 仍旧吃香</strong>，但express实在太过底层，需要造一堆轮子，而我希望能尽快出结果，因此选择抽象程度更高的Nestjs（学习和使用 express 仍旧是必要的）；ORM 框架本打算使用 typeORM，它更轻量和容易理解，但和 typescript 的 strict 模式不兼容（！！），于是考虑直接上手最酷炫的 prisma 框架，之后对其需要专门学习。</p><p>数据库使用 mysql，之后若有需要可能再加上 redis 做缓存？</p><p>另外，该博客使用的标记语言我选择 mdx，其结合 md 和 jsx，能通过 jsx 对 md 进行扩展，但若前后端分离的话，<strong>后端的 mdx 如何获取到它依赖的组件便成为一个大问题</strong>，好在这里找到一个合适的 <a href="https://github.com/kentcdodds/mdx-bundler">项目</a> 能将 mdx 连带依赖进行打包。这虽然会增大文章的体积，但由于是后端进行编译的，因此问题并不大。但这个框架仍旧有一些问题需要研究，比如其能否获取 React 的 Context 之类的，该问题对组件的编写十分重要，如果要获取一些全局状态如是否是黑暗模式等，但这也考虑从另外的方式去操作，比如去添加事件，把相应状态维护在全局变量，通过hook的形式去提供给组件。</p><p>然后，考虑到微服务的需要，<strong>项目后端应当无状态</strong>。</p><p>因此，第一阶段的任务可以归结如下：</p><ol><li>学习 NestJs 以及最佳实践</li><li>学习 TypeORM</li><li>对 mdx，组件进行建模，实现相应 CRUD 接口以及业务操作</li><li>实现前端相应界面，其中后台界面先只考虑检查 mdx 和组件是否能正确编译，先不考虑预览等问题；其中文章页面先不考虑任何样式，实现最简单的即可。</li><li>迁移已有文章到该项目</li></ol><p>前端项目在 <a href="https://github.com/V-YOP/yuuki-blog-frontend">此</a>，后端项目在 <a href="https://github.com/V-YOP/yuuki-blog-backend">此</a>，model 项目在 <a href="https://github.com/V-YOP/yuuki-blog-interface">此</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>饼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn Zod By Examole</title>
    <link href="/2022/10-05LearnZodByExamole.html"/>
    <url>/2022/10-05LearnZodByExamole.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>WORKING…</p></blockquote><p>Zod 是 Typescript 的运行时校验库，学习其以方便类型检查，对代码的优雅以及减少样板代码是比较重要的，何况其除类型检查外还有一些更强的约束，对业务代码开发有利。</p><p>Zod 最佳的学习文档就是其官方文档，这里的笔记主要是参照 <a href="https://github.com/colinhacks/zod">官方文档</a>，但聚焦最常用的部分。</p><p>Zod 就同其他的一些类型校验库一样，通过值而非类型的形式去定义类型（且提供从这种类型定义中获取编译期类型的手段），从而将类型信息能够留到运行时以用于校验，学习的重点在于如何将 typescript 的类型定义转换成 Zod 的值定义。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;z, <span class="hljs-title class_">ZodError</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;zod&#x27;</span><br><span class="hljs-comment">// 所有 primitive 类型都有直接的值定义，这种值定义称为 schema</span><br><br><span class="hljs-comment">// primitive values</span><br>z.<span class="hljs-title function_">string</span>();<br>z.<span class="hljs-title function_">number</span>();<br>z.<span class="hljs-title function_">bigint</span>();<br>z.<span class="hljs-title function_">boolean</span>();<br>z.<span class="hljs-title function_">date</span>();<br><br><span class="hljs-comment">// empty types</span><br>z.<span class="hljs-title function_">undefined</span>();<br>z.<span class="hljs-title function_">null</span>();<br>z.<span class="hljs-title function_">void</span>(); <span class="hljs-comment">// accepts undefined</span><br><br><span class="hljs-comment">// catch-all types</span><br><span class="hljs-comment">// allows any value</span><br>z.<span class="hljs-title function_">any</span>();<br>z.<span class="hljs-title function_">unknown</span>();<br><br><span class="hljs-comment">// never type</span><br><span class="hljs-comment">// allows no values</span><br>z.<span class="hljs-title function_">never</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StringType</span> = z.<span class="hljs-title function_">string</span>()<br><span class="hljs-comment">// 使用 z.infer 类型和 typeof 去取出类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringType</span> = z.<span class="hljs-property">infer</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">StringType</span>&gt; <span class="hljs-comment">// string</span><br><br><span class="hljs-comment">// 可以使用 parse 去解析类型</span><br><span class="hljs-keyword">const</span> str : <span class="hljs-title class_">StringType</span> = <span class="hljs-title class_">StringType</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&quot;hello&quot;</span>) <span class="hljs-comment">// &quot;hello&quot;</span><br><span class="hljs-keyword">const</span> strErr : <span class="hljs-title class_">StringType</span> = <span class="hljs-title class_">StringType</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-number">12</span>) <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// parse 会解析失败会抛出异常，更函数式的方式是使用 safeParse</span><br><span class="hljs-comment">// safeParse 会返回 &#123;success: true, data: T&#125; | &#123;success: false, error: ZodError&#125;</span><br><span class="hljs-keyword">const</span> maybeRes = <span class="hljs-title class_">StringType</span>.<span class="hljs-title function_">safeParse</span>(<span class="hljs-number">12</span>)<br><span class="hljs-keyword">if</span> (maybeRes.<span class="hljs-property">success</span>) &#123;<br>    <span class="hljs-keyword">const</span> result : <span class="hljs-title class_">StringType</span> = maybeRes.<span class="hljs-property">data</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">const</span> error : <span class="hljs-title class_">ZodError</span>&lt;<span class="hljs-built_in">string</span>&gt; = maybeRes.<span class="hljs-property">error</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h1><p>仅有字面量是无法用在业务上的，各种业务模型需要简单类型的组合去描述。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 数组和 tuple 类型，使用函数调用的形式去传递类型参数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">NumberArr</span> = z.<span class="hljs-title function_">array</span>(z.<span class="hljs-title function_">number</span>()) <span class="hljs-comment">// number[]</span><br><span class="hljs-comment">// 另一种方式</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">NumberArr1</span> = z.<span class="hljs-title function_">number</span>().<span class="hljs-title function_">array</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StringNumberPair</span> = z.<span class="hljs-title function_">tuple</span>([z.<span class="hljs-title function_">string</span>(), z.<span class="hljs-title function_">number</span>()]) <span class="hljs-comment">// [string, number]</span><br><br><span class="hljs-comment">// 然后是 object，union 类型和 sum 类型，以及 record 的 schema</span><br><span class="hljs-comment">// type User = &#123;name: string, age: number&#125;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = z.<span class="hljs-title function_">object</span>(&#123;<br>    <span class="hljs-attr">name</span>: z.<span class="hljs-title function_">string</span>(),<br>    <span class="hljs-attr">age</span>: z.<span class="hljs-title function_">number</span>()<br>&#125;)  <br><br><span class="hljs-comment">// object 默认只会接受存在于 schema 中的字段</span><br><span class="hljs-comment">// 比如，对类型 &#123;name: string&#125;，如果尝试 parse &#123;name: &#x27;hello&#x27;, age: 18&#125;，只会得到&#123;name: &#x27;hello&#x27;&#125;</span><br><span class="hljs-comment">// 使用 passthrough 去获得所有值，使用 strict 去严格限制 schema，无论多了值还是少了值均抛出异常</span><br><br><span class="hljs-comment">// union 类型和 sum 类型通过链式调用的 and，or 去表达，或者使用 z.intersection，z.union</span><br><span class="hljs-comment">// type UnionType = &#123;&#125; &amp; number</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UnionType</span> = z.<span class="hljs-title function_">object</span>(&#123;&#125;).<span class="hljs-title function_">and</span>(z.<span class="hljs-title function_">number</span>())<br><br><span class="hljs-comment">// record 类型也是通过函数去传递类型参数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">NumberRecord</span> = z.<span class="hljs-title function_">record</span>(z.<span class="hljs-title function_">number</span>(), z.<span class="hljs-title function_">string</span>()) <span class="hljs-comment">// &#123; [x: number]: string &#125;</span><br><br><span class="hljs-comment">// 字面量也可以定义，通过 z.literal</span><br><span class="hljs-comment">// type SumType = &#123;success: true, code: number&#125; | &#123;success: false, error: string&#125;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">SumType</span> = z.<span class="hljs-title function_">object</span>(&#123;<br>    <span class="hljs-attr">success</span>: z.<span class="hljs-title function_">literal</span>(<span class="hljs-literal">true</span>),<br>    <span class="hljs-attr">code</span>: z.<span class="hljs-title function_">number</span>()<br>&#125;).<span class="hljs-title function_">or</span>(z.<span class="hljs-title function_">object</span>(&#123;<br>    <span class="hljs-attr">success</span>: z.<span class="hljs-title function_">literal</span>(<span class="hljs-literal">false</span>),<br>    <span class="hljs-attr">error</span>: z.<span class="hljs-title function_">string</span>()<br>&#125;))<br><br><span class="hljs-comment">// 使用 optional 来表达？，使用 nullable 表达 T | null</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ABC</span> = z.<span class="hljs-title function_">object</span>(&#123;<br>    <span class="hljs-attr">username</span>: z.<span class="hljs-title function_">string</span>(),<br>    <span class="hljs-attr">age</span>: z.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">optional</span>(), <span class="hljs-comment">// or z.optional(z.string())</span><br>    <span class="hljs-attr">clazz</span>: z.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">nullable</span>() <span class="hljs-comment">// or z.nullable(z.string())</span><br>&#125;)<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">ABC</span> = z.<span class="hljs-property">infer</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-variable constant_">ABC</span>&gt;<br><br><span class="hljs-comment">// schema 定义可以互相引用</span><br><span class="hljs-comment">// 这里引用上面定义的 User</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DB</span> = z.<span class="hljs-title function_">object</span>(&#123;<br>    <span class="hljs-attr">name</span>: z.<span class="hljs-title function_">string</span>(),<br>    <span class="hljs-attr">users</span>: z.<span class="hljs-title function_">array</span>(<span class="hljs-title class_">User</span>) <br>&#125;)<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">DB</span> = z.<span class="hljs-property">infer</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-variable constant_">DB</span>&gt; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">type DB = &#123;</span><br><span class="hljs-comment">    name: string;</span><br><span class="hljs-comment">    users: &#123;</span><br><span class="hljs-comment">        name: string;</span><br><span class="hljs-comment">        age: number;</span><br><span class="hljs-comment">    &#125;[];</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// schema 定义可以用 shape 来互相继承</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Father</span> = z.<span class="hljs-title function_">object</span>(&#123;<br>    <span class="hljs-attr">prop1</span>: z.<span class="hljs-title function_">string</span>(),<br>    <span class="hljs-attr">prop2</span>: z.<span class="hljs-title function_">number</span>()<br>&#125;)<br><span class="hljs-comment">// type Son0 = &#123; prop1: string, prop2: number, prop3: string &#125;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Son0</span> = z.<span class="hljs-title function_">object</span>(&#123; <br>    ...<span class="hljs-title class_">Father</span>.<span class="hljs-property">shape</span>,<br>    <span class="hljs-attr">prop3</span>: z.<span class="hljs-title function_">string</span>()<br>&#125;)<br><br><span class="hljs-comment">// Zod 也提供了 extend 和 merge 用来进行继承，其中 extends 接受 object 对象（同 z.object 一致），而 merge 接受 object schema</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Son1</span> = <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">extend</span>(&#123;<br>    <span class="hljs-attr">prop3</span>: z.<span class="hljs-title function_">string</span>()<br>&#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Son2</span> = <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">merge</span>(z.<span class="hljs-title function_">object</span>(&#123;<br>    <span class="hljs-attr">prop3</span>: z.<span class="hljs-title function_">string</span>()<br>&#125;))<br></code></pre></div></td></tr></table></figure><h1 id="业务校验，自定义校验"><a href="#业务校验，自定义校验" class="headerlink" title="业务校验，自定义校验"></a>业务校验，自定义校验</h1><p>对于 string，number 等类型，Zod 提供了除类型之外的其它校验。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 下列代码可以对 json 进行校验</span><br><span class="hljs-keyword">const</span> literalSchema = z.<span class="hljs-title function_">union</span>([z.<span class="hljs-title function_">string</span>(), z.<span class="hljs-title function_">number</span>(), z.<span class="hljs-title function_">boolean</span>(), z.<span class="hljs-title function_">null</span>()]);<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Literal</span> = z.<span class="hljs-property">infer</span>&lt;<span class="hljs-keyword">typeof</span> literalSchema&gt;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Json</span> = <span class="hljs-title class_">Literal</span> | &#123; [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Json</span> &#125; | <span class="hljs-title class_">Json</span>[];<br><span class="hljs-keyword">const</span> <span class="hljs-attr">jsonSchema</span>: z.<span class="hljs-property">ZodType</span>&lt;<span class="hljs-title class_">Json</span>&gt; = z.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span><br>  z.<span class="hljs-title function_">union</span>([literalSchema, z.<span class="hljs-title function_">array</span>(jsonSchema), z.<span class="hljs-title function_">record</span>(jsonSchema)])<br>)<br><br><span class="hljs-comment">// TODO 自定义校验，业务类型转换（进行校验时常用的一些转换操作，比如字符串转 number 等）</span><br><span class="hljs-comment">// string, number, 数组等都提供了细节校验</span><br><span class="hljs-comment">// refine 函数允许自定义校验</span><br><span class="hljs-comment">// transform 函数允许类型转换</span><br></code></pre></div></td></tr></table></figure><h1 id="常用类型操作符，Promise"><a href="#常用类型操作符，Promise" class="headerlink" title="常用类型操作符，Promise"></a>常用类型操作符，Promise</h1><p>TODO</p><h1 id="函数，泛型"><a href="#函数，泛型" class="headerlink" title="函数，泛型"></a>函数，泛型</h1><p>泛型类型接受类型参数变成实际类型，这本来是在编译期完成的，使用 Zod 时，这个操作通过函数定义和调用去完成。</p><p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>Typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习 C# Part 1——基础类型，控制流，函数，集合类型</title>
    <link href="/2022/09-28LearnCSharp_1.html"/>
    <url>/2022/09-28LearnCSharp_1.html</url>
    
    <content type="html"><![CDATA[<p>学一下 C#，参考 Learn X in Y minutes 的形式，后面的部分可能遥遥无期了，混个脸熟先。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 注释的形式同 Java</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">以及 Scala 等各种 C 系语言</span><br><span class="hljs-comment">文档注释形式后面另说</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 打印一行</span><br>Console.WriteLine(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br><br><span class="hljs-comment">// 基本类型包括 byte, short, int, long, double, float, decimal, bool, char</span><br><span class="hljs-comment">// 其中，除 byte 之外所有数字类型都为有符号，byte 默认无符号</span><br><span class="hljs-comment">// 因此另外提供了 sbyte，表示有符号（signed）byte</span><br><span class="hljs-comment">// 其它数字类型提供 uXXX，比如 uint，ulong，表示无符号（unsigned）类型</span><br><span class="hljs-built_in">byte</span> fooByte = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">short</span> fooShort = <span class="hljs-number">32767</span>; <span class="hljs-comment">// 2^15 - 1</span><br><span class="hljs-built_in">long</span> fooLong = <span class="hljs-number">9223372036854775807L</span>; <span class="hljs-comment">// 使用 L 后缀</span><br><br><span class="hljs-comment">// decimal 是 128 位浮点数，使用 m 后缀（就如 float 使用 f 后缀）</span><br><span class="hljs-built_in">decimal</span> fooDecimal = <span class="hljs-number">100.00000123123</span>m;<br><br><span class="hljs-built_in">bool</span> fooBool = <span class="hljs-literal">true</span>; <span class="hljs-comment">// or false</span><br><span class="hljs-built_in">char</span> a = <span class="hljs-string">&#x27;c&#x27;</span>;<br><br><span class="hljs-comment">// 数学运算如 java</span><br>Console.WriteLine(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>);<br>Console.WriteLine(<span class="hljs-number">42</span> != <span class="hljs-number">42</span>);<br>Console.WriteLine(<span class="hljs-number">3</span> / <span class="hljs-number">2</span>);<br>Console.WriteLine(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>);<br>Console.WriteLine(<span class="hljs-literal">true</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 使用 var 让编译器去推断变量类型，var 在某些时候是必须的，当类型没有名字的时候</span><br><span class="hljs-keyword">var</span> someInt = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> someString = <span class="hljs-string">&quot;rrr&quot;</span>;<br><br><span class="hljs-comment">// 字符串类型 string，同 java 的一样，string 也是引用类型，且不可变。</span><br><span class="hljs-built_in">string</span> foolString = <span class="hljs-string">&quot;hello \t world&quot;</span>;<br><span class="hljs-comment">// 多行字符串的形式，使用@前缀，内容中使用&quot;&quot;来表示&quot;</span><br><span class="hljs-built_in">string</span> multipleLineString = <span class="hljs-string">@&quot;</span><br><span class="hljs-string"># Hello</span><br><span class="hljs-string">Me: &quot;&quot;Hello&quot;&quot;!</span><br><span class="hljs-string">&quot;</span>;<br><br><span class="hljs-comment">// 字符串重载了 []，可以像 js 和 C++一样通过下标访问字符串特定索引的字符</span><br><span class="hljs-built_in">char</span> foolChar =  foolString[<span class="hljs-number">0</span>]; <span class="hljs-comment">// &#x27;h&#x27;</span><br><br><span class="hljs-comment">// 元组类型也是非常重要的，它形式和 kotlin 以及 scala 的一样，且能够进行解构</span><br><span class="hljs-keyword">var</span> (item1, item2, item3) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> somePair = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 字符串</span><br><span class="hljs-built_in">string</span> stringA = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-built_in">string</span> stringB = <span class="hljs-string">&quot;abc&quot;</span>;<br>Console.WriteLine(stringA == stringB); <span class="hljs-comment">// True,</span><br><span class="hljs-comment">// 注意！ ==的默认行为同 Java，但是可以被重载！</span><br><br><span class="hljs-comment">// 字符串的比较使用 string.Compare（一个静态方法）</span><br><span class="hljs-built_in">string</span>.Compare(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;HELLO&quot;</span>, StringComparison.OrdinalIgnoreCase);<br><br><span class="hljs-comment">// 格式化</span><br><span class="hljs-built_in">string</span> helloStr = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;Hello, &#123;0&#125;&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>); <br><span class="hljs-comment">// 但既然有模板字符串，还用啥格式化呢？</span><br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Yuuki&quot;</span>;<br><span class="hljs-built_in">string</span> helloStr1 = <span class="hljs-string">$&quot;Hello, $<span class="hljs-subst">&#123;name&#125;</span>&quot;</span>;<br><span class="hljs-comment">// 日期以及格式化</span><br>DateTime fooDate = DateTime.Now;<br>Console.WriteLine(fooDate.ToString(<span class="hljs-string">&quot;hh:mm, dd MMM yyyy&quot;</span>));<br><br><span class="hljs-comment">// 控制结构，如 if，for，while，do-while，switch 语法同 java 一致</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">42</span> == <span class="hljs-number">42</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;correct!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;never!&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i++ &lt; <span class="hljs-number">10</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;rrr&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;rrr&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 高阶 for 循环有单独的关键字 foreach</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> elem <span class="hljs-keyword">in</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;) <span class="hljs-comment">// 数组字面量，这里的类型 int 可以省去，编译器可以推断</span><br>&#123;<br>    Console.WriteLine(elem);<br>&#125;<br><br><span class="hljs-comment">// 类型转换方法在 Convert 类，以及各个基本类型的方法中</span><br>Console.WriteLine(<span class="hljs-built_in">int</span>.Parse(<span class="hljs-string">&quot;123&quot;</span>));<br>Console.WriteLine(Convert.ToInt32(<span class="hljs-string">&quot;123&quot;</span>));<br></code></pre></div></td></tr></table></figure><h1 id="函数定义，Lambda，柯里化"><a href="#函数定义，Lambda，柯里化" class="headerlink" title="函数定义，Lambda，柯里化"></a>函数定义，Lambda，柯里化</h1><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 函数定义，语法同 Java，注意首字母大写（方法也如此），且花括号换行</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Hello</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>&#123;<br>    Console.Write(<span class="hljs-string">&quot;Hello, &#123;0&#125;&quot;</span>, name); <span class="hljs-comment">// printf</span><br>&#125;<br>Hello(<span class="hljs-string">&quot;Yuuki&quot;</span>); <span class="hljs-comment">// 函数调用</span><br><br><span class="hljs-comment">// 默认值参数，和不定参数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">someFn</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age = <span class="hljs-number">18</span>, <span class="hljs-keyword">params</span> <span class="hljs-built_in">string</span>[] otherParams</span>)</span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manyArgFn</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> clazz = <span class="hljs-string">&quot;765&quot;</span>, <span class="hljs-built_in">string</span> description = <span class="hljs-string">&quot;&quot;</span></span>)</span> &#123;&#125;<br><br><span class="hljs-comment">// 调用时通过名称来传递参数以跳过默认值参数</span><br>manyArgFn(<span class="hljs-string">&quot;haruka&quot;</span>, <span class="hljs-number">18</span>, description: <span class="hljs-string">&quot;TOP IDOL!&quot;</span>);<br><br><span class="hljs-comment">// 函数的参数还能够使用 ref 和 out 去修饰</span><br><span class="hljs-comment">// ref 表示传递引用（就如 c++的&amp;）</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> n</span>)</span><br>&#123;<br>    n = n + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>inc(<span class="hljs-keyword">ref</span> i); <span class="hljs-comment">// 调用时必须给定 ref 关键字表示传递引用</span><br>Console.WriteLine(i); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// out 关键字可以认为是一个只写的引用，用来传递函数调用的结果到一个变量中</span><br><span class="hljs-comment">// C#提供的一些类型转换操作使用的就是这种方式，如 int.TryParse，这应该是 C#没有元组的时代返回多个值的处理方式</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TryParseInt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> result</span>)</span><br>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> i1 = <span class="hljs-built_in">int</span>.Parse(str);<br>        result = i1;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception e)<br>    &#123;<br>        result = <span class="hljs-built_in">int</span>.MinValue;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> result;<br>TryParseInt(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-keyword">out</span> result);<br>Console.WriteLine(result);<br><br><span class="hljs-comment">// 也可以即席定义 out 输出的变量……WTF？</span><br>TryParseInt(<span class="hljs-string">&quot;234&quot;</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> result1);<br>Console.WriteLine(result1);<br><br><span class="hljs-comment">// 函数类型如 Java 的函数式接口，这里用了泛型语法，和 Java 的一致</span><br><span class="hljs-comment">// int =&gt; int，或者说 Function&lt;Integer, Integer&gt;</span><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; doubleFn = n =&gt; &#123; <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>; &#125;; <span class="hljs-comment">// 或者 n =&gt; n * 2</span><br><br><span class="hljs-comment">// 函数变量可以直接调用，这是重载了 () 吗？</span><br>Console.WriteLine(doubleFn(<span class="hljs-number">3</span>));<br><br><span class="hljs-comment">// (int, int) =&gt; int，或者说 BiFunction&lt;Integer, Integer, Integer&gt;</span><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; plus = (x, y) =&gt; x + y;<br><br><span class="hljs-comment">// () =&gt; int, 或者说 Supplier&lt;Integer&gt;</span><br>Func&lt;<span class="hljs-built_in">int</span>&gt; supplier = () =&gt; <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">// int =&gt; void, 或者说 Consumer&lt;Integer&gt;</span><br>Action&lt;<span class="hljs-built_in">int</span>&gt; consumer = (<span class="hljs-built_in">int</span> n) =&gt; Console.Write(<span class="hljs-string">&quot;me a &#123;0&#125;&quot;</span>, n);<br><br><span class="hljs-comment">// 方法引用，直接取名字即可</span><br>Action&lt;<span class="hljs-built_in">string</span>&gt; print = Console.Write;<br><br><span class="hljs-comment">// 函数的参数是逆变的，返回值是协变的，这是说——</span><br><span class="hljs-comment">// 考虑一个函数 object =&gt; string</span><br>Func&lt;<span class="hljs-built_in">object</span>, <span class="hljs-built_in">string</span>&gt; fn0 = obj =&gt; <span class="hljs-string">&quot;42&quot;</span>;<br><br><span class="hljs-comment">// 因为参数是逆变的，且 string 是 object 的子类型，因此 object =&gt; string 是 string =&gt; string 的子类型</span><br><span class="hljs-comment">// 因此，可以把 object =&gt; string 对象赋值给 string =&gt; string 类型变量：</span><br>Func&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; fn1 = fn0;<br><br><span class="hljs-comment">// 因为返回值是协变的，且 string 是 object 的子类型，因此 object =&gt; string 是 object =&gt; object 的子类型</span><br><span class="hljs-comment">// 因此，可以把 object =&gt; string 对象赋值给 object =&gt; object 类型变量：</span><br>Func&lt;<span class="hljs-built_in">object</span>, <span class="hljs-built_in">object</span>&gt; fn2 = fn0;<br><br><span class="hljs-comment">// 简单来说，入参可以更狭窄，返回值可以更广泛：</span><br>Func&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">object</span>&gt; fn3 = fn0;<br><br><span class="hljs-comment">// 闭包没有任何限制：</span><br>Func&lt;Func&lt;<span class="hljs-built_in">int</span>&gt;&gt; Counter = () =&gt;<br>&#123;<br>    <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> () =&gt; count++;<br>&#125;;<br><span class="hljs-keyword">var</span> fooCounter = Counter();<br>Console.WriteLine(fooCounter());<br><br><span class="hljs-comment">// 函数变量也可以递归，只要能够容忍警告（建议还是定义函数）</span><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; fib = <span class="hljs-literal">null</span>;<br>fib = x =&gt; x &lt;= <span class="hljs-number">1</span> ? x : fib(x - <span class="hljs-number">1</span>) + fib(x - <span class="hljs-number">2</span>);<br>Console.WriteLine(fib(<span class="hljs-number">10</span>));<br><br><span class="hljs-comment">// 柯里化形式和 Java 的一样，但调用的时候更舒服一些</span><br>Func&lt;<span class="hljs-built_in">int</span>, Func&lt;<span class="hljs-built_in">int</span>, Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;&gt;&gt; xPyPz = x =&gt; y =&gt; z =&gt; x + y + z;<br>Console.WriteLine(xPyPz(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>));<br></code></pre></div></td></tr></table></figure><h1 id="集合类型的使用"><a href="#集合类型的使用" class="headerlink" title="集合类型的使用"></a>集合类型的使用</h1><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 数组定义和使用方式和 java 一致</span><br><br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-built_in">int</span>[] arr0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;&#125;;<br><span class="hljs-built_in">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-built_in">int</span>[] arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-built_in">string</span>[] strArr = &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-comment">// 数组是协变的，但编译器会给出警告</span><br><span class="hljs-built_in">object</span>[] objArr = strArr;<br><br><span class="hljs-comment">// 多维数组第一印象可以这么定义</span><br><span class="hljs-built_in">int</span> [][] multiDArr = &#123;<span class="hljs-keyword">new</span> []&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;, <span class="hljs-keyword">new</span> []&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;<br><br><span class="hljs-comment">// 但对于任意维度等长的多维数组，C#提供了原生的方式：</span><br><span class="hljs-built_in">int</span>[,] multiDArr1 = &#123; &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;, &#123; <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125; &#125;;<br><span class="hljs-comment">// 访问其只需要一个 []：</span><br>Console.WriteLine(multiDArr1[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 但什么年代了，谁还用数组呢？</span><br><span class="hljs-comment">// C# 也有一套完整的集合类型，其中包括带泛型和不带泛型各一套，这里只考虑带泛型的版本</span><br><br><span class="hljs-comment">// 对于列表，包括 List&lt;T&gt;（对应 Java 的 ArrayList&lt;T&gt;），Queue&lt;T&gt;，Stack&lt;T&gt;，SortedList&lt;T&gt;，LinkedList&lt;T&gt;，其均和 Java 的类似</span><br><span class="hljs-comment">// 但不像 Java，并没有像 List，Map 这样大而全的接口来作为基类</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>a.Add(<span class="hljs-number">1</span>);<br>a.Add(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> a)<br>&#123;<br>    Console.WriteLine(i);<br>&#125;<br><br><span class="hljs-comment">// 列表可以用对象初始化器语法构造，其将被编译成一连串 Add 调用（如何实现的？）</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;<br>&#123;<br>    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-comment">// 然后是 Set 和 Map，在 C#中 Set 包括 HashSet，SortedSet，Map 包括 Dictionary，SortedDictionary，容易发现和 Java 版本的对应关系</span><br><span class="hljs-comment">// 同样可以使用对象初始化器构造，其都分别调用各自的 Add 方法</span><br><span class="hljs-keyword">var</span> someSet = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">int</span>&gt;<br>&#123;<br>    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-comment">// Map 的 Add 方法有两个参数 key 和 value，使用数组的形式去包裹</span><br><span class="hljs-keyword">var</span> someMap = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;<br>&#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>&#125;,<br>    &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="map-filter-reduce"><a href="#map-filter-reduce" class="headerlink" title="map-filter-reduce"></a>map-filter-reduce</h1><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// IEnumerable 接口中提供了 map-filter-reduce 等方法，使 C#对函数式编程有很舒服的支持（更酷炫的在后面）</span><br><span class="hljs-comment">// 并且，这些操作均是惰性的，也就是说其将有同 Java 的 Stream 一样的性能</span><br><span class="hljs-comment">// Map 和数组也继承了该接口</span><br><span class="hljs-keyword">var</span> lst = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;<br>&#123;<br>  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>  <br>&#125;;<br><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;<br>&#123;<br>  &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>&#125;,<br>  &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;,<br>&#125;;<br><br><span class="hljs-comment">// map 即 Select 方法，对每个元素进行同样操作</span><br><span class="hljs-keyword">var</span> lstPlus1 = lst.Select(i =&gt; i + <span class="hljs-number">1</span>).ToList(); <span class="hljs-comment">// [2, 3, 4, 5, 6]</span><br><span class="hljs-keyword">var</span> keys = map.Select(pair =&gt; <span class="hljs-comment">// [1, 2]</span><br>&#123;<br>  <span class="hljs-comment">// 解构语法！</span><br>  <span class="hljs-keyword">var</span> (key, <span class="hljs-keyword">value</span>) = pair;<br>  <span class="hljs-keyword">return</span> key;<br>&#125;).ToList();<br><br><span class="hljs-comment">// flatMap 即 SelectMany 方法，对每个元素进行同样操作得到一个集合，将所有集合展平作为结果</span><br><span class="hljs-keyword">var</span> doubleList = lst.SelectMany(i =&gt; <span class="hljs-keyword">new</span>[] &#123; i, i &#125;).ToList(); <span class="hljs-comment">//  [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]</span><br><br><span class="hljs-comment">// filter 即 Where 方法，对集合进行筛选，筛选出满足条件的新元素组成集合</span><br><span class="hljs-keyword">var</span> oddList = lst.Where(i =&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>).ToList(); <span class="hljs-comment">// [1, 3, 5]</span><br><br><span class="hljs-comment">// reduce 即 Aggregate 方法，顾名思义，将整个集合折叠成一个值，C#似乎只有左折叠</span><br><span class="hljs-keyword">var</span> lstSum = lst.Aggregate(<span class="hljs-number">0</span>, (acc, x) =&gt; acc + x); <span class="hljs-comment">// 15</span><br></code></pre></div></td></tr></table></figure><h1 id="LINQ-的使用"><a href="#LINQ-的使用" class="headerlink" title="LINQ 的使用"></a>LINQ 的使用</h1><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// LINQ，C#提供的一种类似 SQL 的对数组，数据库，以及其它种类数据进行查询的方式</span><br><span class="hljs-comment">// LINQ 其本质类似 Scala 的 for 语句，或 Haskell 的 do 语句，也就是说，它能够用来操作 Monad</span><br><span class="hljs-comment">// 这里只学习能使用 flatMap 以及 map 描述的部分</span><br><span class="hljs-keyword">var</span> nums = <span class="hljs-keyword">new</span> [] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-comment">// 基本使用类似于：</span><br>IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; someQuery0 = <br>    <span class="hljs-keyword">from</span> num <span class="hljs-keyword">in</span> nums <br>    <span class="hljs-keyword">where</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>    <span class="hljs-keyword">select</span> num + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 其对应下面语句：</span><br><span class="hljs-keyword">var</span> someQuery1 =<br>    nums.Where(num =&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">// 或者仅用一个 SelectMany 描述</span><br>        .Select(num =&gt; num + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 当然，若仅能操作单个集合，那就有点弱智了，我们可以给两个数组做个 join：</span><br><span class="hljs-keyword">var</span> nums2 = <span class="hljs-keyword">new</span>[] &#123; <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br><span class="hljs-keyword">var</span> someQuery2 =<br>    <span class="hljs-function"><span class="hljs-keyword">from</span> num1 <span class="hljs-keyword">in</span> nums</span><br><span class="hljs-function">    <span class="hljs-keyword">from</span> num2 <span class="hljs-keyword">in</span> nums2</span><br><span class="hljs-function">    <span class="hljs-title">where</span> (<span class="hljs-params">num1 + num2</span>) % 2</span> == <span class="hljs-number">0</span><br>    <span class="hljs-keyword">select</span> (num1, num2);<br><span class="hljs-comment">// 等价于：</span><br><span class="hljs-keyword">var</span> someQuery3 =<br>    nums.SelectMany(num1 =&gt;<br>        nums2.Where(num2 =&gt; (num1 + num2) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">// 或者用一个 SelectMany 描述</span><br>            .Select(num2 =&gt; (num1, num2)));<br><br><span class="hljs-comment">// 但 LINQ 的功能更多，它还有 join，order by，group by 等语法，这就无法单纯使用 flatMap 去描述了，这里先不表</span><br><span class="hljs-comment">// 但应该都可以描述成为两个/多个集合做笛卡尔积后进行各种操作</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于最近的总结和展望</title>
    <link href="/2022/09-11%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%B1%95%E6%9C%9B.html"/>
    <url>/2022/09-11%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%B1%95%E6%9C%9B.html</url>
    
    <content type="html"><![CDATA[<p>感觉最近有必要做个总结，所以来做个总结，并规划一下最后几个月的目标。以往的实践证明，我规划的目标从来没有完成过的，但仍旧有必要通过某种方式去指出一下。</p><p>回家已经三个月了，就同以往一样，是摆烂的三个月，没学什么东西，画画和吉他都三天打鱼两天晒网：</p><ol><li>关于工作，这几个月对工作已经比较熟悉了，分配的需求大都顺利完成，也有几次独自完成需求的情况了，但对项目仍旧不是太熟悉（或许之后会被调走，也不需要再熟悉了？）我倒也期待被调走，让我去专注在一个新项目上，既是磨练，也是……解脱吧，毕竟如果从头到尾都参与的话，就没有学习成本了。然后沟通能力也有提升，虽然主动发起对话仍旧非常费劲，但相较于之前还是有进步的（比在大连一年的进步都多）。</li><li>关于生活，还是比较摆烂的，一直吃外卖，闲暇时间一直是在看视频，看番，最近两三个星期开始把游戏捡起来了，但是我认为程度是适度的；运动中断了好一阵子，但最近开始捡起来了，甚至强度开始超过之前，这是个好兆头。</li><li>关于吉他，努力了一个月，学习了指板的记忆技巧，学习了一些指型，学习了一些五线谱，学习了一些乐理……但最近有摆的倾向。</li><li>关于画画，最近开始捡起来了，但发现强迫自己去画画仍旧是非常费劲的事情，很多时候宁愿盯着屏幕也不想画，这种心态显然是有很大问题的，但解决方案难找啊……</li></ol><p>然后是展望。</p><p>我一直受困于自己的领域过于单一——只会敲代码，（从就业上）具体来说只会 java 后端，会的还并不深入。考虑到最近世界形势必将发生大变动，我必须增强自己的适应力，从而让我能在这方面少一点担忧，能有更多精力放在吉他和画画上。（但这恐怕难说，我现在开始觉得，除非是进象牙塔（我好他妈想进去！），我绝对不可能完全脱离现实处境去扎在爱好中，在进行爱好活动的时候，我心里永远会蒙上一层阴霾，而这是我个人无法改变的，只能尽力去让自己去适应）。</p><p>增强适应力有两个方面，一是在工作上，提高自己的竞争力（这个词真恶心，但我不得不用！），不然在经济危机到来的时候被一脚踢开就麻了（虽然我也期待这一天）；二是尽量减少开支，我当前的开支主要来自于吃饭和房租，其他方面基本没有花销。</p><p>对于竞争力，首先是在当前的工作上，考虑去熟悉 redis，数据库事务，这两个是业务必定会接触到的，虽然当前我编写的业务还未接触到相关，但我应当去学习以避免之后踩坑。至于其它的地方，比如微服务，spring 内核啥的，真让我干这个的时候再学，我相信我的学习能力。</p><p>然后，考虑更长远，我需要扩宽自己的领域，我希望能够当一个全栈工程师，为此我当前的目标是 js 方向，为此需要熟悉前端（react 方向）html，css 的编写和最佳实践，然后是 nodejs 后端，以及它们相应的编程模式，v8 原理等。当然，我也可能会选择瞄准特定岗位会学习，这个将来再看，现在就按 js 全栈走。</p><p>这里，也考虑去手写自己的博客，既是为了实践练习的需要，也是为了能当作一张名片。为此，html 和 css 的学习必须关注，其中 html 需要学习各种标签的用法，以及 html5 的语义化标签，css 需要学习 flex 布局，常见的布局模式，动画，设计风格如 material 等。然后博客考虑去整一个 express 的后端，为此也需要进行相应学习。</p><p>学习的时候考虑多以 coursera 为平台，毕竟不能浪费我的会员，而且证书也能挂到领英上。</p><p>另外，还需要去深入学习英语，要达到能进入外企工作，或者在诸如 freelancer 等地方接单的程度，这是现在进行时，不表。最近阅读英语书籍确实更加轻松了，说明我在这方面有进步，但口语，写作仍旧是需要针对练习的。</p><p>还有一个问题就是，我这种独善其身的想法，是否是小市民阶级的做派？如果确实如此，那我真的是个混账，但正确的道路又在哪里呢？或许我现在没有勇气去直面它。</p><p>关于减少开支，考虑开始自己做饭，既是吃腻了外卖（而且这里的外卖评价普遍都有点差，我怀疑卫生问题），也是为了省钱，更是为了提高自己的生存能力（不能离开外卖就活不下去了，要为将来的形势考虑）。</p><p>兴趣方面……当前没有兴致画饼，就跟随一句话——<strong>如果不知道如何做，那就先随便找个方向，做了再说，在做的过程中，终究会越来越清楚该如何做</strong>。没有老师的情况下，走弯路是必要的，不要计较一天一周一个月的得失（一年还是要计较的！）。其中关于画画，考虑多去专注写实作品（且使用不同画法去诠释同一个素材，包括但不限于结构素描，无线条的明暗素描，cg厚涂等），这可能是进步最快的方式。</p><p>over。希望我活得能够对得起主席。</p>]]></content>
    
    
    
    <tags>
      
      <tag>饼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Typescript 中 实现 ADT（Algebra Data Types）</title>
    <link href="/2022/08-23implement-Algebra-Data-Types-in-Typescript.html"/>
    <url>/2022/08-23implement-Algebra-Data-Types-in-Typescript.html</url>
    
    <content type="html"><![CDATA[<p>Algebra Data Types，代数数据类型，是一个函数式编程中非常有趣的概念，从 java 角度来看，ADT 可以认为是一种模式，它看着<strong>就像带上数据的枚举类型</strong>，似乎平平无奇，但<strong>使用代数数据类型能让我们更好地进行类型建模</strong>，表达更多的东西并避免运行时异常（典型如空指针）。</p><h1 id="问题在哪里？"><a href="#问题在哪里？" class="headerlink" title="问题在哪里？"></a>问题在哪里？</h1><p>考虑这样的一个（简化的）场景，我们要去实现一个 TODO APP，其中每条 TODO 称为 Task，Task 有如下性质：</p><ol><li>Task 有四种状态：已完成，未完成</li><li>Task 有两种种类：某日的 Task，某日期区间的 Task（即该 Task 在某日期区间内都持续进行，比如进行三天的旅行，摸鱼一个星期……）</li></ol><p>于是，设计出数据库表后，我们编写了这样的实体（Java 语言描述）：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">TaskStatus</span> &#123;<br>    DONE, NOT_DONE<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">TaskType</span> &#123;<br>    DAY, DURATION<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br>    Integer id;<br>    TaskStatus status;<br>    TaskType type;<br>    Date taskDate; <span class="hljs-comment">// 对单日的 Task</span><br>    Date startDate; <span class="hljs-comment">// 日期区间 Task</span><br>    Date endDate; <span class="hljs-comment">// 对多日的 Task</span><br>    Date doneDate; <span class="hljs-comment">// 完成日期</span><br>    <span class="hljs-comment">// other fields and getter/setters</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>Java 开发时一般来说就是这么干的（枚举可能换成数据字典项啥的以节约空间，方便序列化），但这里有一个严重问题：</p><p><strong>一些字段和其它字段是相互关联的，并且这种关联性并未在类型定义上体现出来</strong>，比如对于 startDate 和 endDate，其显然在 type 为 DURATION 的时候才有意义即非 null；对于 taskDate，其只在 type 为 DAY 时有意义；对于 doneDate，其只在 status 为 DONE 时有意义……<strong>这种关联性必须通过文档，注释等手段去表达</strong>。</p><p>而且，要获取这些相关联的数据时，必须要先对 type 和 status 进行判断才能保证正确，但若程序员因不熟悉业务等情况忘记进行判断会如何？bug 可能就要出现了，而编译器并管不了这个。</p><h1 id="Java-中的-ADT"><a href="#Java-中的-ADT" class="headerlink" title="Java 中的 ADT"></a>Java 中的 ADT</h1><p>解决方案呢？我们可以让 Task 成为一个富血对象，严格限制访问域，在 getter，setter 中去实现约束，比如下面实现一个 startDate 的 getter：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 实际上 Optional 也是 ADT</span><br><span class="hljs-comment">// 或者在不合法的时候直接抛出异常，毕竟这属于编码错误了</span><br>Optional&lt;Date&gt; <span class="hljs-title function_">getStartDate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.type == TaskType.DURATION) <span class="hljs-keyword">return</span> Optional.empty(); <br>    <span class="hljs-keyword">return</span> Optional.of(<span class="hljs-built_in">this</span>.startDate);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这能强迫使用者去关心相关的约束，但仍旧显得很繁琐，遗憾的是在 Java 添加 sealed 关键字和模式匹配之前，将 ADT 应用在业务代码上确实没有多少合适的解决方案。</p><p>一个可能的解决方案是什么呢？我们可以把和 Task 的状态相关的字段和这个状态绑在一起，比如对于 TaskStatus 这个状态，我们可以为每个情况定义相应 Class：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 只要所有构造器都是 private，外界便无法合法地继承 TaskStatus</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskStatus</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">TaskStatus</span><span class="hljs-params">()</span>&#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskStatusDone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TaskStatus</span> &#123;<br>      Date doneDate;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskStatusNotDone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TaskStatus</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  TaskStatus status; <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>“带上数据的枚举类型”！在实际操作时，对 status 就必须使用 instanceof 去判断它的类型了，判断后进行类型强转即可获取其值。</p><p>但这里仍旧有一个问题：强转是向下转型，仍旧需要使用者去确定强转的类型，<strong>且 IDE 不一定补全正确的类型</strong>，因此有一定心智负担，且仍旧可能出错。</p><p>一个简单的优化方案是在 TaskStatus 中添加相应方法去获取数据：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskStatus</span> &#123;<br>  <span class="hljs-comment">// 也可以在这里写抽象方法，在子类去实现，可能在子类性能会好一些？</span><br>  <span class="hljs-keyword">public</span> Optional&lt;Date&gt; <span class="hljs-title function_">getDoneDate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> TaskStatusDone) &#123;<br>      <span class="hljs-keyword">return</span> Optional.of(((TaskStatusDone) <span class="hljs-built_in">this</span>).doneDate);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Optional.empty();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 Kotlin，Scala，Typescript 语言中去实现的 ADT 实际上在很大程度上和这种方法（模式）是一致的，但是搭配上这些语言的<strong>模式匹配</strong>功能（以及 sealed, case 等关键字），用起来就会顺滑无比，从而真正在工程实践中有应用价值。</p><h1 id="Typescript-中的-ADT"><a href="#Typescript-中的-ADT" class="headerlink" title="Typescript 中的 ADT"></a>Typescript 中的 ADT</h1><p>在 Typescript 中去实现 ADT 轻而易举，因为它本身就包含所谓的或（积 Product）类型 (<code>|</code>运算符），比如上面的 TaskStatus 可以直接这么表达：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 为了在运行时能够获得具体类型，必须在类型上包含特定的值即 _tag</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TaskNotDone</span> = &#123; <span class="hljs-attr">_tag</span>: <span class="hljs-string">&#x27;TaskNotDone&#x27;</span> &#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TaskDone</span> =  &#123; <span class="hljs-attr">_tag</span>: <span class="hljs-string">&#x27;TaskDone&#x27;</span>, <span class="hljs-attr">doneDate</span>: <span class="hljs-title class_">Date</span> &#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">TaskStatus</span> = <span class="hljs-title class_">TaskDone</span> | <span class="hljs-title class_">TaskNotDone</span><br><br><span class="hljs-keyword">const</span> status : <span class="hljs-title class_">TaskStatus</span> = <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">switch</span> (status.<span class="hljs-property">_tag</span>) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;TaskNotDone&#x27;</span>: <br>    <span class="hljs-comment">// 此时 status 是 TaskNotDone（编译时可知）</span><br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;TaskDone&#x27;</span>:<br>    <span class="hljs-comment">// 此时 status 是 TaskDone（编译时可知）</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Typescript 足够聪明，用户只需要对 _tag 进行判断，它就能够知晓该数据的类型究竟是 TaskDone 还是 TaskNotDone</strong>，因此我们可以用 switch 去做简单的模式匹配（并且输入 case 的时候也能得到补全！）。</p><p>React 的 Reducer 的 Action 类型也可以看作 ADT，这时它的 type 属性就代表它的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">SomeReducerAction</span> = <br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INC&#x27;</span>, <span class="hljs-attr">inc</span>: <span class="hljs-built_in">number</span> &#125; |<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;DEC&#x27;</span>, <span class="hljs-attr">dec</span>: <span class="hljs-built_in">number</span> &#125; |<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET&#x27;</span>, <span class="hljs-attr">v</span>: <span class="hljs-built_in">number</span>&#125; <span class="hljs-comment">// ...</span><br></code></pre></div></td></tr></table></figure><p>但在这里有一个问题——这样操作的话没法往 ADT 上面添加方法了，这对面向对象语言还是非常难受的，但仍旧可以解决，如下面的代码实现 Typescript 版的 Maybe：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Nothing</span> = &#123; <span class="hljs-attr">_tag</span>: <span class="hljs-string">&#x27;Nothing&#x27;</span> &#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Just</span>&lt;A&gt; = &#123; <span class="hljs-attr">_tag</span>: <span class="hljs-string">&#x27;Just&#x27;</span>, <span class="hljs-attr">value</span>: A &#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Optional</span>&lt;A&gt; = (<span class="hljs-title class_">Nothing</span> | <span class="hljs-title class_">Just</span>&lt;A&gt;) &amp; <span class="hljs-title class_">OptMethods</span>&lt;A&gt;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OptMethods</span>&lt;A&gt; &#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">isNothing</span>(): <span class="hljs-variable language_">this</span> is <span class="hljs-title class_">Nothing</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">isJust</span>(): <span class="hljs-variable language_">this</span> is <span class="hljs-title class_">Just</span>&lt;A&gt;<br>  <span class="hljs-keyword">abstract</span> map&lt;B&gt;(<span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">a: A</span>) =&gt;</span> B): <span class="hljs-title class_">Optional</span>&lt;B&gt;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">orElse</span>(<span class="hljs-attr">orElse</span>: A): A<br>  <span class="hljs-keyword">abstract</span> flatMap&lt;B&gt;(<span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">a: A</span>) =&gt;</span> <span class="hljs-title class_">Optional</span>&lt;B&gt;): <span class="hljs-title class_">Optional</span>&lt;B&gt;<br>&#125;<br><br><span class="hljs-comment">// smart constructor</span><br><span class="hljs-keyword">function</span> mkOptional&lt;A&gt;(value?: A | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>) : <span class="hljs-title class_">Optional</span>&lt;A&gt; &#123;<br>  <span class="hljs-keyword">const</span> data : <span class="hljs-title class_">Nothing</span> | <span class="hljs-title class_">Just</span>&lt;A&gt; = value ? &#123;<span class="hljs-attr">_tag</span>: <span class="hljs-string">&#x27;Just&#x27;</span>, value&#125; : &#123;<span class="hljs-attr">_tag</span>: <span class="hljs-string">&#x27;Nothing&#x27;</span>&#125;<br>  <span class="hljs-keyword">const</span> optional : <span class="hljs-title class_">Optional</span>&lt;A&gt; = &#123;<br>    ...data,<br>    <span class="hljs-title function_">isNothing</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_tag</span> === <span class="hljs-string">&#x27;Nothing&#x27;</span><br>    &#125;,<br>    <span class="hljs-title function_">isJust</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_tag</span> === <span class="hljs-string">&#x27;Just&#x27;</span><br>    &#125;,<br>    <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isJust</span>()) <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOptional</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)) <br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNothing</span>()) <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOptional</span>()<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Impossible&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">flatMap</span>(<span class="hljs-params">fn</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNothing</span>()) <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOptional</span>()<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isJust</span>()) <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Impossible&#x27;</span>)<br>    &#125;, <br>    <span class="hljs-title function_">orElse</span>(<span class="hljs-params">orElse</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNothing</span>()) <span class="hljs-keyword">return</span> orElse<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isJust</span>()) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Impossible&#x27;</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> optional<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title class_">Just</span>&lt;A&gt;(<span class="hljs-attr">value</span>: A): <span class="hljs-title class_">Optional</span>&lt;A&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOptional</span>(value)<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title class_">Nothing</span>&lt;A&gt;(): <span class="hljs-title class_">Optional</span>&lt;A&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOptional</span>()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这就舒爽啦！</p><blockquote><p>tips: Haskell 的 ADT 类型定义类似<code>data Maybe a = Nothing | Just a</code>，其中 Maybe 称为<strong>类型构造器</strong>，Nothing 和 Just 对应<strong>值构造器</strong>，Maybe 对应这里的 Optional 类型，Nothing 和 Just 对应两个同名函数</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.susanpotter.net/software/algebraic-data-types-in-typescript/">Algebraic Data Types in TypeScript</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
      <tag>Typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始使用 webpack 搭建 typescript + react 项目</title>
    <link href="/2022/08-19%E4%BD%BF%E7%94%A8webpack%E6%90%AD%E5%BB%BAtypescript-react%E9%A1%B9%E7%9B%AE.html"/>
    <url>/2022/08-19%E4%BD%BF%E7%94%A8webpack%E6%90%AD%E5%BB%BAtypescript-react%E9%A1%B9%E7%9B%AE.html</url>
    
    <content type="html"><![CDATA[<p>为了熟悉 webpack 相关工具链，考虑跟随官方文档，从零开始去创建一个 typescript + react 的项目以作为实践，其中尽量为所有配置项的配置和意义都给予描述，专注所以然而非其然。这里想达到下面的目标：</p><ul><li>最少的配置项，所有配置项都明确描述，尽量依赖默认配置项</li><li>支持 typescript，tsx，集成 react</li><li>提供和 create-react-app 一样的体验</li></ul><h1 id="啥是-webpack"><a href="#啥是-webpack" class="headerlink" title="啥是 webpack"></a>啥是 webpack</h1><p>简单来说，webpack 是一个<strong>静态</strong>的打包器，webpack 从特定的 js 文件（称为 <strong>entry</strong>）开始去构建对应的<strong>依赖树</strong>，其中包括该 js 文件依赖（import）的文本，css，其它 js 文件等，每个依赖树或 entry 都会打成一个包 <strong>bundle</strong>，也称为 chunk。</p><p>每个可以 import 的文件称为 module。</p><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p>首先创建一个新文件，执行<code>npm init</code>，一路 Enter，创建一个默认的 package.json 文件，然后安装相应依赖。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">npm i -D webpack webpack-cli ts-loader css-loader style-loader ts-node typescript mini-css-extract-plugin html-webpack-plugin @types/node @types/react @types/react-dom @types/webpack  <br>npm i -S react react-dom react-scripts<br></code></pre></div></td></tr></table></figure><p>编辑 package.json，移除 main 属性，添加 private 属性为 true。</p><p>然后初始化 tscconfig.json：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">npx tsc -init<br></code></pre></div></td></tr></table></figure><h1 id="first-step"><a href="#first-step" class="headerlink" title="first step"></a>first step</h1><p>先研究一下 webpack 的基础用法，考虑创建文件夹 src，创建两个 js 文件 index.js，Util.js：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Util.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">x, y</span>) =&gt; x + y<br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-comment">// 使用 import 去引入依赖</span><br><span class="hljs-keyword">import</span> &#123;add&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Util&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br></code></pre></div></td></tr></table></figure><p>这时的项目结构：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">dir<br>  <span class="hljs-string">|- package.json</span><br>  <span class="hljs-string">|- package-lock.json</span><br>  <span class="hljs-string">|- /src</span><br>    <span class="hljs-string">|- index.js</span><br>    <span class="hljs-string">|- Util.js</span><br></code></pre></div></td></tr></table></figure><p>然后执行<code>npx webpack</code>命令，能够发现它生成了<code>dist/main.js</code>，其中内容为：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-string">&quot;use strict&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)&#125;)();<br></code></pre></div></td></tr></table></figure><p>显然，webpack 将 index.js 和 Util.js 打包成了 main.js 文件，这就是 webpack 的默认行为——以<code>src/index.js</code>为 entry，输出到<code>dist/main.js</code>。因为 index.js 引入了 Util.js，因此 Util.js 被一并打包（并进行了优化）。这时候我们就可以在 dist 目录下添加 index.html 并引入 main.js 以查看效果。</p><p>但对其它文件呢？比如 jsx 文件？考虑编写一个简单的 jsx 文件并将其 import：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Hello.jsx</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello, Happy World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Hello&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Hello</span>())<br><br></code></pre></div></td></tr></table></figure><p>再执行<code>npx webpack</code>，webpack 会试图找 js，json，wasm 后缀的 Hello 文件，找不到后抱怨<code>Field &#39;browser&#39; doesn&#39;t contain a valid alias configuration</code>，这是 webpack 的默认配置，而这里显然需要自定义配置。</p><h1 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h1><p>在项目根目录（package.json 同级目录）下创建文件 webpack.config.ts（也可以是 js，但这里利用上 ts 的类型机制；<strong>webpack 默认不支持 ts，需要安装 ts-loader，ts-node 依赖</strong>），这个文件将是 webpack 的配置文件。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Configuration</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;webpack&#x27;</span><br><br><span class="hljs-comment">// 添加 devServer 相关类型定义，没有这个 Configuration 中就没有 devServer 配置项了</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;webpack-dev-server&#x27;</span>;<br><br><span class="hljs-comment">// Configuration 是 Webpack 的配置项类型</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">conf</span>: <span class="hljs-title class_">Configuration</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>, <span class="hljs-comment">// 默认为 production 模式</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.ts&#x27;</span>, <span class="hljs-comment">// 入口 js 文件，可以配置多个 entry</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>), <span class="hljs-comment">// 输出路径</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;main.js&#x27;</span>, <span class="hljs-comment">// 输出文件名，具有一定动态性，如可配置成 [name].[chunkhash].js，其会被替换为名称和一个文件哈希值（以保证浏览器会重新加载，但这需要相关 plugin 去支持，后面再详述）</span><br>  &#125;,<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-comment">// webpack 将识别这些后缀文件为 module</span><br>    <span class="hljs-comment">// 这个配置是覆盖原配置的，因此应当给定所有后缀，否则使用第三方库时必然会出问题</span><br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.wasm&quot;</span>, <span class="hljs-string">&quot;.ts&quot;</span>, <span class="hljs-string">&quot;.tsx&quot;</span>, <span class="hljs-string">&quot;.mjs&quot;</span>, <span class="hljs-string">&quot;.cjs&quot;</span>, <span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>] <br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123; <span class="hljs-comment">// 关于 module 的配置</span><br>    <span class="hljs-comment">// 在这里配置 loader</span><br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> conf<br></code></pre></div></td></tr></table></figure><h1 id="配置-ts-支持"><a href="#配置-ts-支持" class="headerlink" title="配置 ts 支持"></a>配置 ts 支持</h1><p>webpack 加载文件是通过 loader 去进行的，特定的 loader 加载特定类型的文件（毕竟要能够打包到 js 文件中，因此必须要将这些文件变成 js 代码格式），比如 raw-loader 加载文本文件，ts-loader 加载 typescript 文件……</p><p>在配置中的 module.rule 项便可以配置 loader 以及相应的后缀，这里配置 tsx 和 ts：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">module</span>: &#123; <span class="hljs-comment">// 关于 module 的配置</span><br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.tsx?$/</span>, <span class="hljs-comment">// ts 或 tsx</span><br>        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;ts-loader&#x27;</span>,<br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span> <span class="hljs-comment">// 排除 node_module 下的 ts 文件</span><br>      &#125;,<br>    ]<br>  &#125;,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>配置了这项后，便可以去直接导入 ts 和 tsx 文件了，index 文件也可以改成 ts。tsx 文件需要在 tsconfig.json 中添加一项配置（毕竟 typescript 需要知道要的究竟是哪个 tsx 实现）：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;jsx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-jsx&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">/* Specify what JSX code is generated. */</span><br></code></pre></div></td></tr></table></figure><h1 id="配置-sourceMap"><a href="#配置-sourceMap" class="headerlink" title="配置 sourceMap"></a>配置 sourceMap</h1><p>如果仅做了上面的配置，当代码中出现未捕获的异常中，控制台中无法看到异常出现的位置，这在开发中是无法容忍的，这将通过配置sourceMap来解决：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;inline-source-map&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="配置绝对路径导入"><a href="#配置绝对路径导入" class="headerlink" title="配置绝对路径导入"></a>配置绝对路径导入</h1><p>使用相对路径去 import 可读性不好，且重构的时候也不方便，实现一个绝对路径的导入是比较重要的。</p><p>绝对路径的配置需要配置两个部分——webpack 和 tsconfig，前者是为了让 webpack 去确定路径，后者为了让 ts 编译器确定路径。这里我们想让<code>@</code>去代替 src 目录，因此我们可以使用形如<code>@/util</code>的形式去导入。</p><p>对于 webpack，添加 resolve.alias 配置：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;/src/&#x27;</span>) <span class="hljs-comment">// 配置@为 src 目录，使不需要每次都使用相对路径去 import</span><br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于 tsconfig，添加下面的配置：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;baseUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">/* Specify the base directory to resolve non-relative module names. */</span><br><span class="hljs-attr">&quot;paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;@/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;src/*&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>               <span class="hljs-comment">/* Specify a set of entries that re-map imports to additional lookup locations. */</span><br></code></pre></div></td></tr></table></figure><blockquote><p>这里的 baseUrl 似乎是默认配置，但不给定这个配置的话 vscode 不会补全路径</p></blockquote><p>既让 webpack 满意，也能让 tsc 满意，目的已经达到了。</p><p>需注意，<strong>tsc 编译时不会去转换 paths</strong>，因此使用 ts-node 去运行，或者使用 tsc 编译后使用 node 去运行时会报错，这在 webpack 环境下不是问题，但倘若将服务端的代码也放在这就会有问题了，解决方案是使用 <a href="https://www.npmjs.com/package/tsconfig-paths">tsconfig-paths</a>，这里先不研究这个。</p><h1 id="编写-react-示例"><a href="#编写-react-示例" class="headerlink" title="编写 react 示例"></a>编写 react 示例</h1><p>好玩的地方来了，在上面的基础上创建一个 react 示例。</p><p>首先需要在 dist 下去创建一个文件 index.html，编辑其 body，添加一个根元素并引入 main.js：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>然后编写 index.tsx 和 App.tsx：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// index.tsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/App&#x27;</span><br><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span><br>);<br><br>root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>)<br><br><span class="hljs-comment">// App.tsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Fragment</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [counter, plus] = <span class="hljs-title function_">useReducer</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello, Fucking World<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;plus&#125;</span>&gt;</span>Counter: &#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行<code>npx webpack</code>，在 dist 目录下执行<code>http-server</code>，访问<code>127.0.0.1:8080</code>，bingo！</p><p>快结束了，但这里仍有几个问题：</p><ol><li>每次修改源代码都需要重新编译，费时费力</li><li>可能有缓存问题（即 main.js 更新，但浏览器仍旧用的旧的 main.js）</li><li>css 等重要的资源未提供通过 js 的导入方式</li><li>未提供方便命令去进行编译，打包等操作</li></ol><h1 id="配置-dev-server-和-http-plugin"><a href="#配置-dev-server-和-http-plugin" class="headerlink" title="配置 dev server 和 http-plugin"></a>配置 dev server 和 http-plugin</h1><p>解决问题 1，2 需要一个合适的热更新机制，webpack 提供了相应机制，即 webpack-dev-server，其会监测源代码的改变并进行热更新。</p><p> devServer 在 webpack 配置文件中配置，只需要添加下面的配置即可：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">devServer</span>: &#123;<br>  <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">static</span>: <span class="hljs-string">&#x27;dist/&#x27;</span> <span class="hljs-comment">// devServer 将从这个位置去获取所有“静态”内容，即 html，js，css 等，这里应当修改为输出目录</span><br>&#125;,<br></code></pre></div></td></tr></table></figure><p>配置此之后，执行<code>npx webpack serve</code>便可启动 devServer。</p><p>然后是解决缓存问题，这里配置输出 bundle 文件名为<code>[name].[chunkhash].js</code>，配置一个插件 HtmlWebpackPlugin，该插件会自动生成 html 文件，其中会自动引入相应 script 标签：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">output</span>: &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[chunkhash].js&#x27;</span>,  <br>&#125;,<br><span class="hljs-attr">plugins</span>: [<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>    <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;index.html&#x27;</span>) <span class="hljs-comment">// 指定 html “模板”文件</span><br>  &#125;),<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProgressPlugin</span>() <span class="hljs-comment">// 展示进度</span><br>],<br></code></pre></div></td></tr></table></figure><p>这里因为要创建一个根 div，且保留原有的 header，因此使用一个模板 html，内容为之前的 html 移除 script 标签的内容。此时启动服务器，查看网页的 header，能看到 js 文件被自动引入了，且原有的 header，body 被保留了。</p><h1 id="导入-css-文件"><a href="#导入-css-文件" class="headerlink" title="导入 css 文件"></a>导入 css 文件</h1><p>现在我们希望能够导入 css 文件，但又不想去手动编辑 html 文件，如何去操作呢？当然仍旧是使用 loader 去实现：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">resolve</span>: &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.wasm&quot;</span>, <span class="hljs-string">&quot;.ts&quot;</span>, <span class="hljs-string">&quot;.tsx&quot;</span>, <span class="hljs-string">&quot;.mjs&quot;</span>, <span class="hljs-string">&quot;.cjs&quot;</span>, <span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span> , <span class="hljs-string">&quot;css&quot;</span>], <span class="hljs-comment">// 添加 css</span><br>&#125;,<br><span class="hljs-attr">module</span>: &#123; <span class="hljs-comment">// 关于 module 的配置</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">rules</span>: [<br>    <span class="hljs-comment">// ...</span><br>    &#123; <span class="hljs-comment">// 添加 rule</span><br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>      <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意的是，cssloader 需要两个 loader，其中执行顺序为从后到前，即先执行 css-loader，再执行 style-loader。<a href="https://webpack.js.org/loaders/css-loader/#getting-started">css-loader</a> 的作用是处理 css 文件中的 import，<a href="https://webpack.js.org/loaders/style-loader/#root">style-loader</a> 则是添加这样的 js 代码，即将 css 文件的内容在<strong>运行时</strong>添加到 header。</p><p>单这样问题就来了——css 文件全放到 js 里会大大增加 js 文件的大小，有什么方法可以规避的？可以使用 <a href="https://webpack.js.org/plugins/mini-css-extract-plugin/">MiniCssExtractPlugin</a> 这个插件使在编译时将文件复制到目标目录；配置 MiniCssExtractPlugin 需要配置 plugins 以及相应 loader：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">plugins</span>: [<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()<br>],<br><span class="hljs-attr">module</span>: &#123; <span class="hljs-comment">// 关于 module 的配置</span><br>  <span class="hljs-attr">rules</span>: [<br>    <span class="hljs-comment">// ...</span><br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>      <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="导入图片资源"><a href="#导入图片资源" class="headerlink" title="导入图片资源"></a>导入图片资源</h1><p>导入 css 很容易，但若是想导入如图片等资源呢？我们可能会在配置文件中加入相应 loader，然后这样使用图片资源：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> imageUrl <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/img/abc.png&#x27;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;imageUrl&#125;</span> /&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>但在 typescript 里，这样会有一个问题——tsc 不知道从这图片文件中究竟导出了什么玩意，这需要我们对 tsc 进行配置，方式是在源代码目录中添加一个 d.ts 文件，并进行相关定义：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// env.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.gif&#x27;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">src</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> src;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.jpg&#x27;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">src</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> src;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.jpeg&#x27;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">src</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> src;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.png&#x27;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">src</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> src;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后在配置文件中添加下面的规则，这里使用了 webpack 5 对静态资源的处理方式 <a href="https://webpack.js.org/guides/asset-modules/">asset module</a>，不需要额外的 loader，原始方法是使用 <a href="https://v4.webpack.js.org/loaders/url-loader/">url-loader</a> 或 <a href="https://v4.webpack.js.org/loaders/file-loader/">file-loader</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif)$/</span>, <span class="hljs-comment">// 图片文件按 url</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset/resource&#x27;</span> <span class="hljs-comment">// 导出 url，注意这里属性名不是 use</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>配置完毕后，typescript 就能正确识别导出的类型了。</p><h1 id="添加启动命令"><a href="#添加启动命令" class="headerlink" title="添加启动命令"></a>添加启动命令</h1><p>每次执行都输入一堆东西很麻烦？考虑在 package.json 中添加相应命令：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --mode=production --node-env=production&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;build:dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --mode=development&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;build:prod&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --mode=production --node-env=production&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;watch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --watch&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;serve&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack serve&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure><hr><p>这里只是介绍最简单的使用，各种优化，开发和生产配置分离，loader 的配置，plugin，webpack 的整个生命周期，测试……有需要再去学习。之后也考虑在这篇笔记的基础上搭建 MERN 环境。</p><p>上述代码见 <a href="/file/webpack-react-example.zip">此</a>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://marxjiao.com/2018/04/10/node-webpack/">使用 webpack 搭建基于 typescript 的 node 开发环境</a></li><li><a href="https://webpack.js.org/guides/getting-started">Webpack get started</a></li><li><a href="https://webpack.js.org/configuration/configuration-languages/#typescript">Webpack 使用 ts 配置文件</a></li><li><a href="https://webpack.js.org/guides/typescript/">Webpack Guide Typescript</a></li><li><a href="https://webpack.js.org/configuration/">Webpack Configurations</a></li><li><a href="https://stackoverflow.com/questions/55916731/using-absolute-paths-in-typescript-for-imports">Stackoverflow using absolute paths in typescript for imports</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Real World</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Fundamentals of Music Theory》 笔记 Week 2</title>
    <link href="/2022/08-17%E3%80%8AFundamentals-of-Music-Theory%E3%80%8Bnote-week-2.html"/>
    <url>/2022/08-17%E3%80%8AFundamentals-of-Music-Theory%E3%80%8Bnote-week-2.html</url>
    
    <content type="html"><![CDATA[<h1 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h1><p>调 Key 是音阶在乐曲上的<strong>应用</strong>。如果一首曲子的所有音符都在一个音阶上，则我们说这首曲子是这个音阶的调。比如，一首曲子所有音符都在 C Major Scale（这个中文怎么说？好像就叫 C 大调音阶……中文的调和音阶耦合在一起了）上，我们就称为<strong>该曲子是 C 大调</strong>。</p><p>调和音阶总是让人混淆的，调更强调音符之间的关系，而音阶有些强调顺序。并且一个调上可能有多个音阶，比如 C 大调调曲子，可以放 A 小调音阶和 C 大调音阶或五声音阶……因此主音非常重要，和弦的功能，各音的关系等随主音为转移，主音不同，关系和功能就不同，色彩就不同。</p><p>也能发现，如果一首曲子的所有音符都在 C Major Scale 上，则它同时也在 D Dorian Scale 上，E Phrygian Scale 上……这这时候曲子的调取决于主音——主音不同，则各个音之间的关系就不同，听感也会不同。</p><p>因为同一个调的升降号出现的位置是固定的，因此五线谱允许将升降号写到最前面以应用在整首乐曲的该线&#x2F;间上，这称为调号 Key Signature。调号使乐谱更容易阅读，下面两张图是 B 大调的小星星，有 5 个升号，分别为使用调号和不使用调号的版本。</p><p><img src="/../images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2/twinkle_twinkle_star_without_key_sign.png"></p><p><img src="/../images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2/twinkle_twinkle_star_with_key_sign.png"></p><p>调号让人能确定当前演奏的曲子的调，比如我们看到升号在 F 上，这曲子就有可能是 G 大调（或 E 小调或其他，因此主音也是重要的）。</p><h1 id="Circle-of-Fifths"><a href="#Circle-of-Fifths" class="headerlink" title="Circle of Fifths"></a>Circle of Fifths</h1><p>五度圈 circle of fifths 是一个非常重要的工具，我们从 C 开始，不断地递增纯五度得到的序列就是五度圈，序列如下：</p><p>C G D A E B #F #C #G #D #A F C</p><p>向上纯五度等同于向下纯四度，因此如果递增纯四度：</p><p>C F Bb Eb Ab Db Gb B E A D G C</p><p>将这个序列反转，又将得到纯五度递增的序列，和上面的序列一致，人们将此绘制成一个环状，其中顺时针为递增纯五度，逆时针为递增纯四度或递减纯五度。可以认为五度圈就是根据这个序列建立起来的：</p><p><img src="/../images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2/Circle_of_fifths.png"></p><p>五度圈有三个部分——调号，大调序列和小调序列，其中每一个调号对应大调序列和（这个大调的关系）小调序列中对应的调，比如对没有升降号的调号情况，得到 C 大调和 A 小调。容易发现小调序列只是大调序列旋转的结果，或许七个中古调式都能起一个自己的序列。</p><p>五度圈有非常多有趣的性质可供学习和应用，比如可以用来<strong>记忆音阶中各音</strong>，比如下属音和属音——下属音是主音的纯四度，因此在主音逆时针方向一格，属音是主音的纯五度，因此在主音顺时针方向一格，下面能看到 C 大调的下属音是 F，属音是 G。</p><p><img src="/../images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2/circle_C.png"></p><p>在这里，主要学习五度圈用于<strong>识别调号</strong>——对特定的调号，通过升降号的数量就能确定它的调，比如只有一个升号，则必定为 G 大调或 E 小调（或其他）。且从 C 开始顺时针或逆时针去遍历的时候，升降号数量都是递增的。</p><p>但是，在遍历时究竟在哪个音符上增加升降号？需要记住添加升降号的顺序。</p><p><strong>添加升号时，顺序是 F♯ C♯ G♯ D♯ A♯ E♯ B♯</strong>，也就是说，对 G 大调，F 为升号，对 D 大调，F，C 为升号，对 A 大调，F，C，G 为升号……就像求前缀。</p><p><strong>添加降号时，顺序是 B♭ E♭ A♭ D♭ G♭ C♭ F♭，和升号相反</strong>。</p><p>可以用一段英文去记忆：<strong>Father Charles Goes Down And Ends Battle</strong>，反之亦然，<strong>Battle Ends And Down Goes Charles Father</strong>。</p><h1 id="Harmonic-Minor-Melodic-Minor"><a href="#Harmonic-Minor-Melodic-Minor" class="headerlink" title="Harmonic Minor, Melodic Minor"></a>Harmonic Minor, Melodic Minor</h1><p>小调有多种类型，最常见的包括自然小调 Natural Minor，和声小调 Harmonic Minor，旋律小调 Melodic Minor。</p><p>其中自然小调即 Aeolian 调式，全半全全半全全。自然小调有和它共享调号的关系大调 Relative Major，每个大调也有和它共享调号的关系小调 Relative Minor。</p><p><strong>自然小调将 7 级音升高半音，便得到和声小调</strong>。这似乎称作将 7 级音<em>导音化</em>。</p><blockquote><p>为何这么做？似乎是因为原本的七级音和主音相差一个大二度，趋近感不强，因此调性中心感觉不强？，因此上升半音让它们的距离只有一个半音</p></blockquote><p>7 级音升高半音后，6 级音和 7 级音的距离又变成了增二度，这似乎会为和声等带来困扰，因此旋律小调来了，它在上行时将 6 级，7 级音都升高一个半音，但在下行时还原成自然小调。下面是一个 F♯ 旋律小调。</p><p><img src="/../images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2/Melodic_Minor_F.png"></p><p>它们的区别我真听不太出来…看更多实践吧。</p><p>和声小调和旋律小调都不属于自然音阶。</p><h1 id="Interval"><a href="#Interval" class="headerlink" title="Interval"></a>Interval</h1><p>再次弹到音程。音程不仅有 x 度之分，同一度之间也有不同特性 quality 的音程，比如对 3 度，从 C 到 E，从 D 到 F 就是两个不同的 3 度。</p><p>音程的特性有如下四种：<strong>小 Minor 音程，纯 Perfect 音程，增 Augmented 音程，减 Diminished 音程</strong>，它们之间可以增减半音去得到。</p><p><img src="/../images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2/Intervals_Quality.png"></p><p>容易发现，半音数为 1，2 时为 2 度，3，4 时为 3 度，5 为纯四度，7 为纯五度，8，9 为 6 度，10，11 为 7 度。</p><p>音程除了可以记半音数去识别，还可以通过音阶去识别，下图展示了大调音程，可以以此为基础去识别音程。</p><p><img src="/../images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2/Major_Scale_Intervals.jpg"></p><p>对于大调音阶，1 级音到 <strong>2，3，6，7 级音为大音程</strong>，<strong>1，4，5，8 为纯音程</strong>。</p><p>对于任意一个音程，我们既可以直接根据半音数去算，也可以从较低的音上构造一个大调音阶，并通过较高的音的位置以及升降号去判断。</p><p>比如，对下面的例子——</p><p><img src="/../images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_2/Interval_Test_Minor_3rd.png"></p><p>首先可以绝对地去看，即去发现它们是 E 和 G，中间夹着 3 个半音，是小三度。</p><p>也可以用这里的方法去看，首先确定度数，E，F，G，是 3 度；然后再做一个 E 大调音阶，找到前三个：1&#x3D;E 2&#x3D;F# 3&#x3D;G#，可以看到 3 度音是 G#，因此 E 到 G#是大三度，因此 E 到 G 是小三度。</p><p>使用这种方法需要记忆相应的调的大调音阶，所以或许会更麻烦。</p><h1 id="一些工具网站"><a href="#一些工具网站" class="headerlink" title="一些工具网站"></a>一些工具网站</h1><p>五度圈和音程有非常多需要记忆的玩意，需要在反复学习和实践中去掌握，这里有几个方便学习的网站。</p><ul><li><a href="https://www.musictheory.net/">musictheory.net</a>，一个交互式学习笔网站</li><li><a href="https://muted.io/">muted.io</a>，另一个交互式学习的网站，有很漂亮的界面以及图示，音频</li><li><a href="https://fretboarder.app/">Fretboarder</a>，吉他指板音阶展示</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>乐理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Fundamentals of Music Theory》 笔记 Week 1</title>
    <link href="/2022/08-13%E3%80%8AFundamentals_of_Music_Theory%E3%80%8Bnote_week_1.html"/>
    <url>/2022/08-13%E3%80%8AFundamentals_of_Music_Theory%E3%80%8Bnote_week_1.html</url>
    
    <content type="html"><![CDATA[<p>最近看 Coursera，它的模块都是按周来组织的，感觉这拿来当成笔记的粒度会很合适？试试吧。下面是 <a href="https://www.coursera.org/learn/edinburgh-music-theory">《Fundamentals of Music Theory》</a> 第一周的笔记。</p><h1 id="Musical-Notes"><a href="#Musical-Notes" class="headerlink" title="Musical Notes"></a>Musical Notes</h1><p>音乐有水平和垂直两个方向，水平方向即时间（时值），垂直方向即音高 Pitch。</p><p>音符 note 即<strong>能分辨出频率高 high，低 low</strong> 的一段声音 sound，它的“高低”即为音高，如吉他，钢琴发出的声音都是可以辨识出来，因此可以唱出来的，因此属于音符，有自己的音高，但像鼓发成的声音唱不出来（分辨不出来他究竟多高）。</p><p>我们将音符命名为 ABCDEFG，到了头后再次循环，如 CDEFGABCDEFG，<strong>这次循环的音到下次循环的同一个音中的音频率相差 2 倍</strong>，它们的距离 distance，或者说音程 interval 为<strong>纯八度 Octave</strong>，一般简称为八度。</p><p>现在最标准的记谱法是五线谱，它有五条线 Line 以及其中四个间 Space 组成，上下能有加线（Ledger Line），其在垂直方向上表示音高，水平方向上表示时间，音符可以在线上或间上，线和它相邻的间的音符相差两度 Second，vise versa。</p><p>五线谱垂直方向的音高是相对的，<strong>需要一个谱号 Clef 去确定绝对音高</strong>，最常用的是 G 谱号或高音谱号 Treble-Clef，G 谱号特点是它从下往上第二线上开始绘制，表示该线音高为 G；<strong>从下往上，五条线的音名分别是 EGBDF（Every Good Band Deserves Fans），四个间的音名分别为 FACE</strong>，能注意到 FACE 后面接的又是 EGBDF，使用此法可以推出任何位置的音高。</p><p>容易看到，相隔一个八度的两个音，必然一个在线上，一个在间上。</p><h1 id="Octave"><a href="#Octave" class="headerlink" title="Octave"></a>Octave</h1><p>钢琴的键可以按八度去分割，每个八度都包含三白键+两黑键，四白键+三黑键的一个组合，总共 12 个键，其中白键音名分别为 CDEFGAB。一个八度有 12 个键，代表一个八度有 12 个音，每个相邻的音的距离为一个半音 semitone，或 half step，两个半音名为全音 tone，或 whole step。一个八度为 12 个半音，即 6 个全音。</p><p>C 到 D，D 到 E，F 到 G，G 到 A，A 到 B 为全音，E 到 F，B 到 C 为半音。音符之间的距离（即音程）用度去表示，如 C 到 D 称为两度 Second，E 到 F 也称为两度（这也是有上下文的），C 到 E 称为三度 Third，C 到 F 称为四度 Fourth……以此类推。</p><h1 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h1><p>音阶 Scale，即<strong>跨越一个八度的一个音符序列，其中各个位置的音符的相互关系是固定的</strong>，如 CDEFGABC，CDEFGC，ABCDEFGA 等，都是合法的音阶，音阶中各个位置称为级音 Degree，使用数字或罗马数字表示。</p><p>音阶有两个属性——<strong>主音 Tonic</strong>以及<strong>调式 Mode</strong>，两者统称调性 Tonality（或者 Quality？）。</p><p>主音即音阶的出发点，调式即音阶之中各音之间的关系，只有同时确定主音以及调式，才能确定音阶中各个音的绝对音名。</p><p>比如对 C 大调（其中 C 为主音，调性为<strong>大调 Major</strong>）C Major，它为 CDEFGABC，其中各级音分别为：</p><table><thead><tr><th align="center">音级</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th></tr></thead><tbody><tr><td align="center">音名</td><td align="center">C</td><td align="center">D</td><td align="center">E</td><td align="center">F</td><td align="center">G</td><td align="center">A</td><td align="center">B</td><td align="center">C</td></tr></tbody></table><p><img src="/images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1/C_Major_Scale.png"></p><p>对 G 大调 G Major，为：</p><table><thead><tr><th align="center">音级</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th></tr></thead><tbody><tr><td align="center">音名</td><td align="center">G</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td><td align="center">E</td><td align="center">F#</td><td align="center">G</td></tr></tbody></table><p>这里的 F# 为 F 高一个半音，读作升 F F <strong>sharp</strong>（就是 C# 那个 sharp）。</p><p>能看到，C 大调和 G 大调各音之间的关系是确定的——它们的距离分别为全音，全音，半音，全音，全音，全音，半音，简称全全半全全全半 TTSTTTS，<strong>这种关系即调式</strong>。调式就像一种模式 Pattern，能从任何音出发去构造相同调式的音阶。</p><p>比如，对 F Major，得到 F G A Bb C D E F，其中 Bb 读作降 B B <strong>flat</strong>，其为 B 降一个半音。</p><p>音阶中各音的命名有下面的要求：</p><ol><li><strong>不能有重复的字母</strong>，比如 C Major，不能写作 C D E E# G A B C。</li><li>不能混用升降号，必须全为（重）升号&#x2F;降号。</li></ol><p>音阶中有多少个音，称为几声音阶。像这种由<strong>两个半音，五个全音</strong>组成的七声音阶，叫做全音阶或自然音阶 Diatonic Scale。从钢琴上任何一个白键开始的，只使用白键的，相邻的八个音组成的音阶都是自然音阶，它有<strong>七种调式</strong>，称为中古调式或教会调式 Church Mode，其中大调是第一种调式，名为 Ionian，小调 Minor（TSTTSTT）是第六种调式，名为 Aeolian。</p><p>音阶中一级音称为主音 tonic，五级音称为属音 dominant（表示占据主导地位），四级音称为下属音 subdominant。</p><p>在实际的音乐中，音阶上每个音出现的概率并非等同，主音和 5 级，4 级，7 级音是出现最多的，这就能暗示调性以及一些其他特征。</p><p>音阶帮助构建音乐。</p><h1 id="Chord"><a href="#Chord" class="headerlink" title="Chord"></a>Chord</h1><p>和弦 Chord 即同时演奏多个音，音阶同和弦密不可分。</p><p>和弦的属性同样称作 Quality。</p><p><strong>同时演奏音阶的一级，三级，五级音称为三和弦 Triad</strong>；如演奏 C 大三和弦 C Major Triad（简写 C Maj，CM），就是同时演奏 C 大调的一三五级音 CEG；A 小三和弦 A Minor Triad（简写 A minor，Am），就是同时演奏 A 小调的一级，三级，五级音。</p><p><img src="/images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1/C_Major_Triad.png" alt="C Maj"></p><p><img src="/images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1/A_Minor_Triad.png" alt="A minor"></p><p>除了从 B 到 F，<strong>其他五度音程均为 7 个半音，称为纯五度 Perfect Fifth</strong>，也就是说除了 BDF，其他<strong>三和弦一级和五级音音程都是纯五度</strong>。但所有大和弦 Major Scale，第一个音和第二个音相隔四个半音，第二个音和第三个音相隔三个半音，小和弦 Minor Scale 则相反。</p><p><strong>相隔四个半音称为大三度（Major Third），相隔三个半音称为小三度（Minor Third）</strong>。可以说大三度+小三度&#x3D;大三和弦，小三度+大三度&#x3D;小三和弦。</p><p>下面展示了从 C 大调上所有音开始的三和弦，容易看到，从 C，F，G（正巧是根音，下属音，属音）开始的三和弦为大三和弦，D，E，A 开始的三和弦为小三和弦，从 B 开始的为减三和弦 Diminished Triad，减三和弦&#x3D;小三度+小三度。</p><p><img src="/images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1/Triads_From_C_Major_Scale.png"></p><p>可以注意到，对所有五度音程，只有 BF 是减五度（或增四度，三全音），其它五度音程均为纯五度，这在推导五度圈的时候很方便——除了BF，所有音符增加一个纯五度时升降号不会改变。</p><h1 id="Primary-Chords"><a href="#Primary-Chords" class="headerlink" title="Primary Chords"></a>Primary Chords</h1><p>下面的例子应该也可以推广到其他主音，其他调式，但这超纲了，对它的抽象留待将来吧。</p><p>C 大调中所有三和弦中，C，F，G 三个大三和弦是最重要的，它们称为 Three Chord Trick（TCT，三和弦技巧？），其中 CMaj 称为<strong>主三和弦 Tonic Triad</strong>，GMaj 称为<strong>属三和弦 Dominant Triad</strong>，FMaj 称为<strong>下属三和弦 SubDominant Triad</strong>。</p><p><strong>当我们试图对一段旋律 Melody 进行和声 Harmonize 的时候，可以选择这样的和弦进行和声，即旋律中的音符在它的成员中。C 大调中每一个音符，都能使用 CMaj，FMaj，GMaj 之一去进行和声</strong>。这是一个常见的实践。</p><p><img src="/images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1/TCT_CMajor_Scale.png"></p><p>比如，当旋律音符为 C 的时候，可以选择 CMaj（CEG）或 FMaj（FAC），因为 C 为这两个和弦中的成员。当旋律音符为 D 的时候，可以选择 GMaj（GBD）去和声。<br><img src="/images/articles/%E3%80%8AFundamentals_of_Music_Theory%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1/TCT_Harmony.png"></p><p>这太酷了！</p><h1 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h1><p>时值 Duration 即音符持续的时间，这个比较熟悉，跳过了，一个重点是，相临的相同时值的音符连线 Beam 不连线，更多的是约定而非强制，按可读性和实际情况来，视频花大篇幅介绍了弱起 Pickup 或 Anacrusis，这是一种可能不连线的情况。</p><h1 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h1><ul><li><a href="https://www.earmaster.com/music-theory-online/ch04/chapter-4-6.html">泛音列 Harmonic series</a></li><li><a href="https://en.wikipedia.org/wiki/Mode_(music)">调式 Mode (music)</a></li><li><a href="http://en.wikipedia.org/wiki/Pentatonic_scale">五声音阶 Pentatonic scale</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>乐理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习 React Hooks</title>
    <link href="/2022/08-11Learn_React_Hooks.html"/>
    <url>/2022/08-11Learn_React_Hooks.html</url>
    
    <content type="html"><![CDATA[<p>React Hook 或许是 React 中最有趣的玩意了，相较于隔壁 vue 的“竞品” <a href="https://vuejs.org/api/composition-api-setup.html">setup</a>，hook 的行为和普通函数的行为非常相像（我觉得这是它最棒的一点——对函数的心智模型可以被继续沿用），且更容易学习（vue 里一万个概念能够把你绕晕十次甚至九次），更容易避免引用泄漏相关的 bug。最近进行了很多学习，是时候该进行一个笔记的做了。</p><h1 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h1><p>理解 Hook 的运行原理的关键在于：对于使用 Hook 的函数式组件，<strong>它的每一次执行都有着自己的 props 和 state，且对于每一次执行，它的 props 和 state 对这一趟而言都是常量</strong>。这意味着什么呢？这意味着我们在思考其运行机制时，可以使用所谓的代换模型——<strong>把 props 和 state 用它的值去替代</strong>。</p><blockquote><p>容易发现，这和传递值类型给函数的行为是一致的</p></blockquote><blockquote><p>代换模型实际上只对 props，state 等生效，对于 setState，useRef，dispatch 等是无效的——它们在多次执行中保持的都是同一个引用，但我认为它仍有使用的价值。</p></blockquote><p>考虑一个最经典的例子。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [counter, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setCounter</span>(counter + <span class="hljs-number">1</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(interval) <span class="hljs-comment">// 清理函数的执行时机也是一个有趣的话题</span><br>&#125;, []) <span class="hljs-comment">// 这里 eslint 会警告一波，这也证明这么写不太行</span><br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>counter: &#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>)<br></code></pre></div></td></tr></table></figure><p>会发生什么呢？其实即使没学过 hook，只要学过闭包就能得到答案了——counter 将始终为 1，这是因为对于<strong>这一趟</strong>的执行，它看到的 counter 为常量 0，我们可以用代换模型去描述：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [<span class="hljs-number">0</span>, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setCounter</span>(<span class="hljs-number">0</span> + <span class="hljs-number">1</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(interval)<br>&#125;, [])<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>counter: &#123;0&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>)<br></code></pre></div></td></tr></table></figure><p>That’s it！这个组件在之后或许还会被渲染数次（代码中没体现），但<strong>这个</strong> interval 函数看到的永远是这一趟的 counter，即 0。这个问题有数种解决方案，比如在依赖数组中加入 counter（这样 counter 每次改变时旧的 interval 会被销毁，新的计数器会被创建，看着有点怪，但确实有用），或者使用传递函数的 setState，即<code>setCounter(counter =&gt; counter + 1)</code>，也可以使用 useRef（虽然它并没意义用于此，且会引入新的复杂度，因为 useRef 的值的改变不会自动触发重渲染）。</p><p>另外，对于 useEffect，不应当考虑其为类组件生命周期的模拟，而是认为它是一种将 props 和 state 和 DOM 之外的事物进行同步的手段。下面该挨个过堂。</p><blockquote><p>setState 的函数式更新，即<code>setCounter(counter =&gt; counter + 1)</code>是同步的，这意味着可以通过某些方式把这时候的 counter 取出来，从而避免上面的问题：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> c<br><span class="hljs-title function_">setCounter</span>(<span class="hljs-function"><span class="hljs-params">counter</span> =&gt;</span> &#123;<br>  c = counter<br>  <span class="hljs-keyword">return</span> counter<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>但在实践中<strong>绝不应该</strong>使用这个操作：它是“未定义”的，在不同的版本中可能会有不同的表现，这里只是随便提一嘴。</p></blockquote><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><p>useState 即创建一个状态，它其实并没有什么可说的。下面是一个示例，这里将 useState 的第一个返回值称为 state，第二个称为 setState。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [count, setCount] = useState&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p>useState 的行为是被明确说明了的：第一次渲染时，其会被赋予初始值即 0，之后通过 setCount 去修改它的值。</p><p>这里有一个有趣的地方在于，函数式组件的每一次渲染都是一次普通的函数调用，因此这里的<code>useState&lt;number&gt;(0)</code>也只是一次普通的函数调用（其它 hook 亦然）。</p><p>既然是普通的函数调用，那它的计算模型当然和普通的函数一致——先计算参数值，再传给函数去求值，因此这里的 0 <strong>每次都会被求值</strong>。在这里这并非是个问题，但倘若求初始值是一个很昂贵的操作呢？比如从 localStorage 中取一个值？倘若仍旧按原来的写法，那每一次渲染都会去拿一次 localStorage。性能被无意义地损耗了。</p><p>React 显然知道这个问题，因此它允许通过一个函数去创建初始值，这个函数显然只会被 React 调用一次，这显然运用了惰性求值&#x2F;传名调用（call by name）——随你怎么说——的模式：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// some expensive operation</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><p>useState 另一个需要关注的地方在于，state 在每一趟调用中是不同的——每一趟渲染中看到的 state 都是这一趟看到的，而 setState 在每一趟中都是相同的，因此 setState 不需要放在 useEffect 等的依赖数组中。</p><h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><p>useEffect，给予函数式组件制造副作用的能力。</p><p>useEffect 的行为和 useState 的很类似：每一趟渲染时，这一趟的 effect 看到的是这一趟的 props 和 state，这等于是说，<strong>每次渲染都有它自己的 Effects</strong>，考虑下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count)<br>  &#125;, <span class="hljs-number">5000</span>)<br>&#125;, [])<br><br><span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setCount(count + 1)&#125;&gt;inc<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>在这 5 秒内，无论我们点击多少次按钮，最后输出的永远是 0，因为这一次 effect 的执行看到的仅是这一次的 count。</p><h2 id="同步，而非生命周期"><a href="#同步，而非生命周期" class="headerlink" title="同步，而非生命周期"></a>同步，而非生命周期</h2><p><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/#%E5%90%8C%E6%AD%A5%EF%BC%8C-%E8%80%8C%E9%9D%9E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">这篇文章的这一节《同步，而非生命周期》</a> 我认为很好地诠释了对 Effect 的心智模型：<strong>React 根据把组件当前的 props 和 state 同步给 DOM，而 Effect 则是根据 props 和 state 同步 DOM 以外的东西</strong>。在这个心智模型中，<strong>不存在所谓的生命周期</strong>，只有 props 和 state 到特定事物的一个映射，我们<strong>关注目的，而非过程</strong>。容易类比，这也是声明式编程相较于命令式编程，react 相较于 jquery 的不同：<strong>关注要做什么（目的），而非如何做（过程）</strong>。</p><p>比如，我们可以把网页的 title 和组件的一个 state 去同步：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [title, setTitle] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;你的名字&#x27;</span>)<br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = title <span class="hljs-comment">// synchronize document.title with state title</span><br>&#125;)<br><span class="hljs-comment">// ...</span><br></code></pre></div></td></tr></table></figure><p>但这种同步并非是单向的，React 也需要接受来自 DOM（以及其他地方）的事件去更新 state，Effect（以及事件处理器）有时候也是依据 DOM 之外的其它东西去修改 state，比如 HTTP 请求，下面是来自于 <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">这篇文章</a> 的一个比较复杂的例子，它通过请求来更新 state。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(&#123;&#125;);<br><span class="hljs-keyword">const</span> [query, setQuery] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;redux&#x27;</span>);<br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  (<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(<span class="hljs-string">`http://hn.algolia.com/api/v1/search?query=<span class="hljs-subst">$&#123;query&#125;</span>`</span>);<br>    <span class="hljs-title function_">setData</span>(result.<span class="hljs-property">data</span>);<br>  &#125;)()<br>&#125;, [query]);<br><span class="hljs-comment">// ...</span><br></code></pre></div></td></tr></table></figure><p>这段代码用这里的心智模型怎么理解呢？我们关注目的，所以我们说我们将这个 http 接口（以及 query 这个状态）和 data 这个 state 进行同步。</p><p>显然，这种同步和这个接口的状态以及 query 状态相关，每当 query 改变，或者接口状态改变，data 这个 state 也应当进行改变；但后者显然是 react 监视不到的，或者说，后者的变化无法触发组件的重新渲染（似乎只有 setState，setReducer 以及某些不可名状的其它情况会触发重新渲染）。</p><blockquote><p>这里会有另一个有趣的问题——从远程获取数据时，是在事件监听器去直接获取，还是去修改相应状态，在 useEffect 中去获取？显然后者是更加接近这里的心智模型的，但究竟孰优孰劣？亦或是两者都有适用场景？</p></blockquote><h2 id="关于清理函数"><a href="#关于清理函数" class="headerlink" title="关于清理函数"></a>关于清理函数</h2><p>要理解清理函数的行为，必须理解 Effect 的执行流程。Effect 在每次渲染之后执行，在这一<strong>次</strong>的 Effect 执行之前，会先执行上一<strong>次</strong> Effect 的清理函数，顺序为：</p><ol><li>渲染完成</li><li>上一次的清理函数执行</li><li>这一次的 Effect 执行</li></ol><p>这里说的是“次”而非“趟”——只有这个Effect确实执行了才算数，比如下面这个 Effect 的清理函数只在组件 unmount 时才执行</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;来了来了&quot;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;溜了溜了&quot;</span>)<br>  &#125;<br>&#125;, [])<br></code></pre></div></td></tr></table></figure><p>比如下面这个 Effect 的清理函数只在重渲染且 data 这个变量改变时才执行：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;来了来了&quot;</span>, data)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;溜了溜了&quot;</span>, data) <br>  &#125;<br>&#125;, [data])<br></code></pre></div></td></tr></table></figure><p>考虑这样一个场景，组件有一个 id prop，我们希望用这个 id 去订阅某个聊天室，每次 id 改变时，我们都希望取消<strong>之前的</strong>订阅，再订阅新的聊天室，这个怎么实现呢？这个问题来自于 <a href="https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state">React FAQ</a>，<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/#%E9%82%A3effect%E4%B8%AD%E7%9A%84%E6%B8%85%E7%90%86%E5%8F%88%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%91%A2%EF%BC%9F">这篇文章</a> 也有描述。</p><p>实际上什么都不需要做：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribe</span>(props.<span class="hljs-property">id</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribe</span>(props.<span class="hljs-property">id</span>);<br>&#125;, [props.<span class="hljs-property">userId</span>]);<br></code></pre></div></td></tr></table></figure><p>这仍旧可以用代换模型来解决，比如 id 从 10 变成 20，两次的代码是这样：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 上一次</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribe</span>(<span class="hljs-number">10</span>);<br>&#125;, [<span class="hljs-number">10</span>]);<br><br><span class="hljs-comment">// 这一次</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribe</span>(<span class="hljs-number">20</span>);<br>&#125;, [<span class="hljs-number">20</span>]);<br></code></pre></div></td></tr></table></figure><p>上一趟的清理函数看到的是上一趟的 id，这一趟看到的是这一趟的 id。</p><p>这里有另一个有趣的场景，假设在某个 Effect 里执行某个异步操作，而且这个 Effect 连续执行了两次，而且旧的请求到达的更晚……如果没有任何操作的话，则新的请求的结果会被旧的请求的结果去覆盖掉，这不是我们想要的，为此我们要么去在执行新的请求的时候销毁旧的请求，要么让它“失能”，后者的操作更加通用，可以归结为一个模式：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> ignore = <span class="hljs-literal">false</span><br>  (<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">getUser</span>(id)<br>    <span class="hljs-keyword">if</span> (ignore) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;)()<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    ignore = <span class="hljs-literal">true</span><br>  &#125;<br>&#125;, [id])<br></code></pre></div></td></tr></table></figure><p>这个 Effect 若执行了下一次，则这一次的清理函数会被调用，ignore 会设置为 true，因此这个请求的结果会被忽略。</p><h2 id="关于依赖数组"><a href="#关于依赖数组" class="headerlink" title="关于依赖数组"></a>关于依赖数组</h2><p>useEffect 以及其它 hook 的<strong>依赖数组</strong>也是非常有趣的部分，它汗 useCallback，useMemo 等都可以认为都是对上面所说的同步的<strong>优化</strong>。</p><p>依赖数组的原理十分简单——每次重新渲染的时候，React 会比较当前依赖数组中的值和上一次的值是否有修改（使用<code>Object.is</code>，行为类似<code>===</code>），若有修改才去触发 Effect。</p><p>React 的官方文档以及其它文章都会警告你，说你应当在依赖数组中包含你依赖的所有 props，state 以及其它可能会有修改的量（包括在函数组件顶级作用域中定义的变量，函数），否则这是<strong>不安全</strong>的，这在某些情景下会让人感觉很奇怪，但其实他们的意思是说，<strong>它的行为将可能会和你的预期不符</strong>。</p><p>这里相关的具体细节还是直接看相关的 <a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/#%E5%85%B3%E4%BA%8E%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%8D%E8%A6%81%E5%AF%B9react%E6%92%92%E8%B0%8E">文章</a> 更合适，但无论如何，持续维护依赖数组（并且安装 react 提供的 lint 插件）总是个好主意。</p><h1 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h1><p>倘若对一个状态的更新的逻辑依赖其他状态的值，这可能就是用 useReducer 的时候了。useReducer 以纯函数的形式统一了更新一系列状态的接口，并枚举出所有对这一系列状态所做的动作（action），以方便管理和维护复杂状态。</p><p>在 Typescript 中使用 reducer 是非常舒服的，下面是一个简单的实例，其中 Action 中的 FIELD 事件表示对特定状态进行更新，这个操作过于通用，因此不应当使用（倘若某个 reducer 提供这个 action 还能正常作用，那估计根本没必要去使用 reducer）：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">CounterState</span> = &#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">enabled</span>: <span class="hljs-built_in">boolean</span><br>&#125;<br><span class="hljs-keyword">const</span> initializeState : <span class="hljs-title class_">CounterState</span> = &#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">CounterAction</span> =<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;SET_COUNTER&quot;</span>, payload?: <span class="hljs-built_in">number</span> &#125; |<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;ENABLE_COUNTER&quot;</span> &#125; |<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;DISABLE_COUNTER&quot;</span> &#125; |<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;INC&quot;</span> &#125; |<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;FIELD&quot;</span>, <span class="hljs-attr">payload</span>: &#123; <span class="hljs-comment">// this thing is really bad!</span><br>      [k <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">CounterState</span>]?: <span class="hljs-title class_">CounterState</span>[k]<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// Reducer&lt;S, A&gt; = (prevState: S, action: A) =&gt; S</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">counterReducer</span>: <span class="hljs-title class_">Reducer</span>&lt;<span class="hljs-title class_">CounterState</span>, <span class="hljs-title class_">CounterAction</span>&gt; = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SET_COUNTER&#x27;</span>: <span class="hljs-keyword">return</span> state.<span class="hljs-property">enabled</span> ? &#123;<br>      ...state,<br>      <span class="hljs-attr">counter</span>: action.<span class="hljs-property">payload</span> ? action.<span class="hljs-property">payload</span> : <span class="hljs-number">0</span><br>    &#125; : &#123; ...state &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ENABLE_COUNTER&#x27;</span>: <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span> &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DISABLE_COUNTER&#x27;</span>: <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INC&#x27;</span>: <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span> &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FIELD&#x27;</span>: <span class="hljs-keyword">return</span> &#123; ...state, ...action.<span class="hljs-property">payload</span> &#125;<br>    <span class="hljs-attr">default</span>: <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// in component</span><br><span class="hljs-keyword">const</span> [&#123;counter, enabled&#125;, dispatch] = <span class="hljs-title function_">useReducer</span>(counterReducer, initializeState)<br><span class="hljs-title function_">dispatch</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNTER&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">42</span>&#125;)<br></code></pre></div></td></tr></table></figure><p>顺带一提，useReducer 还能这么玩：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [counter, inc] = <span class="hljs-title function_">useReducer</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p>我对 useReducer 了解不多，就这样了。十分好奇为何 useReducer 的初始化函数放到第三个参数，没有和 useState 去统一。</p><h1 id="useCallback-amp-useMemo"><a href="#useCallback-amp-useMemo" class="headerlink" title="useCallback &amp; useMemo"></a>useCallback &amp; useMemo</h1><p>有时候，组件的状态粒度过细，无法直接利用，我们就会尝试编写函数和定义变量来先进行一些操作，比如下面的实例：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [firstName, setFirstName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">const</span> [lastName, setLastName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-keyword">const</span> fullName = firstName + lastName<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getFullName</span> = (<span class="hljs-params"></span>) =&gt; firstName + lastName<br></code></pre></div></td></tr></table></figure><p>第一印象还好，但有如下几个问题：</p><ol><li>它们每次重新渲染时都会被执行，而执行过程可能是昂贵的</li><li>倘若定义的是复杂对象或者函数，则它们<strong>每次执行时都会改变</strong>（使用 Object.is 不相等），因此<strong>无法加到依赖数组中</strong></li></ol><p>为此，React 提供了 useMemo 和 useCallback 两个 hook 来解决此问题。</p><p>useMemo 的性质就像 vue 的计算属性（但是是只读的），它会缓存计算值，并只在它的依赖有改变的时候重新计算，未重新计算时，拿到的值总是同一个，即用 Object.is 能比较相等。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [firstName, setFirstName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">const</span> [lastName, setLastName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> firstName + lastName, [firstName, lastName])<br></code></pre></div></td></tr></table></figure><p>useCallback 不会缓存计算值，而是<strong>缓存计算的函数</strong>，以保证在依赖项未改变时仍旧为同一个函数，或者说<strong>使函数本身只在需要的时候才改变</strong>。若想在 Effect 中去引用定义在组件顶级作用域的函数且不违背依赖数组，必须使用 useCallback，见 <a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/#%E4%BD%86%E6%88%91%E4%B8%8D%E8%83%BD%E6%8A%8A%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%94%BE%E5%88%B0effect%E9%87%8C">这里</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchResults</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ✅ Preserves identity when its own deps are the same  </span><br>  <span class="hljs-keyword">const</span> getFetchUrl = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function"><span class="hljs-params">query</span> =&gt;</span> &#123;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query; <br>  &#125;, []);  <span class="hljs-comment">// ✅ Callback deps are OK</span><br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-title function_">getFetchUrl</span>(<span class="hljs-string">&#x27;react&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, [getFetchUrl]); <span class="hljs-comment">// ✅ Effect deps are OK</span><br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-title function_">getFetchUrl</span>(<span class="hljs-string">&#x27;redux&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, [getFetchUrl]); <span class="hljs-comment">// ✅ Effect deps are OK</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="useRef-amp-useImperactiveHandle"><a href="#useRef-amp-useImperactiveHandle" class="headerlink" title="useRef &amp; useImperactiveHandle"></a>useRef &amp; useImperactiveHandle</h1><p>ref 在 React 中有两种功能：</p><ol><li>用于操作 DOM 元素</li><li>子组件暴露给父组件操作&#x2F;值的方式，常用于自定义不受管组件时</li></ol><p>函数式组件中则有第三种功能：</p><ol start="3"><li>实现函数式组件的“实例变量”——对于每一次渲染，其值都引用同一个对象，这使历史的渲染也能够影响当前的该对象</li></ol><p>操作 DOM 是我们都比较熟悉的，想要暴露给父组件操作的话子组件需要使用 forwardRef 函数（HOC？）包装，并且使用 useImperativeHandle 去注册操作&#x2F;值，下面是一个简单的示例，子组件 Counter 暴露给父组件操作以清空它的值：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">CounterProp</span> = &#123;&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">CounterOpt</span> = &#123;<br>  <span class="hljs-title function_">inc</span>(): <span class="hljs-built_in">void</span><br>  <span class="hljs-title function_">clear</span>(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Counter</span> = forwardRef&lt;<span class="hljs-title class_">CounterOpt</span>, <span class="hljs-title class_">CounterProp</span>&gt;(<span class="hljs-function">(<span class="hljs-params">prop, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [counter, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">setCounter</span>(<span class="hljs-number">0</span>)<br>    &#125;,<br>    <span class="hljs-title function_">inc</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">setCounter</span>(counter + <span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;)) <span class="hljs-comment">// useImperativeHandle 同样有依赖数组，但懒得加</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>counter: &#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Father</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> counterRef = useRef&lt;<span class="hljs-title class_">CounterOpt</span>&gt;(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> counterRef.current?.inc()&#125;&gt;inc<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> counterRef.current?.clear()&#125;&gt;clear<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;counterRef&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://overreacted.io/a-complete-guide-to-useeffect/">A Complete Guide to useEffect（有中文，强烈推荐）</a></li><li><a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a></li><li><a href="https://www.robinwieruch.de/react-hooks-fetch-data/">How to fetch data with React Hooks</a></li><li><a href="https://blog.logrocket.com/react-usereducer-hook-ultimate-guide/">React useReducer Hook ultimate guide</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Session, JWT and OAuth2</title>
    <link href="/2022/08-05About_Session_JWT_OAuth2.html"/>
    <url>/2022/08-05About_Session_JWT_OAuth2.html</url>
    
    <content type="html"><![CDATA[<p>最近把项目部署到云函数上时，一直出现跨域问题——登陆能登上，能拿到和设置 cookie，请求的时候也能带上 cookie，可服务端就是拿不到 Cookie（已经使用了 SpringSessionJdbc 以在不同云函数实例下共享 Session）；研究发现这似乎是 Cookie 的 SameSite 属性导致的…气急败坏之下，考虑使用无状态，不依赖 Cookie 的 JWT 来进行权限认证以避免这种劳什子问题。</p><p>于是这里对 JWT 进行一些学习，以及使用其进行 web 应用权限认证的最佳实践。<del>之后将放弃 Shiro（Shiro 似乎只支持 Cookie 的方式），使用 Spring Security 来实现权限认证。</del>这里也顺便学习一下 OAuth2——OAuth2 通常会使用 JWT 或类似的技术去进行校验，之后项目也可以考虑去接入 Github 或其它 OAuth2 授权服务，方便用户登陆。</p><blockquote><p>Shiro 对 JWT 支持不好，Spring Security 过于复杂（且这种复杂度是过度的…实现最简单的满足业务需要的认证功能都需要编写一堆代码，接触一堆概念，这我还不如自己造轮子！），最终我还是选择一个国产的框架 <a href="https://sa-token.dev33.cn/">Sa-Token</a> 来实现权限功能……</p><p>其实使用这个框架的话应当能配置 Cookie，但该框架未提供和 session-jdbc 的集成，因此不考虑 Cookie 方案。</p></blockquote><hr><h1 id="Session-vs-JWT"><a href="#Session-vs-JWT" class="headerlink" title="Session vs JWT"></a>Session vs JWT</h1><p>JWT，即 JSON Web Tokens，本质上仍是一种 Token，因此先研究 Token 是必要的，而 Token 很适合同 Session 进行对比。</p><p>Session 是比较熟悉的，用户登陆时，服务端会保存用户的 Session 信息<strong>到内存</strong>中，并在 Cookie 中置一个 sessionId 作为用户的 Session 信息的 <strong>key</strong>；用户请求时，服务端再检查 sessionId，找到用户的权限信息。</p><p>Session 会有导致诸多问题：</p><ol><li>跨域问题，这不必多说，解决方案是对 Cookie 进行配置，设置 CORS 等。</li><li>分布式下 Session 共享问题，假设服务端是分布式的，则 Session 信息可能仅保存在某个服务器中，而打到其它服务器上的请求就拿不到 Session 信息了。解决方案是<strong>将 Session 集中保存在某台服务器或数据库或 redis</strong>，但<strong>这仍旧会影响服务的横向扩展</strong>。</li><li>单点登陆问题，这和第 2 点问题应当比较类似，解决方案也类似，但缺点仍类似。</li></ol><p>Session 的问题归根结底就是因为，<strong>Session 是有状态的，服务端需要维护 Session 信息</strong>。</p><blockquote><p>似乎也有客户端的 session 方案，就是让客户端持有服务端校验所需的信息，这样服务端就不需要维护 Session 状态了，只需要每次校验时比对数据库即可……但这和 token 其实很类似了。</p></blockquote><p>而 Token，<strong>Token 的服务端来说是无状态的</strong>，<strong>用户的权限信息直接保存在客户端上</strong>，且服务端能在本地（不访问数据库）对用户的权限信息进行校验。容易发现，Token 天生就是分布式的。</p><p>JWT 就是一种 Token。使用 JWT 时，在用户登陆时，用户向<strong>认证服务器</strong>发送账号密码信息后能拿到 Token，其中包括权限信息以及这些信息<strong>使用认证服务器的私钥</strong>进行的签名；用户向服务端发送请求时，服务端<strong>使用公钥</strong>解密签名并对权限信息进行验证。</p><p>Token 有诸多好处：</p><ol><li>对数据库无压力，服务端进行权限信息的认证，获取用户权限时不需要访问数据库，在本地即可完成，且由于权限信息带上了签名，也能防止伪造权限。</li><li>认证和校验分离，认证服务器可以独立出来甚至让相应服务商负责，服务端只需拿到公钥即可，且由于该公钥只用于验签，被恶意者拿到公钥也不会有任何影响。</li><li>分布式友好，每台持有公钥的服务器都能独立进行权限校验，不需要依赖第三方服务，因此横向扩展没有任何影响。</li><li>跨平台，不是所有平台都能使用 Cookie，而使用 Token 则简单许多</li><li>无痛实现单点登录</li></ol><p>同样的，Token 也会有一些缺点：</p><ol><li>无法直接实现登出功能，因为权限信息在客户端而非服务端，但是有一些解决方案。</li><li>JWT 的 Token 的信息是可以直接读出来的，无法（也不应该）存储敏感数据</li><li>权限更新会有延迟——需在旧的 token 过期时才能使用新的权限</li></ol><p>这些问题都需要相应的解决方式。</p><h1 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h1><p>一言以蔽之，OAuth2 是一种授权协议&#x2F;框架，它允许网页或应用代表用户去访问保存在其它应用上的资源。</p><p>OAuth2 中有 4 个角色，其中的 Resource，资源可以认为指用户信息：</p><ul><li>Resource Owner，资源持有者，可以认为是<strong>用户</strong>本身——用户是资源的拥有者；用户授权应用去访问他们的账户。</li><li>Client，很让人混淆，但这里指的是要访问用户信息的<strong>应用</strong>，应用需要在用户的授权下才能去访问用户信息，这个授权会被（资源服务器的？）API 所校验</li><li>Resource Server，资源服务器，持有资源即用户信息的服务器</li><li>Authorization Server，授权服务器，验证用户身份并向应用返回令牌，<strong>应用使用此令牌访问 Resource Server</strong>。</li></ul><p>从应用开发者的视角来看，很多时候一个服务同时担任资源服务器和授权服务器的角色，这时候称其为 Service（服务），或 API 角色。但也不排除 Client 和 Service 为同一个角色的情况。</p><p><img src="https://assets.digitalocean.com/articles/oauth/abstract_flow.png"></p><p>上图比较清晰地说明了 OAuth2 验证流程：</p><ol><li><strong>应用向用户去请求访问服务资源的权限</strong>（比如跳转到 github OAuth2 请求登陆的界面，要求用户输 github 账号密码，确认授权啥的？）</li><li>若用户授权，则应用能拿到一个授权（authorization grant）</li><li>则应用使用这个授权<strong>和应用自己的鉴权信息</strong>向授权服务器请求，拿到令牌</li><li>若授权和应用的鉴权信息均合法，则应用拿到令牌，授权完成</li><li>应用带上令牌作为鉴权信息向资源服务器发送请求</li><li>若令牌合法，则资源服务器向应用返回资源</li></ol><p>authorization grant 的类型不同会决定具体的流程。</p><p>比如我想让我的应用能够用 Github 账号去登陆，此时 Resource Owner 是使用 Github 账号登陆我的应用的用户，Client 是我的应用，Resource Server 和 Authorization Server 是 Github 暴露出来的 API。用户授权后，我从 Github 拿到用户的相关信息如用户名，邮箱等，并操作自己的数据库，完成注册，登陆等操作。</p><p>这里只提大体的框架，深入学习待应用的时候再说。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://jwt.io/introduction">Introduction to JSON Web Tokens</a></li><li><a href="https://www.loginradius.com/blog/engineering/guest-post/jwt-vs-sessions/">How to Authenticate Users: JWT vs. Session</a></li><li><a href="https://zhuanlan.zhihu.com/p/307424363">JWT 万字详解，一文足矣！</a></li><li><a href="https://auth0.com/intro-to-iam/what-is-oauth-2/">What is OAuth 2.0?</a></li><li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">An Introduction to OAuth 2</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Real World</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Study CSS——size, display &amp; position</title>
    <link href="/2022/07-23Study_CSS%E2%80%94%E2%80%94size-display-and-position.html"/>
    <url>/2022/07-23Study_CSS%E2%80%94%E2%80%94size-display-and-position.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>没想到一个月没有写新笔记了…这一个月以来我有何改变呢？这是个问题。</p></blockquote><p>最近学习前端，深感对 html 以及 css 了解太少，进行网页布局时束手束脚，于是参照这篇 <a href="https://www.taniarascia.com/overview-of-css-concepts/">文章</a>，把 CSS 的重要概念过一遍，形成一个整体的印象，以方便接下来的学习以及实践。</p><h1 id="margin-padding-border"><a href="#margin-padding-border" class="headerlink" title="margin, padding, border"></a>margin, padding, border</h1><p><img src="https://www.taniarascia.com/static/ed32dd9a28dcfcb8fc3a87a64e295ef5/432e7/padding1.png"></p><p>margin 为元素到其它元素的距离，border 为元素的边框，padding 为元素的内容到元素边框的距离；margin 在 border 之外，padding 在 border 之内。</p><p>margin，border，padding 有一些重要的规律需要记住：</p><ul><li><strong>margin 永远是透明的</strong>，background 只在 padding 中可见</li><li>margin 可以为负值，padding 不能</li><li>不同元素的 margin 会折叠（collapse，或者说重叠 overlap），padding 会堆叠（stack）<ul><li>折叠是说 margin 会在 xy 轴上重叠（且实际的 margin 会是它们中的较大值；但 margin 为负数的情况下渲染情况并非如此），堆叠是说 padding（实际上元素本身）会在 z 轴上重叠，xy 轴上不会“挤开”（这种情况发生在 margin 为负数时）</li></ul></li><li>padding 可点击，margin 不可</li><li>padding 和 border 计算在元素的大小中，margin 不计算</li></ul><p>margin 可重叠这一点很重要，考虑下面两个元素，它们之间的实际的 margin 会是 10px 而非 15px。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-bottom: 20px&quot;</span>&gt;</span>This is a title<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top:    10px&quot;</span>&gt;</span>Me a paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 style="margin-bottom: 20px">This is a title</h3><p  style="margin-top:    10px">Me a paragraph</p><blockquote><p>顺带一提，指定 margin，padding 时，使用 2 个值时，分别代表上下，左右，使用 4 个值时，代表上，右，下，左（从上开始顺时针）</p></blockquote><h1 id="box-sizing-width-height"><a href="#box-sizing-width-height" class="headerlink" title="box-sizing, width, height"></a>box-sizing, width, height</h1><p><strong>box-sizing 属性表示元素的大小，即 width 和 height 的语义</strong>，可选项有 border-box 和 content-box（默认值），其中使用 border-box 表示元素的大小为 border，padding，content 三者之和，即<strong>元素在边框内的大小</strong>，而 content-box 表示元素的大小为 content 的大小。</p><p>推荐使用 border-box，因为这对布局是更为方便且符合直觉的——我指定 width 是 100px，它就是 100px，我不希望它加上 padding 和 border 后值变得不是这个。当前我使用的 UI 框架 semanticUI 在所有元素均使用 border-box，猜测其它 UI 框架也是如此。</p><h1 id="display"><a href="#display" class="headerlink" title="display"></a>display</h1><p>display 即元素的显示类型，最常用的 display 包括 block, inline, inline-block, flex 和 none。</p><p>example tags:</p><ul><li>Inline: span, strong, em, img</li><li>Inline-block: button, select, (Chrome only: textarea, input)</li><li>Block: div, p, nav, section</li></ul><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>inline 类型顾名思义，这种类型的元素不会创造新的行，<strong>且其竖直方向的 margin 和 padding 会被忽略</strong>，比如下面的例子。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">We often use type variables with type constructors to describe abstract features of a computation. For example, the <span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin: 10px; padding: 10px&quot;</span>&gt;</span>polymorphic type<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span> Maybe a is the type of all computations that may return a value or Nothing. In this way, we can talk about the properties of the container apart from any details of what the container might hold.<br></code></pre></div></td></tr></table></figure><p>We often use type variables with type constructors to describe abstract features of a computation. For example, the <b style="margin: 10px; padding: 10px">polymorphic type</b> Maybe a is the type of all computations that may return a value or Nothing. In this way, we can talk about the properties of the container apart from any details of what the container might hold.</p><h2 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h2><p>inline-block 类型和 inline 一样在行内（因此相邻的 inline-block 元素仍旧在同一行，不会另起一行），且竖直方向的 margin 和 padding 仍起效。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">We often use type variables with type constructors to describe abstract features of a computation. <span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin: 20px; padding: 20px; display: inline-block&quot;</span>&gt;</span>For example<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>, the<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin: 10px; padding: 10px; display: inline-block&quot;</span>&gt;</span> polymorphic type<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Maybe a is the type of all computations that may return a value or Nothing. In this way, we can talk about the properties of the container apart from any details of what the container might hold. <br></code></pre></div></td></tr></table></figure><p>We often use type variables with type constructors to describe abstract features of a computation. <b style="margin: 20px; padding: 20px; display: inline-block">For example</b>, the <i style="margin: 10px; padding: 10px ;display: inline-block">polymorphic type</i> Maybe a is the type of all computations that may return a value or Nothing. In this way, we can talk about the properties of the container apart from any details of what the container might hold. </p><h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>block 即块元素，block 元素会<strong>起新行</strong>，且<strong>默认占据其容器的整个宽度</strong>。</p><p>这里有个问题，如何让 block 元素水平堆叠而非另起一行呢？可以使用 float，但需要注意 <strong>float 元素不参与父元素的大小计算</strong>，因此这里的父 div 的 height 为 0，这会引起文档流的混乱，需要在最后去清空这个浮动效果，这里显示写了一个空元素，但也可以使用 after 伪元素。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: left;&quot;</span>&gt;</span>abc<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: left;&quot;</span>&gt;</span>def<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;clear: both;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><div>  <div style="float: left;">abc</div>  <div style="float: left;">def</div>  <div style="clear: both;"></div></div><h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><p>顾名思义，不显示，常用于显示&#x2F;隐藏元素。</p><h1 id="positioning"><a href="#positioning" class="headerlink" title="positioning"></a>positioning</h1><p>positioning 即定位，它关系着元素位置的计算方式，相关属性为 position，可选值包括 static（默认值），fixed，absolute，relative。</p><blockquote><p>top, left, right, bottom 和 z-index 的属性也和元素位置相关，这些属性在 static 下不起作用。</p></blockquote><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>在元素的 position 属性为默认值即 static 的情况下，元素的定位遵循着称为 <strong>normal (document) flow</strong> 的规律：</p><ul><li>block 元素占据其容器的全部宽度，以及内容的高度</li><li>block 元素互相竖直地堆叠</li><li>inline（和 inline-block）元素的内容大小即为其本身的大小</li><li>所有元素的位置都会互相影响（也就是说都在同一个平面上），margin 会折叠</li></ul><p>static 的元素可以称它是<strong>没有定位</strong>的。</p><h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><p>fixed 元素容易理解——固定在 viewport 的特定位置，用途包括置顶的导航栏，固定在特定位置的“回到开头”按钮，弹出框等。fixed 元素就像被从正常的文档流中移出，其它元素计算位置时<strong>对它不可知</strong>（哪怕是同为 fixed 元素）。</p><p>fixed 元素<strong>的默认位置仍旧是它在文档流中的位置</strong>（且 margin 属性仍旧生效），可以通过 top，left 等属性去指定位置。</p><blockquote><p>这个默认位置问题似乎很多，考虑总是指定绝对位置</p></blockquote><h2 id="absolute-relative"><a href="#absolute-relative" class="headerlink" title="absolute, relative"></a>absolute, relative</h2><p>absolute 则和 fixed 非常类似，<strong>唯一</strong>的区别在于，fixed 元素固定在 viewport 的特定位置，而 <strong>absolute 元素的位置相对于它祖宗节点中第一个非 static 的元素进行固定</strong>，若找不到这样的节点则相对于 DOM 的根节点。</p><p>absolute 的默认位置就会比较有意义一些，比如这里给这一行栓一条带子。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">    left:0;</span></span><br><span class="hljs-string"><span class="hljs-tag">    position: absolute;</span></span><br><span class="hljs-string"><span class="hljs-tag">    height:20px;</span></span><br><span class="hljs-string"><span class="hljs-tag">    width:100%;</span></span><br><span class="hljs-string"><span class="hljs-tag">    background-color: dodgerblue;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 因为它会脱离文档流，为了让它后面的元素能正常排版，需要加个 padding --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;padding-top:20px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><div style="left:0;position: absolute;height:20px;width:100%;background-color: dodgerblue;"></div><div style="padding-top:20px"></div><p>而 relative，relative 元素的行为和 static 完全一致，<strong>唯一</strong>的区别在于它可以用作 absolute 元素的“<strong>锚点</strong>”。</p><p>absolute 的意义也可以猜想了，比如来个固定在一个弹出框右下角特定位置的按钮等。</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><table><thead><tr><th align="center">Position</th><th align="center">Behavior</th><th align="center">In Document Flow</th></tr></thead><tbody><tr><td align="center">static</td><td align="center">默认，元素互相堆叠，互相可知</td><td align="center">Y</td></tr><tr><td align="center">relative</td><td align="center">和 static 一致，但可供 absolute 作为锚点</td><td align="center">Y</td></tr><tr><td align="center">fixed</td><td align="center">位置相对于 viewport</td><td align="center">N</td></tr><tr><td align="center">absolute</td><td align="center">位置相对于父节点中第一个非 static 的元素</td><td align="center">N</td></tr></tbody></table><h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><blockquote><p>可以认为 flex 是一种一维的布局……？</p></blockquote><p>真正现代的东西来啦！block，inline-block，inline 三种 display 都只应用在元素自身，<strong>而 flex 应用在其子元素中</strong>，使用 flex，能够轻易实现元素的水平堆叠。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: flex; width: 500px; height: 200px; border: 1px solid red;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid cornflowerblue&quot;</span>&gt;</span>elem A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid cornflowerblue&quot;</span>&gt;</span>elem B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid cornflowerblue&quot;</span>&gt;</span>elem C<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><div style="display: flex; width: 500px; height: 200px; border: 1px solid red;">  <div style="border: 1px solid cornflowerblue">elem A</div>  <div style="border: 1px solid cornflowerblue">elem B</div>  <div style="border: 1px solid cornflowerblue">elem C</div></div><p>可以看到，这时候子元素水平堆叠，height 而非 width 为 100%。<strong>flex 能将元素按照一个方向去进行排列</strong>，相应配置项名为 flex-direction，值为 row 或 column，默认 row。flex 的方向称为<strong>主轴</strong> main axis。</p><p>但 flex 最酷的地方在于，它解决了一系列编写 layout 的痛点，如水平&#x2F;垂直对齐元素，分割、分组元素等，比如下面是一个常见的导航栏例子。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- align-items: center 指定子元素在垂直于 flex 的方向对齐（对 row，就是上下对齐，对 column，就是左右对齐） --&gt;</span><br><span class="hljs-comment">&lt;!-- justify-content: space-between 元素在主轴上的对齐方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">  display: flex;</span></span><br><span class="hljs-string"><span class="hljs-tag">  background: dodgerblue;</span></span><br><span class="hljs-string"><span class="hljs-tag">  width: 100%; </span></span><br><span class="hljs-string"><span class="hljs-tag">  align-items: center;</span></span><br><span class="hljs-string"><span class="hljs-tag">  justify-content: space-between;</span></span><br><span class="hljs-string"><span class="hljs-tag">  height: 50px;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin: 10px&quot;</span>&gt;</span>LOGO<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin:auto 5px&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin:5px;&quot;</span>&gt;</span>Doc<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin:5px;&quot;</span>&gt;</span>Support<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin:5px;&quot;</span>&gt;</span>Download<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin:5px;&quot;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></div></td></tr></table></figure><nav style="  display: flex;  background: dodgerblue;  width: 100%;   align-items: center;  justify-content: space-between;  height: 50px;">  <div style="margin: 10px">LOGO</div>  <div style="margin:auto 5px">    <a href="#" style="margin:5px;">Doc</a>    <a href="#" style="margin:5px;">Support</a>    <a href="#" style="margin:5px;">Download</a>    <a href="#" style="margin:5px;">Login</a>  </div></nav><p>flex 关于上下和水平的排序的属性，有如下：</p><table><thead><tr><th align="center">属性名称</th><th align="center">作用对象</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">align-items</td><td align="center">container</td><td align="center">每一行行内在交叉轴上的对齐方式</td></tr><tr><td align="center">align-content</td><td align="center">container</td><td align="center">每一行行间在交叉轴上的对齐方式</td></tr><tr><td align="center">align-self</td><td align="center">item</td><td align="center">item 的属性，覆盖行内交叉轴上的对齐方式</td></tr><tr><td align="center">justify-items</td><td align="center">container</td><td align="center">定义子元素的 justify-self</td></tr><tr><td align="center">justify-content</td><td align="center">container</td><td align="center">每一行在主轴上的对齐方式</td></tr><tr><td align="center">justify-self</td><td align="center">X</td><td align="center">flex 下不可用</td></tr></tbody></table><h1 id="additional-resources"><a href="#additional-resources" class="headerlink" title="additional resources"></a>additional resources</h1><p>不得不说，学完这篇文章，我对 html 着实是增加了一些信心，知道自己在做什么了，但这显然还远远不够。flex，以及 media query 后续再进行学习（这篇文章在这两个部分上的介绍应当也是比较精彩的），这里列一些下一步可能要去阅读的资料。</p><ul><li><a href="https://flexboxfroggy.com/">flexbox froggy</a>，一个学习 flex 的游戏。</li><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a></li><li><a href="https://www.element84.com/blog/responsive-typography">Responsive Typography: rem, em, and px, Comprehensive Guide: When to Use Em vs Rem</a></li><li><a href="https://ishadeed.com/article/auto-css/">Everything About Auto in CSS</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于音阶的指型</title>
    <link href="/2022/06-18%E5%85%B3%E4%BA%8E%E9%9F%B3%E9%98%B6%E7%9A%84%E6%8C%87%E5%9E%8B.html"/>
    <url>/2022/06-18%E5%85%B3%E4%BA%8E%E9%9F%B3%E9%98%B6%E7%9A%84%E6%8C%87%E5%9E%8B.html</url>
    
    <content type="html"><![CDATA[<script src="/js/fretboard.js"></script><script>const { Fretboard, Systems } = globalThis.fretboard// 这三个常量的 string 是“相对”的，它不关心 1，2 弦const H_PATTERN = [    {string: 3, fret: 1, level: 1},    {string: 3, fret: 3, level: 2},    {string: 3, fret: 5, level: 3},    {string: 2, fret: 1, level: 4},    {string: 2, fret: 3, level: 5},    {string: 2, fret: 5, level: 6},    {string: 1, fret: 2, level: 7},     {string: 1, fret: 3, level: 1}]const M_PATTERN = [    {string: 3, fret: 2, level: 1},    {string: 3, fret: 4, level: 2},    {string: 2, fret: 1, level: 3},    {string: 2, fret: 2, level: 4},    {string: 2, fret: 4, level: 5},    {string: 1, fret: 1, level: 6},    {string: 1, fret: 3, level: 7},     {string: 1, fret: 4, level: 1}]const L_PATTERN = [    {string: 4, fret: 4, level: 1},    {string: 3, fret: 1, level: 2},    {string: 3, fret: 3, level: 3},    {string: 3, fret: 4, level: 4},    {string: 2, fret: 1, level: 5},    {string: 2, fret: 3, level: 6},    {string: 2, fret: 5, level: 7},    {string: 1, fret: 1, level: 1}]// 生成从特定弦开始的 pattern，并可按品位偏移function hPattern(startString, startFret) {  return H_PATTERN.map(({level, string, fret}) => ({level, string: string + startString - 3, fret: fret + startFret - 1}))   .filter(({string, fret}) => string >= 1)   // 到正确的弦   .map(({string, fret, level}) => {      // 移动 1,2 弦上的位置      if (startString <= 2) {        return {string, fret, level}      }      if (string <= 2) fret += 1      return {string, fret, level}   })}function mPattern(startString, startFret) {  return M_PATTERN.map(({string, fret, level}) => ({level, string: string + startString - 3, fret: fret + startFret - 2}))   .filter(({string, fret}) => string >= 1)   // 到正确的弦   .map(({string, fret, level}) => {      // 移动 1,2 弦上的位置      if (startString <= 2) {        return {string, fret, level}      }      if (string <= 2) fret += 1      return {string, fret, level}   })}function lPattern(startString, startFret) {  return L_PATTERN.map(({string, fret, level}) => ({level, string: string + startString - 4, fret: fret + startFret - 4}))   .filter(({string, fret}) => string >= 1)   // 到正确的弦   .map(({string, fret, level}) => {      // 移动 1,2 弦上的位置      if (startString <= 2) {        return {string, fret, level}      }      if (string <= 2) fret += 1      return {string, fret, level}   })}function multiPattern(...patterns) {  const set = new Set()  return patterns.flatMap(arr => arr).filter(pos => {    if (set.has(JSON.stringify(pos))) return false    set.add(JSON.stringify(pos))    return true  })}// 展示模块的通用配置function patternCommonSetting(stringCount, fretCount) {  const tuning = ["E2", "A2", "D3", "G3", "B3", "E3"].slice(0, stringCount)  return {    stringCount,    tuning,    crop: true,    fretCount,    width: 480,    height: 110,    nutWidth: 1,    dotSize:36,    topPadding: 30,    bottomPadding: 30,    showFretNumbers: false,    dotTextSize: 24,  }}// 展示整个指板时的通用配置，左右预留空位function fretboardCommonSetting(fretCount) {  fretCount += 2  const width = 960 * fretCount / 15  return {    fretCount,    crop: true,    fretLeftPadding: 1,    dotSize:24,    stringWidth: [1,1,2,3,3.5,4],    width,    topPadding: 30,    bottomPadding: 30,  }}function pos2Level(poses) {  const arr = poses.map(({string, fret, level}) => [string + "-" + fret, level])  return ({string, fret}) => {    for(i in arr) {      const [key, value] = arr[i]      if (key === string + "-" + fret) return value    }    throw new Error("WTF")  }}function levelStyle(poses, level) {  console.log(poses, level)  const levelFilter = level => ({string, fret}) => {    for (i in poses) {      const elem = poses[i]      if (string === elem.string && fret === elem.fret && level === elem.level) return true    }    return false  }  switch (level) {    case 1:    case 8:        return {          filter: levelFilter(level),          fill: "#1e272e",          stroke:"",          fontFill: "#ffffff",          r: 15,          fontSize:20        }    case 2:      return {          filter: levelFilter(level),          fill: "#00d8d6",          stroke:"",          fontFill: "#555555",          r: 13,          fontSize:17        }    case 3:        return {          // 三级音          filter: levelFilter(level),          fill: "#f53b57",          stroke:"",          fontFill: "#ffffff",          r: 14,          fontSize:17        }        case 4:        return {          filter: levelFilter(level),          fill: "#d2dae2",          stroke:"",          fontFill: "#666666",          r: 13,          fontSize:17        }    case 5:        return {          // 五级音          filter: levelFilter(level),          fill: "#575fcf",          stroke:"",          fontFill: "#ffffff",          r: 14,          fontSize:17        }    case 6:        return {          filter: levelFilter(level),          fill: "#0be881",          stroke:"",          fontFill: "#666666",          r: 13,          fontSize:17        }    case 7:        return {          filter: levelFilter(level),          fill: "#ef5777",          stroke:"",          fontFill: "#ffffff",          r: 13,          fontSize:17        }  }}</script><p>关于音阶的指型，有许多相关的理论，其中最经典的莫过于 CAGED 系统和 3NPS 系统了，这里能看到 <a href="https://moonwave99.github.io/fretboard.js/examples-systems.html">示例</a>。</p><p>这些系统都挺酷炫的，但有一个重大的问题：</p><p><strong>难记！</strong></p><p>真的记不住，只能说真的记不住，今天弹了明天就忘记了，因此就试图去找更简单的方式（至少是某种记忆方式），这时候在 b 站上看到一个 <a href="https://www.bilibili.com/video/BV1LV411C7iq">视频</a>，感觉就挺中意的，它<strong>将每个八度的两个主音之间的范围作为原子</strong>，而非是直接把一整个把位作为原子。后来，我发现蔡文展的书《吉他终极音阶训练》这本书中就是通过这种思路去描述音阶的，既然有专家打包票，那或许它确实值得学习。</p><p>这个系统有两个显著的优势，一是<strong>减少了要记忆形状的复杂度</strong>，原本需要记忆这整个把位的形状，现在只需要记忆一个八度的形状了（并且八度的形状只有三种）；二是能够<strong>方便地转换和组合成其它指型</strong>，弹完这个八度后，根据主音位置便可以方便地转换成其它指型，后面可以发现 CAGED 系统和 3NPS 系统都是可以从这个系统去构造的，并且它自由度更高。</p><p>这篇笔记的目的就是<strong>绘制这三种指型形状，以及这三种指型从每根弦</strong>（主要是 6、5、4、3 弦，2 弦和 1 弦的话不知道是否有必要）<strong>上出发得到的变体，以供将来参考</strong>，实际上之前学习 fretboard.js 就是这个目的。</p><blockquote><p>虽然这可能是废话，但是这些系统都是描述自然大调（Ionian）音阶的，要去描述其它音阶需要对各级音进行升降的处理（以及删掉一些音），<strong>要学习的东西多着呢</strong>！</p></blockquote><h1 id="三种形状及其命名"><a href="#三种形状及其命名" class="headerlink" title="三种形状及其命名"></a>三种形状及其命名</h1><p>蔡文展的书中对每个指型，采用”数字-数字-L|M|H”的方式命名，其中第一个数字为指型的第一个音的音级，第二个数字为指型出发的弦，字母表示三种形状之一，其中 L 表示 lower，即大部分音都比第一个音的把位低（更靠近琴头），M 表示 middle，即各级音平均分布在第一个音的上下把位，H 表示 Higher，即大部分音都比第一个音的把位高。</p><p>但我翻遍全书，第一个数字好像总是 1，为此这里做一个简化，按”出发的弦数-L|M|H”去命名，将来若真看到了特例，再加上去就得了。</p><blockquote><p>其实还能有一个参数，就是当前的调式（大调，小调，etc……），但考虑到调式一般是应用在该上下文的所有指型上的，这里就不作为参数了。</p></blockquote><p>下面展示了 L，M，H 三个指型，可以发现 M 和 H 指型非常相像，M 指型其实就是 H 指型将 3 级音，6 级音移动到下一根弦上，这也是很方便记忆的。</p><p>下面展示每根弦出发得到的指型。</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><figure id="H-pattern"></figure><script>new Fretboard({  ...patternCommonSetting(3, 5),  el: '#H-pattern',  dotText: pos2Level(H_PATTERN)}).setDots(H_PATTERN).render().style({  // 主音  filter: ({string, fret}) => {    return (string === 3 && fret === 1) || (string === 1 && fret === 3)  },  fill: "#283550",  stroke:"",  fontFill: "#ffffff",  r: 24}).style({  // 三级音  filter: ({string, fret}) => {    return (string === 3 && fret === 5)  },  fill: "#E2A647",  stroke:"",  fontFill: "#ffffff",  r: 20}).style({  // 五级音  filter: ({string, fret}) => {    return (string === 2 && fret === 3)  },  fill: "#BA2B0D",  stroke:"",  fontFill: "#ffffff",  r: 20})</script><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><p>容易发现它和 H 型的相似之处，但它们值得分开记忆：</p><figure id="M-pattern"></figure><script>new Fretboard({  ...patternCommonSetting(3, 4),  el: '#M-pattern',  dotText: pos2Level(M_PATTERN)}).setDots(M_PATTERN).render().style({  // 主音  filter: ({string, fret}) => {    return (string === 3 && fret === 2) || (string === 1 && fret === 4)  },  fill: "#283550",  stroke:"",  fontFill: "#ffffff",  r: 24}).style({  // 三级音  filter: ({string, fret}) => {    return (string === 2 && fret === 1)  },  fill: "#E2A647",  stroke:"",  fontFill: "#ffffff",  r: 20}).style({  // 五级音  filter: ({string, fret}) => {    return (string === 2 && fret === 4)  },  fill: "#BA2B0D",  stroke:"",  fontFill: "#ffffff",  r: 20})</script><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><p>L 型的特色是有 4 根弦参与而非 3 根弦：</p><figure id="L-pattern"></figure><script>new Fretboard({  ...patternCommonSetting(4,5),  el: '#L-pattern',  height:150,  dotText: pos2Level(L_PATTERN)}).setDots(L_PATTERN).render().style({  // 主音  filter: ({string, fret}) => {    return (string === 4 && fret === 4) || (string === 1 && fret === 1)  },  fill: "#283550",  stroke:"",  fontFill: "#ffffff",  r: 24}).style({  // 三级音  filter: ({string, fret}) => {    return (string === 3 && fret === 3)  },  fill: "#E2A647",  stroke:"",  fontFill: "#ffffff",  r: 20}).style({  // 五级音  filter: ({string, fret}) => {    return (string === 2 && fret === 1)  },  fill: "#BA2B0D",  stroke:"",  fontFill: "#ffffff",  r: 20})</script><h1 id="6-弦"><a href="#6-弦" class="headerlink" title="6 弦"></a>6 弦</h1><p>从 6 弦出发时，所有指型都没有任何变形，下面使用 A 调（6 弦 5 品）做例子。</p><h2 id="6-H"><a href="#6-H" class="headerlink" title="6-H"></a>6-H</h2><figure id="_6-H"></figure><script>pattern = hPattern(6, 5)new Fretboard({  ...fretboardCommonSetting(5),  el: '#_6-H',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="6-M"><a href="#6-M" class="headerlink" title="6-M"></a>6-M</h2><figure id="_6-M"></figure><script>  pattern = mPattern(6, 5)new Fretboard({  ...fretboardCommonSetting(4),  el: '#_6-M',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="6-L"><a href="#6-L" class="headerlink" title="6-L"></a>6-L</h2><figure id="_6-L"></figure><script>pattern = lPattern(6, 5)new Fretboard({  ...fretboardCommonSetting(5),  el: '#_6-L',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h1 id="5-弦"><a href="#5-弦" class="headerlink" title="5 弦"></a>5 弦</h1><p>从 5 弦出发时，只有 L 指型有变形，其最高音在 2 弦上，因此要向高音处移动一品，这里使用 D 调（5 弦 5 品）举例。</p><h2 id="5-H"><a href="#5-H" class="headerlink" title="5-H"></a>5-H</h2><figure id="_5-H"></figure><script>pattern = hPattern(5, 5)new Fretboard({  ...fretboardCommonSetting(5),  el: '#_5-H',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="5-M"><a href="#5-M" class="headerlink" title="5-M"></a>5-M</h2><figure id="_5-M"></figure><script>  pattern = mPattern(5, 5)new Fretboard({  ...fretboardCommonSetting(4),  el: '#_5-M',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="5-L"><a href="#5-L" class="headerlink" title="5-L"></a>5-L</h2><figure id="_5-L"></figure><script>pattern = multiPattern(lPattern(5, 5), [{string: 2, fret: 2, level: 7}])            .filter(({string, fret}) => !(string === 3 && fret === 6))new Fretboard({  ...fretboardCommonSetting(4),  el: '#_5-L',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h1 id="4-弦"><a href="#4-弦" class="headerlink" title="4 弦"></a>4 弦</h1><p>使用 G 调（4 弦 5 品）举例。</p><h2 id="4-H"><a href="#4-H" class="headerlink" title="4-H"></a>4-H</h2><figure id="_4-H"></figure><script>pattern = multiPattern(hPattern(4, 5))new Fretboard({  ...fretboardCommonSetting(5),  el: '#_4-H',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="4-M"><a href="#4-M" class="headerlink" title="4-M"></a>4-M</h2><figure id="_4-M"></figure><script>pattern = mPattern(4, 5)new Fretboard({  ...fretboardCommonSetting(5),  el: '#_4-M',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="4-L"><a href="#4-L" class="headerlink" title="4-L"></a>4-L</h2><p>7 可以移到 1 弦上以避免离开把位：</p><figure id="_4-L"></figure><script>pattern = multiPattern(lPattern(4, 5), [{string: 1, fret: 2, level: 7}])            .filter(({string, fret}) => !(string === 2 && fret === 7))new Fretboard({  ...fretboardCommonSetting(4),  el: '#_4-L',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h1 id="3-弦"><a href="#3-弦" class="headerlink" title="3 弦"></a>3 弦</h1><p>使用 C 调（3 弦 5 品）举例。</p><h2 id="3-H"><a href="#3-H" class="headerlink" title="3-H"></a>3-H</h2><figure id="_3-H"></figure><script>pattern = multiPattern(hPattern(3, 5), [{string: 1, fret: 5, level: 6}])            .filter(({string, fret}) => !(string === 2 && fret === 10))new Fretboard({  ...fretboardCommonSetting(5),  el: '#_3-H',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="3-M"><a href="#3-M" class="headerlink" title="3-M"></a>3-M</h2><figure id="_3-M"></figure><script>pattern = mPattern(3, 5)new Fretboard({  ...fretboardCommonSetting(4),  el: '#_3-M',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="3-L"><a href="#3-L" class="headerlink" title="3-L"></a>3-L</h2><p>也需要移动一些音。</p><figure id="_3-L"></figure><script>pattern = [...lPattern(3, 5), {string: 1, fret: 8, level: 1}]new Fretboard({  ...fretboardCommonSetting(6),  el: '#_3-L',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h1 id="2-弦"><a href="#2-弦" class="headerlink" title="2 弦"></a>2 弦</h1><p>2 弦上没有移动，使用 E 调（2 弦 5 品举例）。</p><h2 id="2-H"><a href="#2-H" class="headerlink" title="2-H"></a>2-H</h2><figure id="_2-H"></figure><script>pattern = hPattern(2, 5)new Fretboard({  ...fretboardCommonSetting(5),  el: '#_2-H',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="2-M"><a href="#2-M" class="headerlink" title="2-M"></a>2-M</h2><figure id="_2-M"></figure><script>pattern = mPattern(2, 5)new Fretboard({  ...fretboardCommonSetting(4),  el: '#_2-M',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="2-L"><a href="#2-L" class="headerlink" title="2-L"></a>2-L</h2><figure id="_2-L"></figure><script>pattern = lPattern(2, 5)new Fretboard({  ...fretboardCommonSetting(4),  el: '#_2-L',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="2，1-弦全指型"><a href="#2，1-弦全指型" class="headerlink" title="2，1 弦全指型"></a>2，1 弦全指型</h2><figure id="_2-ALL"></figure><script>pattern = multiPattern(hPattern(2, 5), mPattern(2, 5), lPattern(2, 5))new Fretboard({  ...fretboardCommonSetting(8),  el: '#_2-ALL',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h1 id="指型的合并"><a href="#指型的合并" class="headerlink" title="指型的合并"></a>指型的合并</h1><p>指型之间可以有下列的合并法：</p><ol><li>6-L + 3-M（G 指型）</li><li>6-M + 4-L（E 指型）</li><li>6-H + 4-M（3NPS 指型 1）</li><li>5-M + 3-L（3NPS 指型 4）</li><li>5-H + 3-M（3NPS 指型 5）</li></ol><p>下面均使用 A 调为例子。</p><h2 id="6-L-3-M（G-指型）"><a href="#6-L-3-M（G-指型）" class="headerlink" title="6-L + 3-M（G 指型）"></a>6-L + 3-M（G 指型）</h2><figure id="_6-L_3-M"></figure><script>pattern = multiPattern(mPattern(3, 2), lPattern(6, 5))new Fretboard({  ...fretboardCommonSetting(5),  el: '#_6-L_3-M',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="6-M-4-L（E-指型）"><a href="#6-M-4-L（E-指型）" class="headerlink" title="6-M + 4-L（E 指型）"></a>6-M + 4-L（E 指型）</h2><p>7 应当移动到 1 弦上。</p><figure id="_6-M_4-L"></figure><script>pattern = multiPattern(lPattern(4, 7), mPattern(6, 5), [{string: 1, fret: 4, level: 7}])            .filter(({string, fret}) => !(string === 2 && fret === 9))new Fretboard({  ...fretboardCommonSetting(4),  el: '#_6-M_4-L',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="6-H-4-M（3NPS-指型-1）"><a href="#6-H-4-M（3NPS-指型-1）" class="headerlink" title="6-H + 4-M（3NPS 指型 1）"></a>6-H + 4-M（3NPS 指型 1）</h2><figure id="_6-H_4-M"></figure><script>pattern = multiPattern(hPattern(6, 5), mPattern(4, 7))new Fretboard({  ...fretboardCommonSetting(6),  el: '#_6-H_4-M',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="5-M-3-L（3NPS-指型-4）"><a href="#5-M-3-L（3NPS-指型-4）" class="headerlink" title="5-M + 3-L（3NPS 指型 4）"></a>5-M + 3-L（3NPS 指型 4）</h2><figure id="_5-M_3-L"></figure><script>pattern = multiPattern(mPattern(5, 12), lPattern(3, 14), [{string: 1, fret: 17, level: 1}])new Fretboard({  ...fretboardCommonSetting(7),  el: '#_5-M_3-L',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><h2 id="5-H-3-M（3NPS-指型-5）"><a href="#5-H-3-M（3NPS-指型-5）" class="headerlink" title="5-H + 3-M（3NPS 指型 5）"></a>5-H + 3-M（3NPS 指型 5）</h2><figure id="_5-H_3-M"></figure><script>pattern = multiPattern(hPattern(5, 12), mPattern(3, 14))new Fretboard({  ...fretboardCommonSetting(6),  el: '#_5-H_3-M',  dotText: pos2Level(pattern)}).setDots(pattern).render().style(levelStyle(pattern,1)).style(levelStyle(pattern,2)).style(levelStyle(pattern,3)).style(levelStyle(pattern,4)).style(levelStyle(pattern,5)).style(levelStyle(pattern,6)).style(levelStyle(pattern,7))</script><hr><p>这些指型要全记下来的话得用一年，<strong>但大可以把三种基本指型牢牢记住，然后用的时候快速推导</strong>，同时也要无数次地进行音阶练习来巩固认识。</p><p>下一篇笔记就记录对五线谱的学习，包括各位置的记忆方式（EGBDF，FACE），各种调号，以及从每个位置出发，往上和往下一个八度中各级音的位置，这是为了能够将五线谱和这里所学的音阶指型去做映射，让自己养成首调思维，能够去根据五线谱弹吉他。</p>]]></content>
    
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fretboard.js 入门</title>
    <link href="/2022/06-17fretboard.js%E5%85%A5%E9%97%A8.html"/>
    <url>/2022/06-17fretboard.js%E5%85%A5%E9%97%A8.html</url>
    
    <content type="html"><![CDATA[<script src="/js/fretboard.js"></script><p><a href="https://moonwave99.github.io/fretboard.js/documentation-fretboard.html">Fretboard.js</a> 是一个使用 js 生成 svg 形式的指板图的工具，之后可能要做一些关于吉他的笔记，所以对它进行一些学习。要在浏览器中使用，直接下载 <a href="/js/fretboard.js">该 js 文件</a>，在 html 中引用即可。</p><p>该库具体的使用细节应当参照官方文档，其中提供了很多供参考的 <a href="https://moonwave99.github.io/fretboard.js/examples-systems.html">例子</a>，这里只是做一些最简单的示例。</p><p>该库的基本使用方式为定义一个 figure 标签并给定 id，然后创建相应的 Fretboard 对象，在配置后调用 render 方法，比如下面的代码会定义一个空白的指板。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empty-fretboard&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Fretboard</span> &#125; = globalThis.<span class="hljs-property">fretboard</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> fretboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fretboard</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#empty-fretboard&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">stringWidth</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">1.5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] <span class="hljs-comment">// 为了好看！</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript">fretboard.<span class="hljs-title function_">render</span>()</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>效果如下：</p><figure id="empty-fretboard"></figure><script>const { Fretboard } = globalThis.fretboardconst emptyFretboard = new Fretboard({  el: '#empty-fretboard',  stringWidth: [1,1.5,2,3,4,5]});emptyFretboard.render()</script><p>下面列出了 Fretboard 的构造函数的全部配置，为了描述方便，下面的 instrument 仍旧称为吉他（但它也能够描述其它弦乐器），相较于官方文档，这里进行了一些重排序：</p><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">el</td><td align="center">string</td><td align="center">‘#fretboard’</td><td align="center">对应的标签，使用选择器语法</td></tr><tr><td align="center">fretCount</td><td align="center">number</td><td align="center">15</td><td align="center">展示的品数</td></tr><tr><td align="center">crop</td><td align="center">boolean</td><td align="center">false</td><td align="center">是否对指板图进行剪切，如果为 true，则剪掉左边空余的品位，其实就是说不从 1 品开始，从第一个有指位的品开始进行渲染，这是非常有用的</td></tr><tr><td align="center">fretLeftPadding</td><td align="center">number</td><td align="center">0</td><td align="center">似乎在 crop 为 true 时起作用，表示左边在最低把位的音前空开多少品</td></tr><tr><td align="center">tuning</td><td align="center">string[]</td><td align="center">[“E2”, “A2”, “D3”, “G3”, “B3”, “E4”]</td><td align="center">吉他的 <a href="https://moonwave99.github.io/fretboard.js/documentation-fretboard.html#tuning">调音</a></td></tr><tr><td align="center">stringCount</td><td align="center">number</td><td align="center">6</td><td align="center">吉他的弦数，必须和调音的数组的长度相等</td></tr><tr><td align="center">dotText</td><td align="center">{string: number, fret: number} &#x3D;&gt; string</td><td align="center">(dot) &#x3D;&gt; ‘’</td><td align="center">特定指位的文字，注意这里的 string 是属性名</td></tr><tr><td align="center">stringWidth</td><td align="center">number | [number]</td><td align="center">1</td><td align="center">弦的宽度，可以去传入一个数组，如 [1, 1.5, 2, 3, 4, 5]，设置好了挺美观的</td></tr><tr><td align="center">fretWidth</td><td align="center">string</td><td align="center">1</td><td align="center"><strong>品丝</strong>的宽度</td></tr><tr><td align="center">showFretNumbers</td><td align="center">string</td><td align="center">true</td><td align="center">是否展示品数</td></tr><tr><td align="center">middleFretWidth</td><td align="center">string</td><td align="center">3</td><td align="center">12 品品丝宽度</td></tr><tr><td align="center">scaleFrets</td><td align="center">string</td><td align="center">true</td><td align="center">如果为 true，则品格的宽度按对数增长（现实如此），否则按线性增长</td></tr><tr><td align="center">stringColor</td><td align="center">string</td><td align="center">‘#666’</td><td align="center">弦的颜色</td></tr><tr><td align="center">fretColor</td><td align="center">string</td><td align="center">‘#666’</td><td align="center">品丝的颜色</td></tr><tr><td align="center">nutWidth</td><td align="center">string</td><td align="center">7</td><td align="center">上弦枕的宽度</td></tr><tr><td align="center">nutColor</td><td align="center">string</td><td align="center">‘#666’</td><td align="center">上弦枕颜色</td></tr><tr><td align="center">disabledOpacity</td><td align="center">string</td><td align="center">0.9</td><td align="center">无效（disabled）的指位的不透明度</td></tr><tr><td align="center">middleFretColor</td><td align="center">string</td><td align="center">‘#ff636c’</td><td align="center">12 品品丝颜色</td></tr><tr><td align="center">dotSize</td><td align="center">string</td><td align="center">20</td><td align="center">指位的直径</td></tr><tr><td align="center">dotStrokeColor</td><td align="center">string</td><td align="center">‘#555’</td><td align="center">指位边框的颜色</td></tr><tr><td align="center">dotStrokeWidth</td><td align="center">string</td><td align="center">2</td><td align="center">指位边框宽度</td></tr><tr><td align="center">dotTextSize</td><td align="center">string</td><td align="center">12</td><td align="center">指位上的文字大小</td></tr><tr><td align="center">dotFill</td><td align="center">string</td><td align="center">‘white’</td><td align="center">指位填充颜色</td></tr><tr><td align="center">fretNumbersColor</td><td align="center">string</td><td align="center">‘#00000099’</td><td align="center">品数的颜色</td></tr><tr><td align="center">topPadding</td><td align="center">string</td><td align="center">20</td><td align="center">Top padding（相对于 SVG 容器）</td></tr><tr><td align="center">bottomPadding</td><td align="center">string</td><td align="center">15</td><td align="center">Bottom padding</td></tr><tr><td align="center">leftPadding</td><td align="center">string</td><td align="center">20</td><td align="center">Left padding</td></tr><tr><td align="center">rightPadding</td><td align="center">string</td><td align="center">20</td><td align="center">Right padding</td></tr><tr><td align="center">height</td><td align="center">string</td><td align="center">150</td><td align="center">SVG element height</td></tr><tr><td align="center">width</td><td align="center">string</td><td align="center">960</td><td align="center">SVG element width</td></tr><tr><td align="center">fretNumbersHeight</td><td align="center">string</td><td align="center">40</td><td align="center">Fret numbers container height</td></tr><tr><td align="center">fretNumbersMargin</td><td align="center">string</td><td align="center">20</td><td align="center">Fret number container top margin</td></tr><tr><td align="center">font</td><td align="center">string</td><td align="center">‘Arial’</td><td align="center">文字的字体</td></tr><tr><td align="center">barresColor</td><td align="center">string</td><td align="center">‘#666’</td><td align="center">未见效果，似乎是关于大横按的，描述错误了：Amount of empty frets to display before dots.</td></tr></tbody></table><hr><p>我们的目的当然不仅仅是去展示空白的指板，还得在上面放指位才能起参照作用。</p><p>放置指位使用 setDots 方法，它接受一个<code>&#123;string: number, fret: number&#125;</code>，比如下面的代码展示了一个开放 C 和弦，并在指位上显示其音高：</p><figure id="c-chord"></figure><script>const cChord = new Fretboard({  el: '#c-chord',  stringWidth: [1,1.5,2,3,4,5],  fretCount: 3,    dotText({string, fret}) {    if (string === 5 && fret === 3) return 'C'    if (string === 4 && fret === 2) return 'B'    if (string === 2 && fret === 1) return 'C'  }});cChord.setDots([{    string: 5,    fret: 3,  },  {    string: 4,    fret: 2,  },  {    string: 2,    fret: 1,  }])cChord.render()</script><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;c-chord&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> cChord = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fretboard</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#c-chord&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">stringWidth</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">1.5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],</span><br><span class="language-javascript">  <span class="hljs-attr">fretCount</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">  <span class="hljs-title function_">dotText</span>(<span class="hljs-params">&#123;string, fret&#125;</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string)</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (string === <span class="hljs-number">5</span> &amp;&amp; fret === <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (string === <span class="hljs-number">4</span> &amp;&amp; fret === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (string === <span class="hljs-number">2</span> &amp;&amp; fret === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript">cChord.<span class="hljs-title function_">setDots</span>([&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">string</span>: <span class="hljs-number">5</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">fret</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">string</span>: <span class="hljs-number">4</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">fret</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">string</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">fret</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">  &#125;])</span><br><span class="language-javascript">cChord.<span class="hljs-title function_">render</span>()</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>也可以使用 style 方法，style 方法<strong>需要在 render 后被调用</strong>，可以用来规定特定情况的样式，它的签名如下，满足 filter 的指位会被影响。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">style</span>(&#123;<br>  filter = (): <span class="hljs-function"><span class="hljs-params">boolean</span> =&gt;</span> <span class="hljs-literal">true</span>, <span class="hljs-comment">// filter 用于进行筛选，它不止可以传递指位，也可以传递</span><br>  text,<br>  fontSize, <span class="hljs-comment">// 文字大小</span><br>  fontFill, <span class="hljs-comment">// 文字颜色</span><br>  ...opts   <span class="hljs-comment">// 各种其他配置，会被应用到指位上，这里的配置好像是来自 svg 的……</span><br>&#125;: &#123;<br>  filter?: <span class="hljs-function">(<span class="hljs-params">position: Position</span>) =&gt;</span> boolean | <span class="hljs-title class_">Record</span>&lt;string, string|number|boolean&gt;;<br>  text?: <span class="hljs-function">(<span class="hljs-params">position: Position</span>) =&gt;</span> string;<br>  fontSize?: number;<br>  fontFill?: string;<br>  [<span class="hljs-attr">key</span>: string]: string | number | <span class="hljs-title class_">Function</span>;<br>&#125;): <span class="hljs-title class_">Fretboard</span><br></code></pre></div></td></tr></table></figure><p>比如，我们展示一个开放 G 和弦，其中食指为黄色，中指为蓝色，无名指为红色：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;g-chord&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> gChord = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fretboard</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#g-chord&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">stringWidth</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">1.5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],</span><br><span class="language-javascript">  <span class="hljs-attr">fretCount</span>: <span class="hljs-number">3</span></span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript">gChord.<span class="hljs-title function_">setDots</span>([&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">string</span>: <span class="hljs-number">5</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">fret</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">string</span>: <span class="hljs-number">6</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">fret</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">string</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">fret</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">  &#125;])</span><br><span class="language-javascript">gChord.<span class="hljs-title function_">render</span>().<span class="hljs-title function_">style</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">filter</span>: <span class="hljs-function">(<span class="hljs-params">&#123;string, fret&#125;</span>) =&gt;</span> string === <span class="hljs-number">5</span> &amp;&amp; fret === <span class="hljs-number">2</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">fill</span>: <span class="hljs-string">&quot;yellow&quot;</span></span><br><span class="language-javascript">&#125;).<span class="hljs-title function_">style</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">filter</span>: <span class="hljs-function">(<span class="hljs-params">&#123;string, fret&#125;</span>) =&gt;</span> string === <span class="hljs-number">6</span> &amp;&amp; fret === <span class="hljs-number">3</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">fill</span>: <span class="hljs-string">&quot;blue&quot;</span></span><br><span class="language-javascript">&#125;).<span class="hljs-title function_">style</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">filter</span>: <span class="hljs-function">(<span class="hljs-params">&#123;string, fret&#125;</span>) =&gt;</span> string === <span class="hljs-number">1</span> &amp;&amp; fret === <span class="hljs-number">3</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">fill</span>: <span class="hljs-string">&quot;red&quot;</span></span><br><span class="language-javascript">&#125;)</span><br></code></pre></div></td></tr></table></figure><figure id="g-chord"></figure><script>const gChord = new Fretboard({  el: '#g-chord',  stringWidth: [1,1.5,2,3,4,5],  fretCount: 3});gChord.setDots([{    string: 5,    fret: 2,  },  {    string: 6,    fret: 3,  },  {    string: 1,    fret: 3,  }])gChord.render().style({  filter: ({string, fret}) => string === 5 && fret === 2,  fill: "yellow"}).style({  filter: ({string, fret}) => string === 6 && fret === 3,  fill: "blue"}).style({  filter: ({string, fret}) => string === 1 && fret === 3,  fill: "red"})</script><p>显然，style 方法的自定义性是最高的。</p><hr><p>关于和弦，各种调式的音阶，CAGED 和 TNPS 系统等，这里就先略过了，因为考虑到我当前没有使用其的需要，且官网示例已经足够丰富。下一步是运用这里学到的东西去描述一下蔡文展的指板系统中每个模块主音分别在 6，5，4，3 弦上的形状。</p>]]></content>
    
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对 Spring 一些工具类的索引</title>
    <link href="/2022/06-10%E5%AF%B9Spring%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E7%B4%A2%E5%BC%95.html"/>
    <url>/2022/06-10%E5%AF%B9Spring%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E7%B4%A2%E5%BC%95.html</url>
    
    <content type="html"><![CDATA[<p>Spring（和 Spring Boot） 提供了非常多实用的工具类，考虑到当前 Spring 已经成为 Java EE 开发的事实标准，学习 Spring 的工具类并将其运用到开发中是非常有意义的，<strong>特别是对于各种反射操作</strong>。</p><p>本来是想去系统学习一下的，但想想又没有必要，等用到的时候再去具体了解吧！但做一个索引供查阅还是比较有意义的。下面为我觉得比较重要的工具类，一级表项为项目名：</p><ul><li>spring-boot:<ul><li>org.springframework.boot.context.properties.PropertyMapper（手动 Bean 映射工具）</li><li>org.springframework.boot.task.TaskExecutorBuilder（线程池 Builder）</li></ul></li><li>spring-core:<ul><li>org.springframework.util.function.SingletonSupplier（“惰性求值”的 Supplier）</li><li>org.springframework.util.ClassUtils（获取类的各种属性）</li><li>org.springframework.util.CollectionUtils（各种集合操作）</li><li>org.springframework.util.PatternMatchUtils（仅实现<code>*</code>的字符串匹配工具，应当比正则更高效）</li><li>org.springframework.util.ReflectionUtils（各种奇妙的反射操作，相较于 ClassUtils 更倾向于去 make effect）</li><li>org.springframework.util.StopWatch（简单计时工具）</li><li>org.springframework.util.StreamUtils（IO 流操作）</li><li>org.springframework.util.StringUtils（常用字符串操作）</li><li>org.springframework.util.TypeUtils（继承关系计算）</li><li>org.springframework.core.annotation.AnnotatedElementUtils（注解获取）</li></ul></li><li>spring-data-commons（这些类居然放在 spring-data 下……但一般来说都会引用 redis，因此会引用该包）:<ul><li>org.springframework.data.util.StreamUtils（java8 Stream 操作，终于有 zip 了呜呜呜）</li><li>org.springframework.data.util.Optionals（关于 Optional 的一些操作）</li><li>org.springframework.data.util.ParsingUtils（切分驼峰命名法字符串）</li></ul></li></ul><p>其中，有一些我感觉比较重要，但是不知道应用场景&#x2F;没能力去使用的工具，需要对并发去进一步学习：</p><ul><li>spring-core:<ul><li>org.springframework.util.AutoPopulatingList</li><li>org.springframework.util.concurrent 包下的各种 Future</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Real World</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Excel 的导入导出</title>
    <link href="/2022/06-08%E5%85%B3%E4%BA%8EExcel%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html"/>
    <url>/2022/06-08%E5%85%B3%E4%BA%8EExcel%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</url>
    
    <content type="html"><![CDATA[<p>在上一家公司里，我根据需求使用 FastExcel 去抽象出了一个 excel 导出工具类，但在其中并没有去深入了解 Excel 的操作，而现在时机已到。</p><p>Java 处理 Excel 时，仍旧是使用最传统的 POI 较多（不是舰 C 的 <a href="https://zh.moegirl.org.cn/%E8%88%B0%E9%98%9FCollection:%E5%A4%95%E7%AB%8B">那只</a>），POI 的 <a href="https://poi.apache.org/index.html">官网</a> 见此，<strong>似乎没有成体系的文档</strong>，只有一些用例，但感觉这或许已经足够。</p><p>POI 是一个用于处理 word，excel，ppt 等 office 文件格式的巨型的工具库，但下面所说的 POI 指的都是其中操作 Excel 的部分——HSSF（对应 xls）和 XSSF（对应 xlsx），引入 poi 只需要引入 poi-ooxml 依赖（它包括 poi）：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi-ooxml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>下面尝试去专注这样几个场景：</p><ol><li>数据集的导入：即前端上传一个规范的 Excel 文件，其<strong>包含表头，每一行为一个实体</strong>，行数不定，需获取整个实体集合</li><li>数据集的导出：返回给前端一个规范的 Excel 文件，其包含表头，每一行为一个实体，行数不定</li><li>单个数据的导入：前端上传一个<strong>格式固定</strong>的 Excel 文件，<strong>整个 Excel 作为一个实体</strong></li><li>单个数据的导出（或者按照模板导出）：返回给前端一个格式固定的 Excel 文件，使用单个实体填充其中特定格</li></ol><h1 id="POI-的组成"><a href="#POI-的组成" class="headerlink" title="POI 的组成"></a>POI 的组成</h1><p>POI 对 Excel 的抽象有四个关键的类：Workbook，Sheet，Row 和 Cell，其中，Wookbook 代表整个 Excel 文件，Sheet 代表 Excel 中的一个表格（每一个 Excel 文件都包含多个表格，其通过左下角的选项卡进行切换），Row 代表一个表格中的一行，Cell 代表一个单元格。</p><p><img src="/images/oss/0e6a07bad86e6c5d5c7ec370baa1f576.jpg"></p><p>应当避免使用具体的 HSSF 和 XSSF 类以使代码更抽象，且同时适配 xls 和 xlsx 文件。</p><p>下面的实例主要来自官方文档的 quick-guide，见文章末尾链接。</p><h1 id="数据集的导入"><a href="#数据集的导入" class="headerlink" title="数据集的导入"></a>数据集的导入</h1><p>数据集导入场景要求读取现存的 Excel 文件并识别相关的 Bean，一般思路是：</p><ol><li>通过 Excel 文件&#x2F;流创建 Workbook</li><li>获取表头，知晓每一列对应的字段（当然，也可以用列数来直接区分）</li><li>获取剩余每一行并对其进行处理</li></ol><p>Workbook 能通过 File，InputStream 去构造，比如下面的代码从用户上传的文件中拿到流，并构造 Workbook 和 Sheet（假设是第一个 Sheet）。</p><p>下面通过一个轮子来描述数据集的导入，其将一个 Excel 转换成<code>List&lt;Map&lt;String, Object&gt;&gt;</code>，其中每一个 Map 为一个实体，key 为表头（因此该方法操作的 Excel 必须要有表头，且表头长度必须为 1，这是最简单的情况了）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">excelToCollection</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> sheetIndex)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// UserGuide 中也推荐使用 WorkbookFactory.create(in)</span><br>    <span class="hljs-type">Workbook</span> <span class="hljs-variable">wb</span> <span class="hljs-operator">=</span> WorkbookFactory.create(in);<br>    <span class="hljs-comment">// 获取指定 sheet</span><br>    <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> wb.getSheetAt(sheetIndex);<br>    <span class="hljs-comment">// 获取第一列和最后一列的 rownum</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">firstRowNum</span> <span class="hljs-operator">=</span> sheet.getFirstRowNum();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRowNum</span> <span class="hljs-operator">=</span> sheet.getLastRowNum();<br><br>    <span class="hljs-comment">// 获取表头</span><br>    <span class="hljs-type">Row</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> sheet.getRow(firstRowNum);<br>    List&lt;String&gt; headers = StreamSupport.stream(head.spliterator(), <span class="hljs-literal">false</span>)<br>            .map(Cell::getStringCellValue)<br>            .collect(Collectors.toList());<br><br>    <span class="hljs-keyword">return</span> IntStream.rangeClosed(firstRowNum + <span class="hljs-number">1</span>, lastRowNum)<br>            .mapToObj(sheet::getRow).map(row -&gt; &#123;<br>                Map&lt;String, Object&gt; obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>                StreamSupport.stream(row.spliterator(), <span class="hljs-literal">false</span>).forEach(cell -&gt; &#123;<br>                            obj.put(headers.get(cell.getColumnIndex()), getCellValue(cell));<br>                &#125;);<br>                <span class="hljs-keyword">return</span> obj;<br>            &#125;).collect(Collectors.toList());<br>&#125;<br><br>Object <span class="hljs-title function_">getCellValue</span><span class="hljs-params">(Cell cell)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (cell.getCellType()) &#123;<br>        <span class="hljs-keyword">case</span> _NONE: <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">case</span> BLANK: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">case</span> ERROR: <span class="hljs-keyword">return</span> cell.getErrorCellValue();<br>        <span class="hljs-keyword">case</span> STRING: <span class="hljs-keyword">return</span> cell.getStringCellValue();<br>        <span class="hljs-keyword">case</span> BOOLEAN: <span class="hljs-keyword">return</span> cell.getBooleanCellValue();<br>        <span class="hljs-keyword">case</span> NUMERIC:<br>        <span class="hljs-keyword">case</span> FORMULA: <span class="hljs-keyword">return</span> cell.getNumericCellValue();<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;无法识别&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对下面这个 Excel：</p><p><img src="/images/oss/QQ20220606-0.png"></p><p>其将得到这样的结果：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;名称&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;天海春香&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ID&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1.0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;事务所&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">765.0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;年龄&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">17.0</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;名称&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;如月千早&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ID&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2.0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;事务所&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">765.0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;年龄&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">17.0</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;名称&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;星井美希&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ID&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3.0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;事务所&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">765.0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;年龄&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">16.0</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></div></td></tr></table></figure><p>容易发现，对于这样的简单 Excel，可以要求使用者去直接给出一个<code>(Row, Headers) -&gt; T</code>，从而来方便生成<code>List&lt;T&gt;</code>。</p><h1 id="数据集的导出"><a href="#数据集的导出" class="headerlink" title="数据集的导出"></a>数据集的导出</h1><p>导出数据集就更加容易一些——生成表头，然后后续迭代数据集，一个元素一列即可（最麻烦的地方在于处理导出的类型，这里一股脑用字符串），下面的代码直接将一个元素的列表转为 Workbook，然后再另行导出。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Workbook <span class="hljs-title function_">createByCollection</span><span class="hljs-params">(Collection&lt;?&gt; elems)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, IOException &#123;<br>    List&lt;?&gt; lst = elems.stream()<br>            .filter(Objects::nonNull).collect(Collectors.toList());<br>    <span class="hljs-keyword">if</span> (lst.isEmpty()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;?&quot;</span>);<br>    &#125;<br><br>    Field[] fields = lst.get(<span class="hljs-number">0</span>).getClass().getDeclaredFields();<br>    <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> WorkbookFactory.create(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> workbook.createSheet();<br>    <span class="hljs-type">Row</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fields.length; i++) &#123;<br>        head.createCell(i);<br>        head.getCell(i).setCellValue(fields[i].getName());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lst.size(); i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rowNum</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> sheet.createRow(rowNum);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> lst.get(i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; fields.length; j++) &#123;<br>            row.createCell(j);<br>            row.getCell(j).setCellValue(fields[j].get(elem).toString());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> workbook;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>导出时使用 Workbook 的 write 方法，该方法接受一个输出流，下面的代码可以将 Workbook 转换成 Resource，从而方便在 Spring MVC 的情境中使用（效率存疑）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">arrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(arrayOutputStream);<br>workbook.write(output);<br>output.flush();<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayResource</span>(arrayOutputStream.toByteArray());<br></code></pre></div></td></tr></table></figure><h1 id="单个数据的导入导出"><a href="#单个数据的导入导出" class="headerlink" title="单个数据的导入导出"></a>单个数据的导入导出</h1><p>单个数据的导入导出相较于数据集的导入导出，差别是它的格式一般是固定的，这就是说<strong>数据的特定字段一般来说会对应 Excel 的特定位置</strong>，这说明两件事：</p><ol><li>我们需要“随机访问” Excel 的任意行列</li><li>Excel 中一定有东西是不变的，也就是说在构造 Excel 时，可以为这些不变的地方创建一个模板</li></ol><p>因此，归结出来，单个数据的导入导出情景详细描述如下，两者非常相像：</p><ol><li>导入：接受一个固定格式的 Excel，获取其中特定位置的值并构造一个实体</li><li>导出：以一个现有的 Excel 作为模板，使用一个实体去填充其中特定位置的值</li></ol><p>下面的代码实现了一个写入特定位置的方法，用户调用时指定位置到操作的映射。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setExcelValue</span><span class="hljs-params">(Sheet sheet, Map&lt;String, Consumer&lt;Cell&gt;&gt; cells)</span> &#123;<br>    cells.forEach((cellAddressStr, fn) -&gt; &#123;<br>        <span class="hljs-type">CellAddress</span> <span class="hljs-variable">cellAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CellAddress</span>(cellAddressStr);<br><br>        <span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> sheet.getRow(cellAddress.getRow());<br>        <span class="hljs-keyword">if</span> (row == <span class="hljs-literal">null</span>) row = sheet.createRow(cellAddress.getRow());<br>        <br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell</span> <span class="hljs-operator">=</span> row.getCell(cellAddress.getColumn());<br>        <span class="hljs-keyword">if</span> (cell == <span class="hljs-literal">null</span>) cell = row.createCell(cellAddress.getColumn());<br>        <br>        fn.accept(cell);<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 一个调用的实例</span><br>setExcelValue(sheet, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Consumer&lt;Cell&gt;&gt;()&#123;&#123;<br>    put(<span class="hljs-string">&quot;B1&quot;</span>, cell -&gt; cell.setCellValue(<span class="hljs-string">&quot;天海春香&quot;</span>));<br>    put(<span class="hljs-string">&quot;D1&quot;</span>, cell -&gt; cell.setCellValue(<span class="hljs-number">765</span>));<br>    put(<span class="hljs-string">&quot;B4&quot;</span>, cell -&gt; cell.setCellValue(<span class="hljs-number">17</span>));<br>&#125;&#125;);<br></code></pre></div></td></tr></table></figure><hr><p>这里涉及到的内容是比较少的，对于更加复杂的表格形式，以及样式等都没有顾及到，在性能上也需要进一步研究，等真正遇到时再说吧。</p><h1 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h1><ul><li><a href="https://poi.apache.org/components/spreadsheet/quick-guide.html">给大忙人看的 HSSF 和 XSSF 指南</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Real World</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Spring MVC 处理 form 和文件的实例</title>
    <link href="/2022/06-07%E5%85%B3%E4%BA%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E4%BE%8B.html"/>
    <url>/2022/06-07%E5%85%B3%E4%BA%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E4%BE%8B.html</url>
    
    <content type="html"><![CDATA[<h1 id="关于-MediaType"><a href="#关于-MediaType" class="headerlink" title="关于 MediaType"></a>关于 MediaType</h1><p>在此之前，得先了解下 HTTP 的 MediaType，<strong>MediaType 用来标识内容，即请求体和响应体的编码格式</strong>，HTTP 请求的 Header 中的 Accept 和 Content-Type，HTTP 响应的 Header 中的 Content-Type 都使用 MediaType 来标识，其中 Accept 表示请求者希望响应者发送的数据的格式，Content-Type 代表请求体和响应体的内容格式，一些<strong>最</strong>常见的格式见下。</p><blockquote><p><strong>GET 请求不应当携带请求体！</strong></p></blockquote><table><thead><tr><th align="center">MediaType</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">text&#x2F;html</td><td align="left">HTML 文本</td></tr><tr><td align="center">text&#x2F;plain</td><td align="left">纯文本，空格转换为+</td></tr><tr><td align="center">application&#x2F;json</td><td align="left">序列化的 JSON 格式</td></tr><tr><td align="center">application&#x2F;x-www-form-urlencoded</td><td align="left">键值对形式</td></tr><tr><td align="center">multipart&#x2F;form-data</td><td align="left">似乎啥都有</td></tr></tbody></table><blockquote><p>MediaType 包含三个部分——type，subtype 和 charset，其中 type 是&#x2F;前的值，subtype 是&#x2F;后的值，比如对于 text&#x2F;html，它的全格式是 <code>text/html; charset=UTF-8</code>，它的 type 是 text，subtype 是 html。</p></blockquote><p>在这里，<code>application/x-www-form-urlencoded</code>和<code>multipart/form-data</code>是这篇笔记的主角。</p><h1 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h1><p>application&#x2F;x-www-form-urlencoded 是最经典的格式了，它是键值对集合，其中键和值使用&#x3D;分隔，键值对之间使用&amp;分隔。容易意识到，URL 中？后面的部分就是这种格式，而实际上确实如此。</p><p>application&#x2F;x-www-form-urlencoded 是浏览器原生发送表单的默认格式，比如当前端编写这样的表单时，默认发送的就是这样的格式。<strong>application&#x2F;x-www-form-urlencoded 对于 GET 请求和 POST 请求，其行为不一样，处理方法也不一样</strong>。</p><p>form 元素有两个属性，method 和 enctype 需要配置，method 默认是 get，enctype 默认是 application&#x2F;x-www-form-urlencoded，但对于 GET 请求，enctype 是无效的，</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>考虑下面这个表单。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;//localhost:8080/something&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>firstName: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>lastName: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>点击按钮后，会发出这样的请求，其中<strong>表单数据通过请求体去发送了</strong>，因此有 Content-Type。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">POST /something2 HTTP/1.1<br><span class="hljs-section">Host: localhost:8080</span><br><span class="hljs-section">Content-Type: application/x-www-form-urlencoded</span><br><span class="hljs-section">Content-Length: 23</span><br>......<br></code></pre></div></td></tr></table></figure><p>相应接口的编写有这几种方式，可以看到这里<strong>一直都使用 RequestParam 去接受参数</strong>，这可能有些反直觉，因为在之前的实践中，我是认为 RequestParam 是专门用于获取 ? 后面的 kv 对的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE 可以省略</span><br><span class="hljs-meta">@PostMapping(value = &quot;/something&quot;, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)</span><br>String <span class="hljs-title function_">something</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String fname, <span class="hljs-meta">@RequestParam</span> String lname)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-meta">@PostMapping(value = &quot;/something1&quot;)</span><br>String <span class="hljs-title function_">something2</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, Object&gt; kvPairs)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 使用 RequestBody 就是破坏游戏规则了——这里它不管是什么 Content-Type，直接拿到原始数据，在这里是</span><br><span class="hljs-comment">// fname=hello&amp;lname=world</span><br><span class="hljs-meta">@PostMapping(value = &quot;/something2&quot;)</span><br>String <span class="hljs-title function_">something1</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String body)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>然后看 get，考虑下面的这个表单。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;//localhost:8080/something&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>firstName: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>lastName: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>点击 submit 后，会发出这个请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs curl">GET /something?fname=hello&amp;lname=world HTTP/1.1<br>Host: localhost:8080<br>...... 总之没有 Content-type<br></code></pre></div></td></tr></table></figure><p>需注意：<strong>请求中没有 Content-type 属性，该表单的数据通过 url 传递</strong>！</p><p>因此，对于使用 get 请求的表单，相应的接口需这样编写：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/something&quot;)</span><br>Object <span class="hljs-title function_">something</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String fname, <span class="hljs-meta">@RequestParam</span> String lname)</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>可见，其编写方式和暴露一个普通的 GET 接口别无二致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 x-www-form-urlencoded，无论是 GET 请求还是 POST 请求，都使用 RequestParam 去拿到参数，最好应显式指定要接受的 MediaType。</p><h1 id="form-data"><a href="#form-data" class="headerlink" title="form-data"></a>form-data</h1><p>form-data 也是键值对集合，但其相较于 x-www-form-urlencoded，能够方便地传递二进制数据（特别是文件），下面的实例不考虑 GET 请求。</p><p>考虑下面这样的表单。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;//localhost:8080/form&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>firstName: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>lastName: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>file: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>点击 submit 按钮时，发送的请求的请求头如下：</p><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/form</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:8080<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:101.0) Gecko/20100101 Firefox/101.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data; boundary=---------------------------54702276814275734151962949294<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>272849<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://localhost:8081<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://localhost:8081/<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>_ga=GA1.1.1104277080.1651411886<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">Sec-Fetch-Dest</span><span class="hljs-punctuation">: </span>document<br><span class="hljs-attribute">Sec-Fetch-Mode</span><span class="hljs-punctuation">: </span>navigate<br><span class="hljs-attribute">Sec-Fetch-Site</span><span class="hljs-punctuation">: </span>same-site<br><span class="hljs-attribute">Sec-Fetch-User</span><span class="hljs-punctuation">: </span>?1<br></code></pre></div></td></tr></table></figure><p>请求体如下：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran">-----------------------------<span class="hljs-number">54702276814275734151962949294</span><br>Content-Disposition: <span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; <span class="hljs-keyword">name</span>=<span class="hljs-string">&quot;fname&quot;</span><br><br>hello<br>-----------------------------<span class="hljs-number">54702276814275734151962949294</span><br>Content-Disposition: <span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; <span class="hljs-keyword">name</span>=<span class="hljs-string">&quot;lname&quot;</span><br><br>world<br>-----------------------------<span class="hljs-number">54702276814275734151962949294</span><br>Content-Disposition: <span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; <span class="hljs-keyword">name</span>=<span class="hljs-string">&quot;file&quot;</span>; filename=<span class="hljs-string">&quot;DC03A61BC35DBE767234514D3184BC84.jpg&quot;</span><br>Content-<span class="hljs-keyword">Type</span>: image/jpeg<br><br>...<br></code></pre></div></td></tr></table></figure><p>处理其的接口如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/form&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br>String <span class="hljs-title function_">form</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String lname, <span class="hljs-meta">@RequestParam</span> String fname, <span class="hljs-meta">@RequestPart</span> MultipartFile file)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>可见，这里使用 RequestPart 去拿到值，文件使用 MultipartFile 去拿。但仍旧可以使用 RequestParam，下面对注释的摘录介绍了 Requestparam 和 RequestPart 的区别：</p><blockquote><p>In Spring MVC, “request parameters” map to query parameters, form data, and parts in multipart requests. This is because the Servlet API combines query parameters and form data into a single map called “parameters”, and that includes automatic parsing of the request body.</p><p>Note that @RequestParam annotation can also be used to associate the part of a “multipart&#x2F;form-data” request with a method argument supporting the same method argument types. The main difference is that when the method argument is not a String or raw MultipartFile &#x2F; Part, @RequestParam relies on type conversion via a registered Converter or PropertyEditor while RequestPart relies on HttpMessageConverters taking into consideration the ‘Content-Type’ header of the request part. RequestParam is likely to be used with name-value form fields while RequestPart is likely to be used with parts containing more complex content e.g. JSON, XML).</p></blockquote><p>一些更复杂的使用需参考官方文档（tmd 这里全是宝啊！），有两点需注意：</p><ul><li>form-data 和 x-www-form-urlencoded 都允许重名的参数，可以通过 List 去全部获取到（<strong>需要使用 RequestParam</strong>）</li><li>多个文件能在同一个参数里，同一个参数的所有文件通过<code>List&lt;MultipartFile&gt;</code>去获取到，所有文件通过<code>MultiValueMap&lt;String, MultipartFile&gt;</code>去获取到（<strong>需要用 RequestParam</strong>）</li></ul><p>另外，对于这两种表单类型，想使用自定义类型（包括 Map）去接受参数时 Spring 会抱怨<code>no matching editors or conversion strategy found</code>，需要去在控制器中去自定义相应带 InitBinder 注解的方法并（定义和）注册相应 PropertyEditor，下面的代码注册了一个从字符串到 SomeBean 的 Binder，<strong>这个配置仅用于获取 query param 或 form data，使用 RequestBody 时不会被影响</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// SomeBean.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeBean</span> &#123;<br>    <span class="hljs-keyword">public</span> String a;<br>    <span class="hljs-keyword">public</span> String b;<br>&#125;<br><br><span class="hljs-meta">@InitBinder</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initBinder</span><span class="hljs-params">(WebDataBinder binder)</span> &#123;<br>    <span class="hljs-type">JsonMapper</span> <span class="hljs-variable">jsonMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonMapper</span>();<br>    binder.registerCustomEditor(SomeBean.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyEditorSupport</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAsText</span><span class="hljs-params">(String text)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>            System.out.println(<span class="hljs-string">&quot;rua!!!!!!!!&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.setValue(jsonMapper.readValue(text, SomeBean.class));<br>            &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>只要定义了类型 T 的<code>PropertyEditor</code>，则对<code>List&lt;T&gt;</code> Spring MVC 也能处理。</p><h1 id="关于文件的下载"><a href="#关于文件的下载" class="headerlink" title="关于文件的下载"></a>关于文件的下载</h1><p>前端上传文件说到底只有通过表单以 MultipartFile 上传这一种方式，而下载文件的方法也是需要学习的，Spring MVC 向前端返回文件有数种方式，这里都列举一下。</p><h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><p>直接把 InputStream 写入 HttpServletResponse 的流是使用最多，但最不优雅的方式，如果要使用它的话，就必须得把 HttpServletResponse 传递到服务层（如果保证控制器层不负责业务的话），这实在让人难以接受：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;...&quot;</span>;<br><span class="hljs-keyword">try</span>(<span class="hljs-type">InputStream</span> <span class="hljs-variable">fileStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>    <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> response.getOutputStream()) &#123;<br>    response.setContentType(<span class="hljs-string">&quot;application/octet-stream&quot;</span>);<br>    response.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>    response.setHeader(<span class="hljs-string">&quot;Content-disposition&quot;</span>, <span class="hljs-string">&quot;attachment; filename=&quot;</span> + URLEncoder.encode(fileName, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>    StreamUtils.copy(fileStream, stream); <span class="hljs-comment">// 这个函数来自 org.springframework.util.StreamUtils，用于把输入流的值写到输出流</span><br>&#125; <br></code></pre></div></td></tr></table></figure><h2 id="Resource，byte"><a href="#Resource，byte" class="headerlink" title="Resource，byte[]"></a>Resource，byte[]</h2><p><code>org.springframework.core.io.Resource</code>可以用来返回文件，可能常用的实现包括<code>ByteArrayResource</code>，<code>ClassPathResource</code>，<code>FileSystemResource</code>，<code>InputStreamResource</code>。虽然是题外话，但 <strong>Resource 类读取文件非常方便，应当代替直接使用 ClassLoader 去读取文件的行为</strong>。</p><blockquote><p>虽然<code>ClassPathResource</code>，<code>FileSystemResource</code>能拿到文件名，<strong>但是 Spring 仍会将其当作<code>text/html</code>来返回</strong>！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/resource&quot;)</span><br>Resource <span class="hljs-title function_">resource</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ClassPathResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;application.properties&quot;</span>);<br>    <span class="hljs-keyword">return</span> resource;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也可以直接返回<code>byte[]</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/byteArr&quot;)</span><br><span class="hljs-type">byte</span>[] byteArr() <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这两种都会默认按<code>text/html</code>去返回，如果想要它们返回文件，则需要在注解上添加<code>produces = MediaType.APPLICATION_OCTET_STREAM_VALUE</code>，这样虽然能让用户去下载到文件，但是<strong>文件名是无法修改的</strong>，这显然不太合适。</p><p>InputStream 作为返回值似乎是非法的。</p><h2 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h2><p>要想自定义文件名，就需要能够对响应头进行更多自定义，如果不想注入 HttpResponse，就只能去返回一个 ResponseEntity 了，而 ResponseEntity 用于返回文件是轻而易举的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/resource&quot;)</span><br>ResponseEntity&lt;Resource&gt; <span class="hljs-title function_">entity</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Resource</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;aloha.txt&quot;</span>);<br>    <span class="hljs-keyword">return</span> ResponseEntity.ok()<br>            .headers(header -&gt; &#123;<br>                header.setContentDisposition(<br>                    ContentDisposition.attachment()<br>                        .filename(file.getFilename()).build());<br>                header.setContentType(MediaType.APPLICATION_OCTET_STREAM);<br>            &#125;)<br>            .body(file);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我觉着这几乎是最友好的解决方案了，全程都没有使用魔法常量，并且符合通过返回值来回应前端请求这样的直觉，或许这就是最佳实践。</p><hr><p>实际上可以再发散一下，操作文件总是和操作流有着密不可分的关系，Spring 对流作为请求体这种情景有很好的支持，包括但不限于异步等的支持，对其进行学习是有些必要的。</p><p>这里其实还有一个比较重要的问题：上面所介绍的方法在 OpenFeign 中可用吗？之后再说吧。</p><h1 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/456921996">知乎：HTTP GET 请求可以有 body 吗？</a></li><li><a href="https://blog.csdn.net/u013827143/article/details/86222486">CSDN：form-data 和 x-www-form-urlencoded 的区别</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart-forms">Spring MVC 官方文档中关于 Multipart 的内容</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder">Spring MVC 官方文档中关于 Data Binder 的内容</a></li><li><a href="https://stackoverflow.com/questions/6463916/spring-mvc-no-matching-editors-or-conversion-strategy-found">Spring MVC no matching editors or conversion strategy found</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-output-stream">Spring MVC 官方文档中关于 HTTP 流的内容</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Real World</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>log4j2 配置实践</title>
    <link href="/2022/06-01log4j2%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5.html"/>
    <url>/2022/06-01log4j2%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5.html</url>
    
    <content type="html"><![CDATA[<p>到目前为止，我是如何 debug 的呢？当然是在本地跑起来，一通操作，然后紧盯控制台，坐等要关注的信息出现，这很多时候足以应付需要。可是若是生产环境出现了 bug，让咱去修复呢？这就引入了一堆问题——该在哪里去找日志？该如何去迅速找到自己想要的日志？再上升到理论，在开发的时候如何在出现 bug 时能给出最清晰明了的日志以帮助定位问题？</p><p>为此，必须去了解日志框架及其配置，以及最佳实践。现在使用的最为广泛的日志框架是 log4j2，其使用 slf4j 作为门面，因此对其进行学习。下面说的 log4j 指代 log4j2。</p><hr><p>log4j 作为一个日志框架，它和控制台输出相较有何区别？主要是<strong>它具有更高的自定义性和扩展性</strong>——它能控制日志的格式（除日志文本之外，还能带上时间，线程名，类名等，这通过用户给定的格式化字符串去配置），能控制日志的目的地，能控制日志输出级别…这些玩意都在一个配置文件中进行配置，因此修改不需要更改源代码。</p><p>log4j 的官方文档处记录了一些关于 log4j 的 <a href="https://logging.apache.org/log4j/2.x/articles.html">文章</a>，官网中关于 log4j 的 <a href="https://logging.apache.org/log4j/2.x/manual/architecture.html">架构文档</a> 也是值得阅读的。</p><p>log4j 有三个重要组件：Logger，Appender，Layout，其中 Logger 抽象特定日志级别的日志打印器，如 ERROR 级别，FATAL 级别，INFO 级别；Appender 抽象日志的目的地，如文件，控制台；Layout 抽象日志的格式，如格式化形式，HTML 形式。</p><blockquote><p>或许可以说，日志框架有三个要素：打印什么种类的日志？打印到哪里去？打印什么内容？</p></blockquote><h1 id="何谓日志级别"><a href="#何谓日志级别" class="headerlink" title="何谓日志级别"></a>何谓日志级别</h1><p>这里首先引入了一个新概念——什么是日志级别？显然，我们打的日志本身就是分场合的——展示特定信息的，追溯请求全流程的，仅用于 debug 的，打印错误的，将日志的“场合”抽象出来对规范的日志有利。</p><p>但是，日志框架所抽象出来的并非是日志“种类”，而是日志<strong>级别</strong>，虽然不知道为何这样设计，但既然都这样实践这么多年了……</p><p>log4j 有 8 个级别，按优先级降序排序：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">OFF &gt; FATAL &gt; <span class="hljs-built_in">ERROR</span> &gt; WARN &gt; <span class="hljs-built_in">INFO</span> &gt; <span class="hljs-built_in">DEBUG</span> &gt; TRACE &gt; ALL<br></code></pre></div></td></tr></table></figure><ol><li><code>OFF</code>：Nothing！</li><li><code>FATAL</code>：指明足以终止程序运行的事件，比如连接数据库失败，必需的配置未找到</li><li><code>ERROR</code>：指明错误，但应用可继续运行（用户的输入错误应当放到 WARN）</li><li><code>WARN</code>：指明可能导致错误的事件，或有必要提醒的事件</li><li><code>INFO</code>：程序运行描述信息，粒度较粗</li><li><code>DEBUG</code>：细粒度的描述信息，主要用于帮助 debug</li><li><code>TRACE</code>：程序运行轨迹，最细的粒度</li><li><code>ALL</code>：Everything！</li></ol><blockquote><p>FATAL 是“致命的”，在有些语言里也用 CRITICAL</p></blockquote><p>可以认为 OFF 和 ALL 是标识性的，没有日志处在 OFF 级别，ALL 级别代表所有日志（自定义的日志级别可能在 ALL 级别上才打印）。</p><p><strong>当设置日志级别为特定的优先级的时候，只有大于等于该优先级的日志会被打印</strong>，比如，当我们设置优先级为 INFO 的时候，只有 FATAL，ERROR，WARN，INFO 的信息得到打印。</p><h1 id="Learn-log4j2-xml-in-Y-Minutes"><a href="#Learn-log4j2-xml-in-Y-Minutes" class="headerlink" title="Learn log4j2.xml in Y Minutes"></a>Learn log4j2.xml in Y Minutes</h1><p>log4j 的配置是最重要的一部分（想必也不会有几个人去自定义 Appender 之类的，因此对其的使用，即配置是最重要的），至于具体使用，则留给 slf4j。这里我认为直接采取类似<code>Learn X in Y Minutes</code>的形式即可，描述直接结合配置，事半功倍鸭！</p><blockquote><p>考虑到当前对日志框架没必要深入（长期基本也没必要深入，毕竟是配置文件，试错成本低），因此只学习最基本的东西。</p></blockquote><p>官方的关于配置的文档见 <a href="https://logging.apache.org/log4j/2.x/manual/configuration.html">此</a>，未免讲的有点过于宽泛了吧？</p><h2 id="log4j-的默认配置"><a href="#log4j-的默认配置" class="headerlink" title="log4j 的默认配置"></a>log4j 的默认配置</h2><p>下面展示的是 log4j 没有检查到任何配置时的默认配置，十分沉默，只有 FATAL 和 ERROR 的日志会被输出（到控制台）。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!-- status 是 log4j 自己的日志级别 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Appender 的 name 仅供引用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>这里定义了一个 Appender 和一个 Logger，Appender 代表日志的目的地，这里是控制台，其目标是标准输出流；Logger 代表日志打印者，这里的 Logger 是<strong>根日志打印器 Root</strong>，这代表所有日志如果没有被其它日志打印器“拦截”的话，就会来到根日志打印器。</p><p>这里的 Appender 使用 PatternLayout（显然，Appender 要使用特定的 Layout，直接将其包含在自己的子标签中即可）。</p><p>默认配置用一句话去概述，就是<strong>所有优先级大于等于 ERROR 的日志会送往标准输出流，其它的忽略</strong>，这显然仅供测试时 DEBUG 使用，无法适应生产环境。</p><h2 id="打印日志到文件"><a href="#打印日志到文件" class="headerlink" title="打印日志到文件"></a>打印日志到文件</h2><p>要打印日志到文件，就得先添加作为文件的目的地，并在日志打印器中去引用它，代码类似下面。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logFile&quot;</span>&gt;</span>logs/thelog.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Appender 的 name 仅供引用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;File&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;logFile&#125;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;File&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>这样配置，所有大于等于 INFO，即 INFO，WARN，ERROR，FATAL 的日志会被同时输出到文件<code>logs/thelog.log</code>和控制台上。</p><p>Properties 用于定义可重用的字符串常量。</p><h2 id="分离不同级别的日志"><a href="#分离不同级别的日志" class="headerlink" title="分离不同级别的日志"></a>分离不同级别的日志</h2><p>先声明，想让某特定级别的日志输出到特定位置不一定不能实现，但是是没有实践意义的。</p><p>考虑这样的需求，我们想把所有 INFO 以上的日志都打印到控制台，把所有 WARN 以上的日志都打印到特定文件以供查阅，这通过<strong>配置 AppenderRef 的级别</strong>去实现。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!-- status 是 log4j 自己的日志级别 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logFile&quot;</span>&gt;</span>logs/warn.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Appender 的 name 仅供引用 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;logFile&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注意：<strong>AppenderRef 的级别设置的比 Logger 的级别更低是无效的</strong>，比如 Logger 级别设置为 INFO，AppenderRef 的级别设置为 TRACE，则仍旧只有 INFO 及以上的日志会来到该 Appender。</p><h2 id="分离框架和业务代码的日志"><a href="#分离框架和业务代码的日志" class="headerlink" title="分离框架和业务代码的日志"></a>分离框架和业务代码的日志</h2><p>再进一步，我们想要能够<strong>分离框架的日志和业务的日志</strong>，这样来更好地帮助 debug；同时，我们也想<strong>在某个地方能同时看到所有的日志</strong>。为此，需要定义额外的 logger 了，但代码仍旧是比较容易理解的。</p><p>这里需要引入两个新概念：Logger 的 Name，以及 additivity，Logger 的 Name 一般情况下使用包名，这代表<strong>这个包下的类打的日志会来到这个 Logger</strong>；additivity 则表示这个 Logger 是否会<strong>在处理这个日志后把这个日志“冒泡”到父 Logger</strong>（是的，Logger 有继承性），默认为 true，即冒泡。</p><blockquote><p>Logger 的 Name 通常使用包名，这是由于我们在业务代码中 getLogger 时通常是通过全限定类名，如果随便写的话那肯定全跑 Root 上去了。</p></blockquote><p>从需求出发：我们要让框架的日志输出到<code>logs/framework.log</code>，业务的日志输出到<code>logs/bussiness.log</code>，<strong>控制台上只输出框架日志</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!-- status 是 log4j 自己的日志级别 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logDir&quot;</span>&gt;</span>logs<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;frameworkLogFile&quot;</span>&gt;</span>$&#123;logDir&#125;/framework.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bussinessLogFile&quot;</span>&gt;</span>$&#123;logDir&#125;/bussiness.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Appender 的 name 仅供引用 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;framework&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;frameworkLogFile&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;SPRING    %d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bussiness&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;bussinessLogFile&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;BUSSINESS %d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;me.yuuki&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bussiness&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;TRACE&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;framework&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>上面的配置会达到下面的结果：</p><ul><li><code>me.yuuki</code>包下的 WARN 级别及以上的日志会去到<code>logs/bussiness.log</code></li><li><code>org.springframework</code>包下的 TRACE 级别及以上的日志会去到<code>logs/framework.log</code>和控制台（注意，<strong>TRACE 及以上的日志都会去到控制台</strong>！这就是说 Root 的 level 设置被“覆盖”掉了）</li><li>其它包下的 INFO 级别及以上的日志会去到控制台</li></ul><h2 id="关于-Logger-的继承性"><a href="#关于-Logger-的继承性" class="headerlink" title="关于 Logger 的继承性"></a>关于 Logger 的继承性</h2><p>Logger 使用 NAME 来表示继承性——不考虑相等的情况，如果 Logger A 的 NAME 是 Logger B 的 NAME 的前缀（其实还得带上一个<code>.</code>），则 B 是 A 的子类，比如，<code>me.yuuki.dao</code>是<code>me.yuuki</code>的子类，同时一切 Logger 都是 Root 的子类。</p><p>从当前看来，继承性主要表现在三个地方：</p><ol><li>子类的日志能够冒泡到父类</li><li>子类的日志级别会使用父类的级别如果没有配置</li><li>子类的日志级别会覆盖父类的日志级别</li></ol><blockquote><p>Root 的默认级别为 ERROR。</p></blockquote><p>比如上面的例子中，<code>me.yuuki</code>设置不冒泡，因此只自己处理了；<code>org.springframework</code>的日志级别是 TRACE，因此覆盖了 Root 的 INFO，因此打到<code>org.springframework</code>的日志打到 Root，即输出到控制台上的是 TRACE 级别。</p><p>比如，下面的配置将<code>me.yuuki.dao</code>的日志输出到<code>logs/dao.log</code>，<code>me.yuuki.service</code>的日志输出到<code>logs/service.log</code>，<code>me.yuuki</code>（除<code>dao</code>）的日志输出到<code>logs/bussiness.log</code>，所有日志输出到控制台。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!-- status 是 log4j 自己的日志级别 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logDir&quot;</span>&gt;</span>logs<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;daoLogFile&quot;</span>&gt;</span>$&#123;logDir&#125;/dao.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;serviceLogFile&quot;</span>&gt;</span>$&#123;logDir&#125;/service.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;BizLogFile&quot;</span>&gt;</span>$&#123;logDir&#125;/bussiness.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Appender 的 name 仅供引用 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dao&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;daoLogFile&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;service&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;serviceLogFile&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bussiness&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;BizLogFile&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;me.yuuki.dao&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dao&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;me.yuuki.service&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;service&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;me.yuuki&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bussiness&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这个级别会影响上面的所有 Logger，因为它们没有配置 level --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;TRACE&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="在测试和生产环境使用不同配置"><a href="#在测试和生产环境使用不同配置" class="headerlink" title="在测试和生产环境使用不同配置"></a>在测试和生产环境使用不同配置</h2><p>如何<strong>在不改变配置文件的情况下</strong>让配置文件能直接在测试和生产环境中同时使用？显然我们需要一个类似 profile 之类的东西，而 log4j 确实提供了这种功能，负责该功能的实体称为 Arbiter，仲裁者。仲裁者的行为就像某些语言的 when 语句，或 mybatis 的 if 语句，但有一些更复杂的标签使其能实现 switch 的功能。</p><p>下面就两种复杂程度不同的 Arbiter 配置进行描述，when 和 switch 这两个关键字描述它们的行为再适合不过。但 arbiter 能出现的地方远不止于此，容易找到更优雅的编写方案。</p><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>下面的代码使用了 SystemPropertyArbiter，它根据系统属性 env 的值进行裁决，在生产环境时将文件输出到<code>/tmp/prod.log</code>上，在开发环境时输出到<code>logs/dev.log</code>上。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这个参数需要用 -D 去给进去，很蛋疼 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">SystemPropertyArbiter</span> <span class="hljs-attr">propertyName</span>=<span class="hljs-string">&quot;env&quot;</span> <span class="hljs-attr">propertyValue</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logFile&quot;</span>&gt;</span>logs/dev.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">SystemPropertyArbiter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">SystemPropertyArbiter</span> <span class="hljs-attr">propertyName</span>=<span class="hljs-string">&quot;env&quot;</span> <span class="hljs-attr">propertyValue</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logFile&quot;</span>&gt;</span>/tmp/prod.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">SystemPropertyArbiter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>但是最常用的当然还是 Spring boot profile：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">SpringProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev | test&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logFile&quot;</span>&gt;</span>logs/dev.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">SpringProfile</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">SpringProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logFile&quot;</span>&gt;</span>/tmp/prod.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">SpringProfile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>实现 switch 要使用 SELECT 标签，它的所有子标签都为 Arbiter，<strong>它会找到第一个为真的 Arbiter 并应用</strong>，log4j 提供了一个 DefaultArbiter，它始终为真。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">SystemPropertyArbiter</span> <span class="hljs-attr">propertyName</span>=<span class="hljs-string">&quot;env&quot;</span> <span class="hljs-attr">propertyValue</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logFile&quot;</span>&gt;</span>logs/dev.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">SystemPropertyArbiter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">SystemPropertyArbiter</span> <span class="hljs-attr">propertyName</span>=<span class="hljs-string">&quot;env&quot;</span> <span class="hljs-attr">propertyValue</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logFile&quot;</span>&gt;</span>/tmp/prod.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">SystemPropertyArbiter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">DefaultArbiter</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logFile&quot;</span>&gt;</span>logs/others.log<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultArbiter</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="切割切割！"><a href="#切割切割！" class="headerlink" title="切割切割！"></a>切割切割！</h3><p>但何不做得更绝一些，完成一些彻底的切割？</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">SystemPropertyArbiter</span> <span class="hljs-attr">propertyName</span>=<span class="hljs-string">&quot;env&quot;</span> <span class="hljs-attr">propertyValue</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- +++++++++++++++开发环境+++++++++++++++ --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;logs/dev.log&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span> /&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">SystemPropertyArbiter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">SystemPropertyArbiter</span> <span class="hljs-attr">propertyName</span>=<span class="hljs-string">&quot;env&quot;</span> <span class="hljs-attr">propertyValue</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- +++++++++++++++生产环境+++++++++++++++ --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;logs/prod.log&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span> /&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">SystemPropertyArbiter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">DefaultArbiter</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- +++++++++++++++默认配置+++++++++++++++ --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultArbiter</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="关于-PatternLayout"><a href="#关于-PatternLayout" class="headerlink" title="关于 PatternLayout"></a>关于 PatternLayout</h2><p>PatternLayout 即格式化日志输出，使用一个模式字符串去作为格式，这应该是使用最广泛的 Layout，关于其使用的各种模式，直接翻 <a href="https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout">文档</a> 吧，这里给一个例子。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- %date 表示日期，%thread 表示线程名，%-5level：级别从左显示 5 个字符宽度 %msg：日志消息，%n 是换行符 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %t ] [%c&#123;1.&#125;] - [ %p ]  %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="关于-Appender"><a href="#关于-Appender" class="headerlink" title="关于 Appender"></a>关于 Appender</h2><p>关于 Appender 的文档见 <a href="https://logging.apache.org/log4j/2.x/manual/appenders.html">此</a>，仍旧是给出示例。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Appender，追加器，表示日志的目的地 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加一个控制台追加器，目标是标准输出流  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span> <span class="hljs-attr">follow</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--添加一个文本追加器，文件位于根目录下，名为 server.log--&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;RollingFile name=&quot;File&quot; fileName=&quot;$&#123;FILE_PATH&#125;/platform.log&quot; filePattern=&quot;$&#123;FILE_PATH&#125;/platform/$$&#123;date:yyyy-MM&#125;/%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;File&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/platform.log&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/platform/$$&#123;date:yyyy-MM&#125;/%d&#123;yyyy-MM-dd&#125;-%i.log&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;50MB&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;1000&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- commonFile 无特殊用途，仅做日志模版用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;commonFile&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/common.log&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/common/$$&#123;date:yyyy-MM&#125;/%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;50MB&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- &lt;TimeBasedTriggeringPolicy modulate=&quot;true&quot; interval=&quot;1&quot; /&gt; --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;1000&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Real World</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>todo.txt 简明教程</title>
    <link href="/2022/05-04todo-txt%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B.html"/>
    <url>/2022/05-04todo-txt%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/todotxt/todo.txt">todo.txt</a> 是一种使用纯文本形式来表示 TODO 清单的一个格式，考虑对其进行一些了解。然后也学习一下 <a href="https://github.com/todotxt/todo.txt-cli">todo.txt-cli</a> 的使用，它是一个使用 shell 去实现的，控制台的 todo.txt 文件管理脚本。</p><p>并考虑再之后研究之后能否用 Scala 对<code>todo.txt-cli</code>的接口进行一个实现，并使用 OSS 作为存储以符合我的同步需求；用 Scala 的原因既是因为它足够好用，能让我去实践一下 FP，也是因为它能够编译成 js——我希望能在浏览器等平台上去运行它。</p><h1 id="todo-txt"><a href="#todo-txt" class="headerlink" title="todo.txt"></a>todo.txt</h1><p>todo.txt 使用纯文本形式来保存 TODO 清单，其最重要的规则是，<strong>一行一个 TODO</strong>，它的语法如下。</p><svg xmlns="http://www.w3.org/2000/svg" id="svg2" viewBox="0 0 632.2 281">    <style>        .st0{font-family:Courier;font-size:12px;}        .st1{fill:none;stroke:#000000;stroke-miterlimit:10;}        .st2{font-family:Arial;font-size:10px;}    </style>    <rect width="100%" height="100%" fill="#FFF"/>    <text class="st0" transform="translate(4.024 172.96)">        x (A) 2022-05-16 2022-05-01 learn SpringMVC +chapelShelving @chapel due:2016-05-30    </text>    <path d="M15.2 159v-6H.5v6m36 0v-6H21.8v6m96.5 0v-6H47.5v6m149.3 0v-6H126v6m483.7.2V153H206v6.1m238.7 22.8v7.2H335V182m274.7-.1v7.2H509V182m-7.5-.1v7.2h-49.1V182" class="st1"/>    <text class="st2" transform="rotate(-45 161.175 55.627)">        可选 — 标识完成（必须为小写 x）    </text>    <text class="st2" transform="rotate(-45 171.8 29.976)">        可选 -- 标识优先级（A-Z）    </text>    <text class="st2" transform="rotate(-45 198.684 -34.92)">        可选 -- 完成日期    </text>    <text transform="rotate(-45 237.935 -129.68)">        <tspan x="0" y="0" class="st2">可选 -- 创建日期</tspan>        <tspan x="0" y="12" class="st2">如果只出现一个日期，则认为是创建日期</tspan>    </text>    <text transform="rotate(-45 352.18 -405.478)">        <tspan x="0" y="-16" class="st2">描述和 tag（可选）</tspan>        <tspan x="0" y="0" class="st2">tags 可以出现在任何地方，</tspan>        <tspan x="0" y="12" class="st2">名称由非空字符串组成</tspan>    </text>    <text class="st2" transform="rotate(45 -60.77 576.533)">        项目 tag    </text>    <text class="st2" transform="rotate(45 -17.238 681.627)">        上下文 tag    </text>    <text class="st2" transform="rotate(45 23.978 781.127)">        KV tag    </text></svg><p><code>todo.txt</code>的格式是十分自由的，其设计初衷之一就是要求人类和机器均可读。对每一个 TODO，其有三个维度：</p><ol><li><strong>优先级</strong>：最重要的 TODO 要能够先出现，其通过<code>(A-Z)</code>的语法表示。</li><li><strong>项目</strong>：TODO 应该能够从属于特定项目——人类解决复杂问题的方式就是将其分解为一个个更容易解决的子问题并着手解决。</li><li><strong>上下文</strong>：一个 TODO 要在哪里，在怎样的情况下去完成，换句话说，TODO 的上下文，是需要能够表示的，这样就能让人去关注在当前能够去做的事情。（这似乎是某种称为 <a href="https://en.wikipedia.org/wiki/Getting_Things_Done">GTD，Getting Things Done</a> 的哲学，之后去了解一番）</li></ol><p>项目使用<code>+</code>语法去表示，上下文通过<code>@</code>语法去表示，两者都接受非空字符串作为名称，两者都可以出现任意次数。</p><p>比如，下面指定一个最高优先级的，处在学习项目的，上下文为下班后的 TODO：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs todo.txt">(A) @下班后 +学习 Spring MVC<br></code></pre></div></td></tr></table></figure><blockquote><p>我感觉这并非是一个最佳实践——这个 TODO 太大了：学习？学哪个部分？使用还是原理？我认为，项目应当是“+learnSpringMVC”，描述应该是 “中的 blablala”，即：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">(<span class="hljs-selector-tag">A</span>) @下班后 +learnSpringMVC RestController<br></code></pre></div></td></tr></table></figure></blockquote><p>然后是 KV tag，这是供开发者去使用的 metadata，语法是<code>key:value</code>。</p><p><code>todo.txt</code>就这些东西…简单，但优雅。</p><h1 id="todo-txt-cli"><a href="#todo-txt-cli" class="headerlink" title="todo.txt-cli"></a>todo.txt-cli</h1><p><code>todo.txt-cli</code>是官方提供的命令行下管理<code>todo.txt</code>的脚本，这里介绍它的使用。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>MacOS 和 Linux 可直接使用，Win 用户可使用 Git For Bash 等终端。</p><p>在 <a href="https://github.com/todotxt/todo.txt-cli">官方仓库</a> 下载<code>todo.sh</code>和<code>todo.cfg</code>，其中将<code>todo.sh</code>放置到 PATH 中（下面的示例将其改名为<code>todo</code>），将<code>todo.cfg</code>重命名为<code>~/.todo.cfg</code>，然后编辑<code>.todo.cfg</code>，将<code>TODO_DIR</code>变量修改为更合适的位置，比如<code>export TODO_DIR=$&#123;HOME:-$USERPROFILE&#125;/.todo</code>（原配置放到用户目录，简直了！）</p><p>然后进行测试，输入<code>todo add &#39;Hello, Happy World!&#39;</code>，并检查<code>~/.todo/todo.txt</code>是否有数据。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>先创建测试“数据”，直接编辑<code>todo.txt</code>或者通过<code>todo add</code>命令：</p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">(A) +健身 <span class="hljs-meta">@早晨</span> <span class="hljs-meta">@晚上</span> <span class="hljs-meta">@楼下</span> 各跳绳 500 个<br>(C) +英语 <span class="hljs-meta">@晚上</span> 完成扇贝阅读一篇文章<br>(A) +吉他 yousician 30 分钟<br>(B) +吉他 +辨识 200 个 note<br>+吉他 完成练习二<br></code></pre></div></td></tr></table></figure><ul><li><p>列出所有 TODO：<br><code>todo list</code>（或者<code>todo ls</code>）</p></li><li><p>添加新 TODO：<br><code>todo add &#39;+吉他 爬格子&#39;</code></p></li><li><p>完成特定 TODO，其中 TODO 通过行号指定（在 list 时会显示）：<br><code>todo done 1</code>（或者<code>todo do 1</code>）</p></li><li><p>删除特定 TODO：<br><code>todo rm 1</code></p></li><li><p>列出所有带字符串“完成”的 TODO：<br><code>todo ls 完成</code></p></li><li><p>列出所有<strong>不</strong>带“完成”的 TODO：<br><code>todo ls -完成</code></p></li><li><p>列出所有项目或上下文：<br><code>todo lsprj</code><br><code>todo lsc</code></p></li><li><p>列出所有带吉他项目的 TODO 中出现的项目：<br><code>todo lsprj 吉他</code></p></li></ul><p>先就这些。更多的不如去翻它的 <a href="https://github.com/todotxt/todo.txt-cli/blob/master/USAGE.md">文档</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Foo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Scala 函数式编程》解题笔记——第一部分</title>
    <link href="/2022/04-28%E3%80%8AScala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.html"/>
    <url>/2022/04-28%E3%80%8AScala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.html</url>
    
    <content type="html"><![CDATA[<p>考虑对每个练习都自己实现一波，尽量使用最纯的方式，即不仅函数本身是纯的，内部也不有任何局部的副作用（这在工程实践中肯定是不好的）。</p><h1 id="2-1-尾递归的斐波那契"><a href="#2-1-尾递归的斐波那契" class="headerlink" title="2.1 尾递归的斐波那契"></a>2.1 尾递归的斐波那契</h1><p>题目要求写一个递归函数，获取第 n 个斐波那契数。第一个和第二个斐波那契数分别为 0，1。</p><p>这一题讨论了尾递归函数，以及嵌套（局部）函数定义，其实现是比较显然的。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>  <span class="hljs-meta">@tailrec</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>, n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = <br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) a <span class="hljs-keyword">else</span> go(b, a + b, n - <span class="hljs-number">1</span>)<br>  go(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, n)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一般该尾递归的辅助函数会命名为 go 或 loop（Haskell 里似乎喜欢叫 helper）。应当显式地增加<code>@tailrec</code>注解，以保证编译器会将其进行尾递归优化。如果优化无法进行，则将无法通过编译。</p><h1 id="2-2-isSorted"><a href="#2-2-isSorted" class="headerlink" title="2.2 isSorted"></a>2.2 isSorted</h1><p>该题要求实现一个 isSorted 方法，签名为<code>def isSorted[A](as: Array[A], ordered: (A, A) =&gt; Boolean): Boolean</code>。该题考查泛型（类型变量）的使用，类型变量就像函数参数一样，函数参数在函数体中引用，而类型变量在类型中引用。</p><p>也需要注意，这里使用的是 Array，因此不用考虑像 Haskell 中的 List 那样递归，使用索引进行递归即可。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSorted</span></span>[<span class="hljs-type">A</span>](as: <span class="hljs-type">Array</span>[<span class="hljs-type">A</span>], ordered: (<span class="hljs-type">A</span>, <span class="hljs-type">A</span>) =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Boolean</span> = &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span></span>(index: <span class="hljs-type">Int</span>): <span class="hljs-type">Boolean</span> = &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= as.length) <span class="hljs-literal">true</span> <span class="hljs-comment">// 基线条件</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordered(as(index - <span class="hljs-number">1</span>), as(index))) go(index + <span class="hljs-number">1</span>) <span class="hljs-comment">// 每次比较 index - 1 和 index</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-literal">false</span><br>  &#125;<br>  go(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意的是，这玩意如果要调用的话，直接写<code>isSorted(Array(1,2,2),_ &lt;= _)</code>是不行的，这是 Scala 类型系统一个非常蛋疼的地方——仅从第一个参数 as 的类型输入里，它居然推不出第二个参数 ordered 的具体类型。就连 Java 也能干这个鸭！</p><p>解决方案有几个——指定函数的参数（也可以带上返回值，但没必要），强制指定类型 A，强制指定 ordered 的类型，使用柯里化函数重新定义 isSorted 并调用，它们的语法分别为：</p><ul><li><code>isSorted(Array(1,2,2), (x: Int, y: Int) =&gt; x &lt;= y)</code></li><li><code>isSorted[Int](Array(1,2,2),_ &lt;= _)</code></li><li><code>isSorted(Array(1, 2, 2), (_ &lt;= _) : (Int, Int) =&gt; Boolean)</code></li><li><code>isSorted(Array(1,2,2))(_ &lt;= _)</code></li></ul><p>显然，只有第二种和第四种是比较合适的，Scala 的几个高阶函数比如 fold 等使用第四种方法。</p><h1 id="2-3-curry"><a href="#2-3-curry" class="headerlink" title="2.3 curry"></a>2.3 curry</h1><p>这三个都是比较经典的题目了——柯里化，反柯里化，函数组合。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">curry</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span> =&gt; <span class="hljs-type">C</span> = a =&gt; b =&gt; f(a, b)<br></code></pre></div></td></tr></table></figure><h1 id="2-4-uncurry"><a href="#2-4-uncurry" class="headerlink" title="2.4 uncurry"></a>2.4 uncurry</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uncurry</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](fn: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span> =&gt; <span class="hljs-type">C</span>): (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span> = (a, b) =&gt; fn(a)(b)<br></code></pre></div></td></tr></table></figure><h1 id="2-5-compose"><a href="#2-5-compose" class="headerlink" title="2.5 compose"></a>2.5 compose</h1><p>Haskell 中的 compose 就是<code>.</code>函数。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)<br><span class="hljs-title">f</span> . g = \x -&gt; f(g(x))<br></code></pre></div></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compose</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">C</span>, g: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">A</span> =&gt; <span class="hljs-type">C</span> = x =&gt; f(g(x))<br></code></pre></div></td></tr></table></figure><h1 id="3-1-模式匹配"><a href="#3-1-模式匹配" class="headerlink" title="3.1 模式匹配"></a>3.1 模式匹配</h1><p>这就不是道编程题，答案是 3，模式匹配会从上往下匹配，找到第一个匹配到的。</p><h1 id="3-2-tail"><a href="#3-2-tail" class="headerlink" title="3.2 tail"></a>3.2 tail</h1><p>tail 也是一个经典的函数，这里有个问题，就是如果原 List 是 Nil 的时候，tail 该返回什么？在 Haskell 中，此举会抛出异常，可以写一个全函数——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tail</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> _::xs =&gt; xs<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其它选择是使用 Option，Try 等，抛出异常是中策，返回 null 是下下下策。</p><h1 id="3-3-setHead"><a href="#3-3-setHead" class="headerlink" title="3.3 setHead"></a>3.3 setHead</h1><p>重设列表的 head。函数式的 setter 是怎样的呢？这样。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setHead</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], neoHead: <span class="hljs-type">A</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> _::xs =&gt; neoHead::xs<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-4-drop"><a href="#3-4-drop" class="headerlink" title="3.4 drop"></a>3.4 drop</h1><p>移除掉前 n 个元素，返回剩下的就是 drop 函数。这里一个问题是如果 n 大于列表的长度时该怎么解决，这里返回 Nil。n 小于 0 的时候按等于 0 考虑。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drop</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], n: <span class="hljs-type">Int</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> _::xs <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> =&gt; drop(xs, n - <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">case</span> _ =&gt; l<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-5-dropWhile"><a href="#3-5-dropWhile" class="headerlink" title="3.5 dropWhile"></a>3.5 dropWhile</h1><p>有时候会把 take 和 drop 混淆，想象 take 把前面的元素“拿起来”，drop 把前面的元素“丢掉”。takeWhile 就是一直“拿”，直到不符合；dropWhile 就是一直“丢”，直到不符合。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dropWhile</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> x::xs <span class="hljs-keyword">if</span> p(x) =&gt; dropWhile(xs, p)<br>  <span class="hljs-keyword">case</span> _ =&gt; l<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-6-init"><a href="#3-6-init" class="headerlink" title="3.6 init"></a>3.6 init</h1><p>在 List 头部增加元素是常量级的开销，但在尾部进行操作就不是如此了，为了在尾部进行操作，之前的每一个元素都要被修改。想象一下一个链表<code>1 -&gt; 2 -&gt; 3 -&gt; Nil</code>，现在要在尾部添加一个元素 4，这时候若要保证原链表不变，则必须将整个链表复制一份，再在尾部添加一个元素；但是若在头部添加呢？直接上即可。新的链表是<code>4 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; Nil</code>，对原链表<code>1 -&gt; 2 -&gt; 3 -&gt; Nil</code>来说，它不需要做任何改变。同理，在尾部减少元素时，将整个列表拷贝一份也是必须的。</p><p>实现 init 时考虑和普通的递归函数一样的编写流程，对于<code>[x]</code>，这是基线条件，返回<code>[]</code>，然后对其它列表<code>x::xs</code>，则直接原样拼接即可。init 对于空列表就比较麻了，这里不多想，直接抛异常。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">&quot;empty list&quot;</span>)<br>  <span class="hljs-keyword">case</span> _::<span class="hljs-type">Nil</span> =&gt; l<br>  <span class="hljs-keyword">case</span> x::xs =&gt; x :: init(xs)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-7-foldRight-能否“短路”？"><a href="#3-7-foldRight-能否“短路”？" class="headerlink" title="3.7 foldRight 能否“短路”？"></a>3.7 foldRight 能否“短路”？</h1><p>foldRight 的定义如下，只要记住 foldRight 并非尾递归就容易写出它，把 op 当作右结合的二元操作符来看待有奇效。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldRight</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], z: <span class="hljs-type">B</span>)(op: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; z<br>  <span class="hljs-keyword">case</span> x::xs =&gt; op(x, foldRight(xs, z)(op))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这也不是一个编程题，但是确实很有实践意义，在很多时候能发现这样的业务需求，即我<strong>迭代集合迭代一半，突然发现后面不需要再迭代了，想现在立刻就返回</strong>，但是目前我是没找到合适的方法，唯一感觉可行的方法是利用 break 来终止，但这并不优雅，期待该书能提出更好的解决方案。</p><h1 id="3-8-foldRight-以-Nil-为初始值，以-为操作符？"><a href="#3-8-foldRight-以-Nil-为初始值，以-为操作符？" class="headerlink" title="3.8 foldRight 以 Nil 为初始值，以::为操作符？"></a>3.8 foldRight 以 Nil 为初始值，以<code>::</code>为操作符？</h1><blockquote><p>关于为什么此书定义函数时没有遵循数据放到最后的原则，我猜测原因是因为 Scala 是面向对象语言，而这样的话数据和参数的位置和进行方法调用时相同。</p></blockquote><p><code>foldRight(List(1,2,3),Nil:List[Int])(_::_)</code>会发生什么？这里可以用我之前“发明”的方法来去理解——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span> &gt;=&gt; <span class="hljs-type">Nil</span><br>=&gt; <span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; [<span class="hljs-number">3</span>]<br>=&gt; <span class="hljs-number">1</span> &gt;=&gt; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>=&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></div></td></tr></table></figure><h1 id="3-9-使用-foldRight-实现-length"><a href="#3-9-使用-foldRight-实现-length" class="headerlink" title="3.9 使用 foldRight 实现 length"></a>3.9 使用 foldRight 实现 length</h1><p>easy。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Int</span> =<br>  foldRight(l, <span class="hljs-number">0</span>)&#123;(x, acc) =&gt; <span class="hljs-number">1</span> + acc&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-10-foldLeft"><a href="#3-10-foldLeft" class="headerlink" title="3.10 foldLeft"></a>3.10 foldLeft</h1><p>理解 foldLeft 为尾递归，op 为左结合的二元运算符对编写 foldLeft 有帮助。</p><p>但最具建设性的想法是，对于<code>foldLeft(List(1,2,3,4), 0)(_ + _)</code>，它显然为<code>(((0 + 1) + 2) + 3) + 4</code>，容易发现，它和<code>((1 + 2) + 3) + 4</code>结构是完全一样的，还原后就得到了<code>foldLeft(List(2, 3, 4), 1)(_ + _)</code>，这已经足够编写出实现了。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldLeft</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], z: <span class="hljs-type">B</span>)(op: (<span class="hljs-type">B</span>, <span class="hljs-type">A</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; z<br>  <span class="hljs-keyword">case</span> x::xs =&gt; foldLeft(xs, op(z, x))(op)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-11-sum，product，length"><a href="#3-11-sum，product，length" class="headerlink" title="3.11 sum，product，length"></a>3.11 sum，product，length</h1><p>使用 foldLeft 实现这几个方法。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(l: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">Int</span> = <br>  foldLeft(l, <span class="hljs-number">0</span>)(_ + _)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">product</span></span>(l: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">Int</span> = <br>  foldLeft(l, <span class="hljs-number">1</span>)(_ * _)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Int</span> = <br>  foldLeft(l, <span class="hljs-number">0</span>)((acc, _) =&gt; acc + <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><h1 id="3-12-使用-fold-实现-reverse"><a href="#3-12-使用-fold-实现-reverse" class="headerlink" title="3.12 使用 fold 实现 reverse"></a>3.12 使用 fold 实现 reverse</h1><p>这也是之前实现过的东西，使用<code>flip (::)</code>作为 op，左折叠即可。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] =<br>  foldLeft(l, <span class="hljs-type">Nil</span>: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])((acc, x) =&gt; x::acc)<br></code></pre></div></td></tr></table></figure><h1 id="3-13-使用-foldLeft-实现-foldRight"><a href="#3-13-使用-foldLeft-实现-foldRight" class="headerlink" title="3.13 使用 foldLeft 实现 foldRight"></a>3.13 使用 foldLeft 实现 foldRight</h1><p>foldRight 由于是递归形式，所以可能爆栈，能否使用 foldLeft 实现 foldRight 以防止爆栈呢？</p><p>这个问题确实很难，我想到的唯一的方式是先把原列表 reverse 再进行 foldLeft，看看之后该书会提出什么好玩的解决方案。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldRight_</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], z: <span class="hljs-type">B</span>)(op: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> =<br>  foldLeft(reverse(l), z)((acc, x) =&gt; op(x, acc))<br></code></pre></div></td></tr></table></figure><h1 id="3-14-使用-foldLeft-或-foldRight-实现-append"><a href="#3-14-使用-foldLeft-或-foldRight-实现-append" class="headerlink" title="3.14 使用 foldLeft 或 foldRight 实现 append"></a>3.14 使用 foldLeft 或 foldRight 实现 append</h1><p>append 就是 Haskell 的<code>++</code>。</p><p>使用右折叠的话是比较容易实现的——第一个列表作为原列表，第二个列表作为 zero，op 为<code>::</code>。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span></span>[<span class="hljs-type">A</span>](l1: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], l2: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <br>  foldRight(l1, l2)(_::_)<br></code></pre></div></td></tr></table></figure><p>左折叠的话救比较蛋疼，我想到的话还得先把原列表 reverse 再 append，但考虑到它说的是“或”……</p><h1 id="3-15-flatten"><a href="#3-15-flatten" class="headerlink" title="3.15 flatten"></a>3.15 flatten</h1><p>虽然题目没明确，但这显然是一个 flatten，使用折叠和 append 可以解决。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatten</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <br>  foldRight(l, <span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(append)<br></code></pre></div></td></tr></table></figure><p>为什么使用<code>Nil:List[A]</code>？因为它默认会认为<code>Nil</code>的类型是<code>List[Nothing]</code>，需要做一下向上转型。</p><h1 id="3-16-给列表的每个元素-1"><a href="#3-16-给列表的每个元素-1" class="headerlink" title="3.16 给列表的每个元素 +1"></a>3.16 给列表的每个元素 +1</h1><p>虽然这里可能并不是这个意思，但 map，filter，flatMap 都可以由 fold 操作实现，因此这里都使用 fold。可以发现，foldRight 虽然会导致爆栈，但实现特定函数还是比较方便的。使用 foldLeft 就需要 reverse 了。这里其实最合适的方法是使用循环来实现。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plus1</span></span>(l: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <br>  foldRight(l, <span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>])((x, acc) =&gt; (x + <span class="hljs-number">1</span>) :: acc)<br></code></pre></div></td></tr></table></figure><h1 id="3-17-将-List-Double-转成-List-String"><a href="#3-17-将-List-Double-转成-List-String" class="headerlink" title="3.17 将 List[Double] 转成 List[String]"></a>3.17 将 List[Double] 转成 List[String]</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allToString</span></span>(l: <span class="hljs-type">List</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <br>  foldRight(l, <span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">String</span>])((x, acc) =&gt; x.toString :: acc)<br></code></pre></div></td></tr></table></figure><h1 id="3-18-map"><a href="#3-18-map" class="headerlink" title="3.18 map"></a>3.18 map</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">List</span>[<span class="hljs-type">B</span>] = <br>  foldRight(l, <span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">B</span>])((x, acc) =&gt; f(x) :: acc)<br></code></pre></div></td></tr></table></figure><p>顺带一提，原始的方法为——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">List</span>[<span class="hljs-type">B</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> x::xs =&gt; f(x)::map(xs)(f)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-19-filter"><a href="#3-19-filter" class="headerlink" title="3.19 filter"></a>3.19 filter</h1><p>怎么不举例子啦？</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <br>  foldRight(l, <span class="hljs-type">Nil</span>: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])&#123;(x, acc) =&gt; <span class="hljs-keyword">if</span> (p(x)) x :: acc <span class="hljs-keyword">else</span> acc&#125;<br></code></pre></div></td></tr></table></figure><p>原始的方法为——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> x::xs =&gt; <span class="hljs-keyword">if</span> (p(x)) x::filter(xs)(p) <span class="hljs-keyword">else</span> filter(xs)(p)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>移除所有奇数的调用类似<code>filter(List(1, 2, 3))(_ % 2 == 0)</code>。</p><h1 id="3-20-flatMap"><a href="#3-20-flatMap" class="headerlink" title="3.20 flatMap"></a>3.20 flatMap</h1><p>flatMap 是列表的 bind 操作。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">List</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">B</span>] =<br>  foldRight(l, <span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">B</span>])((x, acc) =&gt; append(f(x), acc))<br></code></pre></div></td></tr></table></figure><p>递归法很显然，懒得写了。</p><h1 id="3-21-使用-flatMap-实现-filter（和-map）"><a href="#3-21-使用-flatMap-实现-filter（和-map）" class="headerlink" title="3.21 使用 flatMap 实现 filter（和 map）"></a>3.21 使用 flatMap 实现 filter（和 map）</h1><p>Scala 的 flatMap 比隔壁 Haskell 的骚操作还多一些。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <br>  flatMap(l)(x =&gt; <span class="hljs-keyword">if</span> (p(x)) <span class="hljs-type">List</span>(x) <span class="hljs-keyword">else</span> <span class="hljs-type">Nil</span>)<br></code></pre></div></td></tr></table></figure><p>再给个杀必死，使用 flatMap 实现 map。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">List</span>[<span class="hljs-type">B</span>] =<br>  flatMap(l)(x =&gt; <span class="hljs-type">List</span>(f(x)))<br></code></pre></div></td></tr></table></figure><h1 id="3-22-两个列表相应元素相加"><a href="#3-22-两个列表相应元素相加" class="headerlink" title="3.22 两个列表相应元素相加"></a>3.22 两个列表相应元素相加</h1><p>trival，但之前的玩意可没法再用了。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plusList</span></span>(l1: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>], l2: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = (l1, l2) <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> (x::xs, y::ys) =&gt; (x + y) :: plusList(xs, ys)<br>  <span class="hljs-keyword">case</span> (_, _) =&gt; <span class="hljs-type">Nil</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-23-zipWith"><a href="#3-23-zipWith" class="headerlink" title="3.23 zipWith"></a>3.23 zipWith</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zipWith</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](l1: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], l2: <span class="hljs-type">List</span>[<span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">List</span>[<span class="hljs-type">C</span>] = <br>  (l1, l2) <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> (x::xs, y::ys) =&gt; f(x, y) :: zipWith(xs, ys)(f)<br>    <span class="hljs-keyword">case</span> (_, _) =&gt; <span class="hljs-type">Nil</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-24-是否是子序列"><a href="#3-24-是否是子序列" class="headerlink" title="3.24 是否是子序列"></a>3.24 是否是子序列</h1><p>给定两个列表 l1，sub，检查 sub 是否是 l1 的子序列。既然书中要求使用最自然的方式，那我就编写一个最自然的方式——从 l1 的每一个元素开始，检查从当前开始时 sub 是否是前缀。更高性能的方式之后再看。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasSubsequence</span></span>[<span class="hljs-type">A</span>](sup: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], sub: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Boolean</span> = &#123;<br>  <span class="hljs-meta">@tailrec</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startWith</span></span>(l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], prefix: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Boolean</span> = (l, prefix) <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> (x::xs, y::ys) =&gt; <span class="hljs-keyword">if</span> (x == y) startWith(xs, ys) <span class="hljs-keyword">else</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">case</span> (_, <span class="hljs-type">Nil</span>) =&gt; <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span><br>  &#125;<br>  sup <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">case</span> _::xs =&gt; <span class="hljs-keyword">if</span> (startWith(sup, sub)) <span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> hasSubsequence(xs, sub)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-25-树的-size"><a href="#3-25-树的-size" class="headerlink" title="3.25 树的 size"></a>3.25 树的 size</h1><p>这里引入了一个树的 ADT——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Tree</span>[+<span class="hljs-type">A</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span>[<span class="hljs-type">A</span>](<span class="hljs-params">value: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Tree</span>[<span class="hljs-type">A</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Branch</span>[<span class="hljs-type">A</span>](<span class="hljs-params">left: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>], right: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Tree</span>[<span class="hljs-type">A</span>]</span><br></code></pre></div></td></tr></table></figure><p>用 Haskell 的话来说，就是——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala">data <span class="hljs-type">Tree</span> a = <span class="hljs-type">Leaf</span> a | <span class="hljs-type">Branch</span> (<span class="hljs-type">Tree</span> a) (<span class="hljs-type">Tree</span> a)<br></code></pre></div></td></tr></table></figure><p>我还没见过根结点没有值的二叉树。</p><p>求树的 size 是简单的，对叶子结点，size 为 1，对根结点，size 为 1 + 左右子树的 size。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span></span>[<span class="hljs-type">A</span>](tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Int</span> = tree <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Leaf</span>(_) =&gt; <span class="hljs-number">1</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Branch</span>(left, right) =&gt; <span class="hljs-number">1</span> + size(left) + size(right)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-26-maximum"><a href="#3-26-maximum" class="headerlink" title="3.26 maximum"></a>3.26 maximum</h1><p>求一棵树<code>Tree[Int]</code>中最大的值，这也是十分显然的。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maximum</span></span>(tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">Int</span> = tree <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Leaf</span>(x) =&gt; x<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Branch</span>(left, right) =&gt; maximum(left) max maximum(right)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-27-depth"><a href="#3-27-depth" class="headerlink" title="3.27 depth"></a>3.27 depth</h1><p>求树的最大深度，这也是很显然的。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depth</span></span>[<span class="hljs-type">A</span>](tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Int</span> = tree <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Leaf</span>(x) =&gt; <span class="hljs-number">1</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Branch</span>(left, right) =&gt; <span class="hljs-number">1</span> + depth(left).max(depth(right))<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-28-map"><a href="#3-28-map" class="headerlink" title="3.28 map"></a>3.28 map</h1><p>对一棵树的所有节点（其实只有叶子结点）应用相同的操作，仍旧是非常简单的。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>])(fn: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Tree</span>[<span class="hljs-type">B</span>] = tree <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Leaf</span>(x) =&gt; <span class="hljs-type">Leaf</span>(fn(x))<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Branch</span>(left, right) =&gt; <span class="hljs-type">Branch</span>(map(left)(fn), map(right)(fn))<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="3-29-fold"><a href="#3-29-fold" class="headerlink" title="3.29 fold"></a>3.29 fold</h1><p>对树进行折叠，这题就离谱了。考虑上面的 size，maximum，depth 函数，它们都是对叶子结点做一个映射，然后对根结点，它会先将其左右子树进行同样的操作，再进行一个“合并”，因此可以猜测签名类似这样：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fold</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>])(mapper: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(combiner: (<span class="hljs-type">B</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span><br></code></pre></div></td></tr></table></figure><p>然后就容易得到实现了——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fold</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](tree: <span class="hljs-type">Tree</span>[<span class="hljs-type">A</span>])(mapper: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(combiner: (<span class="hljs-type">B</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = tree <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Leaf</span>(x) =&gt; mapper(x)<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Branch</span>(left, right) =&gt; combiner(fold(left)(mapper)(combiner), fold(right)(mapper)(combiner))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以发现，编写 List 的折叠时，我们需要考虑 Nil 和 Cons 的情况，编写 Tree 的折叠时，我们需要考虑叶结点和根结点的情况。</p><h1 id="4-1-实现-Option"><a href="#4-1-实现-Option" class="headerlink" title="4.1 实现 Option"></a>4.1 实现 Option</h1><p>实现 Option，其实这里最复杂的地方是关于类型系统的一些问题。签名如下——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// 这是不是说，实现代数数据类型时都应当使用协变？</span><br><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Option</span>[+<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOrElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>])<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>关于这里的 getOrElse 和 orElse 方法中 B 的约束，考虑一个情形——在 Java 中，我们试图从一个 List 中取出一个值：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">List&lt;String&gt; lst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()&#123;&#123; <span class="hljs-comment">/* some add statement */</span> &#125;&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lst.get(<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><p>这个问题其实就是在问，这里的 i 的声明类型可以为哪些？容易发现它需要是 String 的父类，即 String 和 Object，因此这里签名中 B 为 A 的父类是合理的。</p><p>实现是比较简单的，不再多嘴：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Some</span>[+<span class="hljs-type">A</span>](<span class="hljs-params">value: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Option</span>[<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>) = <span class="hljs-type">Some</span>(f(value))<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]) = f(value)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOrElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">B</span>) = value<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]) = <span class="hljs-keyword">this</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>) = <span class="hljs-keyword">if</span> (f(value)) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> <span class="hljs-type">None</span><br>&#125;<br><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">None</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Option</span>[<span class="hljs-type">Nothing</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">Nothing</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] = <span class="hljs-type">None</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">Nothing</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] = <span class="hljs-type">None</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOrElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">Nothing</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">B</span>) = <span class="hljs-keyword">default</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">Nothing</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]) = <span class="hljs-keyword">default</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(f: <span class="hljs-type">Nothing</span> =&gt; <span class="hljs-type">Boolean</span>) = <span class="hljs-type">None</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以编写代码进行一些测试～</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOption</span></span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](map: <span class="hljs-type">Map</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], key: <span class="hljs-type">K</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">V</span>] =<br>  <span class="hljs-keyword">if</span> (map.contains(key)) <span class="hljs-type">Some</span>(map(key)) <span class="hljs-keyword">else</span> <span class="hljs-type">None</span><br><br><span class="hljs-keyword">val</span> map = <span class="hljs-type">Map</span>(<br>  <span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span>,<br>  <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br>)<br><br><span class="hljs-keyword">for</span> &#123;<br>  i &lt;- getOption(map, <span class="hljs-number">1</span>)<br>  j &lt;- getOption(map, <span class="hljs-number">2</span>)<br>&#125; <span class="hljs-keyword">yield</span> i + j <span class="hljs-comment">// Some(5)</span><br></code></pre></div></td></tr></table></figure><p>书中对该题的描述非常诡异，不知所云（英文版的如此，中文版的更甚），在搜索一番后才知道，它是要求将所有实现的方法全都塞在 trait 里面！根据书中的要求——除了 map 和 getOrElse，其它都不使用模式匹配，最后的代码应该是这样：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Option</span>[+<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Some</span>[+<span class="hljs-type">A</span>](<span class="hljs-params">value: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Option</span>[<span class="hljs-type">A</span>]</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">None</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Option</span>[<span class="hljs-type">Nothing</span>]</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">None</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(value) =&gt; <span class="hljs-type">Some</span>(f(value))<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] =<br>    <span class="hljs-keyword">this</span>.map(f).getOrElse(<span class="hljs-type">None</span>)<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOrElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-keyword">default</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(value) =&gt; value<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orElse</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>] =<br>    <span class="hljs-keyword">this</span>.map(<span class="hljs-type">Some</span>(_)).getOrElse(<span class="hljs-keyword">default</span>)<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =<br>    <span class="hljs-keyword">this</span>.flatMap(value =&gt; <span class="hljs-keyword">if</span> (f(value)) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> <span class="hljs-type">None</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于无法使用模式匹配，flatMap，orElse 和 filter 几个函数编写起来都是非常费劲的，但其中最重要的一个地方是，能够发现<code>getOrElse(None)</code>能起到<code>flatten</code>的效果。</p><p>对 flatMap，考虑对于一个<code>Option[Option[Int]]</code>，对<code>Some(Some(1))</code>抑或是<code>Some(None)</code>，我们对其调用<code>this.getOrElse(None)</code>，能发现它们会返回<code>Some(1)</code>和<code>None</code>；而对于<code>None</code>，返回的则是 None，该行为和<code>flatten</code>一致。有了 map，有了 flatten，我们就能够实现 flatMap。</p><p>对 orElse，它的行为是若 this 是 None，则返回 default，否则返回 this。为此我们又需要检查 this 的类型，为此我们又得包装成<code>Option[Option[A]]</code>，使用何种手段进行包装是显然的：对于 None，我们啥都做不了，只能整 None（<code>Some(None)</code>也行，但这里现有的工具做不到）；对于 Some(x)，我们必须要保留这个 x（之后还得用），为此我们返回<code>Some(Some(x))</code>，容易发现，使用<code>this.map(Some(_))</code>能做到这一点。</p><p>然后我们肯定得调用 getOrElse 对其展平。根据 orElse 的需求，对于<code>Some(Some(x))</code>，我们希望能得到<code>Some(x)</code>，对于<code>None</code>，我们希望得到 default，答案是字面的。</p><p>对于 filter，这种的之前也写过，不用多说。</p><p>顺带一提，getOrElse 中使用了非严格求值的语法，这使它能用于一些返回默认值之外的其它目的，比如<code>getOption(map, 1).getOrElse(throw new Exception(&quot;you bad bad&quot;))</code>，倘若 Java 能引入<code>=&gt; A</code>语法的话，就不需要为此定义好几个方法了。</p><h1 id="4-2-使用-flatMap-实现一个求方差的函数"><a href="#4-2-使用-flatMap-实现一个求方差的函数" class="headerlink" title="4.2 使用 flatMap 实现一个求方差的函数"></a>4.2 使用 flatMap 实现一个求方差的函数</h1><p>函数签名如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">variance</span></span>(xs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">Double</span>]<br></code></pre></div></td></tr></table></figure><p>方差的公式请自己百度。为什么这题和 Option 扯上关系呢？这一章是关于错误处理的，而能够发现，对于空的序列求平均数是无法做到的，平均数的函数我们得这么写：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mean</span></span>(xs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">Double</span>] =<br>  <span class="hljs-keyword">if</span> (xs.isEmpty) <span class="hljs-type">None</span> <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">val</span> (sum, length) = xs.foldLeft((<span class="hljs-number">0.0</span>, <span class="hljs-number">0</span>))<br>      &#123; <span class="hljs-keyword">case</span> ((sum, length), x) =&gt; (sum + x, length + <span class="hljs-number">1</span>) &#125;<br>    <span class="hljs-type">Some</span>(sum / length)<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>在求方差时，我们先求出序列的平均数，再对序列的每个元素做映射，求映射后的序列的平均数，这里有两次求平均数，如果第一次失败，则后一次计算不应该执行，我们可以得到这样的代码：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">variance</span></span>(xs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">Double</span>] =<br>  mean(xs).flatMap(m =&gt; mean(xs.map(x =&gt; math.pow(x - m, <span class="hljs-number">2</span>))))<br></code></pre></div></td></tr></table></figure><p>使用 for 描述会更加清晰。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">variance</span></span>(xs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Double</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">Double</span>] = <span class="hljs-keyword">for</span> &#123;<br>  m &lt;- mean(xs)                          <span class="hljs-comment">// 求平均数</span><br>  ys = xs.map(x =&gt; math.pow(x - m, <span class="hljs-number">2</span>))   <span class="hljs-comment">// 对序列做映射</span><br>  result &lt;- mean(ys)                     <span class="hljs-comment">// 求映射后的序列的平均数</span><br>&#125; <span class="hljs-keyword">yield</span> result<br></code></pre></div></td></tr></table></figure><h1 id="4-3-map2"><a href="#4-3-map2" class="headerlink" title="4.3 map2"></a>4.3 map2</h1><p>实现一个 map2 函数，其行为是把<code>(A, B) =&gt; C</code>的函数提升为<code>(Option[A], Option[B]) =&gt; Option[C]</code>，签名和实现如下。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](a: <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>], b: <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">C</span>] = <br>  a.flatMap(va =&gt; b.map(vb =&gt; f(va, vb)))<br></code></pre></div></td></tr></table></figure><p>对它的实现是显然的，关键问题就是如何同时让 a 和 b 中的值处在作用域中，这在之前已经学习过了。</p><p>当然，也可以用 for 去实现，或者同时对 a 和 b 做模式匹配，只有两个都为 Some 的时候再返回<code>Some(f(va, vb))</code>，否则返回 None。</p><h1 id="4-4-sequence"><a href="#4-4-sequence" class="headerlink" title="4.4 sequence"></a>4.4 sequence</h1><p>把<code>List[Option[A]]</code>转换为<code>Option[List[A]]</code>，当原列表中存在任意<code>None</code>则返回 None，否则返回<code>Some(List(...))</code>。</p><p>该题在 Haskell 中做过，不用多说，重点是把<code>::</code>进行提升，转换为<code>(Option[A], Option[B]) =&gt; Option[C]</code>的函数。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence</span></span>[<span class="hljs-type">A</span>](xs: <span class="hljs-type">List</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">Option</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>]] =<br>  xs.foldRight(<span class="hljs-type">Some</span>(<span class="hljs-type">Nil</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>]])((x, acc) =&gt; map2(x, acc)(_ :: _))<br></code></pre></div></td></tr></table></figure><h1 id="4-5-traverse"><a href="#4-5-traverse" class="headerlink" title="4.5 traverse"></a>4.5 traverse</h1><p>traverse 的签名和实现如下，它相当于是把原列表先 map 成 Option 再执行 sequence 方法，但如此的话会遍历两次列表，效率不够好，这里只需要遍历一次。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traverse</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](a: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">List</span>[<span class="hljs-type">B</span>]] =<br>  a.foldRight(<span class="hljs-type">Some</span>(<span class="hljs-type">Nil</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">List</span>[<span class="hljs-type">B</span>]])((x, acc) =&gt; map2(f(x), acc)(_ :: _))<br></code></pre></div></td></tr></table></figure><p>容易发现，traverse 可以实现 sequence：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence</span></span>[<span class="hljs-type">A</span>](xs: <span class="hljs-type">List</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">Option</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>]] =<br>  traverse(xs)(identity)<br></code></pre></div></td></tr></table></figure><h1 id="4-6-map，flatMap，orElse，map2"><a href="#4-6-map，flatMap，orElse，map2" class="headerlink" title="4.6 map，flatMap，orElse，map2"></a>4.6 map，flatMap，orElse，map2</h1><p>实现 Either 的 map，flatMap，orElse，map2，注意 flatMap 和 orElse 的类型定义。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Either</span>[+<span class="hljs-type">E</span>, +<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(value) =&gt; <span class="hljs-type">Right</span>(f(value))<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(value) =&gt; <span class="hljs-type">Left</span>(value)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">EE</span> &gt;: <span class="hljs-type">E</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">B</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(value) =&gt; f(value)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(value) =&gt; <span class="hljs-type">Left</span>(value)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orElse</span></span>[<span class="hljs-type">EE</span> &gt;: <span class="hljs-type">E</span>, <span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](<span class="hljs-keyword">default</span>: =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">B</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(value) =&gt; <span class="hljs-type">Right</span>(value)<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-keyword">default</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2</span></span>[<span class="hljs-type">EE</span> &gt;: <span class="hljs-type">E</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](b: <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">EE</span>, <span class="hljs-type">C</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(aa) =&gt; b.map(bb =&gt; f(aa, bb))<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(value) =&gt; <span class="hljs-type">Left</span>(value)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Left</span>[+<span class="hljs-type">E</span>](<span class="hljs-params">value: <span class="hljs-type">E</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">Nothing</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Right</span>[+<span class="hljs-type">A</span>](<span class="hljs-params">value: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Either</span>[<span class="hljs-type">Nothing</span>, <span class="hljs-type">A</span>]</span><br></code></pre></div></td></tr></table></figure><h1 id="4-7-sequence-和-traverse"><a href="#4-7-sequence-和-traverse" class="headerlink" title="4.7 sequence 和 traverse"></a>4.7 sequence 和 traverse</h1><p>实现 Either 的 sequence 和 traverse 函数。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traverse</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">List</span>[<span class="hljs-type">B</span>]] = l <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">Right</span>(<span class="hljs-type">Nil</span>)<br>  <span class="hljs-keyword">case</span> x :: xs =&gt; f(x).map2(traverse(xs)(f))(_ :: _) <span class="hljs-comment">// 这里的 map2 使用函数形式的话更好看一些</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traverse_1</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">List</span>[<span class="hljs-type">B</span>]] = <br>  l.foldRight(<span class="hljs-type">Right</span>(<span class="hljs-type">Nil</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">List</span>[<span class="hljs-type">B</span>]])&#123;(x, acc) =&gt; f(x).map2(acc)(_ :: _)&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>](l: <span class="hljs-type">List</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>]]): <span class="hljs-type">Either</span>[<span class="hljs-type">E</span>, <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]] = <br>  traverse(l, identity)<br></code></pre></div></td></tr></table></figure><h1 id="4-8-如何保留所有错误？"><a href="#4-8-如何保留所有错误？" class="headerlink" title="4.8 如何保留所有错误？"></a>4.8 如何保留所有错误？</h1><p>Either 有一个缺点，就是它是“Fail Fast”的，第一次出现 Left 时就直接终止掉了，但有时候我们希望能保留每个 Left 的信息。比如我们定义一个 Person，有两个字段 name 和 age，两者都有格式要求，我们定义一个函数去创建 Person，并要求每个错误的输入都要保存错误信息。</p><p>根据 Either 的使用方法，我们首先写出这样的代码：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkName</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">String</span>] =<br>  <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span> || name.isEmpty) <span class="hljs-type">Left</span>(<span class="hljs-string">&quot;name can&#x27;t be empty!&quot;</span>)<br>  <span class="hljs-keyword">else</span> <span class="hljs-type">Right</span>(name)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkAge</span></span>(age: <span class="hljs-type">Int</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <br>  <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">150</span>) <span class="hljs-type">Left</span>(<span class="hljs-string">&quot;invalid age value!&quot;</span>)<br>  <span class="hljs-keyword">else</span> <span class="hljs-type">Right</span>(age)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkPerson</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Person</span>] = <span class="hljs-keyword">for</span> &#123;<br>  n &lt;- mkName(name)<br>  a &lt;- mkAge(age)<br>&#125; <span class="hljs-keyword">yield</span> <span class="hljs-type">Person</span>(n, a)<br></code></pre></div></td></tr></table></figure><p>这能用，但是问题是如果 name 和 age 同时不合法，则只有 name 的错误消息得以保存。这里需要使用类似 Haskell 的 Writer 这样的类型，这时候 E 要求是 Monoid。我们把 E 的范围放窄到 List[E]，可以临时定义一个 map2All 函数并用以实现满足需求的 mkPerson：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2All</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](a: <span class="hljs-type">Either</span>[<span class="hljs-type">List</span>[<span class="hljs-type">E</span>], <span class="hljs-type">A</span>], b: <span class="hljs-type">Either</span>[<span class="hljs-type">List</span>[<span class="hljs-type">E</span>], <span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">List</span>[<span class="hljs-type">E</span>], <span class="hljs-type">C</span>] = (a, b) <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> (<span class="hljs-type">Right</span>(aa), <span class="hljs-type">Right</span>(bb)) =&gt; <span class="hljs-type">Right</span>(f(aa, bb))<br>  <span class="hljs-keyword">case</span> (<span class="hljs-type">Left</span>(aa), <span class="hljs-type">Left</span>(bb)) =&gt; <span class="hljs-type">Left</span>(aa ++ bb)<br>  <span class="hljs-keyword">case</span> (<span class="hljs-type">Left</span>(aa), _) =&gt; <span class="hljs-type">Left</span>(aa)<br>  <span class="hljs-keyword">case</span> (_, <span class="hljs-type">Left</span>(bb)) =&gt; <span class="hljs-type">Left</span>(bb)<br>&#125;<br><br><span class="hljs-comment">// mkName 和 mkAge 的类型也需要改变</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkPerson</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">List</span>[<span class="hljs-type">String</span>], <span class="hljs-type">Person</span>] =<br>  map2All(mkName(name), mkAge(age))(<span class="hljs-type">Person</span>(_, _)) <br></code></pre></div></td></tr></table></figure><p>但这样的话就无法使用 for 和常用高阶函数了，还是另外定义一个新的 ADT（Monad）来干这活比较好。</p><h1 id="5-1-toList"><a href="#5-1-toList" class="headerlink" title="5.1 toList"></a>5.1 toList</h1><p>这一章就感觉整个都挺魔法的，之后还有更多魔法～</p><p>下面的代码都假设是使用 cons 函数而非 Cons 值构造器进行构造的，因此不考虑 thunk 重复计算的问题。</p><p>实现 Stream 的 toList 方法，其计算整个 Stream 并以 List 的形式返回结果，直接写最明显的递归。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toList</span></span>(): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">Nil</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; h() :: t().toList()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>考虑到该方法可能有副作用，所以使用带括号的形式。</p><h1 id="5-2-take，drop"><a href="#5-2-take，drop" class="headerlink" title="5.2 take，drop"></a>5.2 take，drop</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">take</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> =&gt; <span class="hljs-type">Stream</span>.cons(h(), t().take(n - <span class="hljs-number">1</span>))<br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Empty</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drop</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> _ <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> =&gt; <span class="hljs-keyword">this</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">Empty</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; t().drop(n - <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="5-3-takeWhile"><a href="#5-3-takeWhile" class="headerlink" title="5.3 takeWhile"></a>5.3 takeWhile</h1><p>takeWhile 方法，可处理无穷列表。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeWhile</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) <span class="hljs-keyword">if</span> f(h()) =&gt; <span class="hljs-type">Stream</span>.cons(h(), t().takeWhile(f))<br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Empty</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="5-4-forAll"><a href="#5-4-forAll" class="headerlink" title="5.4 forAll"></a>5.4 forAll</h1><p>forAll 方法，特点是一旦遇到 false 就直接短路终止，因此可处理无穷列表，但如果全部都是 true 的话会一直运行下去。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forAll</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Boolean</span> =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-literal">true</span>)((x, acc) =&gt; p(x) &amp;&amp; acc)<br></code></pre></div></td></tr></table></figure><h1 id="5-5-使用-foldRight-实现-takeWhile-方法"><a href="#5-5-使用-foldRight-实现-takeWhile-方法" class="headerlink" title="5.5 使用 foldRight 实现 takeWhile 方法"></a>5.5 使用 foldRight 实现 takeWhile 方法</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeWhile</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>])&#123;(x, acc) =&gt;<br>    <span class="hljs-keyword">if</span> (p(x)) cons(x, acc)<br>    <span class="hljs-keyword">else</span> <span class="hljs-type">Empty</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><p>这玩意为啥这样实现？还是考虑我的那种表示法，比如对<code>Nat.takeWhile(_ &lt; 5)</code>，会得到这样的序列：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Haskell"><span class="hljs-number">0</span> &lt;=&lt; <span class="hljs-number">1</span> &lt;=&lt; <span class="hljs-number">2</span> &lt;=&lt; <span class="hljs-number">3</span> &lt;=&lt; ... &lt;=&lt; n &lt;=&lt; []<br></code></pre></div></td></tr></table></figure><p>对后面的任意大于等于 5 的 n，<code>n &lt;=&lt; []</code>都返回<code>[]</code>，因此最后得到的计算序列仍旧是：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Haskell"><span class="hljs-number">0</span> &lt;=&lt; <span class="hljs-number">1</span> &lt;=&lt; <span class="hljs-number">2</span> &lt;=&lt; <span class="hljs-number">3</span> &lt;=&lt; <span class="hljs-number">4</span> &lt;=&lt; <span class="hljs-number">5</span> &lt;=&lt; []<br></code></pre></div></td></tr></table></figure><p>由此便得到了正确结果。但容易发现，惰性列表的 foldRight 仍旧是会爆栈的。</p><h1 id="5-6-使用-foldRight-实现-headOption-方法"><a href="#5-6-使用-foldRight-实现-headOption-方法" class="headerlink" title="5.6 使用 foldRight 实现 headOption 方法"></a>5.6 使用 foldRight 实现 headOption 方法</h1><p>这题……哪里难了？</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">headOption</span></span>: <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">None</span>: <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>])((x, _) =&gt; <span class="hljs-type">Some</span>(x))<br></code></pre></div></td></tr></table></figure><h1 id="5-7-使用-foldRight-实现-map，filter，append，flatMap"><a href="#5-7-使用-foldRight-实现-map，filter，append，flatMap" class="headerlink" title="5.7 使用 foldRight 实现 map，filter，append，flatMap"></a>5.7 使用 foldRight 实现 map，filter，append，flatMap</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>])((x, acc) =&gt; <span class="hljs-type">Stream</span>.cons(f(x), acc))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>])((x, acc) =&gt; <span class="hljs-keyword">if</span> (p(x)) <span class="hljs-type">Stream</span>.cons(x, acc) <span class="hljs-keyword">else</span> acc)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](ys: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(ys)(<span class="hljs-type">Stream</span>.cons(_, _))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>])((x, acc) =&gt; f(x).append(acc))<br></code></pre></div></td></tr></table></figure><p>关于 append 奇怪的类型参数，这再次关系到协变和逆变的机制，当前还没有学习。</p><h1 id="5-8-repeat"><a href="#5-8-repeat" class="headerlink" title="5.8 repeat"></a>5.8 repeat</h1><p>返回一个无穷流，每个元素都为一个给定值。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constant</span></span>[<span class="hljs-type">A</span>](n: <span class="hljs-type">A</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <br>  <span class="hljs-type">Stream</span>.cons(n, constant(n))<br></code></pre></div></td></tr></table></figure><h1 id="5-9-from"><a href="#5-9-from" class="headerlink" title="5.9 from"></a>5.9 from</h1><p>给定一个整数 n，返回 n，n + 1，n + 2……的无穷流。答案是挺显然的，这里有一个模式：之后的值由之前的值去生成。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] =<br>  <span class="hljs-type">Stream</span>.cons(n, from(n + <span class="hljs-number">1</span>))<br></code></pre></div></td></tr></table></figure><h1 id="5-10-fibs"><a href="#5-10-fibs" class="headerlink" title="5.10 fibs"></a>5.10 fibs</h1><p>斐波那契数列的无限流。实现类似 from——对于每个元素，我们求它的时候需要知道之前的两个元素，为此这两个元素需要当作状态去传递。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibs</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)] =<br>    <span class="hljs-type">Stream</span>.cons((a, b), from(b, a + b))<br>  from(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).map(_._1)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="5-11-unfold"><a href="#5-11-unfold" class="headerlink" title="5.11 unfold"></a>5.11 unfold</h1><p>从上面的 from 和 fibs 抽象出一个更广泛的流构造函数，其不断地去维护一个状态，每一次这个状态都将生成一个新的状态以及要添加到流中的值，也可以终止该操作（当返回 None 时）。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unfold</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">S</span>](z: <span class="hljs-type">S</span>)(f: <span class="hljs-type">S</span> =&gt; <span class="hljs-type">Option</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">S</span>)]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = f(z) <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">Empty</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>((value, nextState)) =&gt; <span class="hljs-type">Stream</span>.cons(value, unfold(nextState)(f))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但这个函数最有趣的地方其实是它叫”unfold”。</p><blockquote><p>这书的翻译真差劲！太差劲了！</p></blockquote><h1 id="5-12-使用-unfold-实现-fibs，from，constant，ones"><a href="#5-12-使用-unfold-实现-fibs，from，constant，ones" class="headerlink" title="5.12 使用 unfold 实现 fibs，from，constant，ones"></a>5.12 使用 unfold 实现 fibs，from，constant，ones</h1><p>题目本身是不难的。根据书中描述，原生的 constant，ones 只需要使用常量的内存，而 unfold 实现的无法如此，但这是可以容忍的。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibs</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] =<br>  unfold((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))&#123; <span class="hljs-keyword">case</span> (a, b) =&gt; <span class="hljs-type">Some</span>((a, (b, a + b))) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from</span></span>(n): <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = <br>  unfold(n)(x =&gt; <span class="hljs-type">Some</span>(x, x + <span class="hljs-number">1</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constant</span></span>[<span class="hljs-type">A</span>](elem: <span class="hljs-type">A</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <br>  unfold(elem)(x =&gt; <span class="hljs-type">Some</span>(x, x))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ones</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = constant(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><h1 id="5-13-使用-unfold-实现-map，take，takeWhile，zipWith，zipAll"><a href="#5-13-使用-unfold-实现-map，take，takeWhile，zipWith，zipAll" class="headerlink" title="5.13 使用 unfold 实现 map，take，takeWhile，zipWith，zipAll"></a>5.13 使用 unfold 实现 map，take，takeWhile，zipWith，zipAll</h1><p>我承认，作者十分擅长给读者造成惊吓。看起来，unfold 和 fold 就“原子性”来说具有十分类似的地位。但 unfold 无法实现像 filter 这样的操作，它只能取“前缀”。它们各有所长，各有有趣之处。</p><p>unfold 实现 map，为此需要再次回忆 unfold 的机制——根据当前的状态生成一个值以及新的状态，这些值将构成新的流。答案是显然的：我们用原列表作为初始状态，每次将头部的元素做映射，然后作为返回的值，剩下的列表作为新的状态。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-comment">// 这个函数写着就很不爽——这里需要进行解构，但解构的话会多一层括号，只能使用偏函数语法，但偏函数的话无法得到编译器的帮助，如果写错了那错误只能在运行时发现</span><br><span class="hljs-comment">// 另外，f 作为第一个参数的话 Scala 无法进行类型推导，实践中不能这么干</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] =<br>  unfold(xs) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; <span class="hljs-type">Some</span>( (f(h()), t()) )<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">None</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><p>takeWhile 的编写是显然的：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeWhile</span></span>[<span class="hljs-type">A</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>)(xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>  unfold(xs) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) <span class="hljs-keyword">if</span> f(h()) =&gt; <span class="hljs-type">Some</span>((h(), t()))<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><p>根据前面编写 take 的实践，take 需要先将原值和 index 做 zip，因此先实现 zipWith。zipWith 在其中一个流没有元素的时候终止：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zipWith</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>)(xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>], ys: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">C</span>] =<br>  unfold((xs, ys)) &#123;<br>    <span class="hljs-keyword">case</span> (<span class="hljs-type">Cons</span>(hx, tx), <span class="hljs-type">Cons</span>(hy, ty)) =&gt; <span class="hljs-type">Some</span>((f(hx(), hy()), (tx(), ty())))<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><p>然后是 take，也是显然的：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">take</span></span>[<span class="hljs-type">A</span>](n: <span class="hljs-type">Int</span>)(xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>  zip(xs, <span class="hljs-type">Stream</span>.<span class="hljs-type">Nat</span>)<br>    .takeWhile &#123;<span class="hljs-keyword">case</span> (_, index) =&gt; index &lt; n &#125;<br>    .map(_._1)<br></code></pre></div></td></tr></table></figure><p>当然，也可以一个 unfold 直接解决问题。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">take</span></span>[<span class="hljs-type">A</span>](n: <span class="hljs-type">Int</span>)(xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <br>  unfold((xs, <span class="hljs-type">Stream</span>.<span class="hljs-type">Nat</span>)) &#123;<br>    <span class="hljs-keyword">case</span> (<span class="hljs-type">Cons</span>(hx, tx), <span class="hljs-type">Cons</span>(hy, ty)) <span class="hljs-keyword">if</span> hy() &lt; n =&gt; <span class="hljs-type">Some</span>(hx(), (tx(), ty()))<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><p>zipAll 函数的行为从它的签名就能看出来——相较于 zipWith，它会在其中一个流没有元素时仍旧进行操作，因此 zipAll 无法使用 zipWith 进行实现，其行为不同。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zipAll</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](xs: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>], ys: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Stream</span>[(<span class="hljs-type">Option</span>[<span class="hljs-type">A</span>], <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>])] = &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tail</span></span>[<span class="hljs-type">X</span>](zs: <span class="hljs-type">Stream</span>[<span class="hljs-type">X</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">X</span>] = zs <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">Empty</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(_, t) =&gt; t()<br>  &#125;<br>  unfold((xs, ys)) &#123;<br>    <span class="hljs-keyword">case</span> (<span class="hljs-type">Empty</span>, <span class="hljs-type">Empty</span>) =&gt; <span class="hljs-type">None</span><br>    <span class="hljs-keyword">case</span> (xs, ys) =&gt; <span class="hljs-type">Some</span>((xs.headOption, ys.headOption), (tail(xs), tail(ys)))<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里别想用 for 或者 Option 的方法去做实现，Option 的组合策略和这个无关。</p><h1 id="5-14-startsWith"><a href="#5-14-startsWith" class="headerlink" title="5.14 startsWith"></a>5.14 startsWith</h1><p>检查一个流是否以另一个流为起始，这题确实挺复杂。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream method</span><br><span class="hljs-comment">// 为啥我写这种方法都要问我要确定协变逆变呢……</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startsWith</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](ys: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Boolean</span> =<br>  <span class="hljs-type">Stream</span>.zipAll(<span class="hljs-keyword">this</span>, ys).foldRight(<span class="hljs-literal">true</span>)&#123;(pair, acc) =&gt;<br>    pair <span class="hljs-keyword">match</span> &#123;<br>      <span class="hljs-keyword">case</span> (<span class="hljs-type">Some</span>(x), <span class="hljs-type">Some</span>(y)) =&gt; x == y &amp;&amp; acc  <span class="hljs-comment">// 如果当前元素相等，去判断接下来的元素</span><br>      <span class="hljs-keyword">case</span> (<span class="hljs-type">Some</span>(_), <span class="hljs-type">None</span>) =&gt; <span class="hljs-literal">true</span>              <span class="hljs-comment">// 如果当前流有值，另一个流没有值，则 true</span><br>      <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span>                           <span class="hljs-comment">// 其它情况都是 false</span><br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><h1 id="5-15-tails"><a href="#5-15-tails" class="headerlink" title="5.15 tails"></a>5.15 tails</h1><p>tails，行为类似 scan 操作，得到流的每一个元素的 tail 并组成新的流，比如对<code>Stream(1, 2, 3)</code>，会得到<code>Stream(Stream(1, 2, 3), Stream(2, 3), Stream(3), Empty)</code>。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tails</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]] =<br>  <span class="hljs-type">Stream</span>.cons(<span class="hljs-keyword">this</span>, <span class="hljs-type">Stream</span>.unfold(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">None</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; <span class="hljs-type">Some</span>((t(), t()))<br>  &#125;)<br></code></pre></div></td></tr></table></figure><p>这个 tails 感觉很不优雅……</p><p>借助 tails 和 startsWith 方法，我们能方便地去表述 hasSubSequence 方法：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasSubSequence</span></span>[<span class="hljs-type">B</span> &gt;: <span class="hljs-type">A</span>](ys: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Boolean</span> =<br>  tails exists (_ startsWith s)<br></code></pre></div></td></tr></table></figure><p>这个 hasSubSequence 和之前写的显式递归的方法的效率是一致的，区别在于这里使用高阶函数的组合去进行表述，这是惰性列表的优越之处。放到普通列表，tails 和 startsWith 都会有额外的计算。</p><h1 id="5-16-scanRight"><a href="#5-16-scanRight" class="headerlink" title="5.16 scanRight"></a>5.16 scanRight</h1><p>实现 scan 方法。scan 方法的签名和 fold 一致，但返回值为列表，其作用效果相当于是对列表本身以及每一个 tail 进行 fold 操作并拼接成结果的列表，但性能是线性的；也可以说是每一次折叠都去暂存结果。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scanRight</span></span>[<span class="hljs-type">B</span>](z: =&gt; <span class="hljs-type">B</span>)(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Stream</span>.cons(z, <span class="hljs-type">Empty</span>))&#123; <span class="hljs-keyword">case</span> (x, acc<span class="hljs-meta">@Cons</span>(h, _)) =&gt; <br>    <span class="hljs-type">Stream</span>.cons(f(x, h()), acc) &#125;<br></code></pre></div></td></tr></table></figure><p>unfold 能实现 scanRight 吗？当然能实现，每次都从当前的状态进行折叠即可，但它无法做到线性的时间复杂度，因为之前的状态无法被储存，比如对于<code>Stream(1, 2, 3).scanRight(0)(_ + _)</code>，在之前已经计算过<code>2 + 3</code>，因此计算<code>1 + 2 + 3</code>的时候只需要让<code>1</code>加上<code>2 + 3</code>的结果即可。</p><h1 id="6-1-nonNegativeInt"><a href="#6-1-nonNegativeInt" class="headerlink" title="6.1 nonNegativeInt"></a>6.1 nonNegativeInt</h1><p>获得一个随机非负整数，注意当拿到的随机数正巧为<code>Int.MinValue</code>时，<code>Math.abs</code>调用仍会返回这个最小值，因此在遇到这个值的时候重新随机。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-meta">@tailrec</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nonNegativeInt</span></span>(rng: <span class="hljs-type">RNG</span>): (<span class="hljs-type">Int</span>, <span class="hljs-type">RNG</span>) = &#123;<br>  <span class="hljs-keyword">val</span> (v, r) = rng.nextInt<br>  <span class="hljs-keyword">if</span> (v == <span class="hljs-type">Int</span>.<span class="hljs-type">MinValue</span>) nonNegativeInt(r)<br>  <span class="hljs-keyword">else</span> (<span class="hljs-type">Math</span>.abs(v), r)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="6-2-double"><a href="#6-2-double" class="headerlink" title="6.2 double"></a>6.2 double</h1><p>获得一个随机的0到1的double，仍旧比较容易。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">double</span></span>(rng: <span class="hljs-type">RNG</span>): (<span class="hljs-type">Double</span>, <span class="hljs-type">RNG</span>) = &#123;<br>  <span class="hljs-keyword">val</span> (v, r) = nonNegativeInt(rng)<br>  (v / <span class="hljs-type">Int</span>.<span class="hljs-type">MaxValue</span>.toDouble, r)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="6-3-intDouble，doubleInt，double3"><a href="#6-3-intDouble，doubleInt，double3" class="headerlink" title="6.3 intDouble，doubleInt，double3"></a>6.3 intDouble，doubleInt，double3</h1><p>这三个函数的实现都是比较简单的，主要目的是考虑它之中重复出现的模式——我们手动维护了状态的变化，即rng，r1，r2等变量。这写起来非常蛋疼，且容易出bug，难以维护。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intDouble</span></span>(rng: <span class="hljs-type">RNG</span>): ((<span class="hljs-type">Int</span>, <span class="hljs-type">Double</span>), <span class="hljs-type">RNG</span>) = &#123;<br>  <span class="hljs-keyword">val</span> (v1, r1) = rng.nextInt<br>  <span class="hljs-keyword">val</span> (v2, r2) = double(r1)<br>  ((v1, v2), r2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doubleInt</span></span>(rng: <span class="hljs-type">RNG</span>): ((<span class="hljs-type">Double</span>, <span class="hljs-type">Int</span>), <span class="hljs-type">RNG</span>) = &#123;<br>  <span class="hljs-keyword">val</span> (v1, r1) = double(rng)<br>  <span class="hljs-keyword">val</span> (v2, r2) = r1.nextInt<br>  ((v1, v2), r2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">double3</span></span>(rng: <span class="hljs-type">RNG</span>): ((<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>), <span class="hljs-type">RNG</span>) = &#123;<br>  <span class="hljs-keyword">val</span> (v1, r1) = double(rng)<br>  <span class="hljs-keyword">val</span> (v2, r2) = double(r1)<br>  <span class="hljs-keyword">val</span> (v3, r3) = double(r2)<br>  ((v1, v2, v3), r3)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="6-4-ints"><a href="#6-4-ints" class="headerlink" title="6.4 ints"></a>6.4 ints</h1><p>返回一个<code>Int</code>的列表，这种题目显然需要使用递归，感觉这好像是一个unfold操作，但既然书中没有对此进行进一步抽象，那我也就敬谢不敏了。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ints</span></span>(count: <span class="hljs-type">Int</span>)(rng: <span class="hljs-type">RNG</span>): (<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>], <span class="hljs-type">RNG</span>) =<br>  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) (<span class="hljs-type">Nil</span>, rng)<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">val</span> (v, r) = rng.nextInt<br>    <span class="hljs-keyword">val</span> (last, s) = ints(count - <span class="hljs-number">1</span>)(r)<br>    (v :: last, s)<br>  &#125;<br></code></pre></div></td></tr></table></figure><h1 id="6-5-使用map实现double"><a href="#6-5-使用map实现double" class="headerlink" title="6.5 使用map实现double"></a>6.5 使用map实现double</h1><p>不难，用于熟悉抽象。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">val</span> double$: <span class="hljs-type">Rand</span>[<span class="hljs-type">Double</span>] = <br>  map(nonNegativeInt)(_ / <span class="hljs-type">Int</span>.<span class="hljs-type">MaxValue</span>.toDouble)<br></code></pre></div></td></tr></table></figure><h1 id="6-6-map2"><a href="#6-6-map2" class="headerlink" title="6.6 map2"></a>6.6 map2</h1><p>实现map2，该操作（组合子）的形式非常熟悉。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](a: <span class="hljs-type">Rand</span>[<span class="hljs-type">A</span>], b: <span class="hljs-type">Rand</span>[<span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Rand</span>[<span class="hljs-type">C</span>] = rng =&gt; &#123;<br>  <span class="hljs-keyword">val</span> (v1, r1) = a(rng)<br>  <span class="hljs-keyword">val</span> (v2, r2) = b(r1)<br>  (f(v1, v2), r2)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="6-7-sequence"><a href="#6-7-sequence" class="headerlink" title="6.7 sequence"></a>6.7 sequence</h1><p>sequence就是将一连串的Rand按序执行，可以注意到这操作的形式和折叠很像。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence</span></span>[<span class="hljs-type">A</span>](fs: <span class="hljs-type">List</span>[<span class="hljs-type">Rand</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">Rand</span>[<span class="hljs-type">List</span>[<span class="hljs-type">A</span>]] = rng =&gt; fs <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; (<span class="hljs-type">Nil</span>, rng)<br>  <span class="hljs-keyword">case</span> x :: xs =&gt; map2(x, sequence(xs))(_ :: _)(rng)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用sequence实现ints也是简单的：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ints$</span></span>(count: <span class="hljs-type">Int</span>): <span class="hljs-type">Rand</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]] =<br>  sequence(<span class="hljs-type">List</span>.fill(count)(_.nextInt))<br></code></pre></div></td></tr></table></figure><h1 id="6-8-flatMap"><a href="#6-8-flatMap" class="headerlink" title="6.8 flatMap"></a>6.8 flatMap</h1><p>flatMap的实现就很有趣了，可以将flatMap理解为顺序的计算，先将当前的计算进行执行，再将计算后得到的状态传递给后一个计算。这样理解大概对一切monad都适用。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](a: <span class="hljs-type">Rand</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Rand</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Rand</span>[<span class="hljs-type">B</span>] = rng =&gt; &#123;<br>  <span class="hljs-keyword">val</span> (v, r) = a(rng)<br>  f(v)(r)<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="6-9-使用flatMap实现map和map2"><a href="#6-9-使用flatMap实现map和map2" class="headerlink" title="6.9 使用flatMap实现map和map2"></a>6.9 使用flatMap实现map和map2</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map$</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](a: <span class="hljs-type">Rand</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Rand</span>[<span class="hljs-type">B</span>] = flatMap(a) &#123; i =&gt; unit(f(i)) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2$</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](ra: <span class="hljs-type">Rand</span>[<span class="hljs-type">A</span>], rb: <span class="hljs-type">Rand</span>[<span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Rand</span>[<span class="hljs-type">C</span>] =<br>  flatMap(ra)(a =&gt; map(rb)(b =&gt; f(a, b))) <span class="hljs-comment">// 或者 flatMap(ra)(a =&gt; flatMap(rb)(b =&gt; unit(f(a, b))))</span><br></code></pre></div></td></tr></table></figure><h1 id="6-10-泛化unit，map，map2，flatMap，sequence"><a href="#6-10-泛化unit，map，map2，flatMap，sequence" class="headerlink" title="6.10 泛化unit，map，map2，flatMap，sequence"></a>6.10 泛化unit，map，map2，flatMap，sequence</h1><p>将纯函数式状态（转移）抽象出来，并实现相应方法或函数：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span>[<span class="hljs-type">S</span>, +<span class="hljs-type">A</span>](<span class="hljs-params">run: <span class="hljs-type">S</span> =&gt; (<span class="hljs-type">A</span>, <span class="hljs-type">S</span></span>)) </span>&#123;<br>  <span class="hljs-comment">// map方法就是构造一个新的State，该State为当前State执行后对结果进行一个映射</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">B</span>] = <span class="hljs-type">State</span> &#123; s =&gt;<br>    <span class="hljs-keyword">val</span> (r, nextS) = run(s)<br>    (f(r), nextS)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2</span></span>[<span class="hljs-type">B</span>, <span class="hljs-type">C</span>](b: <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">C</span>] = <span class="hljs-type">State</span> &#123; s =&gt;<br>    <span class="hljs-keyword">val</span> (r1, s1) = run(s)<br>    <span class="hljs-keyword">val</span> (r2, s2) = b.run(s1)<br>    (f(r1, r2), s2)<br>  &#125;<br><br>  <span class="hljs-comment">// 先执行当前计算，将下一个值传给f，对生成的State执行计算</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">B</span>] = <span class="hljs-type">State</span> &#123; s =&gt;<br>    <span class="hljs-keyword">val</span> (r1, s1) = run(s)<br>    f(r1).run(s1)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">State</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unit</span></span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>] = <span class="hljs-type">State</span>((a, _))<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sequence</span></span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>](a: <span class="hljs-type">List</span>[<span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>]]): <span class="hljs-type">State</span>[<span class="hljs-type">S</span>, <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]] = a <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">State</span>((<span class="hljs-type">Nil</span>, _))<br>    <span class="hljs-keyword">case</span> x :: xs =&gt; x.map2(sequence(xs))(_ :: _)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="6-11-实现一个简单的有穷状态自动机"><a href="#6-11-实现一个简单的有穷状态自动机" class="headerlink" title="6.11 实现一个简单的有穷状态自动机"></a>6.11 实现一个简单的有穷状态自动机</h1><p>这题虽然说着难，但是操作起来还是挺简单的，主要是要根据规则编写状态转移的函数。当编写完状态转移的函数后，便能够编写接受一连串命令的函数了（我看这个函数好像又是个折叠操作）：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Input</span></span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Coin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Input</span></span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Turn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Input</span></span><br><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Machine</span>(<span class="hljs-params">locked: <span class="hljs-type">Boolean</span>, coins: <span class="hljs-type">Int</span>, candies: <span class="hljs-type">Int</span></span>)</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Machine</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">operate</span></span>(input: <span class="hljs-type">Input</span>): <span class="hljs-type">State</span>[<span class="hljs-type">Machine</span>, (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-type">State</span> &#123; state =&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deconstruct</span></span>(state: <span class="hljs-type">Machine</span>): ((<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>), <span class="hljs-type">Machine</span>) = ((state.coins, state.candies), state)<br>    <span class="hljs-comment">// 有三个参数：Input，locked，candies &lt;= 0?</span><br>    (input, state.locked, state.candies) <span class="hljs-keyword">match</span> &#123;<br>      <span class="hljs-keyword">case</span> (input, _, candies) <span class="hljs-keyword">if</span> candies &lt;= <span class="hljs-number">0</span> =&gt; input <span class="hljs-keyword">match</span> &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Coin</span> =&gt; deconstruct(state.copy(coins = state.coins + <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">Turn</span> =&gt; deconstruct(state)<br>      &#125;<br>      <span class="hljs-keyword">case</span> (<span class="hljs-type">Coin</span>, _, _) =&gt; deconstruct(state.copy(locked = <span class="hljs-literal">false</span>, coins = state.coins + <span class="hljs-number">1</span>))<br>      <span class="hljs-keyword">case</span> (<span class="hljs-type">Turn</span>, <span class="hljs-literal">false</span>, candies) =&gt; deconstruct(state.copy(locked = <span class="hljs-literal">true</span>, candies = candies - <span class="hljs-number">1</span>))<br>      <span class="hljs-keyword">case</span> (<span class="hljs-type">Turn</span>, <span class="hljs-literal">true</span>, _) =&gt; deconstruct(state)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">simulateMachine</span></span>(input: <span class="hljs-type">List</span>[<span class="hljs-type">Input</span>]): <span class="hljs-type">State</span>[<span class="hljs-type">Machine</span>, (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)] = input <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">State</span>.get[<span class="hljs-type">Machine</span>].map(s =&gt; (s.coins, s.candies))<br>    <span class="hljs-keyword">case</span> x :: xs =&gt; operate(x).flatMap(_ =&gt; simulateMachine(xs))<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>暂且到此，感觉对学到的东西仍旧不太清晰，待之后学习完第二第三部分后整个回过头来再看一遍吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 foldRight 为何能操作无穷列表</title>
    <link href="/2022/04-18%E5%85%B3%E4%BA%8EfoldRight%E4%B8%BA%E4%BD%95%E8%83%BD%E6%93%8D%E4%BD%9C%E6%97%A0%E7%A9%B7%E5%88%97%E8%A1%A8.html"/>
    <url>/2022/04-18%E5%85%B3%E4%BA%8EfoldRight%E4%B8%BA%E4%BD%95%E8%83%BD%E6%93%8D%E4%BD%9C%E6%97%A0%E7%A9%B7%E5%88%97%E8%A1%A8.html</url>
    
    <content type="html"><![CDATA[<p>从我在第一次接触到 Haskell 中的 foldRight（foldr）起，我就对它十分好奇：foldRight 是如何能够处理无穷列表的？这个问题让我魂牵梦绕，我必须要得到一个合情合理的结果。</p><h1 id="foldRight-的推导"><a href="#foldRight-的推导" class="headerlink" title="foldRight 的推导"></a>foldRight 的推导</h1><p>首先摆出我们的惰性列表的 ADT 以及 foldRight 的实现：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">import</span> scala.&#123;<span class="hljs-type">Stream</span> =&gt; _&#125; <span class="hljs-comment">// 必须排除标准库的 Stream，避免重名</span><br><span class="hljs-comment">// 为图方便，两个值构造器放到前面</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Empty</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Stream</span>[<span class="hljs-type">Nothing</span>]</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span>[+<span class="hljs-type">A</span>](<span class="hljs-params">h: (</span>) <span class="hljs-title">=&gt;</span> <span class="hljs-title">A</span>, <span class="hljs-title">t</span></span>: () =&gt; <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]) <span class="hljs-keyword">extends</span> <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] <span class="hljs-comment">// 注意 final 需要在 case 之前</span><br><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Stream</span>[+<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-comment">// toList 方便展示</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toList</span></span>: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">Nil</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; h() :: t().toList<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldRight</span></span>[<span class="hljs-type">B</span>](z: =&gt; <span class="hljs-type">B</span>)(fn: (<span class="hljs-type">A</span>, =&gt; <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; z<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; fn(h(), t().foldRight(z)(fn)) <span class="hljs-comment">// 也可理解为 h() &gt;=&gt; t().foldRight(z)(fn)，其中 &gt;=&gt; 即为 fn 的中缀表示形式，右结合且对第二个参数非严格求值</span><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Stream</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">A</span>](xs: <span class="hljs-type">A</span>*): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>    xs.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>])((x, acc) =&gt; <span class="hljs-type">Cons</span>(() =&gt; x, () =&gt; acc))<br>  <br>  <span class="hljs-comment">// smart constructor</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cons</span></span>[<span class="hljs-type">A</span>](x: <span class="hljs-type">A</span>, xs: =&gt; <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = &#123;<br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> head = x<br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> tail = xs<br>    <span class="hljs-type">Cons</span>(() =&gt; head, () =&gt; tail)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Scala 的 foldRight 远远比 Haskell 中的要明显：考虑 fn 的签名<code>(A, =&gt; B) =&gt; B</code>，只要我们在 fn 中不对第二个参数求值，即我们不求值<code>t().foldRight(z)(fn)</code>，即我们不求值<code>t</code>，则 t 就根本不会被计算！t 若不被计算，则流中从该处的 h 之后的元素都不会被计算了。</p><p>这是惰性列表和普通列表的 foldRight 的最大的不同：对于普通列表，它的每一次 fn 的调用之前，都会先对左右参数求值，而每次对右边参数求值都是对子列表的 foldRight，这种递归会无限进行，直到到达列表尾部或爆栈；而对于惰性列表，如果不对右边参数求值，则这次 foldRight 就算弄完了，后续列表的求值就当作不存在。</p><p>为此，我们可以干脆地实现一个 headOption 方法：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">headOption</span></span>: <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =<br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">None</span>: <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>])((x, _) =&gt; <span class="hljs-type">Some</span>(x))<br></code></pre></div></td></tr></table></figure><p>虽然这代码是我自己写的，但我还是觉得这玩意有点性感，我们去推导一下<code>Stream</code>，省略一切不必要的东西并使用我的形式：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).headOption<br><span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).foldRight(<span class="hljs-type">None</span>)(fn)        <span class="hljs-comment">// 应用 headOption</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).foldRight(<span class="hljs-type">None</span>)(fn)  <span class="hljs-comment">// 解构 Stream</span><br>fn(<span class="hljs-number">1</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>).foldRight(<span class="hljs-type">None</span>)(fn))    <span class="hljs-comment">// 应用 foldRight</span><br><span class="hljs-type">Some</span>(<span class="hljs-number">1</span>)                                    <span class="hljs-comment">// 应用 fn</span><br></code></pre></div></td></tr></table></figure><p>再考虑一个无穷列表，比如自然数列表，求他的 head：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-type">Stream</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...).headOption<br><span class="hljs-type">Stream</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...).foldRight(<span class="hljs-type">None</span>)(fn)<br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...)).foldRight(<span class="hljs-type">None</span>)(fn)<br>fn(<span class="hljs-number">0</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...).foldRight(<span class="hljs-type">None</span>)(fn))<br><span class="hljs-type">Some</span>(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p>从这里已经能看出来东西了：<strong>只要在某次 fn 调用中不对 acc 求值，我们就能终止后续的 foldRight 方法的调用，此时 fn 的返回值就是最后一次调用的 foldRight 方法的结果，而 z 值实际上只有在列表为空时才被使用</strong>。</p><blockquote><p>该方法对普通列表仍旧适用，但性能是极差的——无法终止后续的 foldRight 方法的调用——我取个 head 为啥要把整个列表都过一遍？</p></blockquote><p>为此，我们再实现一个更加显然的例子——实现能处理无穷列表的 takeWhile：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeWhile</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>])((x, acc) =&gt; <span class="hljs-keyword">if</span> (f(x)) <span class="hljs-type">Stream</span>.cons(x, acc) <span class="hljs-keyword">else</span> <span class="hljs-type">Empty</span>)<br></code></pre></div></td></tr></table></figure><p>对一个自然数列表进行推导，获取所有小于等于 2 的值：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-type">Stream</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...).takeWhile(_ &lt;= <span class="hljs-number">2</span>)<br><span class="hljs-type">Stream</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...).foldRight(<span class="hljs-type">Empty</span>)(fn)                         <span class="hljs-comment">// 应用 takeWhile</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...)).foldRight(<span class="hljs-type">Empty</span>)(fn)                   <span class="hljs-comment">// 解构 Stream</span><br>fn(<span class="hljs-number">0</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...).foldRight(<span class="hljs-type">Empty</span>)(fn))                     <span class="hljs-comment">// 应用 foldRight</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...).foldRight(<span class="hljs-type">Empty</span>)(fn))                   <span class="hljs-comment">// 应用 fn</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...)).foldRight(<span class="hljs-type">Empty</span>)(fn))             <span class="hljs-comment">// 解构 Stream</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, fn(<span class="hljs-number">1</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...).foldRight(<span class="hljs-type">Empty</span>)(fn)))               <span class="hljs-comment">// 应用 foldRight</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...).foldRight(<span class="hljs-type">Empty</span>)(fn)))             <span class="hljs-comment">// 应用 fn</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">3</span>, ...)).foldRight(<span class="hljs-type">Empty</span>)(fn)))       <span class="hljs-comment">// 解构 Stream</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">1</span>, fn(<span class="hljs-number">2</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">3</span>, ...).foldRight(<span class="hljs-type">Empty</span>)(fn))))         <span class="hljs-comment">// 应用 foldRight</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">3</span>, ...).foldRight(<span class="hljs-type">Empty</span>)(fn))))       <span class="hljs-comment">// 应用 fn</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">3</span>, <span class="hljs-type">Stream</span>(...)).foldRight(<span class="hljs-type">Empty</span>)(fn)))) <span class="hljs-comment">// 解构 Stream</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">2</span>, fn(<span class="hljs-number">3</span>, <span class="hljs-type">Stream</span>(...).foldRight(<span class="hljs-type">Empty</span>)(fn)))))   <span class="hljs-comment">// 应用 foldRight</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">0</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Empty</span>)))                                     <span class="hljs-comment">// 应用 fn</span><br><span class="hljs-type">Stream</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)                                                      <span class="hljs-comment">// 使用 Stream 表示</span><br></code></pre></div></td></tr></table></figure><p>容易发现，<strong>我们实际上是在对列表中的每个元素 x 调用 fn，并在 fn 中根据 x 的值来确定操作——我是继续迭代下去，还是在这里直接终止？</strong>从这方面说来，fn 实际上是<code>x =&gt; 行为</code>的映射。使用这种思路，我们就能够实现 take。</p><p>为啥上面使用 takeWhile 做例子呢？因为 take 方法无法使用单纯的 foldRight 实现：它的迭代过程中需要维持一个“内部”的状态，即当前还需要 take 的元素数量。我们先编写一个显式的递归的 take 方法：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">take</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> _ <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> =&gt; <span class="hljs-type">Empty</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">Empty</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; <span class="hljs-type">Stream</span>.cons(h(), t().take(n - <span class="hljs-number">1</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但若强迫要求使用 foldRight，最显然的方式是在 fn 中使用一个闭包去捕获该变量并在每次更新时维护该变量，这性能可能是最好的，但并不优雅，且无法推导：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Bad!</span><br><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">badTake</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = &#123;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>])((x, acc) =&gt; <span class="hljs-keyword">if</span> (i &lt; n) &#123;<br>    i += <span class="hljs-number">1</span><br>    <span class="hljs-type">Stream</span>.cons(x, acc)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-type">Empty</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据上面的认识，即<code>fn = x =&gt; 行为</code>，我们可以将状态包含在 x 中，即当前元素的下标，我们可以先实现一个<code>mapWithIndex</code>的工具方法，利用其将 index 包含在 x 中，并在折叠操作中进行使用，事后再通过 map 丢掉 index，而<code>zipWithIndex</code>可以使用<code>zip</code>和<code>Nat</code>去定义：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// Stream function</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zip</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](la: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>], lb: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Stream</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">B</span>)] = (la, lb) <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> ((<span class="hljs-type">Cons</span>(x, xs), <span class="hljs-type">Cons</span>(y, ys))) =&gt; <span class="hljs-type">Stream</span>.cons((x(), y()), zip(xs(), ys()))<br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Empty</span><br>&#125;<br><span class="hljs-comment">// Stream function，自然数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Nat</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] =<br>    cons(n, go(n + <span class="hljs-number">1</span>))<br>  go(<span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] = <br>  <span class="hljs-keyword">this</span>.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>])((x, acc) =&gt; <span class="hljs-type">Stream</span>.cons(f(x), acc))<br><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zipWithIndex</span></span>: <span class="hljs-type">Stream</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">Int</span>)] = <span class="hljs-type">Stream</span>.zip(<span class="hljs-keyword">this</span>, <span class="hljs-type">Stream</span>.<span class="hljs-type">Nat</span>)<br><span class="hljs-comment">// Stream method</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">take</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>  <span class="hljs-keyword">this</span>.zipWithIndex.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">Int</span>)])&#123; (x, acc) =&gt; <span class="hljs-comment">// 不要在这里省代码！</span><br>    <span class="hljs-keyword">val</span> (_, index) = x<br>    <span class="hljs-keyword">if</span> (index &lt; n) <span class="hljs-type">Stream</span>.cons(x, acc)<br>    <span class="hljs-keyword">else</span> <span class="hljs-type">Empty</span><br>  &#125;.map(_._1)<br></code></pre></div></td></tr></table></figure><p>万分注意！这里定义 take 的 foldRight 的 fn 的时候不能用偏函数的形式去解构 x（形如<code>&#123; case (x@(_, index), acc) =&gt; ... &#125;</code>），<strong>该操作本质上是进行了一次模式匹配，因而会对 acc 进行求值，从而导致爆栈</strong>！</p><p>根据之前对惰性列表中的学习，该操作虽然看起来有点吓人，但性能并不差——实际上只是对每一个元素进行包装和解包装了而已，性能是没有多少损失的，<strong>但仍旧有爆栈的风险，毕竟调用对每个元素递归调用 fn 是必须的</strong>。我觉得解决方案是使用命令式的方式去重新定义 foldRight，使用真正的栈去维护调用栈，然后所有操作都使用 foldRight 或 foldRight 编写的方法或使用命令式的代码来实现。我相信 Scala 标准库中的惰性列表也是这样做的，否则就只能在编译器上打孔了。毕竟爆栈的风险总是存在的，对于列表这种线性结构尤甚。</p><h1 id="关于-gt-gt"><a href="#关于-gt-gt" class="headerlink" title="关于 &gt;=&gt;"></a>关于 &gt;=&gt;</h1><p>对于无穷列表，我之前所使用的解释折叠的方法就很怪了——如何在一个无穷的序列后面加东西？为此该方法需要被改变，而改变后的方法和实际的计算过程是非常相像的——<strong>动态地去构造<code>&gt;=&gt;</code>所连接起来的序列</strong>。</p><p>比如，求一个自然数序列的小于 3 的部分的和，代码我们会这么写：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-type">Stream</span>.<span class="hljs-type">Nat</span>.foldRight(<span class="hljs-number">0</span>)((x, acc) =&gt; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">3</span>) x + acc <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p>为此，按照新的推导方法，过程是这样：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-type">Stream</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, ...).fold<br><span class="hljs-number">0</span> &gt;=&gt; <span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, ...).fold<br><span class="hljs-number">0</span> &gt;=&gt; <span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-type">Stream</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, ...).fold<br><span class="hljs-number">0</span> &gt;=&gt; <span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-type">Stream</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, ...).fold<br><span class="hljs-number">0</span> &gt;=&gt; <span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">0</span>  <span class="hljs-comment">// 在这里，fn(3, Stream(4, ...).fold) 的求值直接返回 0</span><br><span class="hljs-number">0</span> + (<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> + <span class="hljs-number">0</span>))<br><span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>该过程就相当于是从前往后对每一个元素都进行“检查”，找到要求停止的元素，然后把 fn 的返回值作为初始值，在这里是当 x 为 3 时停止，返回一个 0。</p><p>那么问题又来了，对于惰性列表，链式调用（实际上是折叠操作的链式调用）有没有什么更加舒服的描述方式呢？</p><blockquote><p>另一种考虑惰性列表的方式是将其看作无限嵌套的盒子，每次打开一个盒子，盒子里都会有一个值（在 Haskell 里，这个值也是盒子，所谓一切皆 thunk），和一个更小的盒子。</p></blockquote><h1 id="如何看待惰性求值"><a href="#如何看待惰性求值" class="headerlink" title="如何看待惰性求值"></a>如何看待惰性求值</h1><p>惰性求值不会改变代码的形式（即能操作普通列表的方法不需要改变结构 &#x2F; 源代码就能够去操作惰性列表），但有着更高的性能并减少中间生成的临时数据结构，因此它可以认为是函数式编程中的一个<strong>优化方式</strong>。</p><p>但这也带来了代价：对方法的时空复杂度的分析将变得困难，错误编写的代码会导致内存泄漏。因此，对于惰性求值的看法应当就同对于优化的看法一致：<strong>不要提前优化</strong>。但若是惰性列表会简化代码的情况，我认为主动去使用它也是合理的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala 学习笔记——惰性求值</title>
    <link href="/2022/04-16Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC.html"/>
    <url>/2022/04-16Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC.html</url>
    
    <content type="html"><![CDATA[<p>继续阅读《Scala 函数式编程》，记录些有趣的新玩意。这书某些地方的翻译实在连机翻都不如，但原书实在太好了，之后去看英文版。</p><p>该篇笔记记录关于惰性求值以及传名调用，传值调用等概念的学习。惰性求值的重要性在于，它能够使我们操作集合时在使用原有的高阶函数进行操作的基础上<strong>尽量保证性能，不用在操作过程中临时创建集合</strong>。而这种优化在不使用命令式的代码时是很难做到的。惰性求值使我们能同时保证抽象性和性能。<del>那代价是什么呢？</del></p><span id="more"></span><h1 id="关于-Call-By-Value-Call-By-Name"><a href="#关于-Call-By-Value-Call-By-Name" class="headerlink" title="关于 Call By Value, Call By Name"></a>关于 Call By Value, Call By Name</h1><p>某些语句或操作符具有<strong>短路</strong>的特性，比如对 if 语句，如果 cond 为<code>true</code>，则 else 子句就不会被求值；对<code>&amp;&amp;</code>，如果前一个参数为<code>false</code>，则后一个参数不会被求值；对<code>||</code>，如果前一个参数是<code>true</code>，则第二个参数不会被求值。借助短路特性，我们甚至可以写出<code>false &amp;&amp; 1 / 0 == 0</code>这样合法且不会抛出异常的表达式。</p><p>在大多数语言里，我们无法定义具有 if，<code>&amp;&amp;</code>，<code>||</code>这样的语句&#x2F;操作符的行为的函数，比如，假如我们试图定义一个 <code>and</code>，并利用这个 <code>and</code> 去编写一个 <code>head</code> 函数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">and</span><span class="hljs-params">(<span class="hljs-type">boolean</span> condA, <span class="hljs-type">boolean</span> condB)</span> &#123;<br>  <span class="hljs-keyword">return</span> condA &amp;&amp; condB;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">head</span><span class="hljs-params">(List&lt;Integer&gt; lst)</span> &#123;<br>  <span class="hljs-keyword">if</span> (and(lst != <span class="hljs-literal">null</span>, lst.size() != <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-keyword">return</span> lst.get(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;list can&#x27;t be null!&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当我们试图调用这里的 <code>head</code> 函数时：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">List&lt;Integer&gt; lst = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 生产环境可不能这么干！</span><br>System.out.println(head(lst));<br></code></pre></div></td></tr></table></figure><p>能够发现，该代码抛出了空指针异常，这发生在 <code>and</code> 函数调用时。为什么会这样呢？这是因为大多数语言都是 <strong>Call By Value</strong>（传值调用），这是说，<strong>在函数调用之前，它会对各个参数进行求值并将结果值传递给函数</strong>，在这里，就是先求值<code>lst != null</code>和<code>lst.size() != 0</code>这两个表达式，将其结果传递给 <code>and</code> 函数，其中在求值<code>lst.size()</code>时就会抛出空指针异常。</p><p>与此相对的就是 <strong>Call By Name</strong>（传名调用），这是说，<strong>函数参数的表达式会被原样传递给函数，直到被求值时才真正对表达式执行计算</strong>，换句话说，在这个情形中，传值调用传递给函数的是<code>false</code>和<code>Nothing</code>，传名调用传递给函数的是<code>lst != null</code>和<code>lst.size() != 0</code>。</p><p><strong>Call By Name 的行为和<code>() =&gt; A</code>的函数完全一致</strong>，比如我们可以这样实现 if——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-comment">// 考虑到清晰性的需要，使用 Scala 描述，但行为仍旧同 java 的 if 一致。使用 Java 的话得写 Runnable，不太痛快</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myIf</span></span>(cond: <span class="hljs-type">Boolean</span>, onTrue: () =&gt; <span class="hljs-type">Unit</span>, onFalse: () =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> &#123;<br>  <span class="hljs-keyword">if</span> (cond) &#123;<br>    onTrue()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    onFalse()<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以认为 Call By Value 就是严格求值，Call By Name 就是非严格求值或惰性求值。说它是非严格求值，是因为<strong>函数调用时可以不对一个或多个参数进行求值</strong>，而严格求值的函数对所有参数都将求值。Scala 为非严格求值提供了独特的语法（类型定义）<code>=&gt; A</code>，<strong>这样定义的参数只有在被调用的时候才会被求值</strong>，但其使用方法没有任何改变，比如我们可以定义一个类似 Rust 中的 loop 语句——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loop</span></span>(block: =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> = <br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    block <span class="hljs-comment">// 直接写出来就是调用了</span><br>  &#125;<br><br>loop &#123;<br>  println(<span class="hljs-string">&quot;hello!&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>非严格求值中表达式的未求值形式称为<code>thunk</code>。</p><p>也需注意，<code>=&gt; A</code>定义的变量每次调用时其都会被求值，这在某些时候可能并非我们想要的，有时候我们会想要把值只执行一次并缓存，之后都用缓存的值，这时候我们就可以结合<code>lazy val</code>进行使用。</p><p>严格求值在很多时候都是满足需求的，但在某些时候会有性能问题。比如，我们经常会对列表进行链式调用，如果是严格求值，则每次调用时我们都创建了一个新的列表，这在性能上可能会很差，更别说我们无法中途中断某些函数，无法表达无限长度列表等。以现有的工具，如果想要优化的话只能将操作都组合在同一个函数调用中，比如通过 <code>reduce</code> 可以模拟其它所有操作，或者使用命令式的方式。</p><p>于是，在像 Lodash，Spark 的 RDD 或 Java8 的 Stream 等场景&#x2F;技术里，它们进行链式调用时，中途的操作并非是立刻就进行的，所有计算都在最后的行动&#x2F;终端&#x2F;取值操作中才进行，因而可以进行各种优化。</p><p>而函数式编程中对于这种情况的优化可以使用惰性求值去实现，对列表的每一个元素，只有在求值时才会被计算，Scala 默认就提供了惰性的列表——<code>Stream</code>（当前已过期，使用<code>LazyList</code>替代），它的行为和 Haskell 中的一致。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Stream</span>[+<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Empty</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Stream</span>[<span class="hljs-type">Nothing</span>]</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span>[+<span class="hljs-type">A</span>](<span class="hljs-params">h: (</span>) <span class="hljs-title">=&gt;</span> <span class="hljs-title">A</span>, <span class="hljs-title">t</span></span>: () =&gt; <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]) <span class="hljs-keyword">extends</span> <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]<br></code></pre></div></td></tr></table></figure><p>我们可以对 Stream 定义一个惰性的右折叠（以方法的形式），它的行为和 Haskell 中的一致但比 Haskell 中更容易看出来——如果没有对 <code>f</code> 的第二个参数进行求值，则 <code>tail</code> 的部分根本不会被计算。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldRight</span></span>[<span class="hljs-type">B</span>](z: =&gt; <span class="hljs-type">B</span>)(f: (<span class="hljs-type">A</span>, =&gt; <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; f(h(), t().foldRight(z)(f))<br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Empty</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>借助 <code>foldRight</code>，我们可以对无限的列表进行折叠操作，只要在其中某一步中没有对 <code>tail</code> 进行求值即可，比如这里拷贝一个自然数列表：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Nat</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] =<br>    cons(n, go(n + <span class="hljs-number">1</span>))<br>  go(<span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copy</span></span>[<span class="hljs-type">A</span>](l: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <br>  l.foldRight(<span class="hljs-type">Empty</span>)(cons(_, _))<br><br>println(copy(<span class="hljs-type">Nat</span>).take(<span class="hljs-number">10</span>).toList()) <span class="hljs-comment">// List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br></code></pre></div></td></tr></table></figure><p>但更重要的是，考虑到 <code>map</code>，<code>filter</code> 操作也是使用折叠去定义的，我们可以去对无限列表进行<code>map-filter-reduce</code>操作！比如下面定义了 <code>filter</code>，并定义了自然数中奇数的集合：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>[<span class="hljs-type">A</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>)(l: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] =<br>  l.foldRight(<span class="hljs-type">Empty</span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>])((x, acc) =&gt; <span class="hljs-keyword">if</span> (f(x)) cons(x, acc) <span class="hljs-keyword">else</span> acc)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Odd</span></span>: <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] =<br>  filter[<span class="hljs-type">Int</span>](_ % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)(<span class="hljs-type">Nat</span>)<br>println(<span class="hljs-type">Odd</span>.take(<span class="hljs-number">10</span>).toList())<br></code></pre></div></td></tr></table></figure><p>关于foldRight为何能处理无限流，可以考虑这样的场景，对<code>Nat.takeWhile(_ &lt; 5)</code>，会得到这样的序列：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Haskell"><span class="hljs-number">0</span> &lt;=&lt; <span class="hljs-number">1</span> &lt;=&lt; <span class="hljs-number">2</span> &lt;=&lt; <span class="hljs-number">3</span> &lt;=&lt; ... &lt;=&lt; n &lt;=&lt; []<br></code></pre></div></td></tr></table></figure><p>对后面的任意大于等于5的n，<code>n &lt;=&lt; []</code>都返回<code>[]</code>，因此最后得到的计算序列仍旧是：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Haskell"><span class="hljs-number">0</span> &lt;=&lt; <span class="hljs-number">1</span> &lt;=&lt; <span class="hljs-number">2</span> &lt;=&lt; <span class="hljs-number">3</span> &lt;=&lt; <span class="hljs-number">4</span> &lt;=&lt; <span class="hljs-number">5</span> &lt;=&lt; []<br></code></pre></div></td></tr></table></figure><p>在特定情况下<code>&lt;=&lt;</code>会返回<code>[]</code>，这是处理无穷列表的关键之处。</p><h1 id="推导-Stream-的链式调用"><a href="#推导-Stream-的链式调用" class="headerlink" title="推导 Stream 的链式调用"></a>推导 Stream 的链式调用</h1><p>要真正理解 Stream 在链式调用时的行为，我们需要对一些示例去进行推导以去增长感性经验。根据之前的感觉，使用 OOP 的形式进行的推导好像更容易一些，为此我们先实现作为方法的 <code>map</code> 和 <code>filter</code>，使用递归的形式：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">B</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">Empty</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; <span class="hljs-type">Stream</span>.cons(f(h()), t().map(f))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Stream</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">this</span> <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Empty</span> =&gt; <span class="hljs-type">Empty</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(h, t) =&gt; &#123;<br>    <span class="hljs-keyword">val</span> head = h()<br>    <span class="hljs-keyword">if</span> (p(head)) <span class="hljs-type">Stream</span>.cons(h(), t().filter(p))<br>    <span class="hljs-keyword">else</span> t().filter(p)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对<code>Stream(1,2,3,4).filter(_ % 2 == 0).map(_ + 10).toList()</code>，推导如下，其中 Cons 忽略了<code>() =&gt;</code>的部分。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>).filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ + <span class="hljs-number">10</span>).toList()<br><span class="hljs-type">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)).filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ + <span class="hljs-number">10</span>).toList()         <span class="hljs-comment">// 解构 Stream</span><br><span class="hljs-type">Stream</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>).filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ + <span class="hljs-number">10</span>).toList()                  <span class="hljs-comment">// 应用 filter，容易发现，元素 1 在这里直接扔掉了</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)).filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ + <span class="hljs-number">10</span>).toList()          <span class="hljs-comment">// 解构 Stream</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>).filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)).map(_ + <span class="hljs-number">10</span>).toList()          <span class="hljs-comment">// 应用 filter</span><br><span class="hljs-type">Cons</span>(<span class="hljs-number">12</span>, <span class="hljs-type">Stream</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>).filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ + <span class="hljs-number">10</span>)).toList()         <span class="hljs-comment">// 应用 map</span><br><span class="hljs-number">12</span> :: <span class="hljs-type">Stream</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>).filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ + <span class="hljs-number">10</span>).toList()             <span class="hljs-comment">// 应用 toList</span><br><span class="hljs-number">12</span> :: <span class="hljs-type">Cons</span>(<span class="hljs-number">3</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">4</span>, <span class="hljs-type">Empty</span>)).filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ + <span class="hljs-number">10</span>).toList()  <span class="hljs-comment">// 解构 Stream，并对 Stream(4) 转换为 Cons 的模式</span><br><span class="hljs-number">12</span> :: <span class="hljs-type">Cons</span>(<span class="hljs-number">4</span>, <span class="hljs-type">Empty</span>).filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ + <span class="hljs-number">10</span>).toList()           <span class="hljs-comment">// 应用 filter，丢弃 3</span><br><span class="hljs-number">12</span> :: <span class="hljs-type">Cons</span>(<span class="hljs-number">4</span>, <span class="hljs-type">Empty</span>.filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)).map(_ + <span class="hljs-number">10</span>).toList()           <span class="hljs-comment">// 应用 filter</span><br><span class="hljs-number">12</span> :: <span class="hljs-type">Cons</span>(<span class="hljs-number">14</span>, <span class="hljs-type">Empty</span>.filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ + <span class="hljs-number">10</span>)).toList()          <span class="hljs-comment">// 应用 map</span><br><span class="hljs-number">12</span> :: <span class="hljs-number">14</span> :: <span class="hljs-type">Empty</span>.filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ + <span class="hljs-number">10</span>).toList()              <span class="hljs-comment">// 应用 toList</span><br><span class="hljs-number">12</span> :: <span class="hljs-number">14</span> :: <span class="hljs-type">Nil</span><br>[<span class="hljs-number">12</span>, <span class="hljs-number">14</span>]<br></code></pre></div></td></tr></table></figure><p>这种推导感觉挺容易写错的，但容易发现，它的行为就像构造了一个管道，对每个元素，它都将依序通过这些管子并执行各种操作。</p><p><strong>惰性列表使许多方法的定义在保持原有性能的基础上可以使用高阶函数去组合出来</strong>，比如考虑一个 find 方法，我们可以直接结合 <code>filter</code> 和 <code>headOption</code> 去定义它（实际上，我们在 Java 的 Stream 里也可以这么玩嘛！新玩具 get），这无论在性能上还是在优雅性上都是十分高的，因为对于 Stream，filter 等操作是惰性的，并不会真的遍历整个列表。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] = <br>  filter(p).headOption<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个点击翻译文字查看原文的 hexo 标签的实现</title>
    <link href="/2022/04-10%E4%B8%80%E4%B8%AA%E7%82%B9%E5%87%BB%E7%BF%BB%E8%AF%91%E6%96%87%E5%AD%97%E6%9F%A5%E7%9C%8B%E5%8E%9F%E6%96%87%E7%9A%84hexo%E6%A0%87%E7%AD%BE%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <url>/2022/04-10%E4%B8%80%E4%B8%AA%E7%82%B9%E5%87%BB%E7%BF%BB%E8%AF%91%E6%96%87%E5%AD%97%E6%9F%A5%E7%9C%8B%E5%8E%9F%E6%96%87%E7%9A%84hexo%E6%A0%87%E7%AD%BE%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<p>紧绷的精神松懈下来后，马上就感觉不知道该做什么事情了，因此决定去做一下 All About Monads 的翻译，但我也觉得保留原文是非常必要的，因此这里尝试模拟一下 angular 的文档的设计，在点击文字时能够看到原文，效果类似这样。</p><p><img src="/images/oss/202204041044633.png"></p><span id="more"></span><p>为了让它能够开箱即用，相关的 js 代码也是直接生成在 tag 里了，因此这个 tag 标签 copy 即可用。如果要尽量减少生成的 html 文件大小，可以把这个 trans_id 方法加到模板里，然后通过 onclick 中的函数调用里来给定参数，</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">syntax:</span><br><span class="hljs-comment">&#123;% trans %&#125;</span><br><span class="hljs-comment">我是友纪。</span><br><span class="hljs-comment">@@@</span><br><span class="hljs-comment">I am Yuuki.</span><br><span class="hljs-comment">&#123;% endtrans %&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">nextCount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> counter++<br>&#125;<br><br>hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">tag</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;trans&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">ignored, content</span>) &#123;<br>  <span class="hljs-keyword">const</span> splitted = content.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;@@@&quot;</span>)<br>  <span class="hljs-keyword">if</span> (splitted.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`trans 标签使用语法错误！标签中未出现@@@！，原文：<span class="hljs-subst">$&#123;content&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (splitted.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`trans 标签使用语法错误！标签中出现多于 2 次（<span class="hljs-subst">$&#123;splitted.length&#125;</span>次）@@@！，原文：<span class="hljs-subst">$&#123;content&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> [trans, original] = splitted.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> hexo.<span class="hljs-property">render</span>.<span class="hljs-title function_">renderSync</span>(&#123; <span class="hljs-attr">text</span>: str, <span class="hljs-attr">engine</span>: <span class="hljs-string">&#x27;markdown&#x27;</span> &#125;))<br><br>  <span class="hljs-comment">// 原本是想使用原文或翻译的哈希值来作为 id 的，但又想到没这必要，直接用一个自增的变量就好，这说明 hexo 的标签可以是有副作用的</span><br>  <span class="hljs-keyword">const</span> id = <span class="hljs-title function_">nextCount</span>()<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;script&gt;</span><br><span class="hljs-string">    function trans_<span class="hljs-subst">$&#123;id&#125;</span>() &#123;</span><br><span class="hljs-string">      const elem = document.getElementById(&quot;ori_<span class="hljs-subst">$&#123;id&#125;</span>&quot;)</span><br><span class="hljs-string">      if (elem.style[&quot;display&quot;] === &quot;none&quot;) &#123;</span><br><span class="hljs-string">        elem.style[&quot;display&quot;] = &quot;&quot;</span><br><span class="hljs-string">      &#125; else &#123;</span><br><span class="hljs-string">        elem.style[&quot;display&quot;] = &quot;none&quot;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &lt;/script&gt;</span><br><span class="hljs-string">    &lt;div onclick=&quot;trans_<span class="hljs-subst">$&#123;id&#125;</span>()&quot;&#x27;&gt;<span class="hljs-subst">$&#123;trans&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">    &lt;div id=&quot;ori_<span class="hljs-subst">$&#123;id&#125;</span>&quot; style=&quot;border-top: 1px dashed #0273D4;margin-top:-15px;display:none&quot;&gt;<span class="hljs-subst">$&#123;original&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">  `</span>;<br><br>&#125;, &#123; <span class="hljs-attr">ends</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></div></td></tr></table></figure><p>点击下面的文字试试？</p>    <script>    function trans_0() {      const elem = document.getElementById("0")      if (elem.style["display"] === "none") {        elem.style["display"] = ""      } else {        elem.style["display"] = "none"      }    }    </script>    <div onclick="trans_0()"><p>我们经常使用类型变量和类型构造器来描述计算的抽象特性。比如，多态类型<code>Maybe a</code>是这样一个类型，它的所有计算都可能返回一个值或者<code>Nothing</code>。这样，我们就能离开容器持有的东西的细节，专注在容器的属性上。</p></div>    <div id="0" style="border-top: 1px dashed #0273D4;margin-top:-15px;display:none"><p>We often use type variables with type constructors to describe abstract features of a computation. For example, the polymorphic type Maybe a is the type of all computations that may return a value or Nothing. In this way, we can talk about the properties of the container apart from any details of what the container might hold. </p></div>  <p>它的使用如下。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">&#123;% trans %&#125;<br>我们经常使用类型变量和类型构造器来描述计算的抽象特性。比如，多态类型<span class="hljs-code">`Maybe a`</span>是这样一个类型，它的所有计算都可能返回一个值或者<span class="hljs-code">`Nothing`</span>。这样，我们就能离开容器持有的东西的细节，专注在容器的属性上。<br>@@@<br>We often use type variables with type constructors to describe abstract features of a computation. For example, the polymorphic type <span class="hljs-code">`Maybe a`</span> is the type of all computations that may return a value or <span class="hljs-code">`Nothing`</span>. In this way, we can talk about the properties of the container apart from any details of what the container might hold. <br>&#123;% endtrans %&#125;<br></code></pre></div></td></tr></table></figure><p>一个比较麻烦的地方是，hexo 的标签似乎是不支持嵌套的，这非常降低它的泛用性。</p><hr><p>后来又选择使用 docsify 来编写该文档了，所以实现方式需要改变，现在考虑使用特定的标签去作为起始，分割，结束，这些标签应当不会干扰 markdown 的渲染。当前使用<code>&lt;!-- xxx --&gt;</code>来作为分割，实现虽然粗糙但也堪用。具体实现参照文档。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Foo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务学习笔记 1——Prelude</title>
    <link href="/2022/03-27%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94Prelude.html"/>
    <url>/2022/03-27%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94Prelude.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>三个月前做的笔记，后来学到了服务注册和发现，负载均衡模式就停下了。最近可能要捡起来也说不定。</p></blockquote><p>对微服务的学习是至关重要的，这个论断是绝对正确的，单体应用已经难以承受当前的互联网时代的复杂度，且性能等因素也受摩尔定律的约束无法更多提升。无论是对当前还是遥远的将来（？），微服务对工程实践都将是有重大影响的。即使以后分布式技术继续发展，人们发现了什么比微服务更好的分布式架构，对微服务的理解也将会有巨大帮助。</p><span id="more"></span><p>本来打算去看《微服务架构设计模式》这本书来进行学习，但进行一些学习后发现这本书实在不适合初学者——概念太多，实践&#x2F;示例太少，没有相应实践经验的人（That’s me！）难以消化。因此此书我认为应当在有一定经验的基础上再进行阅读，即使该书作者似乎并非以此为出发点。</p><p>当前在看的书是《Spring Microservices in Action》第二版，粗略地翻了翻，感觉还不错，就以此来作为敲门砖了。这书正巧第二版最近刚出，还没有中文翻译，同时也能多学学英文。</p><h1 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h1><p>一个有趣的事实是，这两本书都强调在微服务架构中的<strong>模式</strong>，即对微服务架构中面临的各种问题&#x2F;需求的形式化的描述和解决方案，在这之前我还未能理解为何在此处要特意使用模式来描述，而最近才意识到，将这些问题抽象为模式是在解决方案和特定技术&#x2F;中间件中增加了一道抽象层，从而避免解决方案耦合于特定的技术&#x2F;中间件，让架构真正成为架构，而非特定技术的堆砌。</p><blockquote><p>没有什么问题是不能通过增加一个抽象层解决的，如果不能，就再加一层。</p></blockquote><p>我们在进行架构设计等的时候，也应当从模式出发，而非从特定技术&#x2F;中间件出发。比如，就服务发现和路由——如何对服务进行注册，从而抽象服务的物理地址；如何让消费微服务的客户端能够定位和路由到相应微服务——这个来说，不应当从特定技术，如 Spring Gateway，Nacos，Eureka 等出发，而应当在更抽象即模式的层面上研究，问题和需求究竟是什么，怎样的设计是松散耦合的，可维护可配置的，<strong>这些技术&#x2F;中间件是如何应用这个模式的</strong>，有什么优点和缺点……这样既可以从特定技术中解放出来，也给予我们选择最合适的方案的可能性。</p><h2 id="各种云计算模型（XaaS）"><a href="#各种云计算模型（XaaS）" class="headerlink" title="各种云计算模型（XaaS）"></a>各种云计算模型（XaaS）</h2><p>微服务必定和云脱不了关系，这里介绍了常见的云计算模型，即各种 XaaS（anything as a service）以及用户和服务提供商所需要负担的职责，即开发者使用该种云平台时需要关心的东西——</p><p><img src="/images/oss/20220102131348.png"></p><blockquote><p>可以认为最底层的两个即”Networking, storage, and servers”和”Data center”为真正的硬件设施。</p></blockquote><ul><li><p><em>Infrastructure as a Service (IaaS，基础设施即服务）</em> ——服务提供商负责提供一定基础设施，让用户能够访问诸如服务器，存储和网络等计算资源。在这个模型里，用户需要负责一切和基础设施以及应用的伸缩性相关的东西，IaaS 平台包括 AWS 的 EC2，Azure Virtual Machines，Google Compute Engine，和 Kubernetes。可以认为 IaaS 就相当于是租用了一个云服务器，需要自己管理操作系统之上的所有部分。</p></li><li><p><em>Container as a Service (CaaS，容器即服务）</em> ——基于容器的虚拟化的形式，用户可以把微服务部署在一个轻量的，可携带（绿色）的虚拟容器如 Docker 中。云服务提供商负责运行容器，以及提供所有关于构建，部署，监控和伸缩容器的工具。CaaS 相较于 IaaS，用户不需关心操作系统的细节，且治理工具由云服务提供商提供，因而维护和伸缩起来较 IaaS 更容易。CaaS 平台包括谷歌的 GKE，亚马逊的 ECS（阿里的云服务器也叫这个名字，但阿里的是 IaaS，funny）。这本书主要使用 CaaS，我也认为 CaaS 在复杂性和定制性之间取得了一个很好的平衡。</p></li><li><p><em>Platform as a Service (PaaS，平台即服务）</em> ——服务器提供商提供平台和环境来让用户专注于应用的开发，执行和维护。用户可以完全不用关心物理的基础设施。PaaS 的缺点在于这样部署的应用是和平台提供商耦合的，必须利用平台提供商提供的 API 或工具来交互计算资源，因而移植性欠佳。PaaS 平台包括 Google App Engine，Cloud Fondry，Heroku 和 AWS Elastic Beanstalk。</p></li><li><p><em>Function as a Service (FaaS，功能即服务）</em> ——也称为无服务器架构，用户只需关心服务的开发，其余任何东西都交给云服务商了，应用将运行在服务提供商提供的运行时引擎中。FaaS 平台包括 AWS（Lambda），Google Cloud Function 和 Azure functions，Cloudflare 的 worker 也是 FaaS（还免费呢，好玩）。</p></li><li><p><em>Software as a Service (SaaS，软件即服务）</em> ——用户使用一个特定的应用而不需要部署或维护。用户租了就用，其他什么都关心不了。这像是某种低代码之类的东西。</p></li></ul><h2 id="微服务面临的问题"><a href="#微服务面临的问题" class="headerlink" title="微服务面临的问题"></a>微服务面临的问题</h2><p>在接触到具体的模式前，应当先知道开发微服务架构应用时会遇到什么问题——</p><ol><li><p><strong>服务粒度</strong>——如何正确分解业务领域到一堆微服务中，使其中每个都有合适的职责？职责的粒度若太粗，在不同业务问题领域上有重叠，就会让其难以维护和修改；若太细，则会增加应用整体的复杂度，让服务变成愚蠢的数据抽象层，除了对数据的访问外没有别的逻辑。（这话真难翻译！）</p></li><li><p><strong>通讯协议</strong>——服务和客户端&#x2F;服务间的通信同步还是异步？轻量级还是重量级？通用还是自定义？</p></li><li><p><strong>接口设计</strong>——调用服务的实际接口该如何设计？</p></li><li><p><strong>服务的配置管理</strong>——如何优雅和方便地管理微服务的配置，使不需要修改源代码就可以适应不同环境？</p></li><li><p><strong>服务间的事件处理</strong>——如何使用事件对微服务进行解耦，从而最小化服务间<strong>硬编码</strong>（直接调用？）的相互依赖？</p></li></ol><p>也需要意识到，微服务不是银弹，它和单体架构相比，也只能说是另一种架构风格而已，有自己所适用之处，也有自己的缺点，带来自己的复杂度。</p><blockquote><p>The more distributed a system is, the more places it can fail.</p></blockquote><p>书中介绍道，微服务是无状态（stateless）的。为何要设计成无状态？为了能方便横向扩展，即增加一个微服务的实例数量时不会有任何影响。考虑一个简单情形——维护一个对接口访问量的计数器：如果该状态维护在每个实例（进程）的内存中， 统计完全的计数值就需要统计每一个实例中的值，徒增了复杂度，而这种复杂度完全可以通过 Redis 或数据库等来避免。</p><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>该书书名已经指明，其将以 Spring 作为出发点来介绍微服务。<strong>Spring Cloud 为微服务开发提供了完全的支持，对各种模式提供了相应的中间件的集成，且仅通过简单注解便可快速起步</strong>，因此非常适合进行学习。</p><p>Spring Cloud 当然不是唯一选择，微服务使用轻量级的通讯协议，这使使用不同语言进行开发成为可能。我在网络上看到过。Net Core + Nacos + Spring Cloud 这样的组合。但 Spring 肯定是最优先的选择，毕竟 JVM 这边才是主流。</p>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala 隐式转换之一窥</title>
    <link href="/2022/03-24Scala%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B9%8B%E4%B8%80%E7%AA%A5.html"/>
    <url>/2022/03-24Scala%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B9%8B%E4%B8%80%E7%AA%A5.html</url>
    
    <content type="html"><![CDATA[<p>学习 Spark 的键值对 RDD 时，对其的实现比较感兴趣——它是如何让特定类型的 RDD 拥有自己独有的方法的？于是就对此进行了一些了解，发现它的本质是比较浅显但又确实非常有趣的，现在做下笔记。</p><span id="more"></span><hr><p>当调用对象的不存在的方法，以及调用方法时传递错误类型的对象时，Scala 都会试图在隐式视图中进行一番操作来“<strong>圆场</strong>”。</p><p><strong>如果 Scala 发现用户试图调用对象的不存在的方法，则它会试图在隐式视图中寻找构造参数为当前对象类型的隐式类，并进行隐式转换</strong>，比如我们可以通过这种方式实现类的扩展——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 众所周知，String 是 final 的</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">YuukiStringOps</span> </span>&#123;<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStringOps</span>(<span class="hljs-params">self : <span class="hljs-type">String</span></span>) </span>&#123;<br>    <span class="hljs-comment">// 原来的 String 只有 padTo 方法，其作用是在右侧填充字符，这里添加在左侧添加字符的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">padLeft</span></span>(len : <span class="hljs-type">Int</span>, elem : <span class="hljs-type">Char</span>) : <span class="hljs-type">String</span> =<br>      self.reverse.padTo(len, elem).reverse<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 客户端使用时需要先 import 它来在作用域中引入该隐式类</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Client</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-keyword">import</span> <span class="hljs-type">YuukiStringOps</span>._<br>  println(<span class="hljs-string">&quot;99&quot;</span>.padLeft(<span class="hljs-number">4</span>, &#x27;<span class="hljs-number">0</span>&#x27;)) <span class="hljs-comment">// 0099</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果 Scala 发现用户给一个类型为 B 的参数传递一个类型 A 的实例，则它会试图从隐式视图中选择一个<code>A =&gt; B</code>的用于类型转换的函数。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">SomeOps</span> </span>&#123;<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">int2String</span></span>(self : <span class="hljs-type">Int</span>) : <span class="hljs-type">String</span> =<br>    <span class="hljs-string">s&quot;me a String: <span class="hljs-subst">$self</span>&quot;</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Client</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printMe</span></span>(str : <span class="hljs-type">String</span>) : <span class="hljs-type">Unit</span> = println(str)<br>  <span class="hljs-keyword">import</span> <span class="hljs-type">SomeOps</span>._<br>  printMe(<span class="hljs-number">100</span>) <span class="hljs-comment">// me a String: 100</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>最初的 Scala 没有隐式类，因此当时若要实现隐式类就只能通过隐式类型转换函数来实现，比如下面是不使用隐式类扩展 String 的方法——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">YuukiStringOps</span> </span>&#123;<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string2Ops</span></span>(self : <span class="hljs-type">String</span>) : <span class="hljs-type">YuukiStringOps_</span> =<br>    <span class="hljs-keyword">new</span> <span class="hljs-type">YuukiStringOps_</span>(self)<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YuukiStringOps_</span>(<span class="hljs-params">self : <span class="hljs-type">String</span></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">padLeft</span></span>(len : <span class="hljs-type">Int</span>, elem : <span class="hljs-type">Char</span>) : <span class="hljs-type">String</span> =<br>      self.reverse.padTo(len, elem).reverse<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>容易想象，这种给类添加新操作的方法翻译到 Java 中，将得到所谓的“委托”模式，但 Scala 强大之处在于，用户完全可以对包装后的类一无所知，只需要在上下文中引入该隐式对象即可，这在 Java 中是不可能的。</p><p>但是 Scala 还能做的更多！考虑一个泛型类，假如我们有这样的需求，即希望这个泛型满足特定类型的时候，让它能够调用特定的方法，这倘若放到 Java 里，就只能通过反射进行检查了，而 Scala 做得到——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 我们想要操作的类，其方法不符合我们的需求</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clazz</span>[<span class="hljs-type">A</span>] (<span class="hljs-params">data : <span class="hljs-type">A</span></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span> </span>: <span class="hljs-type">String</span> = data.toString<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Magic</span> </span>&#123;<br>  <span class="hljs-comment">// 我们的需求</span><br>  <span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClazzInt</span>(<span class="hljs-params">self : <span class="hljs-type">Clazz</span>[<span class="hljs-type">Int</span>]</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getValue</span> </span>: <span class="hljs-type">Int</span> = self.data<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Client</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-keyword">import</span> <span class="hljs-type">Magic</span>._<br>  <span class="hljs-keyword">val</span> stringClazz = <span class="hljs-type">Clazz</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>  <span class="hljs-comment">// println(stringClazz.getValue) // IT DOESN&#x27;T WORK!</span><br>  <span class="hljs-keyword">val</span> intClazz = <span class="hljs-type">Clazz</span>(<span class="hljs-number">2</span>)<br>  println(intClazz.getValue) <span class="hljs-comment">// IT WORKS!</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>精巧绝伦！reduceByKey 等键值对 RDD 所特有的方法就是通过这种方式实现的。使用这种方式，既能把相关操作分离到不同地方以减少特定文件的大小，也能够避免用户对新的实现可知，统一实现的接口为 RDD；缺点则在于会让代码变得更加难懂，因此对其的使用应当是谨慎的，应在一定的模式下进行使用，期待之后的进一步学习。</p><hr><p>也可以发现，这种操作和Haskell中的type class概念是很相近的——我们可以让类型成为一个typeclass的实例，从而让它们来具备更多方法，这种约束并非是利用接口，而是利用隐式转换，因此是可插拔的，且其能进行更多约束。这也是为什么Scala能通过像scalaz和cats等第三方库来给原有类型添加Monad等的操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive 学习笔记 2——SORT，JOIN，分区等</title>
    <link href="/2022/03-20Hive%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202%E2%80%94%E2%80%94SORT%EF%BC%8CJOIN%EF%BC%8C%E5%88%86%E5%8C%BA%E7%AD%89.html"/>
    <url>/2022/03-20Hive%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202%E2%80%94%E2%80%94SORT%EF%BC%8CJOIN%EF%BC%8C%E5%88%86%E5%8C%BA%E7%AD%89.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>现在跟随《Hive 编程指南》进行学习，此书的翻译…我在序章已经看到两处明显错误了，中英对照着看吧。</p></blockquote><p>这里去学习一下 SELECT，Hive 最重要的部分。<strong>Hive 的 SELECT 相较于普通的关系型数据库，增加了内置的集合类型，因此各种操作，如函数，聚合，窗口函数等，都会有一些新东西，新模式可用，更别说还有新增的 UDTF 了</strong>；同时由于底层使用 MapReduce，因此<strong>分区</strong>等概念也需要体现在 SQL 中。这些地方需要特别学习。</p><span id="more"></span><p>下面使用的示例仍旧通过尚硅谷的表和数据描述。</p>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">表数据定义见此。</span></summary>        <blockquote><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">---- dept.sql ----<br><br>CREATE TABLE IF NOT EXISTS dept (<br>deptno INT,<br>dname STRING,<br>loc INT<br>)<br>ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;,&#x27;<span class="hljs-comment">;</span><br><br>---- dept.txt ----<br><br><span class="hljs-number">10</span>,ACCOUNTING,<span class="hljs-number">1700</span><br><span class="hljs-number">20</span>,RESEARCH,<span class="hljs-number">1800</span><br><span class="hljs-number">30</span>,SALES,<span class="hljs-number">1900</span><br><span class="hljs-number">40</span>,OPERATIONS,<span class="hljs-number">1700</span><br><br>---- emp.sql ----<br><br>CREATE TABLE IF NOT EXISTS emp (<br>empno INT,<br>ename STRING,<br>job STRING,<br>mgr INT, -- 上级<br>hiredate STRING, -- 入职时间<br>sal DOUBLE, -- 薪水<br>comm DOUBLE, -- 奖金<br>deptno INT)<br>ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;,&#x27;<span class="hljs-comment">;</span><br><br>---- emp.txt ----<br><br><span class="hljs-number">7369</span>,SMITH,CLERK,<span class="hljs-number">7902,1980</span>-<span class="hljs-number">12-17,800</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">20</span><br><span class="hljs-number">7499</span>,ALLEN,SALESMAN,<span class="hljs-number">7698,1981</span>-<span class="hljs-number">2-20,1600</span>.<span class="hljs-number">00,300.00</span>,<span class="hljs-number">30</span><br><span class="hljs-number">7521</span>,WARD,SALESMAN,<span class="hljs-number">7698,1981</span>-<span class="hljs-number">2-22,1250</span>.<span class="hljs-number">00,500.00</span>,<span class="hljs-number">30</span><br><span class="hljs-number">7566</span>,JONES,MANAGER,<span class="hljs-number">7839,1981</span>-<span class="hljs-number">4-2,2975</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">20</span><br><span class="hljs-number">7654</span>,MARTIN,SALESMAN,<span class="hljs-number">7698,1981</span>-<span class="hljs-number">9-28,1250</span>.<span class="hljs-number">00,1400.00</span>,<span class="hljs-number">30</span><br><span class="hljs-number">7698</span>,BLAKE,MANAGER,<span class="hljs-number">7839,1981</span>-<span class="hljs-number">5-1,2850</span>,,<span class="hljs-number">30</span><br><span class="hljs-number">7782</span>,CLARK,MANAGER,<span class="hljs-number">7839,1981</span>-<span class="hljs-number">6-9,2450</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">10</span><br><span class="hljs-number">7788</span>,SCOTT,ANALYST,<span class="hljs-number">7566,1987</span>-<span class="hljs-number">4-19,3000</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">20</span><br><span class="hljs-number">7839</span>,KING,PRESIDENT,,<span class="hljs-number">1981-11-17</span>,<span class="hljs-number">5000</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">10</span><br><span class="hljs-number">7844</span>,TURNER,SALESMAN,<span class="hljs-number">7698,1981</span>-<span class="hljs-number">9-8,1500</span>.<span class="hljs-number">00,0.00,30</span><br><span class="hljs-number">7876</span>,ADAMS,CLERK,<span class="hljs-number">7788,1987</span>-<span class="hljs-number">5-23,1100</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">20</span><br><span class="hljs-number">7900</span>,JAMES,CLERK,<span class="hljs-number">7698,1981</span>-<span class="hljs-number">12-3,950</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">30</span><br><span class="hljs-number">7902</span>,FORD,ANALYST,<span class="hljs-number">7566,1981</span>-<span class="hljs-number">12-3,3000</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">20</span><br><span class="hljs-number">7934</span>,MILLER,CLERK,<span class="hljs-number">7782,1982</span>-<span class="hljs-number">1-23,1300</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure></blockquote>            </details>  <h1 id="表生成函数（UDTF）"><a href="#表生成函数（UDTF）" class="headerlink" title="表生成函数（UDTF）"></a>表生成函数（UDTF）</h1><p>聚合函数从多行数据生成单个数据，而表生成函数则反之——将单列数据扩展成多行多列数据，一个展平操作。</p><p>最典型的表生成函数是 explode，它能够数组和哈希表展平成多列，使用如下——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> explode(<span class="hljs-keyword">ARRAY</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>));<br><span class="hljs-operator">+</span><span class="hljs-comment">---+</span><br><span class="hljs-operator">|</span>col<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---+</span><br><span class="hljs-operator">|</span><span class="hljs-number">1</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">2</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">3</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">2</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">1</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---+</span><br><br><span class="hljs-keyword">SELECT</span> explode(MAP(<span class="hljs-string">&#x27;yuuki&#x27;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&#x27;haruka&#x27;</span>, <span class="hljs-number">17</span>)) <span class="hljs-keyword">AS</span> (name, age);<br><span class="hljs-operator">+</span><span class="hljs-comment">------+---+</span><br><span class="hljs-operator">|</span>name  <span class="hljs-operator">|</span>age<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+---+</span><br><span class="hljs-operator">|</span>yuuki <span class="hljs-operator">|</span><span class="hljs-number">16</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>haruka<span class="hljs-operator">|</span><span class="hljs-number">17</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+---+</span><br></code></pre></div></td></tr></table></figure><h1 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h1><p>关于 Hive 的连接操作，Hive 曾经只能支持等值连接（我用 MapReduce 也只会写等值连接），而现在已经能够支持非等值连接了，并且能够在 ON 中使用 OR 子句，所以现在和关系型数据库的 JOIN 操作已经看不出什么差别了。</p><p>进行多表连接操作时，每次连接操作将产生一个 MapReduce 任务，从左到右依次执行，比如有<code>SELECT .. FROM a JOIN b ON a.id=b.id JOIN c ON b.id=c.id</code>，首先是 a 和 b 先进行连接，然后是连接后的输出表与 c 相连接。但在像这样的例子里，Hive 会进行优化——三个表都使用同一个键进行连接，因此可以同时将三个表进行输入，因此只需要一个 MR 任务。</p><span style="color: #FF0000">应始终保证是小表 JOIN 大表</span>，即从左到右表的大小依次增加以保证性能（相信 Hive 同样做了优化）。<p>为了进行优化，可以在 JOIN 之前提前对各连接的表进行一定的筛选操作，<strong>该操作应当通过子查询来进行</strong>。</p><h2 id="LEFT-SEMI-JOIN"><a href="#LEFT-SEMI-JOIN" class="headerlink" title="LEFT SEMI JOIN"></a>LEFT SEMI JOIN</h2><p>考虑这样的需求，我们想获取每个部门工资最高的员工的信息，如果是关系型数据库，我们有好几种解决方式，可能最经济的方式是首先获取每个部门的最高的工资，然后使用 IN，按部门和工资两个字段进行匹配，比如类似这样——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-comment">-- Hive 下无法编译！</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> (deptno, sal) <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> deptno, <span class="hljs-built_in">MAX</span>(sal) <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno);<br></code></pre></div></td></tr></table></figure><p>但是，<span style="color: #FF0000">Hive 不支持非关联子查询</span>，这是符合逻辑的，因为若使用非关联子查询，这就说明我们需要将子查询执行并进行缓存和随机查询，这是愚蠢的。</p><p>而对于关联子查询，Hive 足够聪明，能够将其转换为 JOIN 来执行，比如这样的 SQL 在 Hive 中就是合法的——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">AS</span> e1 <span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(sal) <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">AS</span> e2 <span class="hljs-keyword">WHERE</span> e1.deptno <span class="hljs-operator">=</span> e2.deptno);<br></code></pre></div></td></tr></table></figure><p>Hive 也提供了一个额外的手段，称为左半连接 LEFT SEMI JOIN，以用于通过连接的语法表示该种操作并保证性能。<strong>左半连接是一种优化过的内连接</strong>，它的原理是在内连接的基础上，对左表的每一条记录，在右表上一旦找到满足 ON 的记录，就立刻返回，停止匹配操作。<strong>左半连接在 SELECT 和 WHERE 中只允许使用左边的字段</strong>。</p><p>上面的操作使用左半连接进行表述则结果如下——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">AS</span> e1<br>  <span class="hljs-keyword">LEFT</span> SEMI <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> deptno, <span class="hljs-built_in">MAX</span>(sal) <span class="hljs-keyword">AS</span> maxSal <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno) <span class="hljs-keyword">AS</span> e2 <br>  <span class="hljs-keyword">ON</span> e1.deptno <span class="hljs-operator">=</span> e2.deptno <span class="hljs-keyword">AND</span> e1.sal <span class="hljs-operator">=</span> e2.maxSal;<br></code></pre></div></td></tr></table></figure><p>并不太清晰。</p><h1 id="SORT-BY，DISTRIBUTE-BY，CLUSTER-BY"><a href="#SORT-BY，DISTRIBUTE-BY，CLUSTER-BY" class="headerlink" title="SORT BY，DISTRIBUTE BY，CLUSTER BY"></a>SORT BY，DISTRIBUTE BY，CLUSTER BY</h1><p>在之前学习到分布式排序时有提到，如果让结果数据全局有序的话，Reducer 必须只能有 1 个，这导致 reduce 的阶段的并行性完全丧失了。而 ORDER BY 这个保证数据全局有序的子句也会造成 Hive 的查询中只能使用一个 Reducer，因此 Hive 显然是不推荐使用 ORDER BY 的，以至于在严格模式里，ORDER BY 必须要和 LIMIT 子句配合。</p><p>为此，Hive 提供了<code>SORT BY</code>，提供每个 Reducer 内部排序的功能，这样，每个 Reducer 生成的数据是有序的，而不同 Reducer 生成的数据之间仍旧是无序的。</p><p>编写 MapReduce 应用的时候，我们可以自定义三个角色——Partitioner，SortComparator，GroupComparator，其中 GroupComparator 对应 GROUP BY，而 Partitioner 和 SortComparator 各有其对应者。</p><p><strong>DISTRIBUTE BY 子句对应 Partitioner</strong>，其负责指定特定 Mapper 的数据要分发给哪个 Reducer。这在某些应用场景下比较有用，比如，我们希望每个 Reducer 处理特定年份的数据，如果不指定 DISTRIBUTE BY 的话，每个 Reducer 将都有每年的数据，很均匀，但也没有实践意义。</p><p>比如，我们想获取每个部门的员工的信息，其中每个部门按工资倒序排序，分别使用和不使用 DISTRIBUTE BY 子句，查看对应执行结果——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-comment">-- 这里数据量太少，需要强制指定 reducer 个数</span><br><span class="hljs-comment">-- 为确保效果，让 reducer 的数量大于部门数量即可</span><br><span class="hljs-keyword">set</span> mapred.reduce.tasks <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp<br>SORT <span class="hljs-keyword">BY</span> deptno, sal <span class="hljs-keyword">DESC</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------+---------+----+----------+----+----+------+</span><br><span class="hljs-operator">|</span>empno<span class="hljs-operator">|</span>ename <span class="hljs-operator">|</span>job      <span class="hljs-operator">|</span>mgr <span class="hljs-operator">|</span>hiredate  <span class="hljs-operator">|</span>sal <span class="hljs-operator">|</span>comm<span class="hljs-operator">|</span>deptno<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------+---------+----+----------+----+----+------+</span><br><span class="hljs-operator">|</span><span class="hljs-number">7902</span> <span class="hljs-operator">|</span>FORD  <span class="hljs-operator">|</span>ANALYST  <span class="hljs-operator">|</span><span class="hljs-number">7566</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-12</span><span class="hljs-number">-3</span> <span class="hljs-operator">|</span><span class="hljs-number">3000</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">20</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7782</span> <span class="hljs-operator">|</span>CLARK <span class="hljs-operator">|</span>MANAGER  <span class="hljs-operator">|</span><span class="hljs-number">7839</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-6</span><span class="hljs-number">-9</span>  <span class="hljs-operator">|</span><span class="hljs-number">2450</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">10</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7369</span> <span class="hljs-operator">|</span>SMITH <span class="hljs-operator">|</span>CLERK    <span class="hljs-operator">|</span><span class="hljs-number">7902</span><span class="hljs-operator">|</span><span class="hljs-number">1980</span><span class="hljs-number">-12</span><span class="hljs-number">-17</span><span class="hljs-operator">|</span><span class="hljs-number">800</span> <span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">20</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7654</span> <span class="hljs-operator">|</span>MARTIN<span class="hljs-operator">|</span>SALESMAN <span class="hljs-operator">|</span><span class="hljs-number">7698</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-9</span><span class="hljs-number">-28</span> <span class="hljs-operator">|</span><span class="hljs-number">1250</span><span class="hljs-operator">|</span><span class="hljs-number">1400</span><span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7839</span> <span class="hljs-operator">|</span>KING  <span class="hljs-operator">|</span>PRESIDENT<span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-11</span><span class="hljs-number">-17</span><span class="hljs-operator">|</span><span class="hljs-number">5000</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">10</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7499</span> <span class="hljs-operator">|</span>ALLEN <span class="hljs-operator">|</span>SALESMAN <span class="hljs-operator">|</span><span class="hljs-number">7698</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-2</span><span class="hljs-number">-20</span> <span class="hljs-operator">|</span><span class="hljs-number">1600</span><span class="hljs-operator">|</span><span class="hljs-number">300</span> <span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7788</span> <span class="hljs-operator">|</span>SCOTT <span class="hljs-operator">|</span>ANALYST  <span class="hljs-operator">|</span><span class="hljs-number">7566</span><span class="hljs-operator">|</span><span class="hljs-number">1987</span><span class="hljs-number">-4</span><span class="hljs-number">-19</span> <span class="hljs-operator">|</span><span class="hljs-number">3000</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">20</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7876</span> <span class="hljs-operator">|</span>ADAMS <span class="hljs-operator">|</span>CLERK    <span class="hljs-operator">|</span><span class="hljs-number">7788</span><span class="hljs-operator">|</span><span class="hljs-number">1987</span><span class="hljs-number">-5</span><span class="hljs-number">-23</span> <span class="hljs-operator">|</span><span class="hljs-number">1100</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">20</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7521</span> <span class="hljs-operator">|</span>WARD  <span class="hljs-operator">|</span>SALESMAN <span class="hljs-operator">|</span><span class="hljs-number">7698</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-2</span><span class="hljs-number">-22</span> <span class="hljs-operator">|</span><span class="hljs-number">1250</span><span class="hljs-operator">|</span><span class="hljs-number">500</span> <span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7934</span> <span class="hljs-operator">|</span>MILLER<span class="hljs-operator">|</span>CLERK    <span class="hljs-operator">|</span><span class="hljs-number">7782</span><span class="hljs-operator">|</span><span class="hljs-number">1982</span><span class="hljs-number">-1</span><span class="hljs-number">-23</span> <span class="hljs-operator">|</span><span class="hljs-number">1300</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">10</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7900</span> <span class="hljs-operator">|</span>JAMES <span class="hljs-operator">|</span>CLERK    <span class="hljs-operator">|</span><span class="hljs-number">7698</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-12</span><span class="hljs-number">-3</span> <span class="hljs-operator">|</span><span class="hljs-number">950</span> <span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7566</span> <span class="hljs-operator">|</span>JONES <span class="hljs-operator">|</span>MANAGER  <span class="hljs-operator">|</span><span class="hljs-number">7839</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-4</span><span class="hljs-number">-2</span>  <span class="hljs-operator">|</span><span class="hljs-number">2975</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">20</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7844</span> <span class="hljs-operator">|</span>TURNER<span class="hljs-operator">|</span>SALESMAN <span class="hljs-operator">|</span><span class="hljs-number">7698</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-9</span><span class="hljs-number">-8</span>  <span class="hljs-operator">|</span><span class="hljs-number">1500</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>   <span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7698</span> <span class="hljs-operator">|</span>BLAKE <span class="hljs-operator">|</span>MANAGER  <span class="hljs-operator">|</span><span class="hljs-number">7839</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-5</span><span class="hljs-number">-1</span>  <span class="hljs-operator">|</span><span class="hljs-number">2850</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------+---------+----+----------+----+----+------+</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp<br>DISTRIBUTE <span class="hljs-keyword">BY</span> deptno<br>SORT <span class="hljs-keyword">BY</span> deptno, sal <span class="hljs-keyword">DESC</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------+---------+----+----------+----+----+------+</span><br><span class="hljs-operator">|</span>empno<span class="hljs-operator">|</span>ename <span class="hljs-operator">|</span>job      <span class="hljs-operator">|</span>mgr <span class="hljs-operator">|</span>hiredate  <span class="hljs-operator">|</span>sal <span class="hljs-operator">|</span>comm<span class="hljs-operator">|</span>deptno<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------+---------+----+----------+----+----+------+</span><br><span class="hljs-operator">|</span><span class="hljs-number">7839</span> <span class="hljs-operator">|</span>KING  <span class="hljs-operator">|</span>PRESIDENT<span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-11</span><span class="hljs-number">-17</span><span class="hljs-operator">|</span><span class="hljs-number">5000</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">10</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7782</span> <span class="hljs-operator">|</span>CLARK <span class="hljs-operator">|</span>MANAGER  <span class="hljs-operator">|</span><span class="hljs-number">7839</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-6</span><span class="hljs-number">-9</span>  <span class="hljs-operator">|</span><span class="hljs-number">2450</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">10</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7934</span> <span class="hljs-operator">|</span>MILLER<span class="hljs-operator">|</span>CLERK    <span class="hljs-operator">|</span><span class="hljs-number">7782</span><span class="hljs-operator">|</span><span class="hljs-number">1982</span><span class="hljs-number">-1</span><span class="hljs-number">-23</span> <span class="hljs-operator">|</span><span class="hljs-number">1300</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">10</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7788</span> <span class="hljs-operator">|</span>SCOTT <span class="hljs-operator">|</span>ANALYST  <span class="hljs-operator">|</span><span class="hljs-number">7566</span><span class="hljs-operator">|</span><span class="hljs-number">1987</span><span class="hljs-number">-4</span><span class="hljs-number">-19</span> <span class="hljs-operator">|</span><span class="hljs-number">3000</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">20</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7902</span> <span class="hljs-operator">|</span>FORD  <span class="hljs-operator">|</span>ANALYST  <span class="hljs-operator">|</span><span class="hljs-number">7566</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-12</span><span class="hljs-number">-3</span> <span class="hljs-operator">|</span><span class="hljs-number">3000</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">20</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7566</span> <span class="hljs-operator">|</span>JONES <span class="hljs-operator">|</span>MANAGER  <span class="hljs-operator">|</span><span class="hljs-number">7839</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-4</span><span class="hljs-number">-2</span>  <span class="hljs-operator">|</span><span class="hljs-number">2975</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">20</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7876</span> <span class="hljs-operator">|</span>ADAMS <span class="hljs-operator">|</span>CLERK    <span class="hljs-operator">|</span><span class="hljs-number">7788</span><span class="hljs-operator">|</span><span class="hljs-number">1987</span><span class="hljs-number">-5</span><span class="hljs-number">-23</span> <span class="hljs-operator">|</span><span class="hljs-number">1100</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">20</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7369</span> <span class="hljs-operator">|</span>SMITH <span class="hljs-operator">|</span>CLERK    <span class="hljs-operator">|</span><span class="hljs-number">7902</span><span class="hljs-operator">|</span><span class="hljs-number">1980</span><span class="hljs-number">-12</span><span class="hljs-number">-17</span><span class="hljs-operator">|</span><span class="hljs-number">800</span> <span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">20</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7698</span> <span class="hljs-operator">|</span>BLAKE <span class="hljs-operator">|</span>MANAGER  <span class="hljs-operator">|</span><span class="hljs-number">7839</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-5</span><span class="hljs-number">-1</span>  <span class="hljs-operator">|</span><span class="hljs-number">2850</span><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7499</span> <span class="hljs-operator">|</span>ALLEN <span class="hljs-operator">|</span>SALESMAN <span class="hljs-operator">|</span><span class="hljs-number">7698</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-2</span><span class="hljs-number">-20</span> <span class="hljs-operator">|</span><span class="hljs-number">1600</span><span class="hljs-operator">|</span><span class="hljs-number">300</span> <span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7844</span> <span class="hljs-operator">|</span>TURNER<span class="hljs-operator">|</span>SALESMAN <span class="hljs-operator">|</span><span class="hljs-number">7698</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-9</span><span class="hljs-number">-8</span>  <span class="hljs-operator">|</span><span class="hljs-number">1500</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>   <span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7654</span> <span class="hljs-operator">|</span>MARTIN<span class="hljs-operator">|</span>SALESMAN <span class="hljs-operator">|</span><span class="hljs-number">7698</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-9</span><span class="hljs-number">-28</span> <span class="hljs-operator">|</span><span class="hljs-number">1250</span><span class="hljs-operator">|</span><span class="hljs-number">1400</span><span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7521</span> <span class="hljs-operator">|</span>WARD  <span class="hljs-operator">|</span>SALESMAN <span class="hljs-operator">|</span><span class="hljs-number">7698</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-2</span><span class="hljs-number">-22</span> <span class="hljs-operator">|</span><span class="hljs-number">1250</span><span class="hljs-operator">|</span><span class="hljs-number">500</span> <span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7900</span> <span class="hljs-operator">|</span>JAMES <span class="hljs-operator">|</span>CLERK    <span class="hljs-operator">|</span><span class="hljs-number">7698</span><span class="hljs-operator">|</span><span class="hljs-number">1981</span><span class="hljs-number">-12</span><span class="hljs-number">-3</span> <span class="hljs-operator">|</span><span class="hljs-number">950</span> <span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span><span class="hljs-number">30</span>    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+------+---------+----+----------+----+----+------+</span><br></code></pre></div></td></tr></table></figure><p>非常显然，指定分区后，每个 reducer 都处理更加“相关”的数据，因此最后生成的数据也更好看了。当然，这要以一定的数据倾斜作为代价。</p><p>顺带一提，<strong>DISTRIBUTE BY 子句在使用 GROUP BY 子句的情况下，只能按用于分组的字段进行分区</strong>，这是符合逻辑的——如果分区的字段不是分组的字段的子集，则结果必然错误，之前在 MapReduce 中已经验证过了。使用 GROUP BY 时，Hive 默认会按分组的字段进行分区，因此结果必然正确（以至于我都不知道如何写出错误的使用方法）。</p><p>CLUSTER BY 是 SORT BY 和 DISTRIBUTE BY 的结合——<strong>如果用于排序和用于分区的字段完全相同且排序均为升序，则可以使用 CLUSTER BY 子句来作为替代</strong>。</p><p>结合使用 DISTRIBUTE BY 和 SORT BY，能够利用复数的 reducer 让结果全局有序，但这显然会导致一定的数据倾斜，降低并行性。<strong>一般如果要获取前 n 条数据，仍旧是使用一个 reducer 并使用 LIMIT</strong>，这样，每个 mapper 就只需要维护 n 条数据（使用大&#x2F;小顶堆），而传递给 reducer 的就只有 n * mapper 数量的数据了，这代价仍旧是可以容忍的。</p><h1 id="抽样查询"><a href="#抽样查询" class="headerlink" title="抽样查询"></a>抽样查询</h1><p>抽样是传统数据处理方法中的一个重要部分，在大数据时代，全量查询成为了主流（是这样吗 hhh 我不确定），但 Hive，以及 MapReduce 仍旧提供了对数据集进行抽样的功能。</p><p>抽样分为分桶抽样和百分比抽样，<strong>分桶抽样就是将特定记录按某（些）字段进行哈希并按桶数取余，以放入特定的桶中，百分比抽样则是字面意思</strong>。</p><p>抽样的语法如<code>SELECT * FROM emp TABLESAMPLE(BUCKET 1 OUT OF 10 ON deptno)</code>，这就是按 deptno 进行哈希并分到 10 个桶中，获取其中第一个桶；也可以使用 ON 语法来使用特定列或函数进行分桶。<strong>如果表本身没有分桶，则 ON 不能省略</strong>，如果表本身分桶且条件为用于分桶的字段，则其性能将会非常好，因为不需要扫描所有的记录了。</p><p><strong>也可以使用 rand 函数进行分桶，其每次执行时都会得到不一样的结果</strong>。</p><p>百分比抽样的语法为<code>SELECT * FROM emp TABLESAMPLE(50 PERCENT)</code>，这里是按 50%进行抽样。<strong>百分比抽样每次结果都是一致的</strong>，因为其是使用给定 seed，按随机数进行抽样的，因此多次执行结果相同。</p><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>关于 Hive 的视图，一个最重要（常不常用我不知道）的需求就是<strong>将一张物理表拆成多张逻辑表，以及进行预先的数据转换操作</strong>，它的重要性来源于 Hive 提供集合类型，因而破坏了第一范式。</p><p>比如，我们有一个保存一些 HTTP 请求参数的文件——</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-attr">name</span><span class="hljs-operator">=</span>haruka<span class="hljs-variable">&amp;age</span>=<span class="hljs-number">16</span><span class="hljs-variable">&amp;clazz</span>=<span class="hljs-number">765</span><br><span class="hljs-attr">age</span><span class="hljs-operator">=</span><span class="hljs-number">17</span><span class="hljs-variable">&amp;name</span>=chihaya<span class="hljs-variable">&amp;height</span>=<span class="hljs-number">162</span><br>...<br></code></pre></div></td></tr></table></figure><p>可以看到，每个记录都是 KV 对形式，但其出现顺序是不一定的，如何处理这样的数据？其实最好的手段是使用相关工具对其进行转换再进行后续建模，这能避免将来读取时解析的时间开销，但这里我们可以直接这样对它建模——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-comment">-- 只有一个字段，所以不用设置字段之间的分隔符</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> raw_t(cols MAP<span class="hljs-operator">&lt;</span>STRING,STRING<span class="hljs-operator">&gt;</span>)<br><span class="hljs-type">ROW</span> FORMAT DELIMITED <br>COLLECTION ITEMS TERMINATED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;&amp;&#x27;</span> <span class="hljs-comment">-- 集合之间的元素的分隔</span><br>MAP KEYS TERMINATED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;=&#x27;</span>;        <span class="hljs-comment">-- KV 之间的分隔</span><br><br><span class="hljs-comment">-- 读取数据……</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> raw_t;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------+</span><br><span class="hljs-operator">|</span>cols                                        <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------+</span><br><span class="hljs-operator">|</span>&#123;&quot;name&quot;:&quot;haruka&quot;,&quot;age&quot;:&quot;16&quot;,&quot;clazz&quot;:&quot;765&quot;&#125;  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>&#123;&quot;age&quot;:&quot;17&quot;,&quot;name&quot;:&quot;chihaya&quot;,&quot;height&quot;:&quot;162&quot;&#125;<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------+</span><br></code></pre></div></td></tr></table></figure><p>这样的数据用起来肯定是相当麻烦的，我们可以为它建立视图——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-comment">-- 创建 view 不需要给定类型！</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> idol_t(<br>    name,<br>    age,<br>    height,<br>    clazz<br>) <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span><br>    cols[<span class="hljs-string">&#x27;name&#x27;</span>],<br>    <span class="hljs-built_in">CAST</span>(cols[<span class="hljs-string">&#x27;age&#x27;</span>] <span class="hljs-keyword">AS</span> <span class="hljs-type">INT</span>),<br>    <span class="hljs-built_in">CAST</span>(cols[<span class="hljs-string">&#x27;height&#x27;</span>] <span class="hljs-keyword">AS</span> <span class="hljs-type">INT</span>),<br>    cols[<span class="hljs-string">&#x27;clazz&#x27;</span>] <span class="hljs-keyword">FROM</span> raw_t;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> idol_t;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------+---+------+-----+</span><br><span class="hljs-operator">|</span>name   <span class="hljs-operator">|</span>age<span class="hljs-operator">|</span>height<span class="hljs-operator">|</span>clazz<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+---+------+-----+</span><br><span class="hljs-operator">|</span>haruka <span class="hljs-operator">|</span><span class="hljs-number">16</span> <span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><span class="hljs-number">765</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>chihaya<span class="hljs-operator">|</span><span class="hljs-number">17</span> <span class="hljs-operator">|</span><span class="hljs-number">162</span>   <span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+---+------+-----+</span><br></code></pre></div></td></tr></table></figure><p>这样得到的结果和物理表无异！Hive当前也提供了物化视图。</p><p>Hive 会尽量对视图查询进行优化，使外部查询语句和视图语句成为单条语句，但并非所有情况下都能进行这种优化。</p><h1 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h1><p>Hive 的类型转换规则同 Java 的——范围更窄的类型能隐式转换成范围更广的类型，如 FLOAT 能转换成 DOUBLE，INT 能转换成 BIGINT，其它类型都能隐式转换成 STRING 等。</p><p>CAST 关键字用于显式的类型转换，语法形如<code>CAST(1 AS STRING)</code>，AS 后跟随目标类型；CAST 能够将数字字符串转化为数字类型，将’TRUE’，’FALSE’转化为布尔类型等，因此它更像是 parse 而非是 cast，<strong>CAST 若解析失败，则返回 NULL</strong>。</p><blockquote><p>Hive 似乎有这样的哲学，就是尽全力保证操作的正常进行，不抛出运行时异常，比如在读取非法数据的时候，这里进行强制类型转换的时候，失败了是返回 NULL。</p></blockquote><p>一些场景不常使用 CAST，如浮点数转换为整型，一般使用 ROUND 函数。（Hive 权威指南居然说 cast 是函数，严肃反对，哪有函数有自己的特定语法的？当这是 lisp 或是某种 DSL 吗？）</p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>分库分表是关系型数据库常用的优化方案，比如，我们可以按天划分表，这样如果查询的是单日的记录，就可以直接从该表进行查询，查询多日的记录就使用 UNION ALL，在多表中查询，这能够避免全表扫描，同时在更新操作的并发性上也能有所提升（Hive 执行分区也使能够避免一些同步问题）。</p><p>Hive 的<strong>分区</strong>实际上进行的就是此种操作，且其是非常有意义的——Hive 的应用环境中，通常要进行全表扫描来满足查询，这时候数据若按查询条件进行分区，便能够减少查询的记录量，但若查询的条件并不在分区里，这反而会造成性能损失——毕竟每个文件对应一个 map task；并且这会造成数据倾斜。</p><p><strong>分区字段和表的字段是分开定义的，且其数据只能通过文件夹名称确定，但其使用和普通字段相同</strong>。分区对应 PARTITION BY 子句，示例如下——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> idols(<br>    name STRING,<br>    age <span class="hljs-type">INT</span>,<br>    height <span class="hljs-type">INT</span><br>)<br>PARTITIONED <span class="hljs-keyword">BY</span> (clazz STRING);<br></code></pre></div></td></tr></table></figure><p>使用 INSERT INTO 来插入数据的时候，分区字段放到表字段的后面。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> idols <span class="hljs-keyword">VALUES</span><br>(&quot;haruka&quot;, <span class="hljs-number">17</span>, <span class="hljs-number">157</span>, <span class="hljs-string">&#x27;765&#x27;</span>),<br>(&quot;hibiki&quot;, <span class="hljs-number">16</span>, <span class="hljs-number">161</span>, <span class="hljs-string">&#x27;961&#x27;</span>),<br>(&quot;chihaya&quot;, <span class="hljs-number">17</span>, <span class="hljs-number">162</span>, <span class="hljs-string">&#x27;765&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>尝试查看一下 HDFS 中的数据，可以看到数据按 clazz 键进行分区了。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">hadoop fs -ls -R -C <span class="hljs-regexp">/user/</span>hive<span class="hljs-regexp">/warehouse/i</span>dols <br><span class="hljs-regexp">/user/</span>hive<span class="hljs-regexp">/warehouse/i</span>dols/clazz=<span class="hljs-number">765</span><br><span class="hljs-regexp">/user/</span>hive<span class="hljs-regexp">/warehouse/i</span>dols<span class="hljs-regexp">/clazz=765/</span><span class="hljs-number">000000</span>_0<br><span class="hljs-regexp">/user/</span>hive<span class="hljs-regexp">/warehouse/i</span>dols/clazz=<span class="hljs-number">961</span><br><span class="hljs-regexp">/user/</span>hive<span class="hljs-regexp">/warehouse/i</span>dols<span class="hljs-regexp">/clazz=961/</span><span class="hljs-number">000000</span>_0<br></code></pre></div></td></tr></table></figure><p>我们也可以使用<code>ALTER TABLE tb_name ADD PARTITION(field = val, ...) LOCATION &#39;path&#39;</code>来添加分区同时指定分区的位置，这在使用外部表，和其它工具交互时会比较有用，比如我们这个分区建立到另一个文件夹——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> idols <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PARTITION</span>(clazz<span class="hljs-operator">=</span><span class="hljs-string">&#x27;346&#x27;</span>) LOCATION <span class="hljs-string">&#x27;/idol/346&#x27;</span>;<br></code></pre></div></td></tr></table></figure><blockquote><p>该路径甚至可以指向其它存储系统，如亚马逊 S3。</p></blockquote><p>对分区进行查询时，Hive 实际上并不关心文件夹存在与否，只是简单返回空结果，这也是 Hive 的设计哲学的结果。</p><h1 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h1><p>调优在工厂实践中<span class="heimu">实际上更是在面试中 :)</span>是非常重要的，对其进行学习是必须的。</p><p>要学习调优，就要先学习 EXPLAIN，知道 Hive 心里究竟有什么小九九。</p><p>比如，要求它解释一下获取最高工资的语句——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(sal) <span class="hljs-keyword">FROM</span> emp;<br><br>STAGE DEPENDENCIES:<br>  Stage<span class="hljs-number">-1</span> <span class="hljs-keyword">is</span> a root stage<br>  Stage<span class="hljs-number">-0</span> depends <span class="hljs-keyword">on</span> stages: Stage<span class="hljs-number">-1</span><br><br>STAGE PLANS:<br>  Stage: Stage<span class="hljs-number">-1</span><br>    Map Reduce<br>      Map Operator Tree:<br>          TableScan<br>            alias: emp<br>            Statistics: Num <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span> Data size: <span class="hljs-number">6540</span> Basic stats: COMPLETE <span class="hljs-keyword">Column</span> stats: <span class="hljs-keyword">NONE</span><br>            <span class="hljs-keyword">Select</span> Operator<br>              expressions: sal (type: <span class="hljs-keyword">double</span>)<br>              outputColumnNames: sal<br>              Statistics: Num <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span> Data size: <span class="hljs-number">6540</span> Basic stats: COMPLETE <span class="hljs-keyword">Column</span> stats: <span class="hljs-keyword">NONE</span><br>              <span class="hljs-keyword">Group</span> <span class="hljs-keyword">By</span> Operator<br>                aggregations: <span class="hljs-built_in">max</span>(sal)<br>                mode: hash<br>                outputColumnNames: _col0<br>                Statistics: Num <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span> Data size: <span class="hljs-number">8</span> Basic stats: COMPLETE <span class="hljs-keyword">Column</span> stats: <span class="hljs-keyword">NONE</span><br>                Reduce Output Operator<br>                  sort <span class="hljs-keyword">order</span>: <br>                  Statistics: Num <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span> Data size: <span class="hljs-number">8</span> Basic stats: COMPLETE <span class="hljs-keyword">Column</span> stats: <span class="hljs-keyword">NONE</span><br>                  <span class="hljs-keyword">value</span> expressions: _col0 (type: <span class="hljs-keyword">double</span>)<br>      Execution mode: vectorized<br>      Reduce Operator Tree:<br>        <span class="hljs-keyword">Group</span> <span class="hljs-keyword">By</span> Operator<br>          aggregations: <span class="hljs-built_in">max</span>(VALUE._col0)<br>          mode: mergepartial<br>          outputColumnNames: _col0<br>          Statistics: Num <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span> Data size: <span class="hljs-number">8</span> Basic stats: COMPLETE <span class="hljs-keyword">Column</span> stats: <span class="hljs-keyword">NONE</span><br>          File Output Operator<br>            compressed: <span class="hljs-literal">false</span><br>            Statistics: Num <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span> Data size: <span class="hljs-number">8</span> Basic stats: COMPLETE <span class="hljs-keyword">Column</span> stats: <span class="hljs-keyword">NONE</span><br>            <span class="hljs-keyword">table</span>:<br>                input format: org.apache.hadoop.mapred.SequenceFileInputFormat<br>                output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat<br>                serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe<br><br>  Stage: Stage<span class="hljs-number">-0</span><br>    <span class="hljs-keyword">Fetch</span> Operator<br>      limit: <span class="hljs-number">-1</span><br>      Processor Tree:<br>        ListSink<br><br></code></pre></div></td></tr></table></figure><p>可以看到，Stage-1 是一个 MapReduce 任务。一个 Hive 任务会有一个或多个 Stage，Stage 之间会有依赖关系。Stage 可能是 MapReduce 任务，也可能是抽样，归并，LIMIT 以及其它。</p><p>比如使用<code>SELECT * FROM emp [TABLESAMPLE(30 PERCENT)]</code>，可以看到它们跑的都是所谓的<code>Fetch Operator</code>，并没有使用 MR 任务，所以性能较好。</p><hr><p>暂且告一段落，之后关于 Hive，还需要学习<strong>自定义 UDF，常用的函数，SerDe，调优</strong>等，以及给出更多示例，现在去学习 Spark，然后是数据仓库。</p><p><strong>数据仓库将是重头戏，因为它直接关系到项目经验，相关的理论，方法论也都是岗位会直接用到的</strong>。因此，值得为它付出最大量的时间，当然，Hadoop，Hive，Spark等也是不能罔顾的，实际上可能还需要掌握一些flink，Spark Streaming这样的实时数仓所需要的技术。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce，Hive，Spark 的两个示例——Word Count 和 JOIN</title>
    <link href="/2022/03-18MapReduce%EF%BC%8CHive%EF%BC%8CSpark%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94Word-Count%E5%92%8CJOIN.html"/>
    <url>/2022/03-18MapReduce%EF%BC%8CHive%EF%BC%8CSpark%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94Word-Count%E5%92%8CJOIN.html</url>
    
    <content type="html"><![CDATA[<p>在系统学习 Hive 的 SELECT 之前，我们先来进行一些超有趣的事情——分别使用 MapReduce，Hive，Spark 来实现同一个程序，感受一下三者代码的差异，这里选择去实现一下 WordCount，以及一个表连接的示例。</p><span id="more"></span><h1 id="Word-Count"><a href="#Word-Count" class="headerlink" title="Word Count"></a>Word Count</h1><p>Word Count，不从它开始从谁开始呢？首先是 MapReduce，使用 Java 语言，代码是庞然大物。</p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NeoWordCount</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NeoWordCountMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, LongWritable&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LongWritable</span> <span class="hljs-variable">ONE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongWritable</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outputK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>            <span class="hljs-keyword">for</span> (String s : value.toString().split(<span class="hljs-string">&quot; &quot;</span>)) &#123;<br>                outputK.set(s);<br>                context.write(outputK, ONE);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NeoWordCountReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, LongWritable, Text, LongWritable&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LongWritable</span> <span class="hljs-variable">outputV</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongWritable</span>();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (LongWritable value : values) &#123;<br>                sum += value.get();<br>            &#125;<br>            outputV.set(sum);<br>            context.write(key, outputV);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">GenericOptionsParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericOptionsParser</span>(args);<br>        <span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> Job.getInstance(parser.getConfiguration());<br>        args = parser.getRemainingArgs();<br><br>        job.setInputFormatClass(TextInputFormat.class);<br>        job.setOutputFormatClass(TextOutputFormat.class);<br><br>        job.setMapOutputKeyClass(Text.class);<br>        job.setMapOutputValueClass(LongWritable.class);<br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputKeyClass(LongWritable.class);<br><br>        job.setMapperClass(NeoWordCountMapper.class);<br>        job.setReducerClass(NeoWordCountReducer.class);<br>        job.setCombinerClass(NeoWordCountReducer.class);<br><br>        FileInputFormat.setInputPaths(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">0</span>]));<br>        FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">1</span>]));<br><br>        System.exit(job.waitForCompletion(<span class="hljs-literal">true</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，Mapper 和 Reducer 的代码是很显然的，在 Mapper 中，我们将每一行字符串按空格分割，并构造<code>(WORD, 1)</code>的键值对，然后我们通过 Combiner 进行本地聚集，再发送给各个 Reducer，每个 Reducer 对每个 KEY 对应的所有值，进行 sum 操作，得到结果。</p><p>但这里却需要定义一堆东西，更别说 Driver 里的许多东西实际上都是重复的。</p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>我们再来看看 Scala 的 Spark 的代码，Spark 实现 WordCount 其实是对我们这些开发人员最舒服的，但我还没系统学习过 Spark，所以不知道自己的描述是否正确。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 定义函数只是为了能形式化地引入外部变量</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordCount</span></span>(sc : <span class="hljs-type">SparkContext</span>, inputPath : <span class="hljs-type">String</span>, outputPath : <span class="hljs-type">String</span>) : <span class="hljs-type">Unit</span> = &#123;<br>  <span class="hljs-comment">// 不使用链式调用也是为了清晰</span><br>  <span class="hljs-keyword">val</span> lines = sc.textFile(inputPath) <span class="hljs-comment">// 读取</span><br>  <span class="hljs-keyword">val</span> words = lines.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>)) <span class="hljs-comment">// 把字符串按空格切割并展平</span><br>  <span class="hljs-keyword">val</span> wordPairs = words..map((_, <span class="hljs-number">1</span>)) <span class="hljs-comment">// 对每个 word 构造键值对 (WORD, 1)</span><br>  <span class="hljs-keyword">val</span> resultPairs = wordPairs.foldByKey(<span class="hljs-number">0</span>)(_ + _) <span class="hljs-comment">// 折叠操作，该方法应当在本地也会进行聚集……应当</span><br>  resultPairs.saveAsTextFile(outputPath) <span class="hljs-comment">// 保存</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>不要看着 flatMap 就想入非非，<strong>RDD 不是 Monad</strong>！但虽然 RDD 不是 Monad，它仍旧可以使用 for，但这时它的上下文是列表的上下文——flatMap 函数的函数参数不能返回 RDD，因此我们在 for 里所能做的只有列表能做的。</p><p>另外，我不知道为何 Spark 最后得到的结果的 KEY 为何是无序的……按理说经过 shuffle，这里应当是有序的才对，我只能猜测，Spark 利用单进程的方便之处，在折叠时是并行进行的，并输出到同一个文件中，放到 MapReduce 的语境下，就是多个 Reducer 的输出文件为同一个，这样无论如何也不可能得出有序的结果。但这也是符合需求的——我确实没有指定排序。</p><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>然后是 Hive，这里展示了 Hive 从建模，读取数据到写出数据的全流程。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 按默认设置建表，默认设置好像是按、<span class="hljs-number">001</span> 分割字段，按、n 分割记录，所以满足需求<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 这时候每一行都会被当作一个记录看待<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> docs(line STRING);<br>LOAD DATA INPATH <span class="hljs-string">&#x27;/hdfs/path/to/the/document&#x27;</span> OVERWRITE <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> docs; <span class="hljs-comment">-- 将文件读入（覆盖）到表中</span><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> word_counts <span class="hljs-keyword">AS</span> <br><span class="hljs-keyword">SELECT</span> word, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span> explode(split(line, <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-keyword">AS</span> word <span class="hljs-keyword">FROM</span> docs) <span class="hljs-keyword">AS</span> w<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> word;<br></code></pre></div></td></tr></table></figure><p><code>(SELECT explode(split(line, &#39; &#39;)) AS word FROM docs)</code>需要特别解释一下，这里使用了所谓的<strong>表生成函数（UDTF）</strong> <code>explode</code>，即通过一行数据生成一个表（该函数处理一个 Array，生成一个表，而 split 得到的是 Array），这里是 docs 表中每行数据按空格进行切割，并将每个结果展平，最后得到一张表，表中每一个记录都是一个单词，<strong>可以认为这是一种 flatMap</strong>，反过来说，这种在 Mapper 阶段干 flatMap 的操作，是显然需要使用 UDTF 的。</p><p>在得到这个单词表后，我们将其按照单词进行分组，并对每个分组进行 COUNT 聚集，得到结果并用该查询结果创建一张新表。通过<code>SELECT *</code>可以发现其生成的结果和 MapReduce 的版本一致。</p><h1 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h1><p>现在考虑一个传统的案例——现在有一张部门表和一张雇员表，其中雇员属于特定部门，且有自己的工资，现在要求获取每个部门的工资最大的雇员的信息，相关表的定义如下。</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">---- dept.sql ----<br><br>CREATE TABLE IF NOT EXISTS dept (<br>deptno INT,<br>dname STRING,<br>loc INT<br>)<br>ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;,&#x27;<span class="hljs-comment">;</span><br><br>---- dept.txt ----<br><br><span class="hljs-number">10</span>,ACCOUNTING,<span class="hljs-number">1700</span><br><span class="hljs-number">20</span>,RESEARCH,<span class="hljs-number">1800</span><br><span class="hljs-number">30</span>,SALES,<span class="hljs-number">1900</span><br><span class="hljs-number">40</span>,OPERATIONS,<span class="hljs-number">1700</span><br><br>---- emp.sql ----<br><br>CREATE TABLE IF NOT EXISTS emp (<br>empno INT,<br>ename STRING,<br>job STRING,<br>mgr INT, -- 上级<br>hiredate STRING, -- 入职时间<br>sal DOUBLE, -- 薪水<br>comm DOUBLE, -- 奖金<br>deptno INT)<br>ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;,&#x27;<span class="hljs-comment">;</span><br><br>---- emp.txt ----<br><br><span class="hljs-number">7369</span>,SMITH,CLERK,<span class="hljs-number">7902,1980</span>-<span class="hljs-number">12-17,800</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">20</span><br><span class="hljs-number">7499</span>,ALLEN,SALESMAN,<span class="hljs-number">7698,1981</span>-<span class="hljs-number">2-20,1600</span>.<span class="hljs-number">00,300.00</span>,<span class="hljs-number">30</span><br><span class="hljs-number">7521</span>,WARD,SALESMAN,<span class="hljs-number">7698,1981</span>-<span class="hljs-number">2-22,1250</span>.<span class="hljs-number">00,500.00</span>,<span class="hljs-number">30</span><br><span class="hljs-number">7566</span>,JONES,MANAGER,<span class="hljs-number">7839,1981</span>-<span class="hljs-number">4-2,2975</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">20</span><br><span class="hljs-number">7654</span>,MARTIN,SALESMAN,<span class="hljs-number">7698,1981</span>-<span class="hljs-number">9-28,1250</span>.<span class="hljs-number">00,1400.00</span>,<span class="hljs-number">30</span><br><span class="hljs-number">7698</span>,BLAKE,MANAGER,<span class="hljs-number">7839,1981</span>-<span class="hljs-number">5-1,2850</span>,,<span class="hljs-number">30</span><br><span class="hljs-number">7782</span>,CLARK,MANAGER,<span class="hljs-number">7839,1981</span>-<span class="hljs-number">6-9,2450</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">10</span><br><span class="hljs-number">7788</span>,SCOTT,ANALYST,<span class="hljs-number">7566,1987</span>-<span class="hljs-number">4-19,3000</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">20</span><br><span class="hljs-number">7839</span>,KING,PRESIDENT,,<span class="hljs-number">1981-11-17</span>,<span class="hljs-number">5000</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">10</span><br><span class="hljs-number">7844</span>,TURNER,SALESMAN,<span class="hljs-number">7698,1981</span>-<span class="hljs-number">9-8,1500</span>.<span class="hljs-number">00,0.00,30</span><br><span class="hljs-number">7876</span>,ADAMS,CLERK,<span class="hljs-number">7788,1987</span>-<span class="hljs-number">5-23,1100</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">20</span><br><span class="hljs-number">7900</span>,JAMES,CLERK,<span class="hljs-number">7698,1981</span>-<span class="hljs-number">12-3,950</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">30</span><br><span class="hljs-number">7902</span>,FORD,ANALYST,<span class="hljs-number">7566,1981</span>-<span class="hljs-number">12-3,3000</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">20</span><br><span class="hljs-number">7934</span>,MILLER,CLERK,<span class="hljs-number">7782,1982</span>-<span class="hljs-number">1-23,1300</span>.<span class="hljs-number">00</span>,,<span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><h2 id="Hive-1"><a href="#Hive-1" class="headerlink" title="Hive"></a>Hive</h2><p>这个需求和 SQL 非常契合，所以我们先使用 Hive 进行描述，我们显然需要一个内连接来进行此工作。（可能有更简单的方式，但我还没学到）</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> department,employee,salary <span class="hljs-keyword">FROM</span><br>    (<span class="hljs-keyword">SELECT</span><br>        dept.dname <span class="hljs-keyword">AS</span> department,<br>        emp.ename <span class="hljs-keyword">AS</span> employee,<br>        emp.sal <span class="hljs-keyword">AS</span> salary,<br>        <span class="hljs-built_in">RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> dept.deptno <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> emp.sal <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">as</span> rk<br>    <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">JOIN</span> emp <span class="hljs-keyword">ON</span> dept.deptno <span class="hljs-operator">=</span> emp.deptno) <span class="hljs-keyword">AS</span> t<br><span class="hljs-keyword">WHERE</span> rk <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>这里使用了 RANK 窗口函数，其中根据部门分区，根据工资降序，获取 rank 为 1 的就是工资最高的，这里<strong>耗时 28 秒</strong>。一个更加清晰的表述使用子查询，但 Hive 不支持子查询，所以这里使用 JOIN 来表述。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> dept.dname, emp.ename, emp.sal <span class="hljs-keyword">FROM</span><br>  dept <span class="hljs-keyword">JOIN</span> emp <span class="hljs-keyword">ON</span> dept.deptno <span class="hljs-operator">=</span> emp.deptno<br>       <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> deptno, <span class="hljs-built_in">MAX</span>(sal) <span class="hljs-keyword">AS</span> max_sal <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno) <span class="hljs-keyword">AS</span> max_t<br><span class="hljs-keyword">ON</span> max_t.deptno <span class="hljs-operator">=</span> emp.deptno <span class="hljs-keyword">AND</span> max_t.max_sal <span class="hljs-operator">=</span> emp.sal;<br></code></pre></div></td></tr></table></figure><p>这个更加麻烦一些，而且性能更加差——两次 JOIN，要执行两次 MapReduce 任务才行，<strong>它耗时 64 秒</strong>（Hive 不是会进行 MapJoin 优化吗？？）。下面的 MapReduce 只描述第一种。</p><h2 id="MapReduce-1"><a href="#MapReduce-1" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>关于 MapReduce 的编写，考虑到部门和雇员是一对多的关系，且部门的数量一定是较少的，我们本可以使用 map 端 join，但为了通用性，我们使用 reduce 端 join，为此，用于 join 的键必须要在键值对的键中，因此，Mapper 的输出的键中应当包含 deptno，然后在 reduce 的值的集合里，我们要让部门作为第一个元素，因此我们需要为此创建一个虚拟键。</p><p>再考虑分区，分组，排序，关于分区，肯定是按 deptno 进行分区；关于分组，我们也是按 deptno 进行分组；关于排序，为了能保证部门在最前面，我们要按 deptno 和虚拟键进行排序，这里也可以把工资也加进来进行排序，以保证第二个元素就能获取到最高的工资，但这其实并无必要。</p><p>根据上面的分析，我们规定，Mapper 的输出类型为<code>&lt;(deptno, virtualKey), Text&gt;</code>（懒得定义一个泛类型了，机械操作太多了），按 deptno 进行分区，按 deptno 进行分组，按 deptno、virtualKey 进行排序；<strong>同时也可以发现，这里可以有一个 Combiner</strong>；Reducer 的输出类型就随意了，人能看就行。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 注意这个需要两个输入，第一个输入是 dept，第二个输入是 emp</span><br><br><span class="hljs-comment">// Mapper 输出的 key</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombineKey</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WritableComparable</span>&lt;CombineKey&gt; &#123;<br>    <span class="hljs-keyword">private</span> Integer deptno;<br>    <span class="hljs-keyword">private</span> Integer virtualKey;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(CombineKey o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!deptno.equals(o.deptno))<br>            <span class="hljs-keyword">return</span> deptno.compareTo(o.deptno);<br>        <span class="hljs-keyword">return</span> virtualKey.compareTo(o.virtualKey);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(DataOutput out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        out.writeInt(deptno);<br>        out.writeInt(virtualKey);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFields</span><span class="hljs-params">(DataInput in)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        deptno = in.readInt();<br>        virtualKey = in.readInt();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, CombineKey, Text&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        String[] cols = value.toString().split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deptno</span> <span class="hljs-operator">=</span> Integer.parseInt(cols[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">CombineKey</span> <span class="hljs-variable">outputK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CombineKey</span>();<br>        outputK.deptno = deptno;<br>        outputK.virtualKey = <span class="hljs-number">0</span>;<br>        context.write(outputK, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmpMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, CombineKey, Text&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        String[] cols = value.toString().split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deptno</span> <span class="hljs-operator">=</span> Integer.parseInt(cols[<span class="hljs-number">7</span>]);<br>        <span class="hljs-type">CombineKey</span> <span class="hljs-variable">outputK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CombineKey</span>();<br>        outputK.deptno = deptno;<br>        outputK.virtualKey = <span class="hljs-number">1</span>;<br>        context.write(outputK, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptnoPartitioner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Partitioner</span>&lt;CombineKey, Text&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(CombineKey combineKey, Text text, <span class="hljs-type">int</span> numPartitions)</span> &#123;<br>        <span class="hljs-keyword">return</span> (combineKey.deptno.hashCode() &amp; Integer.MAX_VALUE) % numPartitions;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptnoGroupComparator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WritableComparator</span> &#123;<br>    <span class="hljs-comment">// 永远记着定义 Comparator 的时候别把这茬忘掉了……</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeptnoGroupComparator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(CombineKey.class, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(WritableComparable a, WritableComparable b)</span> &#123;<br>        <span class="hljs-keyword">return</span> ((CombineKey) a).deptno.compareTo(((CombineKey) b).deptno);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Combiner 的职责是在每个 Mapper 本地聚集</span><br><span class="hljs-comment">// 对于 DeptMapper，没有聚集的必要，对于 EmpMapper，可以直接找到该 Mapper 该部门最大工资的雇员，只写它就行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeCombiner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;CombineKey, Text, CombineKey, Text&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(CombineKey key, Iterable&lt;Text&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (key.virtualKey.equals(<span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-keyword">for</span> (Text value : values) &#123;<br>                context.write(key, value);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">maxSal</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maxEmp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">for</span> (Text value : values) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> value.toString();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">sal</span> <span class="hljs-operator">=</span> Double.parseDouble(emp.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">5</span>]);<br>            <span class="hljs-keyword">if</span> (sal &gt; maxSal) &#123;<br>                maxSal = sal;<br>                maxEmp = emp;<br>            &#125;<br>        &#125;<br>        context.write(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(maxEmp));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;CombineKey, Text, NullWritable, Text&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(CombineKey key, Iterable&lt;Text&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-comment">// 虚拟键不可能是 1，如果是 1，则说明这些雇员根本没有对应的部门</span><br>        <span class="hljs-comment">// 考虑当前连接是内连接，这时直接返回即可</span><br><br>        <span class="hljs-keyword">if</span> (key.virtualKey.equals(<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        String[] deptCols = values.iterator().next().toString().split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">maxSal</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maxEmp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (Text value : values) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> value.toString();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">sal</span> <span class="hljs-operator">=</span> Double.parseDouble(emp.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">5</span>]);<br>            <span class="hljs-keyword">if</span> (sal &gt; maxSal) &#123;<br>                maxSal = sal;<br>                maxEmp = emp;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 部门没有任何雇员，这里是内连接，也是直接返回</span><br>        <span class="hljs-keyword">if</span> (maxEmp == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        String[] empCols = maxEmp.split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;,&quot;</span>)<br>                .add(deptCols[<span class="hljs-number">1</span>])<br>                .add(empCols[<span class="hljs-number">1</span>])<br>                .add(empCols[<span class="hljs-number">5</span>])<br>                .toString();<br><br>        context.write(NullWritable.get(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(result));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>MapReduce 编写这种业务代码真的是非常……非常痛苦，底层细节太多了，远不如 SQL 那样直接，更不用说有三个以上的表进行 reduce 端 join 的时候需要使用多个 MR 任务，且需要注意的细节更多，需要定义更多 Bean……想想就痛苦，和 CRUD 一样的痛苦。</p><h2 id="Spark-1"><a href="#Spark-1" class="headerlink" title="Spark"></a>Spark</h2><p>然后是 Spark 版本。Spark 版本怎么写其实我还没有学过，但跟随着直觉，还是挺容易写的。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">someComplexJob</span></span>(sc : <span class="hljs-type">SparkContext</span>, deptInputPath : <span class="hljs-type">String</span>, empInputPath : <span class="hljs-type">String</span>, outputPath : <span class="hljs-type">String</span>) : <span class="hljs-type">Unit</span> = &#123;<br>  <span class="hljs-keyword">val</span> depts = sc.textFile(deptInputPath)<br>    .map(_.split(<span class="hljs-string">&quot;,&quot;</span>))<br>    .map&#123;cols =&gt; (cols(<span class="hljs-number">0</span>), cols)&#125;<br>  <span class="hljs-keyword">val</span> emps = sc.textFile(empInputPath)<br>    .map(_.split(<span class="hljs-string">&quot;,&quot;</span>))<br>    .map&#123;cols =&gt; (cols(<span class="hljs-number">7</span>), cols)&#125;<br><br>  <span class="hljs-comment">// 值得注意的是，Spark 进行 join 操作不需要</span><br>  <span class="hljs-comment">// 像 MapReduce 那样在 KEY 里给定一个虚拟键，</span><br>  <span class="hljs-comment">// 但相信 Spark 的实现也会采取类似的手段</span><br>  <span class="hljs-keyword">val</span> deptEmps = depts.join(emps)<br><br>  <span class="hljs-comment">// 做一个 max 操作</span><br>  <span class="hljs-comment">// 需注意，reduceByKey 中的参数拿不到 KEY，这点很好</span><br>  <span class="hljs-comment">// 它怎么推断不出来……</span><br>  deptEmps.reduceByKey&#123; (a, b) =&gt;<br>    <span class="hljs-keyword">val</span> (pairA@(_, empA), pairB@(_, empB)) = (a, b)<br>    <span class="hljs-keyword">if</span> (empA(<span class="hljs-number">5</span>).toDouble &gt; empB(<span class="hljs-number">5</span>).toDouble)<br>      pairA<br>    <span class="hljs-keyword">else</span> pairB<br>  &#125;.map&#123;<span class="hljs-keyword">case</span> (_, (dept, emp)) =&gt;<br>    <span class="hljs-type">Array</span>(dept(<span class="hljs-number">1</span>),emp(<span class="hljs-number">1</span>),emp(<span class="hljs-number">5</span>)).mkString(<span class="hljs-string">&quot;,&quot;</span>)<br>  &#125;.saveAsTextFile(outputPath)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Spark 的代码真是优雅！但一个遗憾的地方是函数参数无法解构，使用 PartialFunction 解构，它居然说类型推断不出来，要我给出类型……i 服了 you。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结个啥，我只能说 Spark 太香了。上面的 JOIN 代码，如果在工程实践中应当定义 Bean，MapReduce 进行连接操作时应该使用 GenericWritable 作为 VALUE。实际上本还想写个分布式排序示例，但我对 Hive 和 Spark 都还没学到那里，先跳过了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>分布式计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive 学习笔记 1——架构，DDL 和数据的导出导入</title>
    <link href="/2022/03-17Hive%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201%E2%80%94%E2%80%94%E6%9E%B6%E6%9E%84%EF%BC%8CDDL%20%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5.html"/>
    <url>/2022/03-17Hive%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201%E2%80%94%E2%80%94%E6%9E%B6%E6%9E%84%EF%BC%8CDDL%20%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5.html</url>
    
    <content type="html"><![CDATA[<p>下面的笔记基本上是根据尚硅谷的视频做的，回过头来看看，这样学习的效率是很低的，之后要避免这种手册式的学习和笔记。考虑之后对常用子句多记录一些示例。</p><hr><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Form is liberating</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>Hive 就是一种用于构造 MapReduce 的 DSL 及相关基础设施，这样的概括大概足矣。</p><p>Hive 的文档见 <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual">此</a>。</p><blockquote><p>突然想到，在之前写业务代码的时候，我基本不会去关心代码的性能（至少不会关注常数级的性能），对人的可读性比对机器的可读性更重要；但在大数据领域上这就不一样了——大数据所写的代码，很可能将会被应用上千万次，这时候任何一点常数倍的复杂度的差别就会引起很大的性能问题，</p></blockquote><h1 id="为什么是-Hive"><a href="#为什么是-Hive" class="headerlink" title="为什么是 Hive"></a>为什么是 Hive</h1><p>Hadoop 的一个重要的原则就是<strong>数据本地性</strong>——我们移动计算到数据，而非移动数据到计算，从而减少网络 IO，增加吞吐量。</p><p>移动计算，这点（的字面意思）在 MapReduce 的使用中非常明显——我们把自己的 MapReduce 程序打成 Jar 包，放置到 Hadoop 集群中，并要求它（分发和）运行该 Jar 包，这就是一个典型的“移动计算”的操作了。但这种操作总会让人感觉有点麻烦，即使它可以自动化。</p><p>这时候就自然会想，能不能让客户端直接把程序提交给 Hadoop 集群呢？部分可行，可以通过 Hadoop Stream 做这个，但是程序一般来说总有一些自己的依赖，这时候 Hadoop 集群下必须要有相应依赖，这也引入了额外的麻烦，让人想到 JavaEE 的怪味，和当前的容器化是背道而驰的（咱提交 Docker 镜像过去吧 hhh）。</p><p>自接触函数式编程伊始，将函数&#x2F;过程当作数据来看待已经深入我心，但这种抽象仅在同一进程下能够屏蔽掉底层的麻烦细节，倘若想要把过程真的当作数据来序列化，持久到硬盘中，在本地或网络进行传输的话，就会遇到一万个问题，最典型的一个就是上面说的外部依赖问题。</p><p>为了不引入额外的依赖，这时候我们就想着，能不能<strong>把 Mapper 和 Reducer 的程序形式化，结构化，抽象为一些预先定义的“指令”</strong>，从而能够被方便地解析，以及当作对象传输，从而达到目的？</p><p>另外，在编写 MapReduce 程序时，也会发现，自己写的 Mapper 和 Reducer 好像在形式上有很多重复，而一些操作实现起来非常繁琐，如JOIN等，但是这些繁琐的操作实际上也能够找出模式来。这时候就会希望，有没有啥东西能把这麻烦的过程给抽象一下呢？</p><p>而 Hive 就是这样的一个框架——它是一个解决海量的<strong>结构化</strong>日志的<strong>数据统计工具&#x2F;数据仓库工具</strong>。<span style="color: #FF0000">它模仿 SQL，定义了一种名为 HQL 的 DSL，并能够把用户编写的 HQL 转换成对应的 MapReduce 程序</span>；它将结构化的数据文件映射成为一张表，提供<strong>类 SQL</strong> 的查询的功能。</p><blockquote><p>为什么是 SQL 呢？可以意识到，SQL 中常用的操作，如 select，where，order by，group，count 等，都是可以使用 map（其实是 flatmap）和 reduce 操作表达的，如 select 是 map，where 是 filter，group，count 是 reduce……</p></blockquote><p>顺带一提，Pig 框架也是和 Hive 一样的思想的产物，但 Pig 使用一种特定的脚本语言，且似乎已经不再流行。</p><h2 id="Hive-的特色"><a href="#Hive-的特色" class="headerlink" title="Hive 的特色"></a>Hive 的特色</h2>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">关于 Hive 的优缺点</span></summary>        <blockquote><p>优点——</p><ul><li>语法类 SQL，CRUD 程序员能快速上手（但是数据类型则是类似 Java 的，和其它 SQL 不一样）</li><li>使能够免去编写 MapReduce 程序的麻烦</li><li>善于处理大数据（十亿，百亿级），这是传统的 OLTP 数据库做不到的；但处理小数据无优势</li><li>支持用户自定义函数</li></ul><p>缺点——</p><ul><li>HQL 表达能力有限<ul><li>无法表达迭代式算法（SQL 嘛）</li><li>不擅长数据挖掘</li></ul></li><li>效率差<ul><li>MapReduce 自动生成的，因而性能很大程度上要仰仗“编译器”的优化，不够智能</li><li>调优困难</li></ul></li></ul></blockquote>            </details>  <p>Hive 和 Hadoop 平台紧密结合——Hive 处理的数据存储在 HDFS；Hive 的底层仍旧是 MapReduce（也可以换成 Spark）；Hive 通过 Yarn 来执行程序。</p><p>Hive 的数据存储在 HDFS，这意味着更新操作是很昂贵的，因此 Hive 不建议修改操作。</p><p>Hive 不需要集群部署，只需要一个节点即可，它相较于 Hadoop 集群，更像是一个客户端（但从外部来看，它仍旧是服务端）。</p><p>Hive 有自己的元数据——不然它如何把文件和表做映射呢？Hive 的元数据存储在传统的数据库中，它默认使用一种嵌入式的数据库，名为 Derby（爱马仕欢喜），但一般都会使用 MySQL 等在工程实践中常用的数据库来保存。</p><p>Hive 的数据仍旧是以比较规范的形式存储在 HDFS 中的——它默认使用<code>/user/hive/warehouse</code>存储所有数据（Hive 的 default 数据库），其中每一张表都作为一个文件夹存放，比如我们创建表<code>create table test (id string)</code>，它就会在该目录下创建 test 文件夹；且它是以该文件夹下所有数据作为自己的数据的——如果在该文件夹下创建文件存储和表同样格式的信息，如<code>1001\n1002</code>，它是可以被<code>select</code>查到的，十分有趣（更有趣的是使用 count 查不到，这说明有的操作是通过查询元数据进行的，而有的操作则是通过查询实际数据）；<strong>这让我们很容易通过 sql 以外的方式对表进行数据插入</strong>，但显然需要同时能够对元数据进行维护。</p><p>Hive 是<strong>读时模式</strong>，即在读取数据时才对数据的格式进行验证；而传统数据库是<strong>写时模式</strong>，即在数据写入时就对数据的格式进行检查。读时模式在加载（LOAD）数据时非常迅速，因为它不对数据进行任何校验操作，直接移动文件即可。</p><p>读时模式的优势在于加载迅速，但在查询时则会逊色一些，且难以进行索引等操作（现在有了），但这些其实问题并不大，因为 Hive 的应用场景通常会进行全表扫描，</p><h2 id="Hive-的诸服务及其相互关系"><a href="#Hive-的诸服务及其相互关系" class="headerlink" title="Hive 的诸服务及其相互关系"></a>Hive 的诸服务及其相互关系</h2><p><img src="/images/oss/20220225225304.png"></p><p>接触最多的将是 hiveserver2，启动该服务能让 Hive 以 Thrift 服务的形式运行，从而让外部 Thrift，JDBC 客户端能进行连接；其次是 metastore，Hive 通过 metastore 来访问保存的元数据，而 metastore 将数据保存在关系型数据库中。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>HQL 的数据类型比较类似 Java，其有如下数据类型——</p><ul><li>TINYINT，对应 Java 的 byte</li><li>SMALLINT，对应 short</li><li>INT</li><li>BIGINT，对应 long</li><li>BOOLEAN</li><li>FLOAT</li><li>DOUBLE</li><li>DECIMAL，任意精度的有符号数，如 DECIMAL(10, 2) 表示小数点左部 10 位，右部 2 位。</li><li>STRING，同 String，可变长</li><li>TIMESTAMP，时间类型，精度为纳秒，应该对应 Java 的 Datetime</li><li>DATE，日期类型，类似 LocalDate？</li><li>BINARY，对应 byte[]，用途应为存储一些二进制数据</li></ul><p>还有一些集合数据类型——</p><ul><li>STRUCT，类似 C 的结构体，Java 的 Record，类型的语法形如<code>STRUCT&lt;data1:INT, data2:STRING&gt;</code></li><li>MAP，键值对的映射，语法形如<code>MAP&lt;STRING, INT&gt;</code></li><li>ARRAY，语法形如<code>ARRAY&lt;INT&gt;</code></li><li>UNION，类似 C 的联合体，怀疑它的存在意义</li></ul><p>比如，对一个这样的 JSON 串进行建模，相应的语句见下。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 虽然没啥必要，但是这里指出一下，JSON 没法写注释，假装这是 js 吧</span><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;yuuki&quot;</span>, <span class="hljs-comment">// STRING</span><br>  <span class="hljs-string">&quot;friends&quot;</span>: [<span class="hljs-string">&quot;asuna&quot;</span>, <span class="hljs-string">&quot;kirito&quot;</span>], <span class="hljs-comment">// ARRAY&lt;STRING&gt;</span><br>  <span class="hljs-string">&quot;parents&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;father&quot;</span> : <span class="hljs-number">45</span>,<br>    <span class="hljs-string">&quot;mother&quot;</span> : <span class="hljs-number">40</span><br>  &#125;, <span class="hljs-comment">// STRUCT&lt;father:INT, mother:INT&gt;，父母是确定的</span><br>  <span class="hljs-string">&quot;pets&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;meowmeow&quot;</span> : <span class="hljs-number">3</span>,<br>    <span class="hljs-string">&quot;nyanya&quot;</span> : <span class="hljs-number">2</span><br>  &#125; <span class="hljs-comment">// MAP&lt;STRING, INT&gt;，宠物是不确定的</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_t(<br>  name STRING,<br>  friends <span class="hljs-keyword">ARRAY</span><span class="hljs-operator">&lt;</span>STRING<span class="hljs-operator">&gt;</span>,<br>  parents STRUCT<span class="hljs-operator">&lt;</span>father:<span class="hljs-type">INT</span>, mother:<span class="hljs-type">INT</span><span class="hljs-operator">&gt;</span>,<br>  pets MAP<span class="hljs-operator">&lt;</span>STRING, <span class="hljs-type">INT</span><span class="hljs-operator">&gt;</span><br>)<br><span class="hljs-type">row</span> format delimited <span class="hljs-comment">-- 下面的部分均为&quot;row format delimited&quot;的子句</span><br>fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span>  <span class="hljs-comment">-- （表）字段和字段之间使用 , 分割，字段分隔符似乎强制是一个字符</span><br>collection items terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;_&#x27;</span>  <span class="hljs-comment">-- 集合（三种集合类型）中的元素使用 _ 分割 </span><br>map keys terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;:&#x27;</span>  <span class="hljs-comment">-- MAP 的 KV 之间用 : 分割（STRUCT 里不包括 K，因此其各字段顺序是一定的）</span><br>lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span>;  <span class="hljs-comment">-- 行分隔符，默认为 \n</span><br></code></pre></div></td></tr></table></figure><p><strong>STRUCT 类型通过<code>.</code>来访问字段，MAP 和 ARRAY 通过<code>[]</code>来访问元素</strong>，同 js 一致。</p><p>插入该表的语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> person_t <span class="hljs-keyword">values</span><br>(&quot;yuuki&quot;, <span class="hljs-keyword">array</span>(&quot;asuna&quot;, &quot;kirito&quot;), named_struct(&quot;father&quot;, <span class="hljs-number">45</span>, &quot;mother&quot;, <span class="hljs-number">40</span>), <br>str_to_map(&quot;meowmeow:3,nyanya:2&quot;)); <br></code></pre></div></td></tr></table></figure><h2 id="集合类型的字面量"><a href="#集合类型的字面量" class="headerlink" title="集合类型的字面量"></a>集合类型的字面量</h2><blockquote><p>这些语法只有看书才能找到……Hive的文档和社区一言难尽。</p></blockquote><p>集合类型没有提供直接的字面量，都是使用函数来进行表述的，我认为这是很好的设计。</p><p>数组的字面量形如<code>array(1, 2)</code>，类型需要保证一致。</p><p>结构体的字面量形如<code>struct(&#39;hello&#39;, 1)</code>，最终得到的实际的结构体为<code>&#123;&quot;col1&quot;:&quot;hello&quot;,&quot;col2&quot;:1&#125;</code>，这不一定符合我们的需求，因此还有另一个语法（函数），形如<code>named_struct(&#39;name&#39;, &#39;yuuki&#39;, &#39;age&#39;, 16)</code>，得到<code>&#123;&quot;name&quot;:&quot;yuuki&quot;,&quot;age&quot;:16&#125;</code>。</p><p>哈希表的字面量形如<code>map(&#39;yuuki&#39;, 16, &#39;honoka&#39;, 17)</code>，各键值对的类型需要保证一致。也有一个函数<code>str_to_map(&quot;meowmeow:3,nyanya:2&quot;)</code>，该函数能通过字符串构造哈希表，但类型似乎只能是<code>MAP&lt;STRING,STRING&gt;</code>。</p><h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><blockquote><p>Web 开发里使用 CREATE 之外的 DDL 的机会实际上并不多，因为 Web 开发对表的设计慎之又慎毕竟一改可能就需要改非常多的东西。而大数据的话可能用的情况会稍多些？但是估计也只是仅限于在尾部多加个字段啥的。</p></blockquote><p>DDL（Data Definition Language，数据定义语言），即创建和查询，操作<strong>表结构</strong>的语言，它相较于 DML 不那么重要。这里尽量把麻烦的语法都写出来，方便之后可以查询。</p><h2 id="关于数据库"><a href="#关于数据库" class="headerlink" title="关于数据库"></a>关于数据库</h2><p>USE 关键字用于切换使用数据库。</p><p>SHOW 关键字用于对表，数据库等信息进行展示，也可用于展示 SQL 语句的实际信息（带上所有参数的）。</p><p>比如，创建一个表<code>create table test(id string);</code>，可以使用<code>show create table test;</code>查看建表时的实际语句——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `test`(<br>  `id` string)<br><span class="hljs-type">ROW</span> FORMAT SERDE <br>  <span class="hljs-string">&#x27;org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe&#x27;</span> <br>STORED <span class="hljs-keyword">AS</span> INPUTFORMAT <br>  <span class="hljs-string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span> <br>OUTPUTFORMAT <br>  <span class="hljs-string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span><br>LOCATION<br>  <span class="hljs-string">&#x27;hdfs://hdp1.local:8020/user/hive/warehouse/test&#x27;</span><br>TBLPROPERTIES (<br>  <span class="hljs-string">&#x27;bucketing_version&#x27;</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;2&#x27;</span>, <br>  <span class="hljs-string">&#x27;transient_lastDdlTime&#x27;</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;1645953957&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>CREATE DATABASE 语句创建数据库，语法如下，<code>[]</code>内内容为可选项，大写的单词为关键字，小写为变量。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] db_name <span class="hljs-comment">-- 字面意思</span><br>[COMMENT description] <span class="hljs-comment">-- 字面意思</span><br>[LOCATION hdfs_path] <span class="hljs-comment">-- 指定数据库在 hdfs 上的存储路径</span><br>[<span class="hljs-keyword">WITH</span> DBPROPERTIES (property_name<span class="hljs-operator">=</span>property_value, ...)]; <span class="hljs-comment">-- 一些额外信息，似乎没有和配置相关的</span><br></code></pre></div></td></tr></table></figure><p>自己创建的数据库默认存在<code>/user/hive/warehouse/DB_NAME.db/</code>，数据库上所有表都将在该文件夹下。但 default 就存在<code>/user/hie/warehouse/</code>下，没有另外建立文件夹。</p><p>查询数据库使用 SHOW 关键字，其语法为 <code>SHOW DATABASES [LIKE search_str];</code>，可以使用 like 关键字查询名称符合特定模式的数据库。</p><p>查询数据库信息用<code>DESC DATABASE db_name</code>。</p><p>修改数据库使用<code>ALTER DATABASE db_name SET DBPROPERTIES(&#39;properties_name&#39; = &#39;properties_value&#39;)</code>，只能修改<code>DBPROPERTIES</code>。</p><p>删除用<code>DROP DATABASE [IF EXISTS] db_name [CASCADE]</code>，DROP 默认只能删除空的数据库，若要删除非空的数据库需要使用 CASCADE 关键字。</p><h2 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h2><p>CREATE 关键字用于创建表，它或许是最重要的 DDL 的关键字了。</p><p>下面的语法并非全部，还有更多的未列出（比如上面的建表的示例展示的）</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">EXTERNAL</span>] <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] table_name<br>[(col_name data_type [COMMENT col_comment], ...)]<br>[PARTITIONED <span class="hljs-keyword">BY</span> (col_name data_type [COMMENT col_comment], ...)] <span class="hljs-comment">-- 分区表的配置</span><br>[CLUSTERED <span class="hljs-keyword">BY</span> (col_name, ...)] <span class="hljs-comment">-- 分桶表</span><br>[SORTED <span class="hljs-keyword">BY</span> (col_name, [<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>], ...) [<span class="hljs-keyword">INTO</span> num_buckets BUCKETS]] <span class="hljs-comment">-- TODO 视频的方括号不匹配，也是分桶表的配置</span><br>[<span class="hljs-type">ROW</span> FORMAT row_format] <span class="hljs-comment">-- 行的格式化方式</span><br>[STORED <span class="hljs-keyword">AS</span> file_format] <span class="hljs-comment">-- 使用什么文件格式存放，如文本，压缩……</span><br>[LOCATION hdfs_path] <span class="hljs-comment">-- 字面意思</span><br>[TBLPROPERTIES (property_name<span class="hljs-operator">=</span>property_value, ...)]<br>[<span class="hljs-keyword">AS</span> select_statement]; <span class="hljs-comment">-- 通过查询的方式建表，如 create table abc as (select ...);</span><br></code></pre></div></td></tr></table></figure><p>EXTERNAL 关键字标识表是外部表，默认的表称为管理表（Managed table）<span class="heimu">其实应该叫“被管理表”</span>。</p><p>管理表的特点是，表的元数据的生命周期和实际数据的生命周期一致，也就是说当我们<strong>删除一张管理表的时候，存储在 HDFS 上的实际数据也会同时被删除</strong>。删除外部表的时候，HDFS 的数据不会被删除。</p><p>倘若某数据是同其它系统共享的，应当使用外部表。外部表比管理表更为常用。</p><blockquote><p>使用<code>ALTER TABLE tb_name SET TBLPROPERTIES(&quot;EXTERNAL&quot;=&quot;TRUE&quot;);</code>设置表为外部表，属性大小写敏感。</p></blockquote><p>使用<code>DESC FORMATTED tb_name</code>查询表的信息。</p><h2 id="表的修改，删除"><a href="#表的修改，删除" class="headerlink" title="表的修改，删除"></a>表的修改，删除</h2><p>重命名表使用 RENAME TO 关键字，语法为<code>ALTER TABLE tb_name RENAME TO new_name</code>。</p><p>修改列的信息主要包括列名和列类型。</p><p>更新列的信息使用 CHANGE 关键字，语法为<code>ALTER TABLE tb_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name]</code>，注意更新后的类型必须给定。</p><p>添加列使用 ADD 关键字，更换列使用 REPLACE 关键字，REPLACE 实际上就是直接把所有列全部换掉了。它们的语法为<code>ALTER TABLE tb_name ADD COLUMNS (col_name column_type [COMMENT col_comment], ...);</code>。</p><p>没有删除列的操作，只能使用 REPLACE。</p><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><p>DML（Data Manipulation language，数据操纵语言），即用于对数据库的对象（即实体，即表中的每一行）进行访问的语言，如 SELECT，DELETE，UPDATE 等语句，但 Hive 提供更丰富的操作，以满足各种导入&#x2F;导出数据等的需求。</p><h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>LOAD 和 INSERT 最为常用。</p><h3 id="LOAD（！）"><a href="#LOAD（！）" class="headerlink" title="LOAD（！）"></a>LOAD（！）</h3><p>十分明显地，通过手动上传文件到 HDFS 上来插入数据并非是一个好的选择——元数据没有相应改变，这使得某些查询结果会出现错误，而且这样插入数据也无法在插入时得到 Hive 的校验，因此有可能插入格式错误的数据。</p><p><strong>通过上传文件来插入数据</strong>可以使用所谓的 LOAD 关键字，其语法为<code>LOAD DATA [LOCAL] INPATH &#39;data_path&#39; [OVERWRITE] INTO TABLE tb_name [PARTITION (partcol1=val1,...)]</code>。</p><ul><li>LOCAL: 表示从本地文件系统加载数据，否则从 HDFS 中加载</li><li>OVERWRITE: 表示覆盖原有数据，或者追加数据</li><li>PARTITION: 关于分区信息的设置</li></ul><p>注意！当从 HDFS 中加载数据的时候，它执行的是一种 mv 操作——<strong>移动了文件的位置</strong>！这种移动是逻辑上的，因为 HDFS 的路径中的文件夹是虚拟的，只是改一下路径即可，因此性能和文件大小无关。</p>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">一个例子</span></summary>        <blockquote><p>考虑对下面创建的表执行 LOAD 操作——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTERNAL</span> <span class="hljs-keyword">TABLE</span> student(<br>  id <span class="hljs-type">INT</span>,<br>  name STRING<br>)<br><span class="hljs-type">ROW</span> FORMAT DELIMITED<br>FIELDS TERMINATED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;,&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p>一个插入文件的示例为如下，注意其和表的列格式的配置一致。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">15332,yuuki<br>15333,rin<br>15200,asuna<br>15900,haruka<br>15901,chihaya<br></code></pre></div></td></tr></table></figure><p>假设该文件保存在本地文件目录<code>/home/yuuki/data.txt</code>，则相应插入语句为——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL">LOAD DATA <span class="hljs-keyword">LOCAL</span> INPATH <span class="hljs-string">&#x27;/home/yuuki/data.txt&#x27;</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> student;<br></code></pre></div></td></tr></table></figure><p><strong>注意——LOAD 操作没有走 MR 操作，它是直接把文件放到 HDFS 上的相应路径并修改元信息（元数据中的 numfiles 的值），因此操作非常快</strong>。插入后再运行<code>select count(*) from student</code>，就会发现该操作跑 MR 而非直接查元数据了。</p></blockquote>            </details>  <h4 id="INSERT（！）"><a href="#INSERT（！）" class="headerlink" title="INSERT（！）"></a>INSERT（！）</h4><p>普通的 INSERT 语句不需赘述，但 Hive 提供了一个重要的变体——<strong>通过查询结果插入&#x2F;覆盖数据到表</strong>——<code>INSERT (INTO|OVERWRITE TABLE) tb_name select_clause</code>，一个例子是——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">INSERT</span> OVERWRITE <span class="hljs-keyword">TABLE</span> stud <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">15000</span>;<br></code></pre></div></td></tr></table></figure><p>多个 INSERT 子句可以放置在一起作为单条语句，似乎在分区表中比较常用。</p><p>可以使用FROM子句进行插入，示例如下——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">FROM</span> idols<br><span class="hljs-keyword">INSERT</span> OVERWRITE <span class="hljs-keyword">TABLE</span> idols_961 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">WHERE</span> clazz <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;961&#x27;</span><br><span class="hljs-keyword">INSERT</span> OVERWRITE <span class="hljs-keyword">TABLE</span> idols_765 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">WHERE</span> clazz <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;765&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p><strong>该操作只会对原表进行一次查询</strong>，因而效率更高。</p><h3 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h3><p>CREATE 关键字也有几个能用于<strong>建表的同时插入数据</strong>的操作，比如<code>CREATE TABLE [IF NOT EXISTS] tb_name AS select_clause</code>语句能够通过查询结果创建表，这和 insert 是类似的，区别在于 insert 是向已有的表进行操作，而该操作是通过数据创建表，表的字段由查询结果决定。</p><p>山不去见穆罕默德，穆罕默德就去见山：LOCATION 关键字用于<strong>在已有的数据上建表</strong>的情况——它会指定表的存储位置，因而倘若该位置已经有数据，就相当于是将这些数据插入到表中了。</p><h3 id="IMPORT"><a href="#IMPORT" class="headerlink" title="IMPORT"></a>IMPORT</h3><p>IMPORT 需和 EXPORT 配合使用，相当于是把一个表的数据以特定的形式导出，再导入到另一张表，语法为 <code>IMPORT TABLE tb_name FROM path</code>。用处似乎不多。IMPORT 不能使用在已有数据的表中。</p><h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>INSERT 也可以用来导出数据，语法为<code>INSERT OVERWRITE [LOCAL] DIRECTORY path [ROW FORMAT ...]  select_clause</code>。它默认导出的文件的格式是原始格式（即字段之间用<code>SOH</code>分割的那种格式），无论表的格式如何，可以使用<code>ROW FORMAT DELIMITED ...</code>进行规定。</p><h3 id="EXPORT"><a href="#EXPORT" class="headerlink" title="EXPORT"></a>EXPORT</h3><p>EXPORT 需要和 IMPORT 配合使用，EXPORT 的语法为<code>EXPORT TABLE tb_name TO path</code>，EXPORT 只能导出到 HDFS 中。<strong>IMPORT&#x2F;EXPORT 主要使用在数据迁移中</strong>，因为它在导出时同时会携带所有元数据。</p><h3 id="怪东西"><a href="#怪东西" class="headerlink" title="怪东西"></a>怪东西</h3><p>另外的几种导出数据的操作是，直接使用 HDFS 的命令导出数据文件，或使用<code>hive -e</code>命令，执行单行 SELECT 脚本并把输出流指向特定文件（这种方法会把表头带上）。这些操作显然不会是最佳实践。</p><hr><p>在这里停了一两个星期，去深入学习了 MapReduce 的编程模式，又顺势去复习了 SQL，学习了之前没有了解过的 GROUP BY，JOIN 操作，还有窗口函数，聚集函数……现在回过头来看 Hive，能更清晰些了。下一步是学习各种 SELECT，然后对这里的各个子句进行更加丰富的，结合实际的示例。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce 的魔法——Shuffle</title>
    <link href="/2022/03-15MapReduce%20%E7%9A%84%E9%AD%94%E6%B3%95%E2%80%94%E2%80%94Shuffle.html"/>
    <url>/2022/03-15MapReduce%20%E7%9A%84%E9%AD%94%E6%B3%95%E2%80%94%E2%80%94Shuffle.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>实际上，Shuffle这个术语也存在于Spark这样其他的分布式计算引擎中，所以这里说的Shuffle的概念应该更加广泛一些，我觉得可以说：<strong>汇聚不同节点的数据到特定节点就是Shuffle操作</strong>，这种操作通常发生在按KEY的折叠操作，以及join等情况。</p></blockquote><p>来自 HDFS 或其他地方的输入数据被切割成多个切片，每个切片交由一个 Mapper 负责，每个 Mapper 都将原始的数据映射（map，但实质是 flatMap）成为键值对的形式，这些键值对会经历某种魔法的过程以分发给各个 Reducer，然后每个 Reducer 处理它收到的 KEY 以及与这些 KEY 相关（associated）的键值对，并得到最终结果，保存在 HDFS 或其他地方；Mapper 的输出数据分发给各个 Reducer，<strong>这整个魔法的过程就是所谓的 Shuffle</strong>，今天对它进行一些了解，串联一下之前所学习到的东西。</p><p>Shuffle 分为 Mapper 端和 Reducer 端，称为 Map Shuffle 和 Reduce Shuffle。Shuffle 阶段解决的问题就是，如何尽量高效地将各个 Mapper 的输出传递给各个 Reducer，同时最大化减少 IO 和网络损耗，以及方便 reduce 方法的执行。</p><h1 id="Map-Shuffle"><a href="#Map-Shuffle" class="headerlink" title="Map Shuffle"></a>Map Shuffle</h1><blockquote><p>我经常把一个 map task 说成一个 Mapper，这在当前的大部分时候没有引起过歧义。</p></blockquote><p>一个切片对应一个 Mapper，Mapper 会处理切片中的所有 KV 对形式的原始数据并映射成为输出的 KV 对，而 <strong>Map Shuffle 则是对输出的 KV 对进行处理，使其 partition，sort，combine，保存在本地硬盘中的过程</strong>。</p><blockquote><p>切片是 MR 的抽象，它和 HDFS 的 block 默认是一对一的关系，但若是使用某种压缩小文件的 InputFormat，可能会成为一对多的关系；如果减少切片的大小，则可能是多对一的关系。</p></blockquote><p>用户定义的 map 函数开始进行输出（<code>context.write</code>）时，输出数据并非被直接写入到硬盘中（我们知道，之后这些数据还得 partition，sort，combine，如果直接放到硬盘里，就得增加两倍时间的硬盘 IO 了）。出于效率，它会将结果缓存在一个缓冲区中以备处理。</p><blockquote><p>其实 partition 在 KV 对给到环形缓冲区之前就计算出来了，见<code>MapOutputBuffer#collect</code>的签名能够看到，分区号是作为参数传递进来的，而非是自己获取的。</p></blockquote><p>每个 mapper 都有一个默认 100M 的<strong>环形缓冲区</strong>，输出的 KV 会进入该缓冲区；一旦缓冲区被使用超过 80%（默认值），则启动一个后台的线程把数据<strong>溢写</strong>（spill）到<strong>本地的硬盘</strong>，溢写的过程中 mapper 继续写数据，若填满则阻塞直到溢写完成，mapper 继续向缓冲区中写数据，如此反复。溢写完成后，硬盘中的结果文件将被合并成一个文件用来传递给各个 reducer。</p><p><img src="/images/oss/20220315192220.png"></p><p>环形缓冲区和溢写是 map shuffle 的关键部分，了解了这两个部分，就了解了 map shuffle。</p><h2 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h2><p>关于环形缓冲区的逻辑主要在<code>org.apache.hadoop.mapred.MapTask.MapOutputBuffer#collect</code>，但它状态太多，研究起来是非常麻烦的（不如说把我看麻了，几百行底层代码，还有同步操作），就目前来说，把它当作一个黑箱来看就好，具体的学习等之后背八股文的时候再说吧。</p><h2 id="Spill（溢写）"><a href="#Spill（溢写）" class="headerlink" title="Spill（溢写）"></a>Spill（溢写）</h2><p>溢写的过程并非是把数据直接写到硬盘中了事，为了减少硬盘 IO，它要在这里完成上面所说的 partition，sort，combine 操作，总的来说其过程如下——</p><ol><li>每个 KV 对按分区号进行分区，分区号在 KV 对传递给环形缓冲区之前由 Partitioner 计算得出。</li><li>每个分区内的 KV 对按 KEY 进行排序（使用 SortComparator），传递给 Combiner（如果有的话）。</li><li>将溢写文件写到磁盘中，每次溢写都会产生一个溢写文件，每个溢写文件都包含每个分区的 KV 对，不同分区的数据能够被区分。（也就是说，达到 80% 这个阈值多少次，就会溢写多少次，出现多少个溢写文件）</li></ol><blockquote><p> 有趣的是，在源代码里，调用的方法其实叫 sortAndSpill，是先排序再溢写，所以这里只取 Spill 其实不太合适。</p></blockquote><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>所有溢写文件都创建完成，即 Mapper 的所有原始数据都进行过映射且执行过上面的操作并写到硬盘后，要将所有溢写文件合并到一个文件中，其中每个溢写文件的同一个分区要进行归并排序（仍旧使用 SortComparator）以及进行 combine 操作，直到所有操作完成，这时候该单独文件包含所有分区的所有数据，且每个分区内部有序。</p><hr><p>map 端的 shuffle 到此为止，它的最终目的是将 map 函数的输出键值对进行分区，排序并写到硬盘中成为一个单独的文件，其中，为了让 map 函数的执行和溢写操作能够（部分）并行以及更多优化，使用环形缓冲区来进行此操作。环形缓冲区之后还要继续研究。</p><h1 id="Reduce-Shuffle"><a href="#Reduce-Shuffle" class="headerlink" title="Reduce Shuffle"></a>Reduce Shuffle</h1><p><img src="/images/oss/20220315191103.png"></p><p>每个 Mapper shuffle 的结果都保存在其节点的本地硬盘中，Reducer 会从每个 Mapper 中<strong>拉取</strong>对应自己的 Partition（之前说的都是推，但实际上这里是拉），<strong>从每个 Mapper 中拉取 Partition 并进行归并就是 Reduce Shuffle 的任务</strong>。</p><p>当 Mapper 任务完成后，它会提醒 ApplicationMaster，然后 reducer 就能够从该 Mapper 处拷贝 Partition；拷贝 Mapper 的数据这个过程可以是并行的，即同时从多个 Mapper 处拷贝数据（默认并行数为 5），且该过程不需要待所有 Mapper 都完成后才进行。</p><p>reducer 像 mapper 一样，也会试图在内存中维护一个缓冲区，该缓冲区默认设置占内存的 70%，多余的数据将被溢写到硬盘中。从 mapper 处拿到的数据如果能够被放到缓冲区中则放置，否则放置到硬盘中；一旦缓冲区到达指定大小或接收到的 mapper 输出数量到达指定值，则会将其合并并溢写到硬盘中，其中可能会调用 Combiner（这里也会调用 Combiner！）以减少数量。</p><p>待所有 mapper 的输出均已保存在磁盘中（如果全部输出占的足够小，可能会一直在内存中进行维护，不持久化），则开始进行所谓的排序阶段，该阶段仍旧是合并操作，其将对所有 mapper 的输出进行归并，默认归并因子是 10，也就是说 10 路归并，最后一趟归并会直接传给 reduce 方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce 开发模式 2——排序，二次排序，JOIN</title>
    <link href="/2022/03-14MapReduce%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F2%E2%80%94%E2%80%94ORDER-BY%EF%BC%8CJOIN.html"/>
    <url>/2022/03-14MapReduce%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F2%E2%80%94%E2%80%94ORDER-BY%EF%BC%8CJOIN.html</url>
    
    <content type="html"><![CDATA[<h1 id="ORDER-BY（全局排序）"><a href="#ORDER-BY（全局排序）" class="headerlink" title="ORDER BY（全局排序）"></a>ORDER BY（全局排序）</h1><p>排序是一个常见的业务需求。我们不止可以用 MR 提供的原生类型进行排序，还能够用自定义的类型进行排序。在 SQL 中，我们使用 ORDER BY 子句进行排序，ORDER BY 子句可以接受一个或多个字段，也可以接受表达式。</p><p>MR 支持在两个地方进行排序——首先是 Reducer 接受的各 Mapper 发送的记录会按 KEY 进行归并排序；然后是对每个 KEY，允许在 KEY 对应的 VALUE 集合中进行排序，这个排序的进行是不太明显的。</p><p>考虑这样的需求——我们之前的航空公司数据集是按照月份和星期来排序的，现在突然需要将输出的数据按月份升序之后按星期降序去排序。<strong>我们要保证所有数据整体有序，且性能足够好</strong>。</p><p>之前学习过 MR 的排序机制，我们知道，如果想要让所有数据全排序并存放在同一个文件里，则只能使用一个 Reducer。否则我们必须定制化 Partitioner 和 KEY，以保证不同结果文件之间有序。</p><p>研究一下我们的业务，这里需要按月份去升序，按星期去降序，因此总共的索引数有 12 x 7 &#x3D; 84 个，它们顺序如下——</p><ol><li>1_7</li><li>1_6</li><li>…</li><li>2_7</li><li>…</li><li>12_2</li><li>12_1</li></ol><p>显然，<strong>Partitioner 需要保证所有相邻的索引必须分给同一个 Reducer</strong>。</p><p>首先，我们需要定义 KEY 类型（即 MonthDayWeek）以及 VALUE 类型（所需的结果），KEY 类型需要实现 WritableComparable 接口，VALUE 类型需要实现 Writable。</p><blockquote><p>不一定必须要 WritableComparable，也可以从外部指定另外的 Comparator，这个 Comparator 称为 SortComparator。</p></blockquote>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">类型的代码见此，非常繁琐，信息量很小</span></summary>        <blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> mapreduce<br><br><span class="hljs-keyword">import</span> mapreduce.<span class="hljs-type">DistributedSortJob</span>.args<br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.&#123;<span class="hljs-type">Configurable</span>, <span class="hljs-type">Configuration</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.<span class="hljs-type">Path</span><br><span class="hljs-keyword">import</span> org.apache.hadoop.io<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.&#123;<span class="hljs-type">IntWritable</span>, <span class="hljs-type">LongWritable</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Writable</span>, <span class="hljs-type">WritableComparable</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.&#123;<span class="hljs-type">FileInputFormat</span>, <span class="hljs-type">TextInputFormat</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.&#123;<span class="hljs-type">FileOutputFormat</span>, <span class="hljs-type">TextOutputFormat</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.&#123;<span class="hljs-type">Job</span>, <span class="hljs-type">Mapper</span>, <span class="hljs-type">Partitioner</span>, <span class="hljs-type">Reducer</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.util.<span class="hljs-type">GenericOptionsParser</span><br><br><span class="hljs-keyword">import</span> java.io.&#123;<span class="hljs-type">DataInput</span>, <span class="hljs-type">DataOutput</span>&#125;<br><span class="hljs-keyword">import</span> java.lang<br><br><span class="hljs-comment">// Scala 定义这玩意可太难受了，不能用类参数…否则 Scala 会创建出带参数的构造器，没法用反射创建了</span><br><span class="hljs-comment">// 键类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonthDayWeek</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparable</span>[<span class="hljs-type">MonthDayWeek</span>] </span>&#123;<br>  <span class="hljs-keyword">var</span> month : <span class="hljs-type">IntWritable</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> dayOfWeek : <span class="hljs-type">IntWritable</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(out: <span class="hljs-type">DataOutput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    month.write(out)<br>    dayOfWeek.write(out)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFields</span></span>(in: <span class="hljs-type">DataInput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    month.readFields(in)<br>    dayOfWeek.readFields(in)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compareTo</span></span>(o: <span class="hljs-type">MonthDayWeek</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.month.get == o.month.get) <span class="hljs-comment">// 如果月份相等，则逆序比较 dayOfWeek</span><br>      <span class="hljs-number">-1</span> * dayOfWeek.compareTo(o.dayOfWeek)<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">this</span>.month.compareTo(o.month)<br>  &#125;<br><br>  <span class="hljs-comment">// 自动生成</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canEqual</span></span>(other: <span class="hljs-type">Any</span>): <span class="hljs-type">Boolean</span> = other.isInstanceOf[<span class="hljs-type">MonthDayWeek</span>]<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">equals</span></span>(other: <span class="hljs-type">Any</span>): <span class="hljs-type">Boolean</span> = other <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> that: <span class="hljs-type">MonthDayWeek</span> =&gt;<br>      (that canEqual <span class="hljs-keyword">this</span>) &amp;&amp;<br>        month == that.month &amp;&amp;<br>        dayOfWeek == that.dayOfWeek<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hashCode</span></span>(): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">val</span> state = <span class="hljs-type">Seq</span>(month, dayOfWeek)<br>    state.map(_.hashCode()).foldLeft(<span class="hljs-number">0</span>)((a, b) =&gt; <span class="hljs-number">31</span> * a + b)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 值类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelaysWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Writable</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> year = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> month = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> dayOfWeek = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> arrDelay = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> depDelay = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> originAirportCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>()<br>  <span class="hljs-keyword">var</span> destAirportCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>()<br>  <span class="hljs-keyword">var</span> carrierCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>()<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(out: <span class="hljs-type">DataOutput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    year.write(out)<br>    month.write(out)<br>    date.write(out)<br>    dayOfWeek.write(out)<br>    arrDelay.write(out)<br>    depDelay.write(out)<br>    originAirportCode.write(out)<br>    destAirportCode.write(out)<br>    carrierCode.write(out)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFields</span></span>(in: <span class="hljs-type">DataInput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    year.readFields(in)<br>    month.readFields(in)<br>    date.readFields(in)<br>    dayOfWeek.readFields(in)<br>    arrDelay.readFields(in)<br>    depDelay.readFields(in)<br>    originAirportCode.readFields(in)<br>    destAirportCode.readFields(in)<br>    carrierCode.readFields(in)<br>  &#125;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= <br>    <span class="hljs-string">s&quot;<span class="hljs-subst">$year</span>, <span class="hljs-subst">$month</span>, <span class="hljs-subst">$date</span>, <span class="hljs-subst">$dayOfWeek</span>, <span class="hljs-subst">$arrDelay</span>, <span class="hljs-subst">$depDelay</span>, <span class="hljs-subst">$originAirportCode</span>, <span class="hljs-subst">$destAirportCode</span>, <span class="hljs-subst">$carrierCode</span>&quot;</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote>            </details>  <figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// Mapper 只是做一个映射</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonthDayWeekSortMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">MonthDayWeek</span>, <span class="hljs-type">DelaysWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">val</span> outputK = <span class="hljs-keyword">new</span> <span class="hljs-type">MonthDayWeek</span><br>  <span class="hljs-keyword">val</span> outputV = <span class="hljs-keyword">new</span> <span class="hljs-type">DelaysWritable</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">MonthDayWeek</span>, <span class="hljs-type">DelaysWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">if</span> (value.toString.startsWith(<span class="hljs-string">&quot;Year&quot;</span>)) <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">import</span> <span class="hljs-type">AirlineCol</span>._<br>    <span class="hljs-keyword">val</span> colGetter = <span class="hljs-type">AirlineCol</span>.build(value.toString.split(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    outputK.month = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">Month</span>).toInt)<br>    outputK.dayOfWeek = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">DayOfWeek</span>).toInt)<br><br>    outputV.year = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">Year</span>).toInt)<br>    outputV.month = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">Month</span>).toInt)<br>    outputV.dayOfWeek = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">DayOfWeek</span>).toInt)<br>    outputV.date = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">DayofMonth</span>).toInt)<br>    outputV.arrDelay = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">ArrDelay</span>).toInt)<br>    outputV.depDelay = <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(colGetter(<span class="hljs-type">DepDelay</span>).toInt)<br>    outputV.destAirportCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(colGetter(<span class="hljs-type">Dest</span>))<br>    outputV.originAirportCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(colGetter(<span class="hljs-type">Origin</span>))<br>    outputV.carrierCode = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(colGetter(<span class="hljs-type">UniqueCarrier</span>))<br><br>    context.write(outputK, outputV)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Reducer 更是啥也不干</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonthDayWeekSortReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">MonthDayWeek</span>, <span class="hljs-type">DelaysWritable</span>, <span class="hljs-type">DelaysWritable</span>, <span class="hljs-type">NullWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">MonthDayWeek</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">DelaysWritable</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">MonthDayWeek</span>, <span class="hljs-type">DelaysWritable</span>, <span class="hljs-type">DelaysWritable</span>, <span class="hljs-type">NullWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    values.forEach(context.write(_, <span class="hljs-type">NullWritable</span>.get))<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 继承 Configurable 接口后，就能够拿到配置信息了，通过 key.range 指定配置范围</span><br><span class="hljs-comment">// 用户给定一个 key.range，表示每个 Reducer 将要接受的 KEY 的数量，如果超出，则最后一个 reducer 照单全收；如果 Reducer 设置太多，后来的 Reducer 将会得不到数据。</span><br><span class="hljs-comment">// 比如，设置 key.range = 24，设置 Reducer 为 3 个，则第一个 Reducer 处理 0-23，第二个处理 24-48，第三个处理 49-83</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonthDayWeekSortJobPartitioner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Partitioner</span>[<span class="hljs-type">MonthDayWeek</span>, <span class="hljs-type">DelaysWritable</span>] <span class="hljs-keyword">with</span> <span class="hljs-title">Configurable</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> indexRange : <span class="hljs-type">Int</span> = <span class="hljs-number">84</span> / <span class="hljs-number">7</span>;<br>  <span class="hljs-keyword">var</span> config : <span class="hljs-type">Configuration</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Configuration</span>();<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setConf</span></span>(conf: <span class="hljs-type">Configuration</span>): <span class="hljs-type">Unit</span> = &#123;<br>    config = conf<br>  &#125;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getConf</span></span>: <span class="hljs-type">Configuration</span> = config<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPartition</span></span>(key: <span class="hljs-type">MonthDayWeek</span>, value: <span class="hljs-type">DelaysWritable</span>, numPartitions: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">val</span> index = ((key.month.get - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + (key.dayOfWeek.get - <span class="hljs-number">1</span>)) / config.getInt(<span class="hljs-string">&quot;key.range&quot;</span>, <span class="hljs-number">84</span>)<br><br>    <span class="hljs-keyword">if</span> (index &lt; numPartitions)<br>      index<br>    <span class="hljs-keyword">else</span><br>      numPartitions - <span class="hljs-number">1</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里有两个参数需要配置——<code>mapreduce.job.reduces</code>，标识 Reducer 的数量，<code>key.range</code>，标识每个 Reducer 处理 key 的数量，默认为 84，即所有归一个 Reducer 来处理。将 Reducer 数量设置成 12，key 范围设置成 7，则得到每个文件保存一个月数据的结果。</p><p>可以看到，按 12，7 来设置时，<code>part-r-00000</code>的头部和<code>part-r-00011</code>的尾部是符合需求的——</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">$ head part-r<span class="hljs-string">-00000</span><br>2007, 1, 28, 7, 24, <span class="hljs-string">-3</span>, PHL, PBI, US<br>2007, 1, 28, 7, 6, 11, DFW, BNA, AA<br>2007, 1, 7, 7, 2, <span class="hljs-string">-1</span>, ONT, PHX, US<br>2007, 1, 7, 7, <span class="hljs-string">-12</span>, 1, CLE, PHX, CO<br>2007, 1, 7, 7, 30, 0, ONT, LAS, US<br>2007, 1, 7, 7, <span class="hljs-string">-17</span>, <span class="hljs-string">-1</span>, OMA, PHX, US<br>2007, 1, 28, 7, <span class="hljs-string">-4</span>, <span class="hljs-string">-15</span>, MOT, MSP, NW<br>2007, 1, 7, 7, <span class="hljs-string">-23</span>, 6, OMA, PHX, US<br>2007, 1, 7, 7, <span class="hljs-string">-20</span>, 13, OMA, PHX, US<br>2007, 1, 7, 7, <span class="hljs-string">-8</span>, <span class="hljs-string">-9</span>, RDU, EWR, MQ<br><br>$ tail part-r<span class="hljs-string">-00011</span><br>2007, 12, 31, 1, <span class="hljs-string">-2</span>, 2, XNA, DFW, MQ<br>2007, 12, 24, 1, <span class="hljs-string">-12</span>, <span class="hljs-string">-1</span>, ATL, TYS, DL<br>2007, 12, 3, 1, 50, 39, DFW, XNA, MQ<br>2007, 12, 17, 1, <span class="hljs-string">-1</span>, 1, MDW, STL, WN<br>2007, 12, 24, 1, <span class="hljs-string">-18</span>, <span class="hljs-string">-3</span>, LGA, MCO, DL<br>2007, 12, 24, 1, 31, 54, MCO, LGA, DL<br>2007, 12, 10, 1, 6, 0, DFW, XNA, MQ<br>2007, 12, 10, 1, 66, 45, DFW, HSV, AA<br>2007, 12, 24, 1, <span class="hljs-string">-22</span>, <span class="hljs-string">-12</span>, RSW, BOS, DL<br>2007, 12, 24, 1, 1, <span class="hljs-string">-3</span>, BOS, RSW, DL<br></code></pre></div></td></tr></table></figure><p>至于如何进行进一步的优化呢？一个通常的操作是对输入数据进行采样，获取键的分布情况，并根据该情况特定地去规划分区并分发给相应 Reducer，保证每个 Reducer 的负载均衡。</p><p>可以料想，这种模式（ORDER BY）的实现是绝对能进行抽象的，</p><h1 id="二次排序"><a href="#二次排序" class="headerlink" title="二次排序"></a>二次排序</h1><blockquote><p>二次排序其实就是使用组合键进行排序，这引入了所谓的 GroupComparator 和 SortComparator。</p></blockquote><p>MR 默认的行为会按 KEY 进行排序，但是同一个 KEY 内的记录之间的顺序仍旧是无法保证的，这些记录来自各个 Mapper，因此即使原数据有序，被 Mapper 处理后的数据仍有序，但在这里将仍旧是无序的。</p><p>但 MR 同样也允许对 KEY 内的集合进行排序，这就是所谓的二次排序或辅助排序，<span style="color: #FF0000">二次排序是一个模式而非角色</span>，<strong>它并非是直接对 VALUE 集合进行排序，而是将想再次排序的字段放在 KEY 里，使第一次排序时直接排出需要的顺序</strong>，因此二次排序这个名字实际上只描述了现象，没有点明实质。<strong>二次排序的一个难以理解的地方在于，在 Reducer 阶段，对 KEY 进行归并（即合并各个 Partition）和对 KEY 进行分组所使用的 Comparator 可以不是同一个 Comparator</strong>。</p><p>从一个示例看起，现在假设有一张网站浏览记录表，有如下字段——</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">website     IP               country  click_time</span><br><span class="hljs-section">---------------------------------------------------------</span><br>hoogle.com  123.123.123.123  UK       2022-02-02 12:23:34<br>hoogle.com  123.123.84.94    CA       2022-02-01 12:23:34<br>.....<br></code></pre></div></td></tr></table></figure><p>现在我们想要获取每个网站的每个国家的<strong>最近 5 次的访问时间</strong>。显然，我们可以以网站，国家作为 KEY 进行分组，然后维护一个大小为 5 的大顶堆，遍历整个集合得到结果，在 cleanup 方法中将结果写出。</p><p>但是这显然有一定的限制——要是我们要求获取最近 500 亿次的访问时间呢？这时，我们就必须考虑一些别的方案，比如，我们可以<strong>先把整个表按网站，国家，时间进行排序，再按照网站，国家进行分组</strong>（意识到这顺序和 SQL 中的不对应）即可，在 reduce 中只需要维护一个计数器。</p><p>但是我们之前所学的东西并不支持这种操作——在我们眼里，KEY 用于排序和分组时，使用的比较器是一样的，就是我们在 KEY 类型中实现的<code>WritableComparable</code>接口。因此，这里需要有一点新东西，被引入的就是所谓的<code>SortComparator</code>和<code>GroupComparator</code>。</p><p>SortComparator 用于对 Partitioner 的分区结果进行排序和 Reducer 归并 Mapper 结果时，默认的 SortComparator 就是 KEY 实现的 WritableComparable 接口；GroupComparator 用于 Reducer 进行分组并调用 reduce 方法时。GroupComparator 其实只用来比较是否相等——如果返回 0，则相等，传给用户的 reduce 方法；如果不返回 0，则终止当前的 reduce 方法，另起一个。</p><p>在这里，有三个组件需要自定义——首先是 Partitioner，要保证所有网站被分在一个文件里（不然这排序就没必要了）；然后是 SortComparator 和 GroupComparator，代码见下——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebsiteKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparable</span>[<span class="hljs-type">WebsiteKey</span>] </span>&#123;<br>  <span class="hljs-keyword">var</span> website : <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-keyword">var</span> country : <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-keyword">var</span> click_time : <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(out: <span class="hljs-type">DataOutput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFields</span></span>(in: <span class="hljs-type">DataInput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-comment">// 作为 SortComparator</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compareTo</span></span>(o: <span class="hljs-type">WebsiteKey</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (website != o.website)<br>      website.compareTo(o.website)<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (country != o.country)<br>      country.compareTo(o.country)<br>    <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span> * click_time.compareTo(o.click_time)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebsitePartitioner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Partitioner</span>[<span class="hljs-type">WebsiteKey</span>, <span class="hljs-type">Any</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPartition</span></span>(key: <span class="hljs-type">WebsiteKey</span>, value: <span class="hljs-type">Any</span>, numPartitions: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = ???<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebsiteKeyGroupComparator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparator</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare</span></span>(a: <span class="hljs-type">WritableComparable</span>[_], b: <span class="hljs-type">WritableComparable</span>[_]): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> l : <span class="hljs-type">WebsiteKey</span> = a.asInstanceOf[<span class="hljs-type">WebsiteKey</span>]<br>      <span class="hljs-keyword">val</span> r : <span class="hljs-type">WebsiteKey</span> = b.asInstanceOf[<span class="hljs-type">WebsiteKey</span>]<br><br>      <span class="hljs-keyword">if</span> (l.website != r.website)<br>        l.website .compareTo(r.website)<br>      <span class="hljs-keyword">else</span><br>        l.country.compareTo(r.country)<br>    &#125; <span class="hljs-keyword">catch</span> &#123;<span class="hljs-keyword">case</span> _: <span class="hljs-type">Throwable</span> =&gt; <span class="hljs-number">-1</span> &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Mapper 和 Reducer 不表，Mapper 除了抽取出 KEY 什么都不做，Reducer 直接拿到集合的前五个元素。</p><p>这里的组合键中有三个字段，其中 GroupComparator 中所使用的称为<strong>自然键</strong>，其它的称为<strong>自然值</strong>, 自然键和自然值组成的组合键被 SortComparator 所使用，可以简单地认为 GroupComparator 就是 GROUP BY 中所使用的字段，ORDER BY 就是 SortComparator 所使用的字段。排序应当使用整个 KEY，分组应当使用排序使用的 KEY 的子集，否则可能会发生不可预料的结果。</p><p>但这在 SQL 上好像没有对应的语句——ORDER BY 在 SQL 里是最后才调用的，而 GROUP BY 在此之前执行，如果硬要放到 SQL 的语义中的话，可以认为是在 FROM 的表里进行了排序。可见，在 SQL 上的对应其实是不太明显的。SQL 这样设计的原因我猜测是因为聚集函数不关心列的顺序。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>二次排序使用的场景在于，<strong>需要在同一个分组里的记录有序，且各个记录组（即这里的“有序”区分出来的组）之间有相互依赖</strong>，如果没有后者，则组合键和自然键是一致的，就没必要再自己定义一个 GroupComparator。</p><p>下面对上面的说法进行测试，我们建立一个非常简单的实体，以及规定相应的 Mapper，Reducer，Reducer 仅用于在每一组之前进行一次打印——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TupleWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparable</span>[<span class="hljs-type">TupleWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">var</span> _1 : <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> _2 : <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> _3 : <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondarySortMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">IntTripleWritable</span>, <span class="hljs-type">NullWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">IntTripleWritable</span>, <span class="hljs-type">NullWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">Array</span>(_1,_2,_3) = value.toString.split(<span class="hljs-string">&quot; &quot;</span>).map(_.toInt)<br>    <span class="hljs-keyword">val</span> triple = <span class="hljs-keyword">new</span> <span class="hljs-type">IntTripleWritable</span><br>    triple._1 = _1<br>    triple._2 = _2<br>    triple._3 = _3<br>    context.write(triple, <span class="hljs-type">NullWritable</span>.get)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondarySortReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">IntTripleWritable</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">IntTripleWritable</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">NullWritable</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">IntTripleWritable</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;分组，key:&quot;</span> + key.toString), <span class="hljs-type">NullWritable</span>.get)<br>    values.forEach(_=&gt;context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(key.toString), <span class="hljs-type">NullWritable</span>.get))<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输入数据如下，为 000 到 111 进行洗牌的结果——</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><ol><li>排序和分组一致</li></ol><p>按 2 个字段排序，2 个字段分组时，得到——</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>这和预期比较一致。</p><ol start="2"><li>按_1 和_2 排序，按_1 分组</li></ol><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p><strong>这相当于是把_2 当作了要排序的自然值</strong>，可以看到每个组的_2 都是有序的。</p><ol start="3"><li>全排序，按_1 分组</li></ol><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p><strong>这相当于是把_2，_3 当作了要排序的自然值</strong>。</p><ol start="4"><li>按_1 排序，按_1,_2 分组</li></ol><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>分组，<span class="hljs-built_in">key</span>:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><span style="color: #FF0000">这是一个非法情况，相当于是在分组的时候拿到的数据不是有序的，分组的 KEY 必须为排序的 KEY 的子集！</span><p>同时，通过上面的几个测试，可以看到 GroupComparator 是不会改变 SortComparator 排序的结果的，它只负责分组，也就是说<strong>只看当前记录是否等于上一条记录</strong>，如果 SortComparator 给出了就它看来是错误（无序）的结果，则它也会返回错误的结果。</p><h2 id="一个实际的实例"><a href="#一个实际的实例" class="headerlink" title="一个实际的实例"></a>一个实际的实例</h2><p>再考虑一个实际的实例，还是使用那张航班表，现在考虑获取每个月每个航班的最长的 10 次航行的时间。</p><p>根据需求，我们需要将数据按（月，航班）分组，按（月，航班，总飞行时间（降序））排序，并在每次 reduce 里取得前十条。注意这里使用的组合键，其 hashCode 仅使用 month 和 tailNum，这是为了能在分区的时候分到同一个 Reducer，这样才好分组。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombineKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparable</span>[<span class="hljs-type">CombineKey</span>] </span>&#123;<br>  <span class="hljs-keyword">var</span> month : <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> tailNum : <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-keyword">var</span> allDelay : <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(out: <span class="hljs-type">DataOutput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    out.writeInt(month)<br>    out.writeUTF(tailNum)<br>    out.writeInt(allDelay)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFields</span></span>(in: <span class="hljs-type">DataInput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    month = in.readInt()<br>    tailNum = in.readUTF()<br>    allDelay = in.readInt()<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compareTo</span></span>(o: <span class="hljs-type">CombineKey</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (month != o.month)<br>      month.compareTo(o.month)<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tailNum != o.tailNum)<br>      tailNum.compareTo(o.tailNum)<br>    <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span> * allDelay.compareTo(o.allDelay)<br>  &#125;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= <span class="hljs-string">s&quot;month=<span class="hljs-subst">$month</span>, tailNum=<span class="hljs-subst">$tailNum</span>, allDelay =<span class="hljs-subst">$allDelay</span>&quot;</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canEqual</span></span>(other: <span class="hljs-type">Any</span>): <span class="hljs-type">Boolean</span> = other.isInstanceOf[<span class="hljs-type">CombineKey</span>]<br>  <br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">equals</span></span>(other: <span class="hljs-type">Any</span>): <span class="hljs-type">Boolean</span> = other <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> that: <span class="hljs-type">CombineKey</span> =&gt;<br>      (that canEqual <span class="hljs-keyword">this</span>) &amp;&amp;<br>        month == that.month &amp;&amp;<br>        tailNum == that.tailNum<br>    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hashCode</span></span>(): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">val</span> state = <span class="hljs-type">Seq</span>(month, tailNum)<br>    state.map(_.hashCode()).foldLeft(<span class="hljs-number">0</span>)((a, b) =&gt; <span class="hljs-number">31</span> * a + b)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongestAirtimePerMonthMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">CombineKey</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">CombineKey</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = <span class="hljs-type">Try</span> &#123;<br>    <span class="hljs-keyword">if</span> (value.toString.startsWith(<span class="hljs-string">&quot;Year&quot;</span>)) <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">val</span> colGetter = <span class="hljs-type">AirlineCol</span>.build(value.toString.split(<span class="hljs-string">&quot;,&quot;</span>))<br>    <span class="hljs-keyword">val</span> combineKey = <span class="hljs-keyword">new</span> <span class="hljs-type">CombineKey</span><br><br>    combineKey.month = colGetter(<span class="hljs-type">AirlineCol</span>.<span class="hljs-type">Month</span>).toInt<br>    combineKey.tailNum = colGetter(<span class="hljs-type">AirlineCol</span>.<span class="hljs-type">TailNum</span>)<br>    combineKey.allDelay =<br>      colGetter(<span class="hljs-type">AirlineCol</span>.<span class="hljs-type">ArrDelay</span>).toIntOption.getOrElse(<span class="hljs-number">0</span>)<br>    + colGetter(<span class="hljs-type">AirlineCol</span>.<span class="hljs-type">DepDelay</span>).toIntOption.getOrElse(<span class="hljs-number">0</span>)<br>    context.write(combineKey, value)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongestAirtimePerMonthReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">CombineKey</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">CombineKey</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">Text</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">CombineKey</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>) = &#123;<br>    <span class="hljs-keyword">import</span> scala.jdk.<span class="hljs-type">CollectionConverters</span>._<br>    context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;新分组&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;&quot;</span>))<br>    <span class="hljs-comment">// 在这里使用 take 函数会得到奇怪的结果，不知道底层是啥机制，只能使用最原始的迭代器了。</span><br>    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">val</span> iter = values.iterator()<br>    <span class="hljs-keyword">while</span> (counter &lt; <span class="hljs-number">10</span> &amp;&amp; iter.hasNext) &#123;<br>      counter += <span class="hljs-number">1</span><br>      context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(key.toString), iter.next())<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongestAirtimePerMonthGroupComparator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparator</span>(<span class="hljs-params">classOf[<span class="hljs-type">CombineKey</span>], true</span>) </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare</span></span>(a: <span class="hljs-type">WritableComparable</span>[_], b: <span class="hljs-type">WritableComparable</span>[_]): <span class="hljs-type">Int</span> = <span class="hljs-type">Try</span> &#123;<br>    <span class="hljs-keyword">val</span> l = a.asInstanceOf[<span class="hljs-type">CombineKey</span>]<br>    <span class="hljs-keyword">val</span> r = b.asInstanceOf[<span class="hljs-type">CombineKey</span>]<br><br>    <span class="hljs-keyword">if</span> (l.month != r.month)<br>      l.month.compareTo(r.month)<br>    <span class="hljs-keyword">else</span> l.tailNum.compareTo(r.tailNum)<br>  &#125;.getOrElse(<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二次排序看上去是相当的复杂，但其实原理就是那么简单——<strong>把要进一步排序的字段放到 KEY 里，同时确认哪些字段用于排序（一般是全部），哪些字段用于分组，BINGO</strong>。</p><p><strong>二次排序能够解决许多原本需要在 Reducer 实例中使用实例变量来维护一些状态才能解决的问题</strong>，比如前面说的求最近几次的访问时间，这就需要维护一个大顶堆。Hadoop 本就挺复杂了，再引入带副作用的 map 方法 reduce 方法……对脑袋是一个负担。</p><p>同时，<span style="color: #FF0000">二次排序必须结合对 Partitioner 的重写</span>。在很多情况下我们需要让一系列数据在一个 reducer 中进行处理，比如 Hadoop 权威指南的那个例子，我们要求每年的最高气温，这时候我们按年，气温进行排序，按年进行分组，这时如果按照默认的 HashPartitioner（它按 KEY 的 hashCode 进行分区），则同年的数据可能分到不同的 Reducer 中，我们就会得到错误结果。</p><blockquote><p>感觉分区使用的字段好像很多时候和分组使用的字段相同。</p></blockquote><h1 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h1><p>连接操作应该是 MR 下的最后一个开发模式了，再之后就是去学习原理，输入输出等，然后是 Hive，学习 Hive 时要再次回来联想 MR 的模式。</p><p>连接操作就是 SQL 中的 JOIN，将两个数据集的记录做叉积并筛选出其中匹配的部分。</p><p>在 MR 中，连接操作的实现需要使用一些特定模式来实现，事实上，Hadoop 权威指南也承认 MR 编写连接操作比较棘手，建议使用 Pig，Hive，Spark 等抽象程度更高的框架。且根据两个数据集的大小以及分区方式的不同，具体的处理方式也会不同。比如，如果一个数据集非常大，而一个数据集非常小，则可以把较小的数据集直接维护在每一个节点的内存里并进行使用（使用名为“Side Data”的方式）。这和 SQL 简简单单一个 JOIN 一个 ON 就解决问题形成了鲜明对比，但这是数据集的巨大导致的不得已而为之。</p><p>连接操作如果在 Mapper 处进行，则称为 map 端连接，如果在 Reducer 处执行，则称为 reduce 端连接。数据的组织方式决定了究竟使用map端连接或reduce端连接，这两种连接方式都能够处理两个数据集规模均大的情况。</p><p>Hadoop权威指南没有展开讲map连接，所以我也跳过map连接了。</p><h2 id="reduce连接"><a href="#reduce连接" class="headerlink" title="reduce连接"></a>reduce连接</h2><p>reduce连接虽然性能较差，但适用范围更广，因此更常用，先去学习它。</p><p>reduce连接的思路使用一句话来描述，就是<strong>将要连接的键放入Mapper输出的KEY之中，而要连接的两个数据集都作为Mpper输出的VALUE</strong>，这样，在同一个迭代集合里我们就能够获取到两个数据集的值。显然，我们需要妥善处理它们的顺序（为此需要使用辅助排序），如果是一对多的关系，我们可以让第一个元素作为那个“一”，从而能够在后续的折叠过程中维护该记录；如果是多对多的关系……那就得具体问题具体分析了。</p><p>进行这种操作时，reduce的逻辑可能是这样，当作伪代码看吧——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 不想标注类型</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span> </span>= (key, values, context) =&gt; &#123;<br>  <span class="hljs-keyword">val</span> iter = values.iterator()<br>  <span class="hljs-type">Try</span>(iter.next)<br>    .map(parse)<br>    .filter(_.<span class="hljs-keyword">type</span> == &#x27;<span class="hljs-type">Station</span>&#x27;) <span class="hljs-comment">// 如果第一个值不是Station，则说明没有匹配的气象站，这时候的处理方式估计就对应内连接外连接了</span><br>    .foreach &#123; elem =&gt;<br>      <span class="hljs-keyword">while</span>(iter.hasNext) &#123;<br>        <span class="hljs-comment">// 这时候elem就是第一个元素了，现在对iter进行迭代，执行业务操作</span><br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="从示例开始"><a href="#从示例开始" class="headerlink" title="从示例开始"></a>从示例开始</h2><p>比如，我们现在有两个表，一个是气象站表，一个是气象记录表，它们的示例如下，我们想将它们通过气象站ID进行连接——</p><p>Stations表：  </p><table><thead><tr><th align="center">StationID</th><th align="center">StationName</th></tr></thead><tbody><tr><td align="center">1199</td><td align="center">SIHCCAJAVRI</td></tr><tr><td align="center">1265</td><td align="center">TYNSET-HANSMOEN</td></tr></tbody></table><p>Records表：  </p><table><thead><tr><th align="center">StationID</th><th align="center">Timestamp</th><th align="center">Temperature</th></tr></thead><tbody><tr><td align="center">1265</td><td align="center">194903241200</td><td align="center">111</td></tr><tr><td align="center">1265</td><td align="center">194903241800</td><td align="center">78</td></tr><tr><td align="center">1199</td><td align="center">195005150700</td><td align="center">0</td></tr><tr><td align="center">1199</td><td align="center">195005151200</td><td align="center">22</td></tr><tr><td align="center">1199</td><td align="center">195005151800</td><td align="center">-11</td></tr></tbody></table><p>连接后的表：  </p><table><thead><tr><th align="center">StationID</th><th align="center">StationName</th><th align="center">Timestamp</th><th align="center">Temperature</th></tr></thead><tbody><tr><td align="center">1199</td><td align="center">SIHCCAJAVRI</td><td align="center">195005150700</td><td align="center">0</td></tr><tr><td align="center">1199</td><td align="center">SIHCCAJAVRI</td><td align="center">195005151200</td><td align="center">22</td></tr><tr><td align="center">1199</td><td align="center">SIHCCAJAVRI</td><td align="center">195005151800</td><td align="center">-11</td></tr><tr><td align="center">1265</td><td align="center">TYNSET-HANSMOEN</td><td align="center">194903241200</td><td align="center">111</td></tr><tr><td align="center">1265</td><td align="center">TYNSET-HANSMOEN</td><td align="center">194903241800</td><td align="center">78</td></tr></tbody></table><p>这时候，我们就以StationID以ID，将两个表的文件直接全都读到Mapper中。</p><p>那么如何在Mapper中处理多种形式的文件呢？我们可以在同一个Mapper中处理这两种数据，但也可以使用所谓的<code>MultipleInputs</code>类，使用多种Mapper，从多个数据源中读取数据，但各个Mapper的输出类型需要一致，这和我们的需求是吻合的。</p><p>但是在这么个简单的例子中，我们干脆只使用一个Mapper，在逻辑中区分两个表以避免引入额外的复杂度。</p><p>首先先假设输入文件，我们有两个输入文件分别作为气象站数据和天气数据，都使用CSV格式——</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">--</span> <span class="hljs-string">Station.csv</span><br><span class="hljs-number">1199</span><span class="hljs-string">,SIHCCAJAVRI</span><br><span class="hljs-number">1265</span><span class="hljs-string">,TYNSET-HANSMOEN</span><br><br><span class="hljs-string">--</span> <span class="hljs-string">Records.csv</span><br><span class="hljs-number">1265</span><span class="hljs-string">,194903241200,111</span><br><span class="hljs-number">1265</span><span class="hljs-string">,194903241800,78</span><br><span class="hljs-number">1199</span><span class="hljs-string">,195005150700,0</span><br><span class="hljs-number">1199</span><span class="hljs-string">,195005151200,22</span><br><span class="hljs-number">1199</span><span class="hljs-string">,195005151800,-11</span><br></code></pre></div></td></tr></table></figure><p>只需要检测其中<code>,</code>的数量即可判定数据究竟是气象站还是记录。</p><p>然后是Mapper的输出数据，我们输出的VALUE直接使用原数据，而KEY需要额外的设计——必须保证气象站的数据放在最前面，这时候我们就想到了我们的老朋友——二次排序，我们需要创建一个虚拟的键用来排序，而为了让气象站成为“一”，我们需要给它一个零，因为默认排序是按升序排序的，给它一个0保证它作为第一位，当然这需要其它的记录都是1。</p><p>为此，我们定义一个Pair，其中第一个字段是StationID，第二个字段是虚拟键。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// Scala可以自定义自己的构造器……我之前好像没学过这个</span><br><span class="hljs-comment">// 但是为了能够使用这鬼畜的序列化、反序列化框架，必须使用var定义，我麻了好嘛</span><br><span class="hljs-comment">// 想要不使用var的话就必须使用状态模式了，更麻</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyPair</span>(<span class="hljs-params">var stationID : <span class="hljs-type">String</span>, var virtualKey : <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparable</span>[<span class="hljs-type">KeyPair</span>] </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>() = <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">-1</span>) <span class="hljs-comment">// 供反射使用</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compareTo</span></span>(o: <span class="hljs-type">KeyPair</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (stationID != o.stationID)<br>      stationID.compareTo(o.stationID)<br>    <span class="hljs-keyword">else</span> virtualKey.compareTo(o.virtualKey)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(out: <span class="hljs-type">DataOutput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    out.writeUTF(stationID)<br>    out.writeInt(virtualKey)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFields</span></span>(in: <span class="hljs-type">DataInput</span>): <span class="hljs-type">Unit</span> = &#123;<br>    stationID = in.readUTF()<br>    virtualKey = in.readInt()<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>整个Pair都将被用来排序，其中先按气象站ID进行排序，再按虚拟键进行排序，均为升序。</p><p>然后是GroupComparator，这里只按照气象站ID进行分组。如果定义Partitioner，也应只使用StationID的哈希值，这里没有定义Partitioner。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 考虑到是使用整个KEY进行排序，这里不用自定义SortComparator，让它调用KEY里定义的compareTo方法即可</span><br><span class="hljs-comment">// 顺便，记得调用指定的构造器，使用WritableComparator的空参构造器一定会抛出空指针异常</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinClauseGroupComparator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WritableComparator</span>(<span class="hljs-params">classOf[<span class="hljs-type">KeyPair</span>], true</span>) </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare</span></span>(a: <span class="hljs-type">WritableComparable</span>[_], b: <span class="hljs-type">WritableComparable</span>[_]): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-comment">// 犯了非常愚蠢的错误……变量名写错了，debug了半个小时</span><br>    <span class="hljs-keyword">val</span> l = a.asInstanceOf[<span class="hljs-type">KeyPair</span>]<br>    <span class="hljs-keyword">val</span> r = b.asInstanceOf[<span class="hljs-type">KeyPair</span>]<br>    l.stationID.compareTo(r.stationID)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Mapper的定义同样简单，根据当前处理的数据的类型构造KEY即可。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinClauseMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">KeyPair</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">KeyPair</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> cols = value.toString.split(<span class="hljs-string">&quot;,&quot;</span>)<br>    <span class="hljs-comment">// 如果有两列，说明是Station表，虚拟键为0，否则是记录表，虚拟键为1</span><br>    context.write(<span class="hljs-type">KeyPair</span>(cols(<span class="hljs-number">0</span>), <span class="hljs-keyword">if</span> (cols.length == <span class="hljs-number">2</span>) <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>), value)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最麻烦的是Reducer，Reducer首先要检查第一个元素是否是气象站，如果不是说明这个气象站ID对应的气象站不存在，直接退出执行；如果的确是气象站的话，对之后的每个元素同第一个元素都进行连接操作并写出。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinClauseReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">KeyPair</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">KeyPair</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">Text</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">KeyPair</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> iter = values.iterator()<br><br>    <span class="hljs-comment">// 使用Try的上下文——如果第一列不是站点（模式匹配会失败），则直接抛异常跑路</span><br>    <span class="hljs-keyword">for</span> &#123;<br>      firstElem &lt;- <span class="hljs-type">Try</span>(iter.next())<br>      <span class="hljs-type">Array</span>(stationId, stationName) = firstElem.toString.split(<span class="hljs-string">&quot;,&quot;</span>)<br>    &#125; <span class="hljs-keyword">yield</span> iter.forEachRemaining &#123; elem =&gt;<br>        <span class="hljs-keyword">val</span> <span class="hljs-type">Array</span>(_, timeStamp, temperature) = elem.toString.split(<span class="hljs-string">&quot;,&quot;</span>)<br>        context.write(<br>          <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(<br>            <span class="hljs-type">Array</span>(stationId,<br>            stationName,<br>            timeStamp,<br>            temperature).mkString(<span class="hljs-string">&quot;,&quot;</span>)),<br>          <span class="hljs-type">NullWritable</span>.get)<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，Scala处理这种业务问题相当优美，但需要明确for的使用方式以及如何还原成原生Scala代码。需要记住，for代码体是不在Try的上下文之中的，这里如果抛出异常不会被捕获，除非用yield。</p><p>使用上面的csv文件作为输入进行执行，得到下面的结果，BINGO～</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1199</span>,SIHCCAJAVRI,<span class="hljs-number">195005151800</span>,-<span class="hljs-number">11</span><br><span class="hljs-attribute">1199</span>,SIHCCAJAVRI,<span class="hljs-number">195005151200</span>,<span class="hljs-number">22</span><br><span class="hljs-attribute">1199</span>,SIHCCAJAVRI,<span class="hljs-number">195005150700</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">1265</span>,TYNSET-HANSMOEN,<span class="hljs-number">194903241800</span>,<span class="hljs-number">78</span><br><span class="hljs-attribute">1265</span>,TYNSET-HANSMOEN,<span class="hljs-number">194903241200</span>,<span class="hljs-number">111</span><br></code></pre></div></td></tr></table></figure><p>如果想要使用多个Reducer使能够并行执行，则必须自定义Partitioner。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>使用MR进行分组表面上看起来还是比较简单的——把要合并的两个数据集放在同一个values集合里并特别地去规划它们的顺序即可，ON操作则是交给了二次排序；可是这种假想一遇到真实的业务需求就要抓瞎了——如果连接三个表，四个表，五个表怎么办？如果不使用等于运算符进行连接怎么办？如果连接的键不是主键，从而让这里不是一对多，而是多对多的情况该怎么办？这只能具体情况具体分析了，如果要真正地让这玩意成为生产力，更抽象的技术是必须的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣 SQL 刷题笔记</title>
    <link href="/2022/03-13%E5%8A%9B%E6%89%A3SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html"/>
    <url>/2022/03-13%E5%8A%9B%E6%89%A3SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<p>最近意识到 SQL 的重要性（Hive 要写 SQL，Spark 还要写 SQL，MapReduce 又可以用 SQL 来描述），并且大数据的各种平台作为分析型系统，复杂的查询是屡见不鲜的，因此打算对 SQL 进行专门学习，这里把 LeetCode 上所有免费 SQL 题目都刷一下，之后也要做做别的题目。尽量给出多于一个解决方案。</p><span id="more"></span><h1 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h1><h2 id="175-Combine-Two-Tables"><a href="#175-Combine-Two-Tables" class="headerlink" title="175. Combine Two Tables"></a><a href="https://leetcode.com/problems/combine-two-tables/">175. Combine Two Tables</a></h2><p>有一张 Person 表和一张 Address 表，Person 表标识人的姓名，Address 表标识人的住址，它们的定义如下——</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">Person</span><br><span class="hljs-section">+-------------+---------+</span><br><span class="hljs-section">| Column Name | Type    |</span><br><span class="hljs-section">+-------------+---------+</span><br>| personId    | int     |<br>| lastName    | varchar |<br><span class="hljs-section">| firstName   | varchar |</span><br><span class="hljs-section">+-------------+---------+</span><br><br><span class="hljs-section">Address</span><br><span class="hljs-section">+-------------+---------+</span><br><span class="hljs-section">| Column Name | Type    |</span><br><span class="hljs-section">+-------------+---------+</span><br>| addressId   | int     |<br>| personId    | int     |<br>| city        | varchar |<br><span class="hljs-section">| state       | varchar |</span><br><span class="hljs-section">+-------------+---------+</span><br></code></pre></div></td></tr></table></figure><p>现在，要获取某人的姓名对应的住址，<strong>注意有人可能没有住址</strong>，输入输出为——</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">Input: <br><span class="hljs-section">Person table:</span><br><span class="hljs-section">+----------+----------+-----------+</span><br><span class="hljs-section">| personId | lastName | firstName |</span><br><span class="hljs-section">+----------+----------+-----------+</span><br>| 1        | Wang     | Allen     |<br><span class="hljs-section">| 2        | Alice    | Bob       |</span><br><span class="hljs-section">+----------+----------+-----------+</span><br><span class="hljs-section">Address table:</span><br><span class="hljs-section">+-----------+----------+---------------+------------+</span><br><span class="hljs-section">| addressId | personId | city          | state      |</span><br><span class="hljs-section">+-----------+----------+---------------+------------+</span><br>| 1         | 2        | New York City | New York   |<br><span class="hljs-section">| 2         | 3        | Leetcode      | California |</span><br><span class="hljs-section">+-----------+----------+---------------+------------+</span><br><span class="hljs-section">Output: </span><br><span class="hljs-section">+-----------+----------+---------------+----------+</span><br><span class="hljs-section">| firstName | lastName | city          | state    |</span><br><span class="hljs-section">+-----------+----------+---------------+----------+</span><br>| Allen     | Wang     | Null          | Null     |<br><span class="hljs-section">| Bob       | Alice    | New York City | New York |</span><br><span class="hljs-section">+-----------+----------+---------------+----------+</span><br></code></pre></div></td></tr></table></figure><p>这道题目明显地过了头，可以看到，Wang Allen 这个人是没有住址的，因此对应字段为空，这是一个非常显然的外连接——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    firstName,<br>    lastName,<br>    city,<br>    state<br><span class="hljs-keyword">FROM</span> Person <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> Address <span class="hljs-keyword">ON</span> Person.personId <span class="hljs-operator">=</span> Address.personId;<br></code></pre></div></td></tr></table></figure><p>开门红！</p><h2 id="181-Employees-Earning-More-Than-Their-Managers"><a href="#181-Employees-Earning-More-Than-Their-Managers" class="headerlink" title="181. Employees Earning More Than Their Managers"></a><a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/">181. Employees Earning More Than Their Managers</a></h2><p>现在有一张雇员表，其中 id 字段代表当前雇员的 id，managerId 代表它的上级的 id（也是雇员），现在要求查询工资比他的上级高的雇员的名称。</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+-------------+</span>---------+<br><span class="hljs-section">| Column Name | Type    |</span><br><span class="hljs-section">+-------------+---------+</span><br>| id          | int     |<br>| name        | varchar |<br>| salary      | int     |<br><span class="hljs-section">| managerId   | int     |</span><br><span class="hljs-section">+-------------+---------+</span><br></code></pre></div></td></tr></table></figure><p>一个最直接的想法是，<strong>对每个雇员，根据他的 managerId 找到他的上级的工资</strong>，然后用他的工资和上级的工资做比较，SQL 如下，这里使用了关联子查询——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.name <span class="hljs-keyword">as</span> Employee <br><span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">AS</span> e <br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">AS</span> m <span class="hljs-keyword">WHERE</span> m.id <span class="hljs-operator">=</span> e.managerId);<br></code></pre></div></td></tr></table></figure><p>但再看看这张表的结构，可以发现可以直接让自己和自己内连接，从而把自己的工资和上级的工资放到一张表中，从而能够进行比较。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.name <span class="hljs-keyword">as</span> Employee<br><span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">as</span> e <span class="hljs-keyword">JOIN</span> Employee <span class="hljs-keyword">as</span> m <span class="hljs-keyword">ON</span> e.managerId <span class="hljs-operator">=</span> m.id<br><span class="hljs-keyword">WHERE</span> e.salary <span class="hljs-operator">&gt;</span> m.salary;<br></code></pre></div></td></tr></table></figure><p>输入输出为——</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">Input: <br><span class="hljs-section">Employee table:</span><br><span class="hljs-section">+----+-------+--------+-----------+</span><br><span class="hljs-section">| id | name  | salary | managerId |</span><br><span class="hljs-section">+----+-------+--------+-----------+</span><br>| 1  | Joe   | 70000  | 3         |<br>| 2  | Henry | 80000  | 4         |<br>| 3  | Sam   | 60000  | Null      |<br><span class="hljs-section">| 4  | Max   | 90000  | Null      |</span><br><span class="hljs-section">+----+-------+--------+-----------+</span><br><span class="hljs-section">Output: </span><br><span class="hljs-section">+----------+</span><br><span class="hljs-section">| Employee |</span><br><span class="hljs-section">+----------+</span><br><span class="hljs-section">| Joe      |</span><br><span class="hljs-section">+----------+</span><br></code></pre></div></td></tr></table></figure><p>顺带一提，这里使用左外连接的话，WHERE 执行前的结果的左边四个字段会多包含所有没有上级的雇员，即 Sam，Max，右边四个字段为 NULL；使用左外连接的话，WHERE 执行前的结果的右边四个字段会包含所有没有下级的雇员，即 Joe，Henry，左边四个为 NULL。</p><p>在进行这种思考时，把左右外连接看作<code>内连接的结果 + 左/右边无法匹配的记录</code>即可。</p><p><strong>为表取一个合适的名字非常重要，比如左边的表叫雇员表，右边的表叫上级表，使用业务相关的术语来描述表效果非常好</strong>。</p><h2 id="182-Duplicate-Emails"><a href="#182-Duplicate-Emails" class="headerlink" title="182. Duplicate Emails"></a><a href="https://leetcode.com/problems/duplicate-emails/">182. Duplicate Emails</a></h2><p>考虑一个邮箱表，每个邮箱有自己的 id，id 为主键，邮箱名称可能重复，现在考虑获取有重复的邮箱的名称。</p><p>这显然是一个需要使用聚集操作的场合，考虑可以直接使用邮箱名进行分组，然后使用 HAVING，COUNT 统计出出现次数大于 1 的邮箱名称，代码非常简单。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> email <span class="hljs-keyword">as</span> Email <span class="hljs-keyword">FROM</span> Person <span class="hljs-comment">-- 这个表叫 Person？？</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> email<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>记住，HAVING 对分组后的数据进行筛选，因此可以使用聚集操作。</p><p>还有更 dummy 的解决方案——获取每个邮箱名称的出现次数，找到大于 1 的。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> email <span class="hljs-keyword">FROM</span> <br>(<span class="hljs-keyword">SELECT</span> email, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <span class="hljs-keyword">FROM</span> Person <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> email) <span class="hljs-keyword">as</span> c<br><span class="hljs-keyword">WHERE</span> num <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>还有更弯弯绕的方案——考虑使用 email 字段进行自连接（？），对于重复的邮箱记录<code>(1, a@b.com), (3, a@b.com)</code>，自连接就会得到<code>(1, a@b.com, 1, a@b.com), (1, a@b.com, 3, a@b.com), (3, a@b.com, 1, a@b.com), (3, a@b.com, 3, a@b.com)</code>；对于不重复的邮箱记录<code>(2, b@c.com)</code>，自连接只会得到<code>(2, b@c.com, 2, b@c.com)</code>。</p><p>因此，我们能够发现规律——如果某个邮箱是重复的，那么它自连接必然会得到这样的记录，即第一个 id 和第二个 id 不相等，而不重复的邮箱必然相等（重复的邮箱会同时生成相等和不等的记录）。</p><p>如此，我们便能够得到相应的 SQL，注意需要筛选重复的——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> p1.email <span class="hljs-keyword">AS</span> Email <span class="hljs-keyword">FROM</span> <br>Person p1 <span class="hljs-keyword">JOIN</span> Person p2 <span class="hljs-keyword">ON</span> p1.email <span class="hljs-operator">=</span> p2.email<br><span class="hljs-keyword">WHERE</span> p1.id <span class="hljs-operator">!=</span> p2.id;<br></code></pre></div></td></tr></table></figure><p>可以，无论是可读性还是性能，都糟糕透顶。</p><h2 id="183-Customers-Who-Never-Order"><a href="#183-Customers-Who-Never-Order" class="headerlink" title="183. Customers Who Never Order"></a><a href="https://leetcode.com/problems/customers-who-never-order/">183. Customers Who Never Order</a></h2><p>现在有一张消费者表，只包括 ID 和名称；有一张订单表，包含 ID 和消费者 ID，现在考虑要找到没有任何对应订单的消费者。</p><p>最直接的想法是，根据订单表获取所有有过消费的消费者 ID，然后对每个消费者，检查他是否在这个 ID 集合中即可——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">AS</span> Customers <span class="hljs-keyword">FROM</span> Customers <br><span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> customerId <span class="hljs-keyword">FROM</span> Orders);<br></code></pre></div></td></tr></table></figure><p>但也可以考虑使用外连接——首先将消费者表作为主表，使用 id 作为同订单外连接，这样就得到了每个消费者消费的全部消费记录，而没有消费记录的消费者则只有一条，且订单部分为 NULL，这时候我们就可以按主键分组并在订单表的任意字段调用 COUNT 即可。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c.name <span class="hljs-keyword">AS</span> Customers <br><span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> Orders <span class="hljs-keyword">AS</span> o <span class="hljs-keyword">ON</span> c.id <span class="hljs-operator">=</span> o.customerId <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c.id<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(customerId) <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><p>这里有个有趣的地方——不是说在使用 GROUP BY 时，SELECT 部分只允许出现三个角色：分组的字段，聚集函数处理的列，以及常数吗？为什么在这里出现了列还能正常地跑呢？</p><p>因为，表是通过 JOIN 构建的，而左边的列，即 c.id，c.name 总是一一对应的（c.id 是主键，因此对任意一个 c.id，只能找到同一个 c.name），这性质在 JOIN 后仍旧会保留，因此 c.name 是原子的。</p><p>这里也可以认为，在这里当我们使用<code>GROUP BY c.id</code>时，它和<code>GROUP BY c.id, c.name</code>等价。</p><p>至于网上说 GROUP BY 对主键使用无意义，这论述是正确的，但是这里处理的表并非是 Customers，而是 Customers 和 Orders 进行连接后得到的临时表，这时候 c.id 的主键性质已经失效了——能找到不同的记录，它们拥有同样的主键。</p><p>当然，上面其实不必进行分组和聚集操作——使用外连接时，如果某个消费者的订单处为 NULL，则他必然没有任何消费，因为如此便不会为 NULL，我们可以直接使用 IS NULL 判断——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c.name <span class="hljs-keyword">AS</span> Customers<br><span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> Orders <span class="hljs-keyword">AS</span> o <span class="hljs-keyword">ON</span> c.id <span class="hljs-operator">=</span> o.customerId <br><span class="hljs-keyword">WHERE</span> customerId <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br></code></pre></div></td></tr></table></figure><h2 id="196-Delete-Duplicate-Emails"><a href="#196-Delete-Duplicate-Emails" class="headerlink" title="196. Delete Duplicate Emails"></a><a href="https://leetcode.com/problems/delete-duplicate-emails/">196. Delete Duplicate Emails</a></h2><p>一图胜千言。</p><p><img src="/images/oss/20220309001948.png"></p><p>在我尝试了无数次后，我突然发现，<span style="color: #FF0000">这题是删除</span>！真该仔细看看英文，下面也有老外和我犯了一样的错误 hh。</p><p>但这题确实有够恶心，让人不禁想问，这真的是 Easy 难度？</p><p>这题的表结构和 182 一样，但要求删除重复的邮箱，只保留 ID 最小的。</p><p>问题就变得很容易——考虑将邮箱按邮箱路径分组，并找到每组的最小 ID，对该组的邮箱，删除大于该最小 ID 的邮箱即可。这里显然需要使用关系子查询。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> Person<br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(id) <span class="hljs-keyword">FROM</span> Person <span class="hljs-keyword">AS</span> p2 <br>              <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> p2.email <br>              <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> email); <br></code></pre></div></td></tr></table></figure><p>但问题其实没那么容易……<strong>MySQL 好像不支持在 UPDATE（DELETE）子句中的关联子查询中引用自己</strong>……这确实会让实现变得非常复杂。</p><p>想了想，直接跳过这题，它一点都不明显，甚至用的语法我都没见过&#x2F;吐血，神 TM 在 DELETE 里用连接，会这个的只有数据库 guru 吧。</p><h2 id="197-Rising-Temperature"><a href="#197-Rising-Temperature" class="headerlink" title="197. Rising Temperature"></a><a href="https://leetcode.com/problems/rising-temperature/">197. Rising Temperature</a></h2><p>有一张日期——温度表，记录每天的温度；现在考虑计算出温度比前一天高的日期。</p><p>该问题比较简单——将某日的日期和它的昨日做连接，筛选出大于昨日的温度的日期即可。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> today.id <span class="hljs-keyword">AS</span> id <span class="hljs-keyword">FROM</span> <br>Weather today <span class="hljs-keyword">JOIN</span> Weather yesterday <br>  <span class="hljs-keyword">ON</span> today.recordDate <span class="hljs-operator">=</span> date_add(yesterday.recordDate, <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DAY</span>)<br><span class="hljs-keyword">WHERE</span> today.temperature <span class="hljs-operator">&gt;</span> yesterday.temperature;<br></code></pre></div></td></tr></table></figure><p>这里唯一需要注意的是日期需要用相应的函数来进行处理，不要试图写什么<code>date + 1</code> 还期待它能够理解。</p><h2 id="595-Big-Countries"><a href="#595-Big-Countries" class="headerlink" title="595. Big Countries"></a><a href="https://leetcode.com/problems/big-countries/">595. Big Countries</a></h2><p>单纯的 WHERE 而已，跳过。</p><h2 id="596-Classes-More-Than-5-Students"><a href="#596-Classes-More-Than-5-Students" class="headerlink" title="596. Classes More Than 5 Students"></a><a href="https://leetcode.com/problems/classes-more-than-5-students/">596. Classes More Than 5 Students</a></h2><p>现在有一个学生——班级表，表结构为——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL">Courses <span class="hljs-keyword">table</span>:<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+---------+</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">Column</span> Name <span class="hljs-operator">|</span> Type    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+---------+</span><br><span class="hljs-operator">|</span> student     <span class="hljs-operator">|</span> <span class="hljs-type">varchar</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> class       <span class="hljs-operator">|</span> <span class="hljs-type">varchar</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+---------+</span><br></code></pre></div></td></tr></table></figure><p>其中<code>(student, class)</code>为主键（就像关系表），现在考虑筛选出有大于等于 5 个学生的班级。</p><p>非常简单，按 class 分组，使用 COUNT 做分组的筛选条件即可。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> class <span class="hljs-keyword">FROM</span> Courses <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">5</span>;<br></code></pre></div></td></tr></table></figure><h2 id="620-Not-Boring-Movies"><a href="#620-Not-Boring-Movies" class="headerlink" title="620. Not Boring Movies"></a><a href="https://leetcode.com/problems/not-boring-movies/">620. Not Boring Movies</a></h2><p>电影无不无聊我不知道，反正这一题挺无聊。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Cinema <br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> description <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;boring&#x27;</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> rating <span class="hljs-keyword">DESC</span>;<br></code></pre></div></td></tr></table></figure><h2 id="627-Swap-Salary"><a href="#627-Swap-Salary" class="headerlink" title="627. Swap Salary"></a><a href="https://leetcode.com/problems/swap-salary/">627. Swap Salary</a></h2><p>现在有一张雇员表，它有一个性别字段，使用’f’和’m’来标识性别。现在，我们要给所有人都变个性。</p><p>这题考查了“关联”的 UPDATE 语句——我们可以在 SET 子句<code>SET field = expr</code>中的 expr 中<strong>引用当前行的字段</strong>，</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> Salary<br><span class="hljs-keyword">SET</span> sex <span class="hljs-operator">=</span> <span class="hljs-keyword">CASE</span> sex <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;m&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-keyword">END</span>;<br></code></pre></div></td></tr></table></figure><p>注意，SET 子句中的&#x3D;并非是等于运算符，而是某种“赋值运算符”，其行为和命令式编程语言中的&#x3D;一致。</p><p>这道题目的测试用例有问题，导致不熟悉语法的我吃了大亏。</p><h2 id="1179-Reformat-Department-Table"><a href="#1179-Reformat-Department-Table" class="headerlink" title="1179. Reformat Department Table"></a><a href="https://leetcode.com/problems/reformat-department-table/">1179. Reformat Department Table</a></h2><p>这一题需要重点关注一下。</p><p>现在有一张部门每月的收入表，表结构如下，其中 id 为部门 id，<code>(id, month)</code>为主键——</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+-------------+</span>---------+<br><span class="hljs-section">| Column Name | Type    |</span><br><span class="hljs-section">+-------------+---------+</span><br>| id          | int     |<br>| revenue     | int     |<br><span class="hljs-section">| month       | varchar |</span><br><span class="hljs-section">+-------------+---------+</span><br></code></pre></div></td></tr></table></figure><p>现在，考虑每个部门（id）从 1 月到 12 月的收入，做成一张横表。</p><p>显然，我们必须要按 id 进行分组后再进行其它操作，所以我们先看看分组后会发生什么——</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">原数据</span><br><span class="hljs-section">+------+---------+-------+</span><br><span class="hljs-section">| id   | revenue | month |</span><br><span class="hljs-section">+------+---------+-------+</span><br>| 1    | 8000    | Jan   |<br>| 2    | 9000    | Jan   |<br>| 3    | 10000   | Feb   |<br>| 1    | 7000    | Feb   |<br><span class="hljs-section">| 1    | 6000    | Mar   |</span><br><span class="hljs-section">+------+---------+-------+</span><br><br><span class="hljs-section">按 id 分组后，会得到——</span><br><span class="hljs-section">+-------+------+---------+-------+</span><br><span class="hljs-section">| id    | id   | revenue | month |</span><br><span class="hljs-section">+-------+------+---------+-------+</span><br>| 1     | 1    | 8000    | Jan   |<br>|       | 1    | 7000    | Feb   |<br><span class="hljs-section">|       | 1    | 6000    | Mar   |</span><br><span class="hljs-section">+-------+------+---------+-------+</span><br><span class="hljs-section">| 2     | 2    | 9000    | Jan   |</span><br><span class="hljs-section">+-------+------+---------+-------+</span><br><span class="hljs-section">| 3     | 3    | 10000   | Feb   |</span><br><span class="hljs-section">+-------+------+---------+-------+</span><br></code></pre></div></td></tr></table></figure><p>在这里，我们想要得到形如<code>1, 8000, 7000, 6000, NULL, ...</code>这样的列，因此我们必须要从分组后的数据中分别<strong>选择</strong>出 month 为 Jan，Feb，Mar……等的记录的收入。</p><p>但是我们做不到，<strong>对分组后的数据进行操作，只能使用聚集函数</strong>，没法进一步筛选。因此这里只能使用特定的聚集函数来进行该操作，这里符合要求的只有 SUM 了。我们可以在 SUM 中使用 IF 或 CASE 表达式，仅统计所需月份的收入，否则就使用 NULL。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> id,<br><span class="hljs-built_in">SUM</span>(IF(<span class="hljs-keyword">month</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Jan&#x27;</span>, revenue, <span class="hljs-keyword">NULL</span>)) <span class="hljs-keyword">AS</span> Jan_Revenue,<br><span class="hljs-built_in">SUM</span>(IF(<span class="hljs-keyword">month</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Feb&#x27;</span>, revenue, <span class="hljs-keyword">NULL</span>)) <span class="hljs-keyword">AS</span> Feb_Revenue,<br><span class="hljs-built_in">SUM</span>(IF(<span class="hljs-keyword">month</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Mar&#x27;</span>, revenue, <span class="hljs-keyword">NULL</span>)) <span class="hljs-keyword">AS</span> Mar_Revenue<br><span class="hljs-comment">-- ...</span><br><span class="hljs-keyword">FROM</span> Department <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> id;<br></code></pre></div></td></tr></table></figure><p>这里我也试图使用关联子查询，但是这直接超时了……显然这样性能是最优解，记住这个模式。</p><h1 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h1><h2 id="178-Rank-Scores"><a href="#178-Rank-Scores" class="headerlink" title="178. Rank Scores"></a><a href="https://leetcode.com/problems/rank-scores/">178. Rank Scores</a></h2><p>现在有一张 ID——成绩表，现在要求按成绩降序进行排名，相同成绩的并列，成绩相邻的排名计数+1，比如，对于下面的输入，有下面的输出——</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">Input: <br><span class="hljs-section">Scores table:</span><br><span class="hljs-section">+----+-------+</span><br><span class="hljs-section">| id | score |</span><br><span class="hljs-section">+----+-------+</span><br>| 1  | 3.50  |<br>| 2  | 3.65  |<br>| 3  | 4.00  |<br>| 4  | 3.85  |<br>| 5  | 4.00  |<br><span class="hljs-section">| 6  | 3.65  |</span><br><span class="hljs-section">+----+-------+</span><br><span class="hljs-section">Output: </span><br><span class="hljs-section">+-------+------+</span><br><span class="hljs-section">| score | rank |</span><br><span class="hljs-section">+-------+------+</span><br>| 4.00  | 1    |<br>| 3.85  | 2    |<br>| 3.65  | 3    |<br><span class="hljs-section">| 3.50  | 4    |</span><br><span class="hljs-section">+-------+------+</span><br></code></pre></div></td></tr></table></figure><p>该题显然需要使用窗口函数，观察输出，显然需要使用 DENSE_RANK。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> score, <span class="hljs-built_in">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> `rank`<br><span class="hljs-keyword">FROM</span> Scores;<br></code></pre></div></td></tr></table></figure><p>但是使用窗口函数算什么好汉？有没有别的手段可以用呢？</p><p>确实有，答案就是我们要手动模拟窗口函数的执行过程——对每一个记录，检查比它大的集合的数量。根据对应的窗口函数的不同，使用不同的约束方式。</p><p>比如，对 RANK，直接统计比它大 score 大的集合的数量即可，SQL 如下——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> score,<br>  (<span class="hljs-keyword">SELECT</span> (<span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Scores <span class="hljs-keyword">AS</span> s1 <span class="hljs-keyword">WHERE</span> s1.score <span class="hljs-operator">&gt;</span> s0.score) <span class="hljs-keyword">AS</span> `rank`<br><span class="hljs-keyword">FROM</span> Scores <span class="hljs-keyword">AS</span> s0 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> s0.score <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">-- 等价于</span><br><span class="hljs-keyword">SELECT</span> score, <span class="hljs-built_in">RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">FROM</span> Scores;<br></code></pre></div></td></tr></table></figure><p>ROW_NUMBER 就有一些麻烦，需要妥善处理相等的情况。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <br>  score,<br>  (<span class="hljs-keyword">SELECT</span> (<span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Scores <span class="hljs-keyword">AS</span> s1 <span class="hljs-keyword">WHERE</span> <br>    s1.score <span class="hljs-operator">&gt;</span> s0.score <span class="hljs-keyword">OR</span> (s1.score <span class="hljs-operator">=</span> s0.score <span class="hljs-keyword">AND</span> s1.id <span class="hljs-operator">&gt;</span> s0.id))<br>  <span class="hljs-keyword">AS</span> `rank`<br><span class="hljs-keyword">FROM</span> Scores <span class="hljs-keyword">AS</span> s0 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> s0.score <span class="hljs-keyword">DESC</span>, s0.id <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">-- 等价于</span><br><span class="hljs-keyword">SELECT</span> score, <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">FROM</span> Scores;<br></code></pre></div></td></tr></table></figure><p>这里计数分了两个部分——大于当前分数的部分和等于当前分数的部分，大于的部分需要全部统计，等于的部分只需要统计其中一部分（相同的组里 ROW_NUMBER 仍旧是递增的），统计哪部分随意，只要排序后结果正确即可。</p><p>DENSE_RANK 的话，它不看前面具体有多少个分数高于它，只看有多少“种”分数高于它，在 RANK 中的 COUNT 中加上 DISTINCT 约束即可。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> score,<br>  (<span class="hljs-keyword">SELECT</span> (<span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> s1.score) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Scores <span class="hljs-keyword">AS</span> s1 <span class="hljs-keyword">WHERE</span> s1.score <span class="hljs-operator">&gt;</span> s0.score) <span class="hljs-keyword">AS</span> `rank`<br><span class="hljs-keyword">FROM</span> Scores <span class="hljs-keyword">AS</span> s0 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> s0.score <span class="hljs-keyword">DESC</span>;<br></code></pre></div></td></tr></table></figure><h2 id="176-Second-Highest-Salary"><a href="#176-Second-Highest-Salary" class="headerlink" title="176. Second Highest Salary"></a><a href="https://leetcode.com/problems/second-highest-salary/">176. Second Highest Salary</a></h2><p>现在有一张 ID——工资表，要求获取第二（DISTINCT 的）高的工资，如果没有第二高的工资，则返回 NULL。</p><p>考虑到有返回 NULL 的需求，感觉就可以使用连接操作了，进行自连接，右外连接，假设左表为 lower_t，右表为 higher_t，条件设为<code>lower_t.salary &lt;= higher_t.salary AND lower_t.id != higher_t.id</code>，取<code>MAX(lower_t.salary)</code>即可。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(lower_t.salary) <span class="hljs-keyword">AS</span> SecondHighestSalary<br><span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">AS</span> lower_t <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> Employee <span class="hljs-keyword">AS</span> higher_t <br><span class="hljs-keyword">ON</span> (lower_t.salary <span class="hljs-operator">&lt;</span> higher_t.salary);<br></code></pre></div></td></tr></table></figure><blockquote><p>记住，使用左外连接时，右边的值可能为 NULL，使用右外连接时，左边的值可能为 NULL。</p></blockquote><p>这样写性能颇为灾难。第二种方法就是经典的排序了，DISTINCT 并用 LIMIT 取第二个值，取到了就返回它，否则返回 NULL。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"># Write your MySQL query statement below<br><span class="hljs-keyword">SELECT</span> <br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> salary <br>  <span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <br><span class="hljs-keyword">AS</span> SecondHighestSalary;<br></code></pre></div></td></tr></table></figure><p>外层的 SELECT 能够把空表转换成 NULL。</p><p>第三种方式是，直接筛掉最高的工资，再次调用 MAX 就是第二高的工资了。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">AS</span> SecondHighestSalary <span class="hljs-keyword">FROM</span> Employee <br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">!=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">FROM</span> Employee)<br></code></pre></div></td></tr></table></figure><h2 id="177-Nth-Highest-Salary"><a href="#177-Nth-Highest-Salary" class="headerlink" title="177. Nth Highest Salary"></a><a href="https://leetcode.com/problems/nth-highest-salary/">177. Nth Highest Salary</a></h2><p>和上题类似，但获取第 N 高的工资。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> getNthHighestSalary(N <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span><br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">SELECT</span> (N <span class="hljs-operator">-</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">INTO</span> N;<br>  <span class="hljs-keyword">RETURN</span> (<br>      # Write your MySQL query statement below.<br>      <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> salary <br>        <span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span> LIMIT N, <span class="hljs-number">1</span><br>  );<br><span class="hljs-keyword">END</span><br></code></pre></div></td></tr></table></figure><p>第一想法是，直接拿上一题的代码过来不就好了，这里需要注意 N 需要减 1（偏移量从 0 开始计数），LIMIT 子句里不允许对偏移量和列数进行运算，所以直接修改变量。</p><p>另外的想法就是利用窗口函数了，DENSE_RANK 显然满足要求。确定完 rank 后，直接用相等判就好了。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> getNthHighestSalary(N <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span><br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">SELECT</span> (N <span class="hljs-operator">-</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">INTO</span> N;<br>  <span class="hljs-keyword">RETURN</span> (<br>      <span class="hljs-keyword">SELECT</span> t.salary <span class="hljs-keyword">FROM</span> <br>      (<span class="hljs-keyword">SELECT</span> salary, <br>              <span class="hljs-built_in">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> `rank` <br>           <span class="hljs-keyword">FROM</span> Employee) <span class="hljs-keyword">AS</span> t<br>      <span class="hljs-keyword">WHERE</span> t.rank <span class="hljs-operator">=</span> N <span class="hljs-operator">+</span> <span class="hljs-number">1</span> LIMIT <span class="hljs-number">1</span><br>  );<br><span class="hljs-keyword">END</span><br></code></pre></div></td></tr></table></figure><h2 id="184-Department-Highest-Salary"><a href="#184-Department-Highest-Salary" class="headerlink" title="184. Department Highest Salary"></a><a href="https://leetcode.com/problems/department-highest-salary/">184. Department Highest Salary</a></h2><p>现在有一个雇员表，一个部门表，部门表包含部门 ID 和名称，雇员表包含雇员 ID，名称，薪水，部门 ID。</p><p>现在想要知道每个部门中薪水最高的人的信息，需注意的是一个部门中薪水最高的人不止一个。要做的第一件事是明确的——将两个表进行内连接。</p><p>然后这时我们就想着，可以对于每个雇员，检查他所处的部门的最高的薪水，检查他的薪水是否和这最高薪水相等，如果相等就说明他是最高的，将其插入到结果中。这里使用了关联子查询，所以效率很差。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> d.name <span class="hljs-keyword">AS</span> Department, e.name <span class="hljs-keyword">AS</span> Employee, salary<br><span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">JOIN</span> Department <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">ON</span> e.departmentId <span class="hljs-operator">=</span> d.id<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">AS</span> e0 <br>                   <span class="hljs-keyword">WHERE</span> e0.departmentId <span class="hljs-operator">=</span> e.departmentId);<br></code></pre></div></td></tr></table></figure><p>但我们又想着，为啥要对每个雇员分别去查他的部门呢？直接预先把所有部门的最高薪水都查到，在比较时连部门带薪水一起比较不就好了！</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> d.name <span class="hljs-keyword">AS</span> Department, e.name <span class="hljs-keyword">AS</span> Employee, salary<br><span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">JOIN</span> Department <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">ON</span> e.departmentId <span class="hljs-operator">=</span> d.id<br><span class="hljs-keyword">WHERE</span> (d.id, e.salary) <span class="hljs-keyword">IN</span> (<br>  <span class="hljs-keyword">SELECT</span> departmentId, <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> departmentId<br>);<br></code></pre></div></td></tr></table></figure><p>没想到 SQL 还能进行这种非原子的比较，很酷炫。</p><p>直奔评论区，发现有人对 Employee 表，用 RANK 函数直接获得每个部门的薪水的排名，然后从中筛选出排名为 1 的 Employee，使用这些 Employee 对 Department 进行 JOIN。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> d.name <span class="hljs-keyword">AS</span> Department, e.name <span class="hljs-keyword">AS</span> Employee, salary<br><span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, <br>       <span class="hljs-built_in">RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> departmentId <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>) <br>      <span class="hljs-keyword">AS</span> rk <span class="hljs-keyword">FROM</span> Employee) <br>    <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">JOIN</span> Department <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">ON</span> e.departmentId <span class="hljs-operator">=</span> d.id <br><span class="hljs-keyword">WHERE</span> e.rk <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>但这些方法其实性能都差不多，怎么清晰怎么来吧。</p><h2 id="180-Consecutive-Numbers"><a href="#180-Consecutive-Numbers" class="headerlink" title="180. Consecutive Numbers"></a><a href="https://leetcode.com/problems/consecutive-numbers/">180. Consecutive Numbers</a></h2><p>现在，有一张 ID——数字表，要求获取这样的数字，它连续出现超过三次，输入输出类似这样——</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">Input: <br><span class="hljs-section">Logs table:</span><br><span class="hljs-section">+----+-----+</span><br><span class="hljs-section">| id | num |</span><br><span class="hljs-section">+----+-----+</span><br>| 1  | 1   |<br>| 2  | 1   |<br>| 3  | 1   |<br>| 4  | 2   |<br>| 5  | 1   |<br>| 6  | 2   |<br><span class="hljs-section">| 7  | 2   |</span><br><span class="hljs-section">+----+-----+</span><br><span class="hljs-section">Output: </span><br><span class="hljs-section">+-----------------+</span><br><span class="hljs-section">| ConsecutiveNums |</span><br><span class="hljs-section">+-----------------+</span><br><span class="hljs-section">| 1               |</span><br><span class="hljs-section">+-----------------+</span><br></code></pre></div></td></tr></table></figure><p>这里，只有数字 1 连续出现三次，选择它。</p><p>这题，直接使用特定窗口函数吧……有一个 LEAD 函数和 LAG 函数，<strong>LEAD 函数获取向前看 n 行的数据，LAG 函数获取向后看 n 行的数据</strong>，这里往前后分别看一行，如果前后一行和当前行相等，说明三行相等，符合要求。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> num <span class="hljs-keyword">AS</span> ConsecutiveNums<br><span class="hljs-keyword">FROM</span> (<br><span class="hljs-keyword">SELECT</span> num,<br>    <span class="hljs-built_in">LEAD</span>(num) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id) <span class="hljs-keyword">AS</span> `lead`,<br>    <span class="hljs-built_in">LAG</span>(num) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id) <span class="hljs-keyword">AS</span> `lag`<br><span class="hljs-keyword">FROM</span> Logs<br>) <span class="hljs-keyword">AS</span> t<br><span class="hljs-keyword">WHERE</span> num<span class="hljs-operator">=</span>`lead` <span class="hljs-keyword">and</span> num<span class="hljs-operator">=</span>`lag`;<br></code></pre></div></td></tr></table></figure><p>官方解答进行了两次自连接，且不能处理所有情况，很残废。</p><h2 id="626-Exchange-Seats"><a href="#626-Exchange-Seats" class="headerlink" title="626. Exchange Seats"></a><a href="https://leetcode.com/problems/exchange-seats/">626. Exchange Seats</a></h2><p>现在有一个学生的座位 ID——名称表，要求每个座位为偶数的和他之前的奇数位学生交换座位，如果总座位数为奇数，则最后一个学生不移动，输入和输出如下。</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">Input: <br><span class="hljs-section">Seat table:</span><br><span class="hljs-section">+----+---------+</span><br><span class="hljs-section">| id | student |</span><br><span class="hljs-section">+----+---------+</span><br>| 1  | Abbot   |<br>| 2  | Doris   |<br>| 3  | Emerson |<br>| 4  | Green   |<br><span class="hljs-section">| 5  | Jeames  |</span><br><span class="hljs-section">+----+---------+</span><br><span class="hljs-section">Output: </span><br><span class="hljs-section">+----+---------+</span><br><span class="hljs-section">| id | student |</span><br><span class="hljs-section">+----+---------+</span><br>| 1  | Doris   |<br>| 2  | Abbot   |<br>| 3  | Green   |<br>| 4  | Emerson |<br><span class="hljs-section">| 5  | Jeames  |</span><br><span class="hljs-section">+----+---------+</span><br></code></pre></div></td></tr></table></figure><p>这其实是一个数学题，我们首先能发现，将<code>IF(ID % 2 = 0, id - 1, id + 1)</code>座位新 ID 进行排序的话，学生的顺序就符合要求了，但最后一个 ID 如果是奇数的话会出现错误，那既然这样的话我们直接按照这个顺序上一个 ROW_NUMBER 不就好了？</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <br>  <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> IF(id <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, id <span class="hljs-operator">-</span> <span class="hljs-number">1</span>, id <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)) <span class="hljs-keyword">AS</span> id,<br>  student <br><span class="hljs-keyword">FROM</span> Seat;<br></code></pre></div></td></tr></table></figure><p>官方推荐的解决方式是在执行之前获取表记录的数量，若是奇数就对最后一个值去特别处理，这相当于是修改了新 ID 的计算方式，这里不表了。</p><h1 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a>Hard</h1><h2 id="185-Department-Top-Three-Salaries"><a href="#185-Department-Top-Three-Salaries" class="headerlink" title="185. Department Top Three Salaries"></a><a href="https://leetcode.com/problems/department-top-three-salaries/solution/">185. Department Top Three Salaries</a></h2><p>和 <a href="https://leetcode.com/problems/department-highest-salary/">184. Department Highest Salary</a> 一样，但是要求获取前三高（DISTINCT 的）的薪资。</p><p>最开始的想法是，可以直接按上一题使用窗口函数的方法进行修改，判断 rank 时使用<code>[1,3]</code>。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> d.name <span class="hljs-keyword">AS</span> Department, e.name <span class="hljs-keyword">AS</span> Employee, salary<br><span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, <br>       <span class="hljs-built_in">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> departmentId <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>) <br>      <span class="hljs-keyword">AS</span> rk <span class="hljs-keyword">FROM</span> Employee) <br>    <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">JOIN</span> Department <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">ON</span> e.departmentId <span class="hljs-operator">=</span> d.id <br><span class="hljs-keyword">WHERE</span> e.rk <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3</span>;<br></code></pre></div></td></tr></table></figure><p>这代码性能不太好（我不服，tnnd 有人和我的代码一样，怎么性能比我快一倍？怀疑是他们的硬件原因），官方的 Solution 是，对每一个雇员，检查同部门的比它高的薪水的“种类”（DISTINCT），如果这“种类”小于 3，则该雇员的薪水在前三中。这和上一题的关联子查询类似。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> d.name <span class="hljs-keyword">AS</span> Department, e.name <span class="hljs-keyword">AS</span> Employee, salary<br><span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">JOIN</span> Department <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">ON</span> e.departmentId <span class="hljs-operator">=</span> d.id<br><span class="hljs-keyword">WHERE</span> <span class="hljs-number">3</span> <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> salary) <span class="hljs-keyword">FROM</span> Employee e1<br>             <span class="hljs-keyword">WHERE</span> e1.departmentId <span class="hljs-operator">=</span> e.departmentId<br>               <span class="hljs-keyword">AND</span> e1.salary <span class="hljs-operator">&gt;</span> e.salary);<br></code></pre></div></td></tr></table></figure><p>可见，这种求第 N 个排名的题基本都可以用关联子查询或窗口函数来解决，其中窗口函数显然是更加通俗易懂的。</p><h2 id="262-Trips-and-Users"><a href="#262-Trips-and-Users" class="headerlink" title="262. Trips and Users"></a><a href="https://leetcode.com/problems/trips-and-users/">262. Trips and Users</a></h2><p>这题其实很简单，但却麻烦了我半天……最大的问题是审题不仔细，然后对某些函数不熟悉。</p><p>现在有一张出租车订单表和一张用户表，出租车订单表中包含用户 id 和驾驶员 id，两 id 都引用用户表，还包含订单的状态——完成或取消；用户表包含用户的角色以及是否被 ban。</p><p>现在，要求获取 <strong>2013-10-01 到 2013-10-03 日期中</strong>的每天的，用户和驾驶员均未被 ban 的，订单的取消率。</p><p>问题其实很简单——筛选出驾驶员和用户未被 ban 的订单，按天分组，统计状态为取消的订单数除以总订单数，格式化即可。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> request_at <span class="hljs-keyword">AS</span> <span class="hljs-keyword">Day</span>, <br>       ROUND(<span class="hljs-number">1</span> <span class="hljs-operator">-</span> (<span class="hljs-built_in">COUNT</span>(IF(status <span class="hljs-operator">=</span> &quot;completed&quot;, <span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)), <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> `Cancellation Rate`<br><span class="hljs-keyword">FROM</span> Trips <span class="hljs-keyword">WHERE</span> <br>    request_at <span class="hljs-keyword">BETWEEN</span> &quot;2013-10-01&quot; <span class="hljs-keyword">AND</span> &quot;2013-10-03&quot;<br><span class="hljs-keyword">AND</span> client_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> users_id <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> banned <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Yes&#x27;</span>)   <br><span class="hljs-keyword">AND</span> driver_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> users_id <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> banned <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Yes&#x27;</span>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> request_at;<br></code></pre></div></td></tr></table></figure><h2 id="601-Human-Traffic-of-Stadium"><a href="#601-Human-Traffic-of-Stadium" class="headerlink" title="601. Human Traffic of Stadium"></a><a href="https://leetcode.com/problems/human-traffic-of-stadium/">601. Human Traffic of Stadium</a></h2><p>最后一题了！</p><p>现在有一张体育场入场数表，表示每天体育场的入场人数，它长这样——</p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">Stadium table:<br>+------+------------+-----------+<br>|<span class="hljs-string"> id   </span>|<span class="hljs-string"> visit_date </span>|<span class="hljs-string"> people    </span>|<br>+------+------------+-----------+<br>|<span class="hljs-string"> 1    </span>|<span class="hljs-string"> 2017-01-01 </span>|<span class="hljs-string"> 10        </span>|<br>|<span class="hljs-string"> 2    </span>|<span class="hljs-string"> 2017-01-02 </span>|<span class="hljs-string"> 109       </span>|<br>|<span class="hljs-string"> 3    </span>|<span class="hljs-string"> 2017-01-03 </span>|<span class="hljs-string"> 150       </span>|<br>|<span class="hljs-string"> 4    </span>|<span class="hljs-string"> 2017-01-04 </span>|<span class="hljs-string"> 99        </span>|<br>|<span class="hljs-string"> 5    </span>|<span class="hljs-string"> 2017-01-05 </span>|<span class="hljs-string"> 145       </span>|<br>|<span class="hljs-string"> 6    </span>|<span class="hljs-string"> 2017-01-06 </span>|<span class="hljs-string"> 1455      </span>|<br>|<span class="hljs-string"> 7    </span>|<span class="hljs-string"> 2017-01-07 </span>|<span class="hljs-string"> 199       </span>|<br>|<span class="hljs-string"> 8    </span>|<span class="hljs-string"> 2017-01-09 </span>|<span class="hljs-string"> 188       </span>|<br>+------+------------+-----------+<br></code></pre></div></td></tr></table></figure><p>参观日期递增，id 和日期一一对应且递增，现在要求获取这些记录——参观人数大于等于 100 且超过连续 3 个 id 如此，比如对上面的表，会选择 5，6，7，8，因为这四个 id 相邻且人数连续大于等于 100.</p><p>这题直接使用窗口函数就行了，对每一条记录，我们要检查它以及其上两条，它以及上下一条，它以及其下两条这三个集合中的最小值大于等于 100，只要其中一个满足，它就是符合要求的。</p><p>这里使用 ROW 来取得前后的数据，需注意如果前后没有数据，它就干脆不取了，所以需要保证传递给 MIN 的数据为 3 个。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-comment">-- 好工整啊</span><br><span class="hljs-comment">-- 因为 id 本来就是 ASC 的，这里就不用加了</span><br><span class="hljs-keyword">SELECT</span> id, visit_date, people <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> id, visit_date, people, <br>     <span class="hljs-built_in">MIN</span>(people) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1</span> PRECEDING <span class="hljs-keyword">AND</span> <span class="hljs-number">1</span> FOLLOWING) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">100</span> <br>    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1</span> PRECEDING <span class="hljs-keyword">AND</span> <span class="hljs-number">1</span> FOLLOWING) <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>  <span class="hljs-keyword">OR</span> <span class="hljs-built_in">MIN</span>(people) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2</span> PRECEDING <span class="hljs-keyword">AND</span> <span class="hljs-keyword">CURRENT</span> <span class="hljs-type">ROW</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">100</span> <br>    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2</span> PRECEDING <span class="hljs-keyword">AND</span> <span class="hljs-keyword">CURRENT</span> <span class="hljs-type">ROW</span>) <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>  <span class="hljs-keyword">OR</span> <span class="hljs-built_in">MIN</span>(people) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-keyword">CURRENT</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">2</span> FOLLOWING) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">100</span> <br>    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-keyword">CURRENT</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">2</span> FOLLOWING) <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-keyword">AS</span> flag  <br><span class="hljs-keyword">FROM</span> Stadium) <span class="hljs-keyword">AS</span> t <span class="hljs-keyword">WHERE</span> flag;<br></code></pre></div></td></tr></table></figure><p>可以看到，窗口函数真的能够玩很多花活，且格式非常灵活，之后还得继续了解。</p><hr><p>下一步是牛客网的82道题！</p>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 MR 为何需要排序，以及一个分布式排序的示例</title>
    <link href="/2022/03-12%E5%85%B3%E4%BA%8EMR%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A4%BA%E4%BE%8B.html"/>
    <url>/2022/03-12%E5%85%B3%E4%BA%8EMR%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A4%BA%E4%BE%8B.html</url>
    
    <content type="html"><![CDATA[<p>之前去了解了一下关于MapReduce的几个比较疑惑的问题，认为有必要专门记录一下，同时也给定一个分布式排序的示例，这应用到了这里谈到的特性。但学习过程中我实际上没有参考多少权威资料，全凭一孔之见，所以非常大的可能有错误。</p><span id="more"></span><h1 id="一些疑问及我对它的理解"><a href="#一些疑问及我对它的理解" class="headerlink" title="一些疑问及我对它的理解"></a>一些疑问及我对它的理解</h1><h2 id="为何-MapReduce-需要排序？"><a href="#为何-MapReduce-需要排序？" class="headerlink" title="为何 MapReduce 需要排序？"></a>为何 MapReduce 需要排序？</h2><p>有时候我会想，为啥 MapReduce 中的数据需要排序呢？感觉不排序也没什么问题呀？Map 阶段得到了所需的 KV 对，把 KEY 哈希完后直接发送给对应的 Reducer，等拿到这个 KEY 的所有数据就直接开始 reduce 操作呗？</p><p>我认为这里有一个比较主要的原因是，<strong>对无序的数据集合进行分组（和 reduce）操作是非常昂贵的</strong>。倘若要获取某个 KEY 的所有记录，需要遍历整个集合。这样，我们在 reduce 方法中的那种操作就会很迷惑——<strong>对每一个 key，都把所有记录遍历一遍，拿到对应的分组</strong>。但考虑到访问特定分组必须是<strong>流式</strong>的，这是必要之举。</p><p>这和在普通应用中的分组操作不同，考虑我们在普通应用中进行分组的方法，我们会去定义一个名为 bucket 的哈希表，key 为分组的键，而 value 为记录的集合，我们将迭代整个记录的集合并将其存放在对应的 bucket 中。这就是问题所在——<strong>大数据量大情况下我们是无法在内存中维护这样一个 bucket 的</strong>。</p><p>基于这种限制，我认为，如果要对无序的巨量记录进行流式的分组和 reduce 操作，其时间复杂度将是 n^2——对每一个 key，都遍历整个记录集合。</p><p>而对有序的集合呢？那问题就容易了，考虑到有序的集合中，同一个 KEY 的记录总是紧挨着的，我们直接维护一个当前的 KEY，遍历整个集合，如果该 KEY 和当前相等，就说明还是这个 KEY 的数据，向用户的 reduce 方法的 value 迭代器里再添一个，如果不相等，则说明是下一个 KEY，终止当前的 reduce 方法，起一个新的。这样，就能在线性时间复杂度的情况下流式地 reduce 掉整个集合了。</p><p>我认为，这就是排序的意义，同时这应该也是 KV 存储的意义——让并行性本就不如 map 阶段的 reduce 阶段能更加轻松。同时，排序也使得可以容易得到易处理，人类可读的数据。</p><p>如果事实就是如此，那说数据被分组其实是一个谎言——其实什么都没干，只是顺序地迭代集合罢了，只不过表现出来的行为（接口等）是分组而已。但这种抽象，这种“谎言”是非常有趣的。</p><p>顺带一提，Haskell 的列表的 group 行为和这非常相似。事实证明，这种算法甚至能够处理无穷列表，或许一切流式操作都有如此特性吧。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- Haskell 代码</span><br><br><span class="hljs-title">duetNat</span> = [<span class="hljs-number">1</span> ..] &gt;&gt;= \i -&gt; [i, i] <span class="hljs-comment">-- [1, 1, 2, 2, 3, 3, ...]</span><br><span class="hljs-comment">-- &gt;&gt;&gt; take 10 $ group duetNat</span><br><span class="hljs-comment">-- [[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10]]</span><br></code></pre></div></td></tr></table></figure><p>但参考谷歌的论文对 MR 中进行排序的论述，感觉我可能想太多——</p><blockquote><p>我们确保在给定的分区中，中间 key&#x2F;value pair 数据的处理顺序是按照 key 值增量顺序处理的。这样的顺 序保证对每个分成生成一个有序的输出文件，<strong>这对于需要对输出文件按 key 值随机存取的应用非常有意义， 对在排序输出的数据集也很有帮助</strong>。</p><p>We guarantee that within a given partition, the intermediate key&#x2F;value pairs are processed in increasing key order. This ordering guarantee makes it easy to generate a sorted output file per partition, <strong>which is useful when the output file format needs to support efficient random access lookups by key, or users of the output find it convenient to have the data sorted</strong>.</p></blockquote><blockquote><p>另外，JOIN 操作对于有序的集合的复杂度为<code>O(n)</code>，这也是排序的一个必要之处。</p></blockquote><h2 id="为何-Partitioner-执行在-Combiner-之前？"><a href="#为何-Partitioner-执行在-Combiner-之前？" class="headerlink" title="为何 Partitioner 执行在 Combiner 之前？"></a>为何 Partitioner 执行在 Combiner 之前？</h2><p>太长不看，两个原因——整个集合排序开销大，分区后容易并行 combine</p><p>MR 在执行 partitioner 后将每个分组进行排序，再传递给 Combiner，为什么不先 Combine 后再进行排序呢？我怀疑他们是想让 Reducer 和 Combiner 行为一致：接受的 key 总是按顺序的。</p><p>而倘若先进行 Combine，<strong>则 Combine 之前必须进行排序</strong>，而这样开销更大，假设原记录数为 n，则时间复杂度为 nlogn，而假设分了 k 个区，对每个区进行排序，总时间复杂度为 k * (n&#x2F;k) * (log n &#x2F; k)，即 n * (log n &#x2F; k)，这还是没有考虑到分过区后每个区可以并行地排序的情况！因此，显然分区后对每个分区进行局部排序开销更小。况且，如果两个 KEY 本就该分给不同的 Reducer，那么对它们进行排序有什么意义呢？</p><p>而且，分过区后，可以非常容易地对每个分区进行并行的 combine 操作（当然，不分区也能进行并行的 combine，就像 java8-stream 的 reduce 方法一样）。</p><p>但这些猜测仍旧无法彻底让我信服，还得之后再研究。</p><h1 id="分布式排序"><a href="#分布式排序" class="headerlink" title="分布式排序"></a>分布式排序</h1><p>当只有一个 Reducer 时，MR 可以用于进行分布式排序。它的原理利用了 MR 的执行流程。</p><p>每个 Mapper 处理完自己的所有记录集合后，会传递给 Partitioner 进行分区操作，Partitioner 分完区后，每个分区的结果会按照 KEY 进行排序，经过 Combiner 后发送给对应的 Reducer。</p><p>每个 Reducer 都将接受每一个 Mapper 传递过来的记录集合，每一个 Mapper 的集合都是有序的，但所有 Mapper（传递给它）的集合总的来说是无序的，因此，Reducer 会进行一种所谓的多路归并算法，将每一个 Mapper 传递的局部有序的集合归并在一起，得到一个整体有序的最终集合，并用于分组。</p><p>当只有一个 Reducer 时，所有 Mapper 的有序的集合都将发送给它，并由它进行归并，排序后传递给用户的 reduce 方法。因此，用户接受到的 reduce 方法，它看到的 KEY 是按顺序的，此时若直接把 KEY 输出，最终得到的结果文件里就是排完序的结果。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 在特定文件夹里创建 16 个文件，每个文件里包含 500 万个数</span><br><span class="hljs-comment">// 总共约 1520M 大小</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CreateInputFiles</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> path = <span class="hljs-string">&quot;/路径/到/输入路径&quot;</span><br>  (<span class="hljs-number">0</span> until <span class="hljs-number">16</span>).foreach &#123;i =&gt;<br>    <span class="hljs-keyword">val</span> writer = <span class="hljs-keyword">new</span> <span class="hljs-type">FileWriter</span>(<span class="hljs-string">s&quot;<span class="hljs-subst">$path</span>/<span class="hljs-subst">$i</span>.txt&quot;</span>)<br>    (<span class="hljs-number">0</span> until <span class="hljs-number">5000000</span>).foreach(_ =&gt; writer.write(<span class="hljs-type">Math</span>.abs(<span class="hljs-type">Random</span>.nextLong()) + <span class="hljs-string">&quot;\n&quot;</span>))<br>    writer.close()<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributedSortMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">LongWritable</span>, <span class="hljs-type">NullWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">val</span> outputK = <span class="hljs-keyword">new</span> <span class="hljs-type">LongWritable</span>()<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">LongWritable</span>, <span class="hljs-type">NullWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    value.toString.toLongOption <span class="hljs-keyword">match</span> &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; &#123;&#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(longValue) =&gt; &#123;<br>        outputK.set(longValue)<br>        context.write(outputK, <span class="hljs-type">NullWritable</span>.get)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributedSortReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">LongWritable</span>, <span class="hljs-type">NullWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">LongWritable</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">NullWritable</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">LongWritable</span>, <span class="hljs-type">NullWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 为什么要调用 forEach 呢？因为可能有多个值相等，这时候它们会被分在一个组里</span><br>    <span class="hljs-comment">// 直接打印到结果文件里，那就只留下了不重复的了</span><br>    <span class="hljs-comment">// 当然，在这里没必要，在 Long 这么大的范围，8000 万条数据还真的不容易撞</span><br>    values.forEach(_ =&gt; context.write(key, <span class="hljs-type">NullWritable</span>.get))<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">DistributedSortJob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> parser = <span class="hljs-keyword">new</span> <span class="hljs-type">GenericOptionsParser</span>(args)<br>  <span class="hljs-keyword">val</span> job = <span class="hljs-type">Job</span>.getInstance(parser.getConfiguration)<br>  <span class="hljs-keyword">val</span> inputPath +: outputPath +: _ = parser.getRemainingArgs.toSeq.map(<span class="hljs-keyword">new</span> <span class="hljs-type">Path</span>(_))<br><br>  job.setInputFormatClass(classOf[<span class="hljs-type">TextInputFormat</span>])<br>  job.setOutputKeyClass(classOf[<span class="hljs-type">TextOutputFormat</span>[_,_]])<br>  job.setMapOutputKeyClass(classOf[<span class="hljs-type">LongWritable</span>])<br>  job.setMapOutputValueClass(classOf[<span class="hljs-type">NullWritable</span>])<br>  job.setOutputKeyClass(classOf[<span class="hljs-type">LongWritable</span>])<br>  job.setOutputValueClass(classOf[<span class="hljs-type">NullWritable</span>])<br><br>  job.setMapperClass(classOf[<span class="hljs-type">DistributedSortMapper</span>])<br>  job.setReducerClass(classOf[<span class="hljs-type">DistributedSortReducer</span>])<br>  <span class="hljs-type">FileInputFormat</span>.setInputPaths(job, inputPath)<br>  <span class="hljs-type">FileOutputFormat</span>.setOutputPath(job, outputPath)<br><br>  <span class="hljs-type">System</span>.exit(<span class="hljs-keyword">if</span> (job.waitForCompletion(<span class="hljs-literal">true</span>)) <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>这种分布式排序的缺陷之一在于，只有一个 Reducer，因而限制了该过程的并行性，在性能上不太够。一个解决方案是自定义 Partitioner，<strong>使每个 Reducer 之间接受的 KEY 是有序的</strong>，既然 Reducer 之间是有序的，每个 Reducer 内部都是有序的，则整体就是有序的。Spark 似乎使用类似的分区方式。但这种分区方式是和业务耦合的，需要自定义。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 学习笔记——GROUP BY，JOIN，窗口函数</title>
    <link href="/2022/03-10SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94GROUP-BY%EF%BC%8CJOIN%EF%BC%8C%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0.html"/>
    <url>/2022/03-10SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94GROUP-BY%EF%BC%8CJOIN%EF%BC%8C%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<p>上次去认真学习 SQL 还是 20 年的 12 月，时间才过去 15 个月，但我却觉得恍若隔世。</p><p>最近看书《深入理解 Hadoop》，它对 MapReduce 使用 SQL 语言进行描述，在学习过程中我发现我对之前还不了解的 GROUP BY，聚集函数等概念有了一些更深刻的理解，正巧 Hive，Spark SQL 等都需要一定的 SQL 技术，趁此机会进行进一步的学习，把 GROUP BY，JOIN 等子句好好拿下来。</p><p>为了符合将来工作的需求，使用 Hive 进行描述（但好像其实没有涉及到 Hive 独有的操作）。</p><span id="more"></span><hr><blockquote><p>着实想不到，MapReduce，函数式编程，SQL，感觉三者之间联系颇多。</p></blockquote><h1 id="SQL-各子句执行顺序"><a href="#SQL-各子句执行顺序" class="headerlink" title="SQL 各子句执行顺序"></a>SQL 各子句执行顺序</h1><p>在开始学习之前，先 peek 一下 SQL 的各种子句的执行顺序——</p><ol><li>FROM</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>SELECT</li><li>WINDOW</li><li>ORDER BY</li></ol><p>FROM 子句首先执行，它可能是一个表，视图，或其它的 SELECT 语句，它会根据结果创建一个临时的虚拟表；然后是 WHERE 子句，<strong>对虚拟表中每一行进行筛选操作</strong>，获得一个筛选后的新的虚拟表；然后是 GROUP BY，按照特定字段&#x2F;列簇进行分组；然后是 HAVING 子句，<strong>对各个分组进行筛选操作</strong>，得到筛选后的分组表；SELECT 子句，包含映射和聚集操作，根据查询的列表提取和构造指定列；然后是 SELECT 中的窗口 WINDOW 函数，对 SELECT 的结果进行 OLAP 操作，并将结果作为新的列添加到原 SELECT 结果中；最后是 ORDER BY，对 SELECT 的结果进行排序。</p><p>有两个有趣的地方——WHERE 在 SELECT 之前执行，因此无法利用到 SELECT 中的别名；WHERE 在分组之前执行，用于筛选原表中的数据，而 HAVING 在分组之后执行，用于筛选分组后（但未聚集，这时候的每一条记录，或每一个分组形如<code>(KEY, [COL1, COL2, ...])</code>）的数据，因此 WHERE 中无法使用聚集函数。</p><p>但其实更有趣的是，这顺序和 MapReduce 的顺序非常类似，Hive 的编写者是否也是因为注意到这一点才创造了 Hive？</p><h1 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h1><p>GROUP BY 子句执行分组操作——将记录映射成标识符（通常是特定字段），然后将标识符相同的记录划分为一组，最终得到一个<code>[KEY, Collection[Entity]</code>的集合。</p><p>比如，这里有一个 Student 表，它的数据为——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student_t<br>(<br>    id        <span class="hljs-type">INT</span>,<br>    class_id  <span class="hljs-type">INT</span>,<br>    stud_name STRING,<br>    age       <span class="hljs-type">INT</span>,<br>    <span class="hljs-type">character</span> STRING<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student_t<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, &quot;kikuchi makoto&quot;, <span class="hljs-number">15</span>, &quot;IDOL&quot;),<br>       (<span class="hljs-number">1</span>, <span class="hljs-number">101</span>, &quot;haru urara&quot;, <span class="hljs-number">14</span>, &quot;UMA_MUSUME&quot;),<br>       (<span class="hljs-number">2</span>, <span class="hljs-number">101</span>, &quot;seiun sky&quot;, <span class="hljs-number">16</span>, &quot;UMA_MUSUME&quot;),<br>       (<span class="hljs-number">3</span>, <span class="hljs-number">102</span>, &quot;tokai teio&quot;, <span class="hljs-number">15</span>, &quot;UMA_MUSUME&quot;),<br>       (<span class="hljs-number">4</span>, <span class="hljs-number">102</span>, &quot;takatsuki yayoi&quot;, <span class="hljs-number">16</span>, &quot;IDOL&quot;),<br>       (<span class="hljs-number">5</span>, <span class="hljs-number">103</span>, &quot;silence suzuka&quot;, <span class="hljs-number">16</span>, &quot;UMA_MUSUME&quot;),<br>       (<span class="hljs-number">6</span>, <span class="hljs-number">104</span>, &quot;amami haruka&quot;, <span class="hljs-number">17</span>,&quot;IDOL&quot;),<br>       (<span class="hljs-number">7</span>, <span class="hljs-number">104</span>, &quot;kisaragi chihaya&quot;, <span class="hljs-number">16</span>,&quot;IDOL&quot;);<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student_t;<br>id class_id   name                age <span class="hljs-type">character</span><br><span class="hljs-comment">--------------------------------------------------</span><br><span class="hljs-number">0</span>  <span class="hljs-number">101</span>       &quot;kikuchi makoto&quot;     <span class="hljs-number">16</span>  &quot;IDOL&quot;<br><span class="hljs-number">1</span>  <span class="hljs-number">101</span>       &quot;haru urara&quot;         <span class="hljs-number">14</span>  &quot;UMA_MUSUME&quot;<br><span class="hljs-number">2</span>  <span class="hljs-number">101</span>       &quot;seiun sky&quot;          <span class="hljs-number">16</span>  &quot;UMA_MUSUME&quot;<br><span class="hljs-number">3</span>  <span class="hljs-number">102</span>       &quot;tokai teio&quot;         <span class="hljs-number">15</span>  &quot;UMA_MUSUME&quot;<br><span class="hljs-number">4</span>  <span class="hljs-number">102</span>       &quot;takatsuki yayoi&quot;    <span class="hljs-number">16</span>  &quot;IDOL&quot;<br><span class="hljs-number">5</span>  <span class="hljs-number">103</span>       &quot;silence suzuka&quot;     <span class="hljs-number">16</span>  &quot;UMA_MUSUME&quot;<br><span class="hljs-number">6</span>  <span class="hljs-number">104</span>       &quot;amami haruka&quot;       <span class="hljs-number">17</span>  &quot;IDOL&quot;<br><span class="hljs-number">7</span>  <span class="hljs-number">104</span>       &quot;kisaragi chihaya&quot;   <span class="hljs-number">16</span>  &quot;IDOL&quot;<br></code></pre></div></td></tr></table></figure><p>按班级 ID 分组后，相当于是得到了一个这样的临时表，由于 SQL 的列必须是原子的，因此这个表是虚拟的——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student_t <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class_id; <span class="hljs-comment">-- 无法编译！</span><br><br>key(class_id) <span class="hljs-keyword">value</span>(id class_id)  name                age <span class="hljs-type">character</span><br><span class="hljs-comment">----------------------------------------------------------------------</span><br><span class="hljs-number">101</span>                 <span class="hljs-number">0</span>  <span class="hljs-number">101</span>       &quot;kikuchi makoto&quot;     <span class="hljs-number">15</span>  &quot;IDOL&quot;<br>                    <span class="hljs-number">1</span>  <span class="hljs-number">101</span>       &quot;haru urara&quot;         <span class="hljs-number">14</span>  &quot;UMA_MUSUME&quot;<br>                    <span class="hljs-number">2</span>  <span class="hljs-number">101</span>       &quot;seiun sky&quot;          <span class="hljs-number">16</span>  &quot;UMA_MUSUME&quot;<br><span class="hljs-comment">----------------------------------------------------------------------</span><br><span class="hljs-number">102</span>                 <span class="hljs-number">3</span>  <span class="hljs-number">102</span>       &quot;tokai teio&quot;         <span class="hljs-number">15</span>  &quot;UMA_MUSUME&quot;<br>                    <span class="hljs-number">4</span>  <span class="hljs-number">102</span>       &quot;takatsuki yayoi&quot;    <span class="hljs-number">16</span>  &quot;IDOL&quot;<br><span class="hljs-comment">----------------------------------------------------------------------</span><br><span class="hljs-number">103</span>                 <span class="hljs-number">5</span>  <span class="hljs-number">103</span>       &quot;silence suzuka&quot;     <span class="hljs-number">16</span>  &quot;UMA_MUSUME&quot;<br><span class="hljs-comment">----------------------------------------------------------------------</span><br><span class="hljs-number">104</span>                 <span class="hljs-number">6</span>  <span class="hljs-number">104</span>       &quot;amami haruka&quot;       <span class="hljs-number">17</span>  &quot;IDOL&quot;<br>                    <span class="hljs-number">7</span>  <span class="hljs-number">104</span>       &quot;kisaragi chihaya&quot;   <span class="hljs-number">16</span>  &quot;IDOL&quot;<br></code></pre></div></td></tr></table></figure><p>这样的临时表是不合法的，我们必须要通过某种方式将 value 从集合变成原子的值，这种方式就是<strong>聚集函数</strong>（Aggregation Function），<strong>聚集函数将分组中的某一列作为参数，并得到一个原子的值</strong>。常见的聚集函数有 COUNT，AVG，MIN，MAX 等。</p><blockquote><p>COUNT 是个特例——它可以选择接受整个分组而非某一列作为参数，语法为 <code>COUNT(*)</code>或<code>COUNT（任意非 NULL 常值）</code>，这样定义的原因是 COUNT 按特定列统计时会忽略 NULL，这在需要统计所有行数时行为不符合需要。</p></blockquote><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>比如，当我们试图获取每个班级的平均年龄的时候，会使用 AVG 聚集函数，使用 age 列作为参数，它会将每个分组的 age 列变成一行并作为参数（列转行？），并得到其平均值，比如对班级 101，会得到<code>AVG(15,14,16)</code>，结果为——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> class_id, <span class="hljs-built_in">AVG</span>(age) <span class="hljs-keyword">AS</span> average_age <span class="hljs-keyword">FROM</span> student_t <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class_id;<br>class_id    average_age<br><span class="hljs-comment">--------------------------</span><br><span class="hljs-number">101</span>         <span class="hljs-built_in">AVG</span>(<br>              <span class="hljs-number">15</span>,<br>              <span class="hljs-number">14</span>,<br>              <span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">15</span><br><span class="hljs-comment">--------------------------</span><br><span class="hljs-number">102</span>         <span class="hljs-built_in">AVG</span>(<br>              <span class="hljs-number">15</span>,<br>              <span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">15.5</span><br><span class="hljs-comment">--------------------------</span><br><span class="hljs-number">103</span>         <span class="hljs-built_in">AVG</span>(<span class="hljs-number">16</span>) <span class="hljs-operator">=</span> <span class="hljs-number">16</span><br><span class="hljs-comment">--------------------------</span><br><span class="hljs-number">104</span>         <span class="hljs-built_in">AVG</span>(<br>              <span class="hljs-number">17</span>,<br>              <span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">16.5</span><br></code></pre></div></td></tr></table></figure><p>也<strong>可以在多个列上进行聚集操作</strong>，比如这里获取了每个班级的最大年龄，最小年龄，每个列会分别进行聚集。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>  class_id, <br>  <span class="hljs-built_in">MAX</span>(age) <span class="hljs-keyword">AS</span> maximum_age,<br>  <span class="hljs-built_in">MIN</span>(age) <span class="hljs-keyword">AS</span> minimum_age<br><span class="hljs-keyword">FROM</span> student_t <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class_id;<br><br>class_id    maximum_age      minimum_age<br><span class="hljs-comment">-----------------------------------------</span><br><span class="hljs-number">101</span>         <span class="hljs-built_in">MAX</span>(             <span class="hljs-built_in">MIN</span>(<br>              <span class="hljs-number">15</span>,              <span class="hljs-number">15</span>,<br>              <span class="hljs-number">14</span>,              <span class="hljs-number">14</span>,<br>              <span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">16</span>       <span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">14</span><br><span class="hljs-comment">-----------------------------------------</span><br><span class="hljs-number">102</span>         <span class="hljs-built_in">MAX</span>(             <span class="hljs-built_in">MIN</span>(<br>              <span class="hljs-number">15</span>,              <span class="hljs-number">15</span>,<br>              <span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">16</span>       <span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">15</span><br><span class="hljs-comment">-----------------------------------------</span><br><span class="hljs-number">103</span>         <span class="hljs-built_in">MAX</span>(<span class="hljs-number">16</span>) <span class="hljs-operator">=</span> <span class="hljs-number">16</span>     <span class="hljs-built_in">MIN</span>(<span class="hljs-number">16</span>) <span class="hljs-operator">=</span> <span class="hljs-number">16</span><br><span class="hljs-comment">-----------------------------------------</span><br><span class="hljs-number">104</span>         <span class="hljs-built_in">MAX</span>(             <span class="hljs-built_in">MIN</span>(<br>              <span class="hljs-number">17</span>,              <span class="hljs-number">17</span>,<br>              <span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">17</span>       <span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">16</span><br></code></pre></div></td></tr></table></figure><p><strong>聚集函数中也可以使用表达式</strong>，比如我们想要统计每个班级中 IDOL 的数量，筛选 IDOL 的操作既可以使用 WHERE 进行，也可以在聚集函数中进行——我们可以使用<code>count(if(character = &quot;IDOL&quot;, 1, NULL))</code>，这借用了 count 函数如果接受到 NULL 则跳过这一特性——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> class_id, <span class="hljs-built_in">COUNT</span>(IF(<span class="hljs-type">character</span> <span class="hljs-operator">=</span> &quot;IDOL&quot;, <span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>)) <span class="hljs-keyword">as</span> idol_num<br><span class="hljs-keyword">FROM</span> student_t <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class_id;<br><br>class_id     idol_num<br><span class="hljs-comment">------------------------------------------------------</span><br><span class="hljs-number">101</span>          <span class="hljs-built_in">COUNT</span>(<br>               if(&quot;IDOL&quot; <span class="hljs-operator">=</span> &quot;IDOL&quot;, <span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>),<br>               if(&quot;UMA_MUSUME&quot; <span class="hljs-operator">=</span> &quot;IDOL&quot;, <span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>),<br>               if(&quot;UMA_MUSUME&quot; <span class="hljs-operator">=</span> &quot;IDOL&quot;, <span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>)) <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-comment">------------------------------------------------------</span><br><span class="hljs-number">102</span>          <span class="hljs-built_in">COUNT</span>(<br>               if(&quot;UMA_MUSUME&quot; <span class="hljs-operator">=</span> &quot;IDOL&quot;, <span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>),<br>               if(&quot;IDOL&quot; <span class="hljs-operator">=</span> &quot;IDOL&quot;, <span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>))       <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-comment">------------------------------------------------------</span><br><span class="hljs-number">103</span>          <span class="hljs-built_in">COUNT</span>(<br>               if(&quot;UMA_MUSUME&quot; <span class="hljs-operator">=</span> &quot;IDOL&quot;, <span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>)) <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-comment">------------------------------------------------------</span><br><span class="hljs-number">104</span>          <span class="hljs-built_in">COUNT</span>(<br>               if(&quot;IDOL&quot; <span class="hljs-operator">=</span> &quot;IDOL&quot;, <span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>),<br>               if(&quot;IDOL&quot; <span class="hljs-operator">=</span> &quot;IDOL&quot;, <span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>))       <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p><strong>将聚集函数看作对一整个列进行的操作，我认为是一个很合适的理解的方法</strong>。同时，从函数式编程的角度，可以把聚集函数内的表达式当作一个<strong>函数字面量</strong>（它是 lazy 的），使用 Scala 来表述的话，就类似<code>count(if (_.character == &quot;IDOL&quot;) 1 else null)</code>，其中<code>_</code>为每一行的记录。</p><blockquote><p>需注意，SELECT 选择的值必须是原子的，因此能选择的字段只能为<strong>分组的 key</strong>，<strong>聚集函数操作后的列</strong>；以及常数；后面提到的 HAVING 子句也有同样的限制。</p></blockquote><p>顺便，没有 GROUP BY 的时候，也可以执行聚集函数，此时整个表会被当成一个分组对待，没有 KEY。</p><p>GROUP BY 在某些时候行为同 SELECT DISTINCT 一致，性能似乎也不相伯仲（Hive 是这样吗？我不确定），因此究竟使用何种方法还是看语义，使用 GROUP BY 来做去重，语义是不太明显的。</p><p>另外，某些看上去非常简单的操作可能是一条 SELECT 语句无法完成的，比如获取年龄最小的 IDOL 的记录，需要一个嵌套的 SELECT 操作，其中内层使用 GROUP BY，获取最小的 IDOL 的年龄的值，外层使用相等比较符来找到年龄同该最小年龄相等的记录——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student_t<br><span class="hljs-keyword">WHERE</span> <span class="hljs-type">character</span> <span class="hljs-operator">=</span> &quot;IDOL&quot; <span class="hljs-keyword">AND</span> <br>age <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(age) <span class="hljs-keyword">FROM</span> student_t <span class="hljs-keyword">WHERE</span> <span class="hljs-type">character</span> <span class="hljs-operator">=</span> &quot;IDOL&quot;);<br></code></pre></div></td></tr></table></figure><h2 id="WHERE-和-HAVING"><a href="#WHERE-和-HAVING" class="headerlink" title="WHERE 和 HAVING"></a>WHERE 和 HAVING</h2><p>在使用 GROUP BY 的语句中，WHERE 和 HAVING 可以提供筛选操作，其中 <strong>WHERE 在分组前进行筛选，HAVING 在分组后进行筛选</strong>。或者说，<strong>WHERE 指定行的条件，HAVING 指定组的条件</strong>。</p><h3 id="GROUP-BY-中的-WHERE"><a href="#GROUP-BY-中的-WHERE" class="headerlink" title="GROUP BY 中的 WHERE"></a>GROUP BY 中的 WHERE</h3><p>考虑我们想筛选每个 class 中所有 IDOL 的平均年龄，我们就需要首先通过 WHERE 子句筛选出所有 IDOL，再进行分组——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> class_id, <span class="hljs-built_in">AVG</span>(age) <span class="hljs-keyword">as</span> average_age <span class="hljs-keyword">FROM</span> student_t<br><span class="hljs-keyword">WHERE</span> <span class="hljs-type">character</span> <span class="hljs-operator">=</span> &quot;IDOL&quot;<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class_id;<br><br>class_id    average_age<br><span class="hljs-comment">--------------------------</span><br><span class="hljs-number">101</span>         <span class="hljs-built_in">AVG</span>(<span class="hljs-number">15</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">15</span><br><span class="hljs-comment">--------------------------</span><br><span class="hljs-number">102</span>         <span class="hljs-built_in">AVG</span>(<span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">16</span><br><span class="hljs-comment">--------------------------</span><br><span class="hljs-number">104</span>         <span class="hljs-built_in">AVG</span>(<br>              <span class="hljs-number">17</span>,<br>              <span class="hljs-number">16</span>)   <span class="hljs-operator">=</span> <span class="hljs-number">16.5</span><br></code></pre></div></td></tr></table></figure><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><p>HAGVING 子句用在对分组后对数据进行筛选中，比如对上面的例子，我们进一步想要获取平均年龄大于 15 的班级，这时候就需要使用 HAVING 子句——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> class_id, <span class="hljs-built_in">AVG</span>(age) <span class="hljs-keyword">as</span> average_age <span class="hljs-keyword">FROM</span> student_t<br><span class="hljs-keyword">WHERE</span> <span class="hljs-type">character</span> <span class="hljs-operator">=</span> &quot;IDOL&quot;<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class_id<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(age) <span class="hljs-operator">&gt;</span> <span class="hljs-number">15</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">16</span> <span class="hljs-keyword">in</span> age;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-----------+</span><br><span class="hljs-operator">|</span>class_id<span class="hljs-operator">|</span>average_age<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-----------+</span><br><span class="hljs-operator">|</span><span class="hljs-number">102</span>     <span class="hljs-operator">|</span><span class="hljs-number">16</span>         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">104</span>     <span class="hljs-operator">|</span><span class="hljs-number">17</span>         <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-----------+</span><br><span class="hljs-comment">-- 懒得画表了，直接出结果</span><br></code></pre></div></td></tr></table></figure><p>由于 HAVING 在 GROUP BY 后执行，它可以执行聚集函数。</p><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>在使用聚集函数时，能通过 DISTINCT 关键字能筛选出列的重复的字段，比如<code>COUNT(DISTINCT age)</code>，能统计出不同年龄的数量，如<code>15,15,17,16,17</code>，筛去重复值后得到<code>15,17,16</code>，结果为 3。</p><h2 id="关联子查询——引用外部查询的变量"><a href="#关联子查询——引用外部查询的变量" class="headerlink" title="关联子查询——引用外部查询的变量"></a>关联子查询——引用外部查询的变量</h2><p>上面展示了获取<strong>所有班级中</strong>年龄最小的学生的 SQL 代码——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student_t<br><span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(age) <span class="hljs-keyword">FROM</span> student_t);<br><span class="hljs-operator">+</span><span class="hljs-comment">--+--------+----------+---+----------+</span><br><span class="hljs-operator">|</span>id<span class="hljs-operator">|</span>class_id<span class="hljs-operator">|</span>stud_name <span class="hljs-operator">|</span>age<span class="hljs-operator">|</span><span class="hljs-type">character</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--+--------+----------+---+----------+</span><br><span class="hljs-operator">|</span><span class="hljs-number">1</span> <span class="hljs-operator">|</span><span class="hljs-number">101</span>     <span class="hljs-operator">|</span>haru urara<span class="hljs-operator">|</span><span class="hljs-number">14</span> <span class="hljs-operator">|</span>UMA_MUSUME<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--+--------+----------+---+----------+</span><br></code></pre></div></td></tr></table></figure><p>这里使用了所谓<strong>子查询</strong>的模式——<code>(SELECT MIN(age) FROM student_t)</code>是一个嵌套的 SELECT 语句，它用于获得最小的年龄数；同时，由于不使用聚集函数时，整个表会被当成一个分组对待，所以这个 SELECT 的输出是一行一列的，一行一列的表可以当作标量看待，因此可以和 age 做比较。</p><p>那么如果我们想要获取<strong>每一个班级</strong>中年龄最小的学生呢？可以意识到，<strong>对每一个学生，她都需要与当前班级的最小年龄做比较</strong>，因此，在子查询中，<strong>需要利用到当前（的 WHERE 子句）所处理的行的班级信息</strong>，代码如下——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student_t <span class="hljs-keyword">AS</span> s1<br><span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(age) <span class="hljs-keyword">FROM</span> student_t <span class="hljs-keyword">AS</span> s2 <span class="hljs-keyword">WHERE</span> s1.class_id <span class="hljs-operator">=</span> s2.class_id);<br><span class="hljs-operator">+</span><span class="hljs-comment">--+--------+----------------+---+----------+</span><br><span class="hljs-operator">|</span>id<span class="hljs-operator">|</span>class_id<span class="hljs-operator">|</span>stud_name       <span class="hljs-operator">|</span>age<span class="hljs-operator">|</span><span class="hljs-type">character</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--+--------+----------------+---+----------+</span><br><span class="hljs-operator">|</span><span class="hljs-number">1</span> <span class="hljs-operator">|</span><span class="hljs-number">101</span>     <span class="hljs-operator">|</span>haru urara      <span class="hljs-operator">|</span><span class="hljs-number">14</span> <span class="hljs-operator">|</span>UMA_MUSUME<span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">3</span> <span class="hljs-operator">|</span><span class="hljs-number">102</span>     <span class="hljs-operator">|</span>tokai teio      <span class="hljs-operator">|</span><span class="hljs-number">15</span> <span class="hljs-operator">|</span>UMA_MUSUME<span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">5</span> <span class="hljs-operator">|</span><span class="hljs-number">103</span>     <span class="hljs-operator">|</span>silence suzuka  <span class="hljs-operator">|</span><span class="hljs-number">16</span> <span class="hljs-operator">|</span>UMA_MUSUME<span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">6</span> <span class="hljs-operator">|</span><span class="hljs-number">104</span>     <span class="hljs-operator">|</span>amami haruka    <span class="hljs-operator">|</span><span class="hljs-number">17</span> <span class="hljs-operator">|</span>IDOL      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">7</span> <span class="hljs-operator">|</span><span class="hljs-number">104</span>     <span class="hljs-operator">|</span>kisaragi chihaya<span class="hljs-operator">|</span><span class="hljs-number">17</span> <span class="hljs-operator">|</span>IDOL      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--+--------+----------------+---+----------+</span><br></code></pre></div></td></tr></table></figure><p>这里由于两个 SELECT 查询都为同一个表，因此需要给定不同别名以进行区分。可以发现，内部的子查询引用了外部的行的一个字段，进行了这种引用的查询称作<strong>关联子查询</strong>，它的行为非常类似<strong>闭包</strong>。</p><p>需要注意的是，普通的子查询是一次执行即可的，而对于关联子查询，<strong>如果它引用的外界的变量发生改变，它就必须需要重新计算</strong>（因为它已经不够“纯”了），因此可能性能会较差一些。</p><blockquote><p>之前看日本人的《SQL 基础教程》，介绍到关联子查询时说，利用被划分的组进行比较的子查询就是关联子查询，这种说法有些狭隘，没有覆盖到所有情况。但此书确实值得一看。</p></blockquote><h1 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h1><p>主要参考 <a href="https://blog.jooq.org/say-no-to-venn-diagrams-when-explaining-joins">这篇文章</a>。这里为了一致性，只使用<code>tb1 [LEFT|RIGHT] JOIN tb2 ON expr</code>的语法。</p><p>JOIN 操作即将两张或更多张表进行连接，从而构造一个新的表的操作。<strong>JOIN 操作的本质就是将两张表做笛卡尔积，并进行一定的筛选操作</strong>。</p><p>最基础的 JOIN 操作为<code>CROSS JOIN</code>，即单纯将两张表做笛卡尔积操作，得到新的表。</p><p>比如，考虑下面两张表，它们的 id 字段是同义的。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb1(data STRING, id <span class="hljs-type">INT</span>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb2(id <span class="hljs-type">INT</span>, data STRING);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb1 <span class="hljs-keyword">VALUES</span><br>(&quot;amami&quot;, <span class="hljs-number">0</span>),<br>(&quot;kisaragi&quot;, <span class="hljs-number">1</span>),<br>(&quot;tokai&quot;, <span class="hljs-number">2</span>),<br>(&quot;haru&quot;, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb2 <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">2</span>, &quot;teio&quot;),<br>(<span class="hljs-number">3</span>, &quot;urara&quot;),<br>(<span class="hljs-number">4</span>, &quot;sky&quot;); <span class="hljs-comment">-- 我 INSERT 类型写错了它怎么不报错啊……太宽松了吧</span><br></code></pre></div></td></tr></table></figure><p>两表字段的对应关系可以这样表示——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">data         id   data<br><span class="hljs-comment">-------------------------</span><br>   &quot;amami&quot;   <span class="hljs-number">0</span><br>&quot;kisaragi&quot;   <span class="hljs-number">1</span><br>   &quot;tokai&quot;   <span class="hljs-number">2</span>    &quot;teio&quot;<br>    &quot;haru&quot;   <span class="hljs-number">3</span>    &quot;urara&quot;<br>             <span class="hljs-number">4</span>    &quot;sky&quot;<br></code></pre></div></td></tr></table></figure><blockquote><p>需注意的是，这种对应关系可能不是唯一的，表 A 的某条记录，它可能可以和表 B 的多条记录对应，Vise Versa。</p></blockquote><h2 id="CROSS-JOIN"><a href="#CROSS-JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h2><p><code>CROSS JOIN</code>的语法非常简单，直接在 FROM 中的表名位置协商<code>tb1 JOIN tb2</code>即可——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tb1 <span class="hljs-keyword">JOIN</span> tb2;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--+--+-----+</span><br><span class="hljs-operator">|</span>data    <span class="hljs-operator">|</span>id<span class="hljs-operator">|</span>id<span class="hljs-operator">|</span>data <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--+--+-----+</span><br><span class="hljs-operator">|</span>amami   <span class="hljs-operator">|</span><span class="hljs-number">0</span> <span class="hljs-operator">|</span><span class="hljs-number">2</span> <span class="hljs-operator">|</span>teio <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>amami   <span class="hljs-operator">|</span><span class="hljs-number">0</span> <span class="hljs-operator">|</span><span class="hljs-number">3</span> <span class="hljs-operator">|</span>urara<span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>amami   <span class="hljs-operator">|</span><span class="hljs-number">0</span> <span class="hljs-operator">|</span><span class="hljs-number">4</span> <span class="hljs-operator">|</span>sky  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>kisaragi<span class="hljs-operator">|</span><span class="hljs-number">1</span> <span class="hljs-operator">|</span><span class="hljs-number">2</span> <span class="hljs-operator">|</span>teio <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>kisaragi<span class="hljs-operator">|</span><span class="hljs-number">1</span> <span class="hljs-operator">|</span><span class="hljs-number">3</span> <span class="hljs-operator">|</span>urara<span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>kisaragi<span class="hljs-operator">|</span><span class="hljs-number">1</span> <span class="hljs-operator">|</span><span class="hljs-number">4</span> <span class="hljs-operator">|</span>sky  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>tokai   <span class="hljs-operator">|</span><span class="hljs-number">2</span> <span class="hljs-operator">|</span><span class="hljs-number">2</span> <span class="hljs-operator">|</span>teio <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>tokai   <span class="hljs-operator">|</span><span class="hljs-number">2</span> <span class="hljs-operator">|</span><span class="hljs-number">3</span> <span class="hljs-operator">|</span>urara<span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>tokai   <span class="hljs-operator">|</span><span class="hljs-number">2</span> <span class="hljs-operator">|</span><span class="hljs-number">4</span> <span class="hljs-operator">|</span>sky  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>haru    <span class="hljs-operator">|</span><span class="hljs-number">3</span> <span class="hljs-operator">|</span><span class="hljs-number">2</span> <span class="hljs-operator">|</span>teio <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--+--+-----+</span><br></code></pre></div></td></tr></table></figure><p>可以看到结果符合预期，为 tb1 和 tb2 的笛卡尔积，长度为 4x3&#x3D;12。</p><p>但是，笛卡尔积通常是没有实践意义的，通常找不到直接使用笛卡尔积的场景，但笛卡尔积是其它连接操作的基础，都是在笛卡尔积上进行一定的筛选的结果。</p><h2 id="INNER-JOIN（内连接）"><a href="#INNER-JOIN（内连接）" class="headerlink" title="INNER JOIN（内连接）"></a>INNER JOIN（内连接）</h2><p>内连接或许是最符合直觉的连接操作了，它在笛卡尔积的基础上使用一个表达式进行筛选，最常用的表达式是让两张表中相同字段判等，比如在这里，就是<code>tb1.id = tb2.id</code>，SQL 语句见下——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> tb1.data, tb1.id, tb2.data <span class="hljs-keyword">FROM</span> <br>tb1 <span class="hljs-keyword">JOIN</span> tb2 <span class="hljs-keyword">ON</span> tb1.id <span class="hljs-operator">=</span> tb2.id;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----+--+-----+</span><br><span class="hljs-operator">|</span>data <span class="hljs-operator">|</span>id<span class="hljs-operator">|</span>data <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+--+-----+</span><br><span class="hljs-operator">|</span>tokai<span class="hljs-operator">|</span><span class="hljs-number">2</span> <span class="hljs-operator">|</span>teio <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>haru <span class="hljs-operator">|</span><span class="hljs-number">3</span> <span class="hljs-operator">|</span>urara<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+--+-----+</span><br></code></pre></div></td></tr></table></figure><p>可以看到，结果中只有匹配该条件的记录。</p><p>内连接得到的结果表的记录数量小于表一和表二。</p><h2 id="OUTER-JOIN（外连接）"><a href="#OUTER-JOIN（外连接）" class="headerlink" title="OUTER JOIN（外连接）"></a>OUTER JOIN（外连接）</h2><p>然后是外连接，外连接分为左外连接（LEFT [OUTER] JOIN）和右外连接（RIGHT [OUTER] JOIN），其中左外连接在内连接的基础上，对左边的表（称为主表），如果其某条记录在右边的表中没有匹配的，则仍旧将该记录作为结果，其中对应右表的字段设定为 NULL；右外连接则是以右边的表作为主表进行上面的操作。</p><p>下面展示了左外连接和右外连接的结果。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> tb1.data, tb1.id, tb2.data <span class="hljs-keyword">FROM</span><br>tb1 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> tb2 <span class="hljs-keyword">ON</span> tb1.id <span class="hljs-operator">=</span> tb2.id;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--+-----+</span><br><span class="hljs-operator">|</span>data    <span class="hljs-operator">|</span>id<span class="hljs-operator">|</span>data <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--+-----+</span><br><span class="hljs-operator">|</span>amami   <span class="hljs-operator">|</span><span class="hljs-number">0</span> <span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>kisaragi<span class="hljs-operator">|</span><span class="hljs-number">1</span> <span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>tokai   <span class="hljs-operator">|</span><span class="hljs-number">2</span> <span class="hljs-operator">|</span>teio <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>haru    <span class="hljs-operator">|</span><span class="hljs-number">3</span> <span class="hljs-operator">|</span>urara<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--+-----+</span><br><br><span class="hljs-keyword">SELECT</span> tb1.data, tb1.id, tb2.data <span class="hljs-keyword">FROM</span><br>tb1 <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> tb2 <span class="hljs-keyword">ON</span> tb1.id <span class="hljs-operator">=</span> tb2.id;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----+----+-----+</span><br><span class="hljs-operator">|</span>data <span class="hljs-operator">|</span>id  <span class="hljs-operator">|</span>data <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+----+-----+</span><br><span class="hljs-operator">|</span>tokai<span class="hljs-operator">|</span><span class="hljs-number">2</span>   <span class="hljs-operator">|</span>teio <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>haru <span class="hljs-operator">|</span><span class="hljs-number">3</span>   <span class="hljs-operator">|</span>urara<span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><span class="hljs-keyword">NULL</span><span class="hljs-operator">|</span>sky  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----+----+-----+</span><br></code></pre></div></td></tr></table></figure><p>外连接通常在我们需要<strong>保留主表的信息</strong>的时候，比如对于一个作者表和一个书籍表，我们想表达每个作者编写的数据，这时候如果某个作者没有书籍，我们如果使用内连接的话就会把他漏掉了。</p><p>外连接时，如果用于进行连接的字段是唯一的，则结果表的大小等于主表的大小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用一张图展示内连接，左外连接和右外连接所执行的操作，可用于形象理解。</p><p><img src="/images/oss/20220308201345.png"></p><blockquote><p>这里总共有3个部分，考虑使用其中1个，2个，3个，则总共能得到 C3,1 + C3,2 + C3,3，总共七种连接方式。</p></blockquote><p><strong>JOIN 操作在 FROM 子句执行时执行，因此它是最先执行的，之后的 WHERE，GROUP BY 等操作全都是在 JOIN 后的临时表中执行的</strong>。</p><p>还有一些更复杂的连接操作（一切不使用&#x3D;进行连接的操作都挺复杂的），现在先不研究。</p><h1 id="WINDOW（窗口）函数"><a href="#WINDOW（窗口）函数" class="headerlink" title="WINDOW（窗口）函数"></a>WINDOW（窗口）函数</h1><p>WINDOW 函数是近十年才加入 SQL 的，OLAP 方向的事物，它的名字中的 WINDOW，指的是“滑动窗口”那种窗口，即<strong>范围</strong>，窗口函数就其行为来说，可以认为是<strong>按特定顺序对特定范围的记录进行迭代，且每次迭代都会产生一个值并插入到查询结果中的函数</strong>，它的行为类似** Python 或 js 中的 yield**，维护有自己的状态，或者说函数式编程中的 scan 函数。</p><p>下面的代码使用了 ROW_NUMBER 窗口函数，该函数就像一个计数器，迭代每一行都+1。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 不添加主键实在不是一个好主意，主键应当是每一个表都有的，不然不符合2NF了</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb(data <span class="hljs-type">INT</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">100</span>),(<span class="hljs-number">101</span>),(<span class="hljs-number">101</span>),(<span class="hljs-number">102</span>),(<span class="hljs-number">102</span>),(<span class="hljs-number">102</span>),(<span class="hljs-number">103</span>);<br><br><span class="hljs-keyword">SELECT</span> data, <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> data) <span class="hljs-keyword">FROM</span> tb;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-operator">|</span>data<span class="hljs-operator">|</span>number<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-operator">|</span><span class="hljs-number">100</span> <span class="hljs-operator">|</span><span class="hljs-number">1</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">101</span> <span class="hljs-operator">|</span><span class="hljs-number">2</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">101</span> <span class="hljs-operator">|</span><span class="hljs-number">3</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">102</span> <span class="hljs-operator">|</span><span class="hljs-number">4</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">102</span> <span class="hljs-operator">|</span><span class="hljs-number">5</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">102</span> <span class="hljs-operator">|</span><span class="hljs-number">6</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">103</span> <span class="hljs-operator">|</span><span class="hljs-number">7</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br></code></pre></div></td></tr></table></figure><p>相似用途的窗口函数还有 RANK 和 DENSE_RANK，它们的语义一看结果便知。</p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">SELECT data,<br>       RANK() OVER (ORDER BY data) AS ranking,<br>       DENSE_RANK() OVER (ORDER BY data) AS dense_ranking,<br>       ROW_NUMBER() OVER (ORDER BY data) AS row_num<br>FROM tb;<br>+----+-------+-------------+-------+<br>|<span class="hljs-string">data</span>|<span class="hljs-string">ranking</span>|<span class="hljs-string">dense_ranking</span>|<span class="hljs-string">row_num</span>|<br>+----+-------+-------------+-------+<br>|<span class="hljs-string">100 </span>|<span class="hljs-string">1      </span>|<span class="hljs-string">1            </span>|<span class="hljs-string">1      </span>|<br>|<span class="hljs-string">101 </span>|<span class="hljs-string">2      </span>|<span class="hljs-string">2            </span>|<span class="hljs-string">2      </span>|<br>|<span class="hljs-string">101 </span>|<span class="hljs-string">2      </span>|<span class="hljs-string">2            </span>|<span class="hljs-string">3      </span>|<br>|<span class="hljs-string">102 </span>|<span class="hljs-string">4      </span>|<span class="hljs-string">3            </span>|<span class="hljs-string">4      </span>|<br>|<span class="hljs-string">102 </span>|<span class="hljs-string">4      </span>|<span class="hljs-string">3            </span>|<span class="hljs-string">5      </span>|<br>|<span class="hljs-string">102 </span>|<span class="hljs-string">4      </span>|<span class="hljs-string">3            </span>|<span class="hljs-string">6      </span>|<br>|<span class="hljs-string">103 </span>|<span class="hljs-string">7      </span>|<span class="hljs-string">4            </span>|<span class="hljs-string">7      </span>|<br>+----+-------+-------------+-------+<br><br></code></pre></div></td></tr></table></figure><p>窗口函数的语法形如<code>fn() OVER ([PARTITION BY field] ORDER BY field)</code>，其中 PARTITON BY 子句用于给定分组（即确定记录的范围，它会对每一个组都分别执行该窗口函数；如果不给定范围，则默认整个表作为范围）；ORDER BY 子句用于给定调用顺序，顺序是必须给定的，这是容易理解的——对于这种有状态的函数，如果调用顺序不确定，则结果也不确定了。</p><p>窗口函数有两个重要特性——</p><ol><li>窗口函数对<strong>记录的集合</strong>起作用，这是说它对<strong>整个表</strong>或者<strong>每个分组</strong>进行操作；这一点很类似聚集函数，但<strong>聚集函数处理完一整个集合生成的是一个值，而窗口函数生成一列值</strong>。</li><li>窗口函数在 SELECT 后执行，因此它只能对 SELECT 的结果进行操作。</li></ol><p>聚集函数也可以用作窗口函数，此时它的行为类似函数式编程中的 scan 函数——在 reduce 时保留之前的结果，比如下面使用了 SUM 作为窗口函数；<strong>使用聚集函数作为窗口函数时，需要将要聚集的字段置于函数的括号中</strong>——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <br>  data, <br>  <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> DATA) <span class="hljs-keyword">AS</span> id, <br>  <span class="hljs-built_in">SUM</span>(data) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id) <br><span class="hljs-keyword">FROM</span> tb;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+--+------------+</span><br><span class="hljs-operator">|</span>data<span class="hljs-operator">|</span>id<span class="hljs-operator">|</span>sum_window_1<span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+--+------------+</span><br><span class="hljs-operator">|</span><span class="hljs-number">100</span> <span class="hljs-operator">|</span><span class="hljs-number">1</span> <span class="hljs-operator">|</span><span class="hljs-number">100</span>         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">101</span> <span class="hljs-operator">|</span><span class="hljs-number">3</span> <span class="hljs-operator">|</span><span class="hljs-number">201</span>         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">101</span> <span class="hljs-operator">|</span><span class="hljs-number">2</span> <span class="hljs-operator">|</span><span class="hljs-number">302</span>         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">102</span> <span class="hljs-operator">|</span><span class="hljs-number">6</span> <span class="hljs-operator">|</span><span class="hljs-number">404</span>         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">102</span> <span class="hljs-operator">|</span><span class="hljs-number">5</span> <span class="hljs-operator">|</span><span class="hljs-number">506</span>         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">102</span> <span class="hljs-operator">|</span><span class="hljs-number">4</span> <span class="hljs-operator">|</span><span class="hljs-number">608</span>         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span><span class="hljs-number">103</span> <span class="hljs-operator">|</span><span class="hljs-number">7</span> <span class="hljs-operator">|</span><span class="hljs-number">711</span>         <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+--+------------+</span><br></code></pre></div></td></tr></table></figure><p>这里特意创建了一列 ID 让 SUM 用以排序，这是因为 SUM 对单行数据的结果非常奇怪，怀疑这是某种优化机制导致的。</p><blockquote><p>学到后面的 ROW 的语法后，感觉这里的抽象不太合适。</p></blockquote><p>下面使用 Scala 中的 scan 函数实现 ROW_NUMBER，DENSE_RANK，RANK 函数，尽量按照函数式编程的风格。如果并非产生该列，而是产生原纪录连带该列时，我觉得使用 reduce 更为适合（想想当时是如何使用 reduce 实现 map 的），但这时候的代码恐怕会太过晦涩。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">row_number</span></span>[<span class="hljs-type">A</span>] (entities : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] =<br>  entities.scanLeft(<span class="hljs-number">0</span>)&#123;(acc, _) =&gt; acc + <span class="hljs-number">1</span>&#125;.tail<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dense_rank</span></span>[<span class="hljs-type">A</span>] (entities : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vars</span>(<span class="hljs-params">last : <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] = <span class="hljs-type">None</span>, rank : <span class="hljs-type">Int</span> = 0</span>)</span><br>  entities.scanLeft(<span class="hljs-type">Vars</span>())&#123; (acc, entity) =&gt;<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">Vars</span>(last, rank) = acc<br>    last <span class="hljs-keyword">match</span> &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">Vars</span>(<span class="hljs-type">Some</span>(entity), rank + <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(lastEntity) <span class="hljs-keyword">if</span> (lastEntity == entity) =&gt; <span class="hljs-type">Vars</span>(<span class="hljs-type">Some</span>(entity), rank)<br>      <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Vars</span>(<span class="hljs-type">Some</span>(entity), rank + <span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;.map(_.rank).tail<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rank</span></span>[<span class="hljs-type">A</span>] (entities : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vars</span>(<span class="hljs-params">last : <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] = <span class="hljs-type">None</span>, counter : <span class="hljs-type">Int</span> = 0, rank : <span class="hljs-type">Int</span> = 0</span>)</span><br>  entities.scanLeft(<span class="hljs-type">Vars</span>())&#123;(acc, entity) =&gt;<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">Vars</span>(last, counter, rank) = acc<br>    last <span class="hljs-keyword">match</span> &#123;<br>      <span class="hljs-comment">// 对第一个元素</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">Vars</span>(<span class="hljs-type">Some</span>(entity), counter + <span class="hljs-number">1</span>, rank + <span class="hljs-number">1</span>)<br>      <span class="hljs-comment">// 如果当前元素和上一个元素相等</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(lastEntity) <span class="hljs-keyword">if</span> (lastEntity == entity) =&gt;<br>        <span class="hljs-type">Vars</span>(<span class="hljs-type">Some</span>(entity), counter + <span class="hljs-number">1</span>, rank)<br>      <span class="hljs-keyword">case</span> _ =&gt;<br>        <span class="hljs-type">Vars</span>(<span class="hljs-type">Some</span>(entity), <span class="hljs-number">1</span>, rank + counter)<br>    &#125;<br>  &#125;.map(_.rank).tail<br>&#125;<br></code></pre></div></td></tr></table></figure><p>窗口函数（或许限于聚集函数的窗口函数）的行为其实就是，<strong>对每一组的每一行数据，将窗口的开始（默认为该组的开始）到窗口的结束（默认为该行）的记录作为参数传递给窗口函数并获得当前值</strong>。这里使用了“窗口的开始”，“窗口的结束”来描述，是因为窗口的范围是可以让用户通过 ROWS 子句自己指定的，比如一个比较常见的需求是所谓的“移动平均”——对每条记录，它及其周围记录的平均值。</p><hr><p>下一步是继续去学习 Hive，同时期待学习更多 SQL 编写的模式，从而使能够去编写和阅读复杂的查询操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce 开发模式 1——Mapper，Reducer，Combiner，Partitioner</title>
    <link href="/2022/03-06MapReduce%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F1%E2%80%94%E2%80%94Mapper%EF%BC%8CReducer%EF%BC%8CCombiner.html"/>
    <url>/2022/03-06MapReduce%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F1%E2%80%94%E2%80%94Mapper%EF%BC%8CReducer%EF%BC%8CCombiner.html</url>
    
    <content type="html"><![CDATA[<p>开始根据《深入理解 Hadoop》去学习 MapReduce 的编程模式。MapReduce 的接口看上去是十分简单的，但显然，<strong>为了尽量快地能够将其用于工程实践，首先学点模式肯定是最合适的</strong>。</p><p>这里特意使用“<strong>开发模式</strong>”，而非“编程模式”，“设计模式”，这是因为 MapReduce 的编写中，Mapper，Reducer 的设计和 Job 的配置是密不可分的，并且需要程序员对 MapReduce 全流程及其原理有一定的理解，<strong>这里涉及的东西显然不止于编程</strong>（下面的实际内容也偏向理论和原理更多，没多少代码，代码也都很简单），因此我使用“开发模式”这一说法。</p><p>MapReduce 中主要包含 6 个用户可以自定义的组件&#x2F;角色，按照数据的流向为顺序，他们是——</p><ol><li>InputFormat</li><li>Mapper</li><li>Partitioner</li><li>Combiner</li><li>Reducer</li><li>OutputFormat</li></ol><p>各种开发模式主要相关的是中间四个角色，即 Mapper，Combiner，Partitioner，Reducer，先对它们进行了解，同时辅以一些代码示例，使用 Java 和 Scala 表达，之后或许会一直使用 Scala，很性感。</p><hr><p>Hive 证明，SQL 能翻译成 MapReduce 程序，但反过来说，<strong>我们也可以使用 SQL 来说明 MapReduce 的一些模式</strong>——</p><ul><li><strong>SELECT</strong>：即 Map 操作，筛选&#x2F;构造特定列</li><li><strong>WHERE</strong>：即 Filter 操作，筛选特定行（即特定 KV 对，称作行是因为它符合直觉一些）</li><li><strong>AGGREGATION</strong>：即 Reduce，聚集操作，将一个分组聚合成一个值，比如 MAX，MIN，SUM，COUNT 等</li><li><strong>SORTING</strong>：对输出结果进行排序</li><li><strong>JOIN</strong>：根据不同表&#x2F;查询结果的相同列进行连接操作</li></ul><p>十分显然，<strong>Map 阶段可以执行 SELECT，WHERE 操作，Map 阶段同时负责以及 GROUP BY——返回值的 KEY 就是用于分组的字段；而 Reduce 阶段执行的则是 AGGREGATION</strong>。SORTING 和 JOIN 不那么显然，之后再说。排序当前猜测是 Partitioner 执行的。</p><blockquote><p>当然，MapReduce 的能力绝对不限于 SQL，这么说只是因为它更容易理解罢了。我实际上确实有一些怀疑——使用函数式编程的术语对 MR 进行表述是否比 SQL 更容易理解和贴合实际？</p></blockquote><p>学习过程中将试图使用该书中所提到的 <a href="https://community.amstat.org/jointscsg-section/dataexpo/dataexpo2009">航空数据</a>，其为标准的 csv 格式（以及一些 html 文档），解压后得到的 csv 文件内容类似下面，<strong>首行是表头，应当剔除掉</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csv">Year,Month,DayofMonth,DayOfWeek,DepTime,CRSDepTime,ArrTime,CRSArrTime,UniqueCarrier,FlightNum,TailNum,ActualElapsedTime,CRSElapsedTime,AirTime,ArrDelay,DepDelay,Origin,Dest,Distance,TaxiIn,TaxiOut,Cancelled,CancellationCode,Diverted,CarrierDelay,WeatherDelay,NASDelay,SecurityDelay,LateAircraftDelay<br>1987,10,14,3,741,730,912,849,PS,1451,NA,91,79,NA,23,11,SAN,SFO,447,NA,NA,0,NA,0,NA,NA,NA,NA,NA<br>1987,10,15,4,729,730,903,849,PS,1451,NA,94,79,NA,14,-1,SAN,SFO,447,NA,NA,0,NA,0,NA,NA,NA,NA,NA<br>1987,10,17,6,741,730,918,849,PS,1451,NA,97,79,NA,29,11,SAN,SFO,447,NA,NA,0,NA,0,NA,NA,NA,NA,NA<br>1987,10,18,7,729,730,847,849,PS,1451,NA,78,79,NA,-2,-1,SAN,SFO,447,NA,NA,0,NA,0,NA,NA,NA,NA,NA<br>1987,10,19,1,749,730,922,849,PS,1451,NA,93,79,NA,33,19,SAN,SFO,447,NA,NA,0,NA,0,NA,NA,NA,NA,NA<br></code></pre></div></td></tr></table></figure>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">关于各种数据的字段及其说明</span></summary>        <blockquote><table><thead><tr><th align="center">字段名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Year</td><td align="center">该航班的年份（1987 到 2008）</td></tr><tr><td align="center">Month</td><td align="center">月份（1-12）</td></tr><tr><td align="center">DayofMonth</td><td align="center">月份的日期（1-31）</td></tr><tr><td align="center">DayOfWeek</td><td align="center">周几，1&#x3D;周一，7&#x3D;周日</td></tr><tr><td align="center">DepTime</td><td align="center">本地时区的航班起飞时间，HHMM 格式，前不补零，如 753 表示 07:53，1503 表示 15:03</td></tr><tr><td align="center">CRSDepTime</td><td align="center">原定起飞时间，格式同上</td></tr><tr><td align="center">ArrTime</td><td align="center">实际到达时间，格式同上</td></tr><tr><td align="center">CRSArrTime</td><td align="center">原定到达时间，格式同上</td></tr><tr><td align="center">UniqueCarrier</td><td align="center">航空公司代码</td></tr><tr><td align="center">FlightNum</td><td align="center">航班的唯一标识</td></tr><tr><td align="center">TailNum</td><td align="center">飞机的唯一标识</td></tr><tr><td align="center">ActualElapsedTime</td><td align="center">实际飞行时间（分）</td></tr><tr><td align="center">CRSElapsedTime</td><td align="center">原定飞行时间（分）</td></tr><tr><td align="center">AirTIme</td><td align="center">总的飞行时间（分）</td></tr><tr><td align="center">ArrDelay</td><td align="center">到达延迟时间（分）</td></tr><tr><td align="center">DepDelay</td><td align="center">起飞延迟时间（分）</td></tr><tr><td align="center">Origin</td><td align="center">起飞机场代码</td></tr><tr><td align="center">Dest</td><td align="center">目的地机场代码</td></tr><tr><td align="center">Distance</td><td align="center">总飞行距离（英里）</td></tr><tr><td align="center">TaxiIn</td><td align="center">航班到达期间，出租车进入时间（分）</td></tr><tr><td align="center">TaxiOut</td><td align="center">起飞期间，出租车离开时间（分）</td></tr><tr><td align="center">Cancelled</td><td align="center">航班是否取消，1&#x3D;是，0&#x3D;否</td></tr><tr><td align="center">CancellationCode</td><td align="center">取消原因，A&#x3D;承运，B&#x3D;天气，C&#x3D;NAS，D&#x3D;安全问题</td></tr><tr><td align="center">Diverted</td><td align="center">是否改道，1&#x3D;是，0&#x3D;否</td></tr><tr><td align="center">CarrierDelay</td><td align="center">航空公司造成的延误时间（分）</td></tr><tr><td align="center">WeatherDelay</td><td align="center">天气造成的延误时间（分）</td></tr><tr><td align="center">NASDelay</td><td align="center">国家空管系统（NAS）造成的延误时间（分）</td></tr><tr><td align="center">SecurityDelay</td><td align="center">安全原因造成的延误时间（分）</td></tr><tr><td align="center">LateAircraftDelay</td><td align="center">该航班在上个机场到达晚点而造成在本机场到达延迟时间（分）</td></tr></tbody></table><p><strong>一切空值都使用 NA 表示，各个字段都需要考虑 NA 的情况</strong>。</p><p>这里提供一个类来为原始数据建模，方便能快速和类型安全地取得数据，取得特定列的数据的代码见下面 SelectClause 的使用。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">AirlineCol</span> &#123;<br>    Year(<span class="hljs-number">0</span>),<br>    Month(<span class="hljs-number">1</span>),<br>    DayofMonth(<span class="hljs-number">2</span>),<br>    DayOfWeek(<span class="hljs-number">3</span>),<br>    DepTime(<span class="hljs-number">4</span>),<br>    CRSDepTime(<span class="hljs-number">5</span>),<br>    ArrTime(<span class="hljs-number">6</span>),<br>    CRSArrTime(<span class="hljs-number">7</span>),<br>    UniqueCarrier(<span class="hljs-number">8</span>),<br>    FlightNum(<span class="hljs-number">9</span>),<br>    TailNum(<span class="hljs-number">10</span>),<br>    ActualElapsedTime(<span class="hljs-number">11</span>),<br>    CRSElapsedTime(<span class="hljs-number">12</span>),<br>    AirTime(<span class="hljs-number">13</span>),<br>    ArrDelay(<span class="hljs-number">14</span>),<br>    DepDelay(<span class="hljs-number">15</span>),<br>    Origin(<span class="hljs-number">16</span>),<br>    Dest(<span class="hljs-number">17</span>),<br>    Distance(<span class="hljs-number">18</span>),<br>    TaxiIn(<span class="hljs-number">19</span>),<br>    TaxiOut(<span class="hljs-number">20</span>),<br>    Cancelled(<span class="hljs-number">21</span>),<br>    CancellationCode(<span class="hljs-number">22</span>),<br>    Diverted(<span class="hljs-number">23</span>),<br>    CarrierDelay(<span class="hljs-number">24</span>),<br>    WeatherDelay(<span class="hljs-number">25</span>),<br>    NASDelay(<span class="hljs-number">26</span>),<br>    SecurityDelay(<span class="hljs-number">27</span>),<br>    LateAircraftDelay(<span class="hljs-number">28</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> index;<br>    AirlineCol(<span class="hljs-type">int</span> index) &#123;<br>        <span class="hljs-built_in">this</span>.index = index;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 不把 Function 接口直接暴露出去</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ColGetter</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Function&lt;AirlineCol, String&gt; fn;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">ColGetter</span><span class="hljs-params">(Function&lt;AirlineCol, String&gt; fn)</span> &#123;<br>            <span class="hljs-built_in">this</span>.fn = fn;<br>        &#125;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCol</span><span class="hljs-params">(AirlineCol colEnum)</span> &#123;<br>            <span class="hljs-keyword">return</span> fn.apply(colEnum);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ColGetter <span class="hljs-title function_">get</span><span class="hljs-params">(String[] cols)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColGetter</span>((col) -&gt; cols[col.index]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote>            </details>  <p>下面，按照各种子句来一一学习各种开发模式，其中穿插着一些关于 MR 本身的概念。</p><h1 id="Mapper——SELECT-和-WHERE"><a href="#Mapper——SELECT-和-WHERE" class="headerlink" title="Mapper——SELECT 和 WHERE"></a>Mapper——SELECT 和 WHERE</h1><p>典型的 MapReduce 程序主要包含两个阶段——Map 阶段和 Reduce 阶段，其中包含四个角色——Mapper，Combiner，Partitioner，Reducer。</p><p>但并非所有 Job 都需要所有的这些角色：倘若不需要 Reduce 阶段，这是说，倘若作业仅使用 SELECT 和 WHERE 就能够表述的话，仅需要自定义 Mapper 角色即可。这种情况包括对原始数据进行清理，格式化，筛选等操作。</p><h2 id="SELECT-子句（flatMap-操作）"><a href="#SELECT-子句（flatMap-操作）" class="headerlink" title="SELECT 子句（flatMap 操作）"></a>SELECT 子句（flatMap 操作）</h2><p>SELECT 子句用于筛选特定列，更准确的说是将每行原数据映射成为新数据。</p><p>考虑这样一个需求——将原数据转换成下面格式的数据：</p><ul><li>航班的日期，格式为年&#x2F;月&#x2F;日</li><li>周几</li><li>预计起飞时间</li><li>预计到达时间</li><li>起飞机场的代码</li><li>到达机场的代码</li><li>航班总里程</li><li>实际飞行时间</li><li>计划飞行时间</li><li>起飞延迟时间</li><li>到达延迟时间</li></ul><p>解决方法非常显然——获取每一行数据，通过原数据构造所需新数据，向上下文中写入新数据，这是一个典型的 SELECT，只不过做了一些字段拼接和转换之类的操作罢了。</p>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">SelectClause 代码见此</span></summary>        <blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.NullWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.StringJoiner;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 《深入理解 Hadoop》的第一个示例，演示 Select 子句的使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectClause</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectClauseMapper</span> <br>    <span class="hljs-comment">// 输出的数据不需要主键，也不需要排序，所以使用 NullWritable</span><br>    <span class="hljs-comment">// 如果使用其它的类型，则每行开头都会有一个、t</span><br>            <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, NullWritable, Text&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outputV</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>            <span class="hljs-comment">// 表头</span><br>            <span class="hljs-keyword">if</span> (value.toString().startsWith(<span class="hljs-string">&quot;Year&quot;</span>)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            AirlineCol.<span class="hljs-type">ColGetter</span> <span class="hljs-variable">cols</span> <span class="hljs-operator">=</span> AirlineCol.build(value.toString().split(<span class="hljs-string">&quot;,&quot;</span>));<br><br>            <span class="hljs-comment">// 很壮观</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;/&quot;</span>)<br>                    .add(cols.getCol(AirlineCol.Year))<br>                    .add(StringUtils.leftPad(cols.getCol(AirlineCol.Month), <span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>))<br>                    .add(StringUtils.leftPad(cols.getCol(AirlineCol.DayofMonth), <span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>))<br>                    .toString();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">dayOfWeek</span> <span class="hljs-operator">=</span> cols.getCol(AirlineCol.DayOfWeek);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">depTime</span> <span class="hljs-operator">=</span> StringUtils.leftPad(cols.getCol(AirlineCol.DepTime), <span class="hljs-number">4</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">arrTime</span> <span class="hljs-operator">=</span> StringUtils.leftPad(cols.getCol(AirlineCol.ArrTime), <span class="hljs-number">4</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> cols.getCol(AirlineCol.Origin);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> cols.getCol(AirlineCol.Dest);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> cols.getCol(AirlineCol.Distance);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">actualElapsedTime</span> <span class="hljs-operator">=</span> cols.getCol(AirlineCol.ActualElapsedTime);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">CRSElapsedTime</span> <span class="hljs-operator">=</span> cols.getCol(AirlineCol.CRSElapsedTime);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">depDelay</span> <span class="hljs-operator">=</span> cols.getCol(AirlineCol.DepDelay);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">arrDelay</span> <span class="hljs-operator">=</span> cols.getCol(AirlineCol.ArrDelay);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;,&quot;</span>)<br>                    .add(date)<br>                    .add(dayOfWeek)<br>                    .add(depTime)<br>                    .add(arrTime)<br>                    .add(origin)<br>                    .add(dest)<br>                    .add(distance)<br>                    .add(actualElapsedTime)<br>                    .add(CRSElapsedTime)<br>                    .add(depDelay)<br>                    .add(arrDelay)<br>                    .toString();<br>            outputV.set(result);<br><br>            context.write(NullWritable.get(), outputV);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 不需要 Reducer</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, ClassNotFoundException &#123;<br>        <span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> Job.getInstance();<br>        job.setJarByClass(SelectClause.class);<br><br>        <span class="hljs-comment">// TextInputFormat 为默认值，继承 FileOutputFormat</span><br>        <span class="hljs-comment">// TextInputFormat 逐行读取数据，对压缩文件能透明地处理</span><br>        job.setInputFormatClass(TextInputFormat.class);<br>        <span class="hljs-comment">// TextOutFormat 默认输出未压缩的文本文件</span><br>        job.setOutputFormatClass(TextOutputFormat.class);<br><br>        job.setMapOutputKeyClass(NullWritable.class);<br>        job.setMapOutputValueClass(Text.class);<br>        <span class="hljs-comment">// 不需要设置</span><br>        <span class="hljs-comment">// job.setOutputKeyClass(NullWritable.class);</span><br>        <span class="hljs-comment">// job.setOutputValueClass(NullWritable.class);</span><br><br>        job.setMapperClass(SelectClauseMapper.class);<br>        job.setNumReduceTasks(<span class="hljs-number">0</span>);<br><br>        FileInputFormat.setInputPaths(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">0</span>]));<br>        FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">1</span>]));<br><br>        System.exit(job.waitForCompletion(<span class="hljs-literal">true</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote>            </details>  <blockquote><p>非常有趣的是，在本地跑 1987.csv 的时候，它切分了 4 个 Split，这说明本地的块大小默认为 32M，这是很合理的，因为在本地一般执行的是测试数据，量一般不大，同时又要照顾一下并发测试的需求。</p></blockquote><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p>代码本身没有什么麻烦的地方，主要是配置部分有很多需要学习的地方，虽然已经学过一些了，但我认为重复一次是好主意。setJar 之类的方法先略过——</p><p><code>setInputFormatClass</code>，设置 InputFormat，默认值为 TextInputFormat，这里显式地设定了。TextInputFormat 逐行读取数据，对压缩文件能透明地处理。<strong>InputFormat 的泛型需和 Mapper 的输入 KV 匹配</strong>（不匹配也没有关系，比如之前的代码有继承<code>Mapper&lt;Object, Text, ..., ...&gt;</code>的，使用更广泛的类型并不会报错。</p><p><code>TextInputFormat</code>的签名为<code>class TextInputFormat extends FileInputFormat&lt;LongWritable, Text&gt;</code>，注意它<strong>不带泛型</strong>，所以让 Mapper 的输入有一定的强制性。</p><p><code>setOutputFormatClass</code>，设置 OutputFormat，OutputFormat 决定输出时的行为，比如输出的格式，位置等（HDFS，数据库，第三方系统……），默认值为 TextOutputFormat，其默认行为将把输出数据一行一行地输出到不压缩的文本文件中。</p><p><code>TextOutputFormat</code>的签名为<code>class TextOutputFormat&lt;K, V&gt; extends FileOutputFormat&lt;K, V&gt;</code>，<strong>它的类型参数仍旧没有给定</strong>，所以给 Reducer（或者 Mapper，如果没有 Reducer 的话） 输出类型的设定是比较自由的。</p><p><code>setMapOutputKeyClass</code>和<code>setMapOutputValueClass</code>，设置 Mapper 输出值的类型，需和 Mapper 的输出 KV 匹配。这两个配置显然被<code>OutputFormat</code>所使用以用于序列化 Mapper 的输出值。<code>setOutputKeyClass</code>，<code>setOutputValueClass</code>同理，设置 Reducer 输出值的类型。</p>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">关于 OutputKey 和 OutputValue 设置的问题</span></summary>        <blockquote><p><a href="https://www.dictionary.com/browse/tldr">TL;DR</a>，最佳实践是无论任何时候都给定 Map 和 Reduce 输出的 Class。</p><p>其实 OutputKeyClass，OutputValueClass，MapOutputKeyClass，MapOutputValueClass 这四个类并非一定要配置，<strong>它们究竟是否被使用取决于使用的 OutputFormat</strong>。</p><p><span style="color: #FF0000">默认的 TextOutputFormat 不会使用这几个类的信息</span>——<strong>它的实现中直接调用了 K，V 对象的 toString 方法，并未使用上面的配置，仅仅是使用 instanceof 规定了 NullWritable 的情况</strong>，因此使用 TextOutputFormat 时，只有 Mapper 和 Reducer 的输出结果对实际的输出格式有影响，上面的配置不产生任何影响。</p><p>但是，不能靠特例来投机取巧，试图少敲几行代码，这增大了心智负担，在进行配置时需要强迫人去了解各种 OutputFormat 的具体实现乃至源码。因此，<strong>应当保证一致性，无论何种情况都给定 Mapper 和 Reducer 输出值的类型配置，以减少心智负担</strong>，且这样绝对不会抛出运行时异常，只要配置的没有错误的话。</p><p>顺带一提，书中说因为 Mapper 和 Reducer 的泛型会被擦除，所以无法在运行时知道 Mapper 和 Reducer 的输出的类型，所以需要手动设定。这说法是错误的——<strong>泛型实现类的泛型是不会被擦除的，在运行时能够获取到</strong>。</p></blockquote>            </details>  <p><code>setMapperClass</code>，字面意思。</p><p><code>setNumReduceTasks</code>，设置 Reducer 的数量，设为 0 以避免 Reduce 阶段。</p><p><code>waitForCompletion</code>，提交任务，参数为 true 表示打印日志到控制台。</p><h3 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h3><p>在本地执行时非常方便，在 IDEA 的 Run Configuration 中配置 CLI 参数为输入输出路径，点击 Run 即可，因此不表。</p><p>在集群上运行时需要打 jar 包，考虑到现在是容器化的时代，应当让打出来的 jar 包包含所有依赖，以使其能够在无任何依赖的情况下执行，不需要在 Hadoop 集群上添加依赖库（当然，至少学习情况下应该这样……不知道生产环境怎么处理）。为此，需要在 pom 下添加下面的配置——</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--打包时，包含所有依赖的 jar 包--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRefs</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRef</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRefs</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>然后，执行<code>mvn package</code>打包，丢到集群里，用<code>hadoop jar /path/to/jar SelectClause /hdfs/path/input /hdfs/path/output</code>命令来执行 jar 包。注意 output 文件夹需不存在，为空也不行。</p><p>使用 1987 和 1988 两年的数据作为输入，通过日志能够发现 2 个 bz2 文件构造了 2 个 split（即使它解压后比 128M 大得多！）。待运行完毕后，能看到目录下生成了 2 个 Map 结果文件——</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">[root@hive share]# hdfs dfs -ls /output<br>Found 3 items<br>-rw-r--r--   3 yuuki supergroup          0 2022<span class="hljs-string">-03</span><span class="hljs-string">-05</span> 08:57 /output/_SUCCESS<br>-rw-r--r--   3 yuuki supergroup  245082556 2022<span class="hljs-string">-03</span><span class="hljs-string">-05</span> 08:57 /output/part-m<span class="hljs-string">-00000</span><br>-rw-r--r--   3 yuuki supergroup   61719917 2022<span class="hljs-string">-03</span><span class="hljs-string">-05</span> 08:56 /output/part-m<span class="hljs-string">-00001</span><br></code></pre></div></td></tr></table></figure><p>输出内容的顺序是不一定的，比如可能 00000 文件是 1988，00001 是 1987 年的数据。</p><h2 id="WHERE-子句（filter-操作）"><a href="#WHERE-子句（filter-操作）" class="headerlink" title="WHERE 子句（filter 操作）"></a>WHERE 子句（filter 操作）</h2><p>现在又来了一个需求——<strong>筛选</strong>出飞机到达或起飞的实际时间延迟超过 n 分钟的航班，同时标识航班推迟的时刻——是在起点推迟（飞机起飞慢了），还是在目的地推迟（飞机到达慢了），还是都有推迟，分别使用 O，D，B 表示。显然该操作需要结合 SELECT 和 WHERE 子句。</p><blockquote><p>使用简写字母表示的目的是为了尽可能减少数据长度，从而减少 IO。</p></blockquote><p>该需求同时要求延迟时间 n 要能够通过外部自定义而非硬编码，这一点通过 <strong>Configuration 类</strong>做到。每一个 Task，无论是 Mapper 还是 Reducer，<strong>在运行时都能够访问到一个所谓的 Configuration 的实例，其数据是在提交任务时给定的</strong>。因此，在提交任务时设置任务所需要的配置（hadoop jar 的-D 参数可以用来配置它）就成为可能。</p>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">WhereClause 的代码见此</span></summary>        <blockquote><p>试着使用 Scala 来写，确实更清爽很多，但仍旧完全是命令式的。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.hadoop.fs.<span class="hljs-type">Path</span><br><span class="hljs-keyword">import</span> org.apache.hadoop.io.&#123;<span class="hljs-type">LongWritable</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.&#123;<span class="hljs-type">FileInputFormat</span>, <span class="hljs-type">TextInputFormat</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.&#123;<span class="hljs-type">FileOutputFormat</span>, <span class="hljs-type">TextOutputFormat</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.&#123;<span class="hljs-type">Job</span>, <span class="hljs-type">Mapper</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.util.<span class="hljs-type">GenericOptionsParser</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhereClauseMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> delayInMinutes: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> outputK = <span class="hljs-type">NullWritable</span>.get<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> outputV = <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>()<br><br>  <span class="hljs-comment">// setup 方法在初次启动时调用，通常用于获取特定资源，以及初始化配置</span><br>  <span class="hljs-comment">// 还有个 cleanup，主要用于释放资源</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setup</span></span>(context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    delayInMinutes = context.getConfiguration.getInt(<span class="hljs-string">&quot;map.where.delay&quot;</span>, <span class="hljs-number">1</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 只能说……写得很痛苦</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">if</span> (value.toString.startsWith(<span class="hljs-string">&quot;Year&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 重用 SelectClause 的映射操作</span><br>    <span class="hljs-keyword">val</span> cols = <span class="hljs-type">SelectClause</span>.parse(value.toString).split(<span class="hljs-string">&quot;,&quot;</span>)<br><br>    <span class="hljs-comment">// 有一些 NA 的情况</span><br>    <span class="hljs-keyword">val</span> depDel = cols(<span class="hljs-number">8</span>).toIntOption.getOrElse(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">val</span> arrDel = cols(<span class="hljs-number">9</span>).toIntOption.getOrElse(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">if</span> (depDel &lt; delayInMinutes &amp;&amp; arrDel &lt; delayInMinutes) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">val</span> resultStr = cols.mkString(<span class="hljs-string">&quot;,&quot;</span>) + &#123;<br>      <span class="hljs-keyword">if</span> (depDel &gt;= delayInMinutes &amp;&amp; arrDel &gt;= delayInMinutes) <span class="hljs-string">&quot;,B&quot;</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (depDel &gt;= delayInMinutes) <span class="hljs-string">&quot;,O&quot;</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arrDel &gt;= delayInMinutes) <span class="hljs-string">&quot;,D&quot;</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br><br>    outputV.set(resultStr)<br>    context.write(outputK, outputV)<br>  &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">WhereClause</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 使用 Hadoop 提供的工具来解析命令行</span><br>    <span class="hljs-comment">// 实际上这才是 Driver 类编写的最佳实践</span><br>    <span class="hljs-keyword">val</span> parser = <span class="hljs-keyword">new</span> <span class="hljs-type">GenericOptionsParser</span>(args)<br><br>    <span class="hljs-comment">// 解构出前两个元素作为输入和输出路径</span><br>    <span class="hljs-comment">// getRemainingArgs 方法将获取所有参数以外的东西</span><br>    <span class="hljs-keyword">val</span> inputPath +: outputPath +: _ = parser.getRemainingArgs.toSeq.map(<span class="hljs-keyword">new</span> <span class="hljs-type">Path</span>(_))<br>    <span class="hljs-comment">// -D map.where.delay 实际上就是在这里注入给 Job 的</span><br>    <span class="hljs-keyword">val</span> job = <span class="hljs-type">Job</span>.getInstance(parser.getConfiguration)<br><br>    job.setJarByClass(<span class="hljs-type">WhereClause</span>.getClass)<br>    job.setInputFormatClass(classOf[<span class="hljs-type">TextInputFormat</span>])<br>    <span class="hljs-comment">// Scala 是如何做到这个的？？</span><br>    job.setOutputFormatClass(classOf[<span class="hljs-type">TextOutputFormat</span>[<span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>]])<br><br>    job.setMapOutputKeyClass(classOf[<span class="hljs-type">NullWritable</span>])<br>    job.setMapOutputValueClass(classOf[<span class="hljs-type">NullWritable</span>])<br><br>    job.setMapperClass(classOf[<span class="hljs-type">WhereClauseMapper</span>])<br>    job.setNumReduceTasks(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-type">FileInputFormat</span>.setInputPaths(job, inputPath)<br>    <span class="hljs-type">FileOutputFormat</span>.setOutputPath(job, outputPath)<br><br>    <span class="hljs-type">System</span>.exit &#123;<br>      <span class="hljs-keyword">if</span> (job.waitForCompletion(<span class="hljs-literal">true</span>)) <span class="hljs-number">0</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote>            </details>  <p>首先不设置<code>map.where.delay</code>，调用<code>hadoop jar xx.jar WhereClause /data/sampledata /output</code>，能看到 Map 前后 Record 数量分别为 6513924，6513883，没有筛选掉多少，这说明只有极少数的航班的延误时间能够小于 1 分钟；然后设置该配置，调用<code>hadoop jar xx.jar WhereClause -D map.where.delay=100 /data/sampledata /output</code>，会发现 Map 后的 Record 数量为 2630774，筛选了超过一半的航班（这延误率有点夸张吧 hhh）。</p><h3 id="关于-GenericOptionParser"><a href="#关于-GenericOptionParser" class="headerlink" title="关于 GenericOptionParser"></a>关于 GenericOptionParser</h3><p>注意！这里的<code>-D map.where.delay=100</code>，对它的解析并非是<code>hadoop jar</code>命令的结果，而是在 Driver 类中所使用的 <code>GenericOptionParser</code>，它负责解析出一些常用的配置。<code>hadoop jar</code>的语法为<code>hadoop jar &lt;jar&gt; [mainClass] args...</code>，这里的 args 直接作为控制台参数传递给 Main 方法。</p><p><code>GenericOptionParser</code>一般来说仅用于传递自定义的参数<code>-D &lt;name&gt;=&lt;value&gt;</code>，或者传递第三方库，后者为了方便不进行使用。</p><p>然后，重复一遍使用 GenericOptionParser 后 Driver 的样板（这里其实有很多“个性”，称不上样板），我喜欢样板——</p><ul><li>使用控制台参数创建 GenericOptionParser</li><li>从 GenericOptionParser 中解构出 Configuration 和 inputPath，outputPath</li><li>根据 Configuration 创建 Job</li><li>通过 Class 设置 Jar</li><li>设置 InputFormat，OutputFormat</li><li>设置 MapOutputKey，MapOutputValue，OutputKey，OutputValue</li><li>设置 Mapper，Reducer（如果没有 Reducer，设置 Reducer task 数目为 0）</li><li>使用 FileInputFormat，FileOutputFormat 的静态方法设置输入路径和输出路径</li><li>提交任务</li></ul><h1 id="Reducer——GROUP-BY，AGGREGATION"><a href="#Reducer——GROUP-BY，AGGREGATION" class="headerlink" title="Reducer——GROUP BY，AGGREGATION"></a>Reducer——GROUP BY，AGGREGATION</h1><p>常用的聚合查询包括聚集函数，如 SUM，COUNT，MAX，MIN 等，以及两个子句 GROUP BY，HAVING。</p><p>但在此之前，我们先来看看在编程语言中的集合的 GroupBy 操作。Haskell 的 GroupBy 并不典型，这里看 Scala 的。</p><h2 id="关于-Scala-和-SQL-的-Group-By-操作"><a href="#关于-Scala-和-SQL-的-Group-By-操作" class="headerlink" title="关于 Scala 和 SQL 的 Group By 操作"></a>关于 Scala 和 SQL 的 Group By 操作</h2><p>Scala 中，集合的 GroupBy 操作的签名为——</p><figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-operator">//</span> 集合包含元素类型为 <span class="hljs-variable">A</span><br><span class="hljs-variable">def</span> <span class="hljs-built_in">GroupBy</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">(</span><span class="hljs-variable">f</span><span class="hljs-operator">:</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=&gt;</span> <span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:</span> <span class="hljs-built_in">Map</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">//</span> <span class="hljs-built_in">C</span> 是原集合的类型，如 <span class="hljs-built_in">List</span><span class="hljs-punctuation">[</span><span class="hljs-variable">A</span><span class="hljs-punctuation">]</span><br></code></pre></div></td></tr></table></figure><p>函数 f 用于构造 key，得到相同 key 的实体会被分到同一个组中。</p><p>考虑一个学生实体及相关的数据。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">id      : <span class="hljs-type">Int</span>, <span class="hljs-comment">// 主键</span></span></span><br><span class="hljs-params"><span class="hljs-class">                   classId : <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-class">                   name    : <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-class">                   age     : <span class="hljs-type">Int</span></span>)</span><br><br><span class="hljs-keyword">val</span> datas = <span class="hljs-type">List</span>(<br>  <span class="hljs-type">Student</span>(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, <span class="hljs-string">&quot;king halo&quot;</span>, <span class="hljs-number">15</span>),<br>  <span class="hljs-type">Student</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>, <span class="hljs-string">&quot;haru urara&quot;</span>, <span class="hljs-number">14</span>),<br>  <span class="hljs-type">Student</span>(<span class="hljs-number">2</span>, <span class="hljs-number">101</span>, <span class="hljs-string">&quot;seiun sky&quot;</span>, <span class="hljs-number">16</span>),<br>  <span class="hljs-type">Student</span>(<span class="hljs-number">3</span>, <span class="hljs-number">102</span>, <span class="hljs-string">&quot;tokai teio&quot;</span>, <span class="hljs-number">15</span>),<br>  <span class="hljs-type">Student</span>(<span class="hljs-number">4</span>, <span class="hljs-number">102</span>, <span class="hljs-string">&quot;special week&quot;</span>, <span class="hljs-number">16</span>),<br>  <span class="hljs-type">Student</span>(<span class="hljs-number">5</span>, <span class="hljs-number">103</span>, <span class="hljs-string">&quot;silence suzuka&quot;</span>, <span class="hljs-number">16</span>),<br>  <span class="hljs-type">Student</span>(<span class="hljs-number">6</span>, <span class="hljs-number">104</span>, <span class="hljs-string">&quot;amami haruka&quot;</span>, <span class="hljs-number">17</span>),<br>  <span class="hljs-type">Student</span>(<span class="hljs-number">7</span>, <span class="hljs-number">104</span>, <span class="hljs-string">&quot;kisaragi chihaya&quot;</span>, <span class="hljs-number">17</span>)<br>)<br></code></pre></div></td></tr></table></figure><p>对其调用<code>groupBy(_.classId)</code>后，会得到——</p><p><img src="/images/oss/20220305234151.png"></p><p>然后，试图统计每个班级的平均年龄以及该班级的所有学生的 id（的拼接），全部代码为——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 没有 average 函数，需要自定义一个，不考虑泛用性了</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">average</span></span>(lst : <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]) : <span class="hljs-type">Double</span> = &#123;<br>  <span class="hljs-keyword">val</span> (sum, len) = lst.foldLeft((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))&#123;<br>    <span class="hljs-keyword">case</span> ((sum, len), elem) =&gt; (sum + elem, len + <span class="hljs-number">1</span>)<br>  &#125;<br>  sum / len.toDouble<br>&#125;<br><br>a.groupBy(_.classId).map &#123; <span class="hljs-keyword">case</span> (k, v) =&gt;<br>  <span class="hljs-type">List</span>(k,     average(v.map(_.age)),     v.map(_.id).mkString(<span class="hljs-string">&quot;,&quot;</span>)) <span class="hljs-comment">// LOOK AT ME!</span><br>&#125;.map(_.mkString(<span class="hljs-string">&quot;\t\t&quot;</span>)).mkString(<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">结果：</span><br><span class="hljs-comment">101        15.0        0,1,2</span><br><span class="hljs-comment">102        15.5        3,4</span><br><span class="hljs-comment">103        16.0        5</span><br><span class="hljs-comment">104        17.0        6,7</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>再从 SQL 的角度来看，在进行 GROUP BY 操作后，会得到上图的结果，被 GROUP BY 的字段不是原子的，这并不符合 SQL 的要求，因此必须要使用某种手段将这字段集合“聚集”到一起，形成单个值。这种聚集手段一般来说是聚集函数。</p><blockquote><p>之前学习 SQL 的时候就没有掌握这里……总的来说，GROUP BY 操作实际上就是构造这样的表，KEY 以外的字段（即 VALUE）不是原子的，需要进行某种“聚集”操作，将它变成原子的。</p></blockquote><p>对应的 SQL 为——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> student_t;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student_t (<br>  id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>  class_id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>),<br>  stud_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>  age <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student_t <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, &quot;king halo&quot;, <span class="hljs-number">15</span>),<br>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>, &quot;haru urara&quot;, <span class="hljs-number">14</span>),<br>(<span class="hljs-number">2</span>, <span class="hljs-number">101</span>, &quot;seiun sky&quot;, <span class="hljs-number">16</span>),<br>(<span class="hljs-number">3</span>, <span class="hljs-number">102</span>, &quot;tokai teio&quot;, <span class="hljs-number">15</span>),<br>(<span class="hljs-number">4</span>, <span class="hljs-number">102</span>, &quot;special week&quot;, <span class="hljs-number">16</span>),<br>(<span class="hljs-number">5</span>, <span class="hljs-number">103</span>, &quot;silence suzuka&quot;, <span class="hljs-number">16</span>),<br>(<span class="hljs-number">6</span>, <span class="hljs-number">104</span>, &quot;amami haruka&quot;, <span class="hljs-number">17</span>),<br>(<span class="hljs-number">7</span>, <span class="hljs-number">104</span>, &quot;kisaragi chihaya&quot;, <span class="hljs-number">17</span>);<br><br><span class="hljs-keyword">select</span> class_id, <span class="hljs-built_in">AVG</span>(age), GROUP_CONCAT(id) <span class="hljs-keyword">FROM</span> student_t <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class_id; <span class="hljs-comment">-- 可以在这里使用各种聚集函数</span><br><span class="hljs-comment">-- 这里的行为就相当于是，筛选出了待聚集字段中的 age 和 id，然后对 age 进行求和，对 id 进行聚集，这两个操作是可以同时进行的（可以在同一个迭代里同时进行）。</span><br><span class="hljs-comment">-- 一切聚集操作都可以“并行”吗？</span><br></code></pre></div></td></tr></table></figure><p> 对比 SQL 和 Scala 的操作，能够发现两者基本是一致的——它们的行为是：（首先按 Where 进行筛选操作！）首先按标识符分组，然后相当于是创建了一张仅有两个字段的临时表，其中第一个字段为标识符，第二个字段为对应该标识符的实体的集合，这时候的任务就变成了对每个标识符对应实体的集合进行“聚集”（reduce 操作；众所周知，reduce 操作可以实现 map 操作），构造一个原子的值或列簇。</p><h2 id="GROUP-BY-子句和-聚集函数"><a href="#GROUP-BY-子句和-聚集函数" class="headerlink" title="GROUP BY 子句和 聚集函数"></a>GROUP BY 子句和 聚集函数</h2><p>考虑这样的需求，我们需要知道<strong>每</strong>月航班准时到达或起飞的比例，知道<strong>每</strong>月航班取消或改道比例等，像这种需求，就是<strong>要求把数据按特定字段（如日期，编号，性别等）进行分组，对每一组分别进行聚集操作</strong>，从而能够获取特定于该字段上下文的特定信息，比如“每个月的航班数量”，“每个姓氏的数量”，“每个班级的人数”……</p><p>直接从一个例子开始，我们需要从原始数据中获取到这些信息——</p><ul><li>月份</li><li>该月航班数量</li><li>准时到达的比例</li><li>到达延迟的比例</li><li>准时起飞的比例</li><li>延迟起飞的比例</li><li>取消的比例</li><li>改航的比例</li></ul><p>考虑到原始数据的结构，我们需要从原始数据的结构中取出如下信息，即 Mappser 部分——</p><ul><li>航班的月份</li><li>航班到达延迟时间（为 0 的认为没有延迟）</li><li>航班起飞延迟时间（同上）</li><li>是否取消</li><li>是否改航</li></ul><p>这里只有 SELECT 操作，没有 WHERE 操作，获取这样的数据对应的 SQL 为——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">month</span>, arrDelay, depDelay, canceled, diverted <span class="hljs-keyword">FROM</span> airline_t;<br></code></pre></div></td></tr></table></figure><p>这样得到的数据是每个航班的数据，并非是按月分组的数据，因此我们先加上<code>GROUP BY</code>——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-comment">-- can&#x27;t run!</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">month</span>, arrDelay, depDelay, canceled, diverted <span class="hljs-keyword">FROM</span> airline_t <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">month</span>;<br></code></pre></div></td></tr></table></figure><p>按 month 分组后，arrDelay，depDelay，canceled，diverted 这四个字段就不是原子的了，需要使用聚集函数，<strong>而具体如何进行聚集呢？这由业务决定</strong>（废话）。</p><p>再次考虑需求，可以看到，我们要做的主要是要统计每个月的航班数量，以及准时到达的数量，准时起飞的数量，取消的数量，改航的数量，然后就能够计算上面的所有比例了，容易得到下面的 SQL——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>                                                 <span class="hljs-keyword">month</span>,<br>  <span class="hljs-built_in">COUNT</span>(<span class="hljs-number">1</span>)                                    <span class="hljs-keyword">AS</span> airline_count,<br>  <span class="hljs-built_in">COUNT</span>(arrDelay <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">NULL</span>) <span class="hljs-operator">/</span> airline_count <span class="hljs-keyword">AS</span> arrive_in_time,<br>  <span class="hljs-number">1</span> <span class="hljs-operator">-</span> arrive_in_time                          <span class="hljs-keyword">AS</span> arrive_delay,<br>  <span class="hljs-built_in">COUNT</span>(depDelay <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">NULL</span>) <span class="hljs-operator">/</span> airline_count <span class="hljs-keyword">AS</span> dep_in_time,<br>  <span class="hljs-number">1</span> <span class="hljs-operator">-</span> dep_in_time                             <span class="hljs-keyword">AS</span> dep_delay,<br>  <span class="hljs-built_in">COUNT</span>(canceled <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">NULL</span>) <span class="hljs-operator">/</span> airline_count <span class="hljs-keyword">AS</span> is_canceled,<br>  <span class="hljs-built_in">COUNT</span>(diverted <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">NULL</span>) <span class="hljs-operator">/</span> airline_count <span class="hljs-keyword">AS</span> is_diverted<br><span class="hljs-keyword">FROM</span> airline_t <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">month</span>;<br></code></pre></div></td></tr></table></figure><p>下面，开始编写相应的 Mapper 和 Reducer，同时尽可能减少输出的数据长度。</p><p>关于 Mapper 的编写，目前有三种考虑——</p><ol><li>只做简单的映射操作，将相应字段取得即可。</li><li>根据问题背景，设置输出的 KV 对格式为<code>&lt;Text, IntWritable&gt;</code>，其中 K 为月份，V 为按二进制位对特定状况进行标识的一个数字，如（从右往左数）第一个 bit 为 1 时，则到达延误，第二个 bit 为 1 时则出发延误，第三个 bit 表示航班取消，第四个 bit 表示航班改航。</li><li>将各个延误情况区分开，比如 9 月某个航班既出发延误，又到达延误，则向上下文中写入三个 KV 对，分别标识一条记录（任何航班都会插入该条），一条出发延误记录，一条到达延误记录，<code>(&quot;09&quot;, 0)</code>，<code>(&quot;09&quot;, 1)</code>，<code>(&quot;09&quot;, 2)</code></li></ol><blockquote><p>记录即 KV 对。</p></blockquote><p>第一种方法……字面意思，有一些完全没有必要的信息（如具体的延误时间）发送给了 Reducer，比较浪费；第二种方法需要的网络 IO 较少，但实现比较麻烦；第三种方法实现最为方便，但网络 IO 较多，这里使用第三种方法。</p><blockquote><p>但最大的问题是，这三种方案都无法使用 Combiner 或者需要另外定义 Combiner。应当使用一个集合类型如 ArrayWritable 作为 Mapper 的输出值。这待后面谈到 Combiner 时再说。</p></blockquote>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">优化前的 AggregationMRJob 见此</span></summary>        <blockquote><p>之后的示例里就不写 Driver 了，顶多提及一下重要配置。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.hadoop.fs.<span class="hljs-type">Path</span><br><span class="hljs-keyword">import</span> org.apache.hadoop.io.&#123;<span class="hljs-type">IntWritable</span>, <span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.&#123;<span class="hljs-type">Job</span>, <span class="hljs-type">Mapper</span>, <span class="hljs-type">Reducer</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.&#123;<span class="hljs-type">FileInputFormat</span>, <span class="hljs-type">TextInputFormat</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.&#123;<span class="hljs-type">FileOutputFormat</span>, <span class="hljs-type">TextOutputFormat</span>&#125;<br><span class="hljs-keyword">import</span> org.apache.hadoop.util.<span class="hljs-type">GenericOptionsParser</span><br><br><span class="hljs-keyword">import</span> java.lang<br><br><span class="hljs-comment">// Mapper 的输出为（月份， 标识符）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AggregationMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">IntWritable</span>] </span>&#123;<br><br>  <span class="hljs-comment">// 为了让代码业务逻辑更明显，不使用类变量存储输出的 Writable 对象了</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">IntWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">import</span> <span class="hljs-type">AirlineCol</span>._<br>    <span class="hljs-keyword">if</span> (value.toString.startsWith(<span class="hljs-string">&quot;Year&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">val</span> colGetter = <span class="hljs-type">AirlineCol</span>.build(value.toString.split(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    <span class="hljs-comment">// Scala 默认居然没有提供 padLeft……真的假的？</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">padLeft</span></span>(str : <span class="hljs-type">String</span>, len : <span class="hljs-type">Int</span>, c : <span class="hljs-type">Char</span>) : <span class="hljs-type">String</span> =<br>      str.reverse.padTo(len, c).reverse<br><br>    <span class="hljs-keyword">val</span> month = padLeft(colGetter(<span class="hljs-type">Month</span>), <span class="hljs-number">2</span>, &#x27;<span class="hljs-number">0</span>&#x27;)<br>    <span class="hljs-keyword">val</span> arrDelay = colGetter(<span class="hljs-type">ArrDelay</span>).toIntOption.getOrElse(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">val</span> depDelay = colGetter(<span class="hljs-type">DepDelay</span>).toIntOption.getOrElse(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">val</span> isCancelled = colGetter(<span class="hljs-type">Cancelled</span>) == <span class="hljs-string">&quot;1&quot;</span><br>    <span class="hljs-keyword">val</span> isDiverted = colGetter(<span class="hljs-type">Diverted</span>) == <span class="hljs-string">&quot;1&quot;</span><br><br>    context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(month), <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">if</span> (arrDelay &gt; <span class="hljs-number">0</span>) &#123;<br>      context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(month), <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">1</span>))<br>    &#125;<br>    <span class="hljs-keyword">if</span> (depDelay &gt; <span class="hljs-number">0</span>) &#123;<br>      context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(month), <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">2</span>))<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isCancelled) &#123;<br>      context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(month), <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">3</span>))<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isDiverted) &#123;<br>      context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(month), <span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(<span class="hljs-number">4</span>))<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AggregationReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">Text</span>, <span class="hljs-type">IntWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">Text</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">IntWritable</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">Text</span>, <span class="hljs-type">IntWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 将 Java 的 Iterable 转换为 Scala 的 Iterable</span><br>    <span class="hljs-keyword">import</span> scala.jdk.<span class="hljs-type">CollectionConverters</span>.<span class="hljs-type">IterableHasAsScala</span><br><br>    <span class="hljs-keyword">val</span> (recordCount, arrDelayCount, depDelayCount, cancelCount, divertCount) =<br>      values.asScala.foldLeft((<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)) &#123; (counter, elem) =&gt;<br>        elem.get <span class="hljs-keyword">match</span> &#123;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; counter.copy(_1 = counter._1 + <span class="hljs-number">1</span>)<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> =&gt; counter.copy(_2 = counter._2 + <span class="hljs-number">1</span>)<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> =&gt; counter.copy(_3 = counter._3 + <span class="hljs-number">1</span>)<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">3</span> =&gt; counter.copy(_4 = counter._4 + <span class="hljs-number">1</span>)<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">4</span> =&gt; counter.copy(_5 = counter._5 + <span class="hljs-number">1</span>)<br>        &#125;<br>      &#125;<br><br>    <span class="hljs-keyword">val</span> result = recordCount.toString +<span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-type">List</span>(<br>      <span class="hljs-number">1</span> - arrDelayCount / recordCount, <span class="hljs-comment">// 准时到达</span><br>      arrDelayCount / recordCount, <span class="hljs-comment">// 延迟到达</span><br>      <span class="hljs-number">1</span> - depDelayCount / recordCount, <span class="hljs-comment">// 准时出发</span><br>      depDelayCount / recordCount, <span class="hljs-comment">// 延迟出发</span><br>      cancelCount / recordCount, <span class="hljs-comment">// 取消</span><br>      divertCount / recordCount <span class="hljs-comment">// 改航</span><br>    ).map(s =&gt; (s * <span class="hljs-number">100</span>).toString.take(<span class="hljs-number">5</span>) + <span class="hljs-string">&quot;%&quot;</span>).mkString(<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment">// 格式化一下</span><br>    context.write(key, <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(result))<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 GROUP BY 子句的使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AggregationMRJob</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 1. 根据 args 初始化 GenericOptionParser</span><br>    <span class="hljs-keyword">val</span> parser = <span class="hljs-keyword">new</span> <span class="hljs-type">GenericOptionsParser</span>(args)<br>    <span class="hljs-comment">// 2. 获取输入，输出路径</span><br>    <span class="hljs-keyword">val</span> inputPath +: outputPath +: _ = parser.getRemainingArgs.toSeq.map(<span class="hljs-keyword">new</span> <span class="hljs-type">Path</span>(_))<br>    <span class="hljs-comment">// 3. 获取 Configuration，构造 Job</span><br>    <span class="hljs-keyword">val</span> job = <span class="hljs-type">Job</span>.getInstance(parser.getConfiguration)<br>    job setJarByClass <span class="hljs-type">AggregationMRJob</span>.getClass<br>    <span class="hljs-comment">// 4. 设置 InputFormat, OutputFormat</span><br>    job setInputFormatClass classOf[<span class="hljs-type">TextInputFormat</span>]<br>    job setOutputFormatClass classOf[<span class="hljs-type">TextOutputFormat</span>[<span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>]]<br>    <span class="hljs-comment">// 5. 设置 Mapper 和 Reducer 的输出类型</span><br>    job setMapOutputKeyClass classOf[<span class="hljs-type">Text</span>]<br>    job setMapOutputValueClass classOf[<span class="hljs-type">IntWritable</span>]<br>    job setOutputKeyClass classOf[<span class="hljs-type">Text</span>]<br>    job setOutputValueClass classOf[<span class="hljs-type">Text</span>]<br>    <span class="hljs-comment">// 6. 设置 Mapper，Reducer</span><br>    job setMapperClass classOf[<span class="hljs-type">AggregationMapper</span>]<br>    job setReducerClass classOf[<span class="hljs-type">AggregationReducer</span>]<br>    job setNumReduceTasks <span class="hljs-number">1</span> <span class="hljs-comment">// 默认值</span><br>    <span class="hljs-comment">// 7. 设置输入输出路径</span><br>    <span class="hljs-type">FileInputFormat</span>.setInputPaths(job, inputPath)<br>    <span class="hljs-type">FileOutputFormat</span>.setOutputPath(job, outputPath)<br>    <span class="hljs-comment">// 8. 启动</span><br>    <span class="hljs-type">System</span> exit &#123;<br>      <span class="hljs-keyword">if</span> (job waitForCompletion <span class="hljs-literal">true</span>) <span class="hljs-number">0</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote>            </details>  <p>得到的数据如下，这里并没有使用标准 CSV 格式，如果使用，则输出的 KEY 应该使用 NullWritable 类型。</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">01</span><span class="hljs-number">436950</span>.<span class="hljs-number">0</span>,<span class="hljs-number">40</span>.<span class="hljs-number">08</span>%,<span class="hljs-number">59</span>.<span class="hljs-number">91</span>%,<span class="hljs-number">54</span>.<span class="hljs-number">54</span>%,<span class="hljs-number">45</span>.<span class="hljs-number">45</span>%,<span class="hljs-number">3</span>.<span class="hljs-number">605</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">527</span>%<br><span class="hljs-attribute">02</span><span class="hljs-number">412579</span>.<span class="hljs-number">0</span>,<span class="hljs-number">41</span>.<span class="hljs-number">29</span>%,<span class="hljs-number">58</span>.<span class="hljs-number">70</span>%,<span class="hljs-number">56</span>.<span class="hljs-number">87</span>%,<span class="hljs-number">43</span>.<span class="hljs-number">12</span>%,<span class="hljs-number">1</span>.<span class="hljs-number">774</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">305</span>%<br><span class="hljs-attribute">03</span><span class="hljs-number">445080</span>.<span class="hljs-number">0</span>,<span class="hljs-number">42</span>.<span class="hljs-number">68</span>%,<span class="hljs-number">57</span>.<span class="hljs-number">31</span>%,<span class="hljs-number">57</span>.<span class="hljs-number">95</span>%,<span class="hljs-number">42</span>.<span class="hljs-number">04</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">701</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">237</span>%<br><span class="hljs-attribute">04</span><span class="hljs-number">427325</span>.<span class="hljs-number">0</span>,<span class="hljs-number">48</span>.<span class="hljs-number">68</span>%,<span class="hljs-number">51</span>.<span class="hljs-number">31</span>%,<span class="hljs-number">62</span>.<span class="hljs-number">74</span>%,<span class="hljs-number">37</span>.<span class="hljs-number">25</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">564</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">248</span>%<br><span class="hljs-attribute">05</span><span class="hljs-number">435916</span>.<span class="hljs-number">0</span>,<span class="hljs-number">49</span>.<span class="hljs-number">28</span>%,<span class="hljs-number">50</span>.<span class="hljs-number">71</span>%,<span class="hljs-number">62</span>.<span class="hljs-number">35</span>%,<span class="hljs-number">37</span>.<span class="hljs-number">64</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">602</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">245</span>%<br><span class="hljs-attribute">06</span><span class="hljs-number">431299</span>.<span class="hljs-number">0</span>,<span class="hljs-number">50</span>.<span class="hljs-number">06</span>%,<span class="hljs-number">49</span>.<span class="hljs-number">93</span>%,<span class="hljs-number">61</span>.<span class="hljs-number">60</span>%,<span class="hljs-number">38</span>.<span class="hljs-number">39</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">278</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">216</span>%<br><span class="hljs-attribute">07</span><span class="hljs-number">441118</span>.<span class="hljs-number">0</span>,<span class="hljs-number">49</span>.<span class="hljs-number">15</span>%,<span class="hljs-number">50</span>.<span class="hljs-number">84</span>%,<span class="hljs-number">60</span>.<span class="hljs-number">36</span>%,<span class="hljs-number">39</span>.<span class="hljs-number">63</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">623</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">329</span>%<br><span class="hljs-attribute">08</span><span class="hljs-number">446769</span>.<span class="hljs-number">0</span>,<span class="hljs-number">48</span>.<span class="hljs-number">97</span>%,<span class="hljs-number">51</span>.<span class="hljs-number">02</span>%,<span class="hljs-number">60</span>.<span class="hljs-number">69</span>%,<span class="hljs-number">39</span>.<span class="hljs-number">30</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">554</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">281</span>%<br><span class="hljs-attribute">09</span><span class="hljs-number">424075</span>.<span class="hljs-number">0</span>,<span class="hljs-number">51</span>.<span class="hljs-number">76</span>%,<span class="hljs-number">48</span>.<span class="hljs-number">23</span>%,<span class="hljs-number">67</span>.<span class="hljs-number">38</span>%,<span class="hljs-number">32</span>.<span class="hljs-number">61</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">480</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">190</span>%<br><span class="hljs-attribute">10</span><span class="hljs-number">441670</span>.<span class="hljs-number">0</span>,<span class="hljs-number">47</span>.<span class="hljs-number">72</span>%,<span class="hljs-number">52</span>.<span class="hljs-number">27</span>%,<span class="hljs-number">63</span>.<span class="hljs-number">27</span>%,<span class="hljs-number">36</span>.<span class="hljs-number">72</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">522</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">186</span>%<br><span class="hljs-attribute">11</span><span class="hljs-number">420861</span>.<span class="hljs-number">0</span>,<span class="hljs-number">43</span>.<span class="hljs-number">60</span>%,<span class="hljs-number">56</span>.<span class="hljs-number">39</span>%,<span class="hljs-number">58</span>.<span class="hljs-number">38</span>%,<span class="hljs-number">41</span>.<span class="hljs-number">61</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">835</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">249</span>%<br><span class="hljs-attribute">12</span><span class="hljs-number">438454</span>.<span class="hljs-number">0</span>,<span class="hljs-number">43</span>.<span class="hljs-number">13</span>%,<span class="hljs-number">56</span>.<span class="hljs-number">86</span>%,<span class="hljs-number">56</span>.<span class="hljs-number">86</span>%,<span class="hljs-number">43</span>.<span class="hljs-number">13</span>%,<span class="hljs-number">1</span>.<span class="hljs-number">055</span>%,<span class="hljs-number">0</span>.<span class="hljs-number">308</span>%<br></code></pre></div></td></tr></table></figure><h3 id="关于-Reducer"><a href="#关于-Reducer" class="headerlink" title="关于 Reducer"></a>关于 Reducer</h3><p>每个 Mapper 的结果会按照 KEY 进行<strong>排序</strong>和 <strong>Shuffle</strong>（非常重要），分别发送给不同的 Reducer，Reducer 的输入类型需和 Mapper 的输出类型匹配，<strong>每个 Reducer 都将拿到一些 KEY 对应的记录的集合</strong>，比如 ReducerA 会拿到 KEY 为<code>01</code>，<code>03</code>的记录集合，ReducerB 会拿到<code>02</code>，<code>04</code>的记录的集合（通常不是这样，KEY 会被进行哈希以保证平均）……这里的操作非常重要，之后必须得自己学习。</p><blockquote><p>Mapper 的结果会按 KEY 分发给不同的 Reducer，这是说，特定的 KEY 必定会发送且只发送给一个特定的 Reducer；每一个 Reducer 会接受每个 Mapper 的结果，这是说特定的 Reducer 看到的每一个 KEY，它的 VALUE 会来自每一个 Mapper。</p></blockquote><p>在取得集合后，Reducer 对每个 KEY，都会将其对应的记录集合进行聚集操作，这就是每一次调用 reduce 函数所做的事情。比如，一个 Mapper 的输出结果可能是这样——</p><figure class="highlight node-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs node-repl">01 0<br>01 1<br>01 2<br>01 0<br><span class="hljs-meta prompt_">...</span><br>03 0<br>03 1<br>03 0<br>03 3<br>03 0<br><span class="hljs-meta prompt_">...</span><br></code></pre></div></td></tr></table></figure><p>它传递给 Reducer 后，可能变成这样，它本质上和此图结构相同。</p><p><img src="/images/oss/20220305234151.png"></p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">01 </span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,...] <br><span class="hljs-symbol">03 </span>[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,...]<br></code></pre></div></td></tr></table></figure><p>后面的工作就是典型的对集合进行聚集的操作了。需注意的是，它不会一开始就把整个集合全部都加载到内存，那在大数据量大情况下百分百会把内存用完，这也是为什么它传递过来的是一个 Iterable 对象，只允许用户流式地去访问集合。</p><p>Reducer 有几个重要的规律&#x2F;原则——</p><ul><li>对每一个 Reducer，<strong>每调用一次 reduce 方法，就是处理一个 KEY 对应的记录集合</strong>，即<strong>一个或多个</strong> Mapper 输出的一部分。</li><li>对同一个 Reducer，<strong>它处理的 KEY 是经过排序的，但 KEY 对应的记录集合默认并不排序</strong>，运行过程中可能还会发生变化；用户可以自定义<strong>二次排序</strong>方法对 VALUE 集合进行排序。</li><li><strong>Reducer 之间是不排序的</strong>，如 ReducerA 可能会拿到 01,03,05,07,09,11 月的 KEY，ReducerB 可能拿到 02,04,06,08,10,12 月的 KEY；Reducer 之间的排序也是可以自定义的。</li></ul><h3 id="关于-Combiner"><a href="#关于-Combiner" class="headerlink" title="关于 Combiner"></a>关于 Combiner</h3><p>需求解决了，但是这并非是个合适的解决方案——分析输出的日志可以发现平均每一条记录会导致 Mapper 产生两条记录，假设现在有 1 亿条数据，则有 2 亿条记录会被传递给 Reducer。<strong>Reducer 通常是无法做到数据本地性的，因此需要 Mapper 将结果通过网络传输给 Reducer，这会造成大量的损耗，而 Combiner 有助于缓解这一问题</strong>。</p><p>考虑上面提到的 Mapper 的输出结果，它显然能做优化——有那么多<code>01 0</code>，为啥不能先在本地直接先做一次聚集，然后再传递给 Reducer 呢？这能减少非常大量的 IO（在这个场景下，得有四五个数量级了）！</p><p><strong>Combiner 就是服务这样的目的——为每一个 Mapper 的输出在本地预先进行聚集，从而减少网络 IO</strong>。<strong>Combiner 使用 Reducer 接口</strong>，因为其行为也是 reduce。Combiner 的输入要和 Mapper 的输出匹配，输出要和 Reducer 的输入匹配，<span style="color: #FF0000">Combiner 的输入必须和输出一致</span>。</p><p><strong>为什么 Combiner 的输入和输出要一致？因为 Combiner 的调用次数是不确定的，Mapper 的结果可能会经过多次 Combine 操作才最终聚集起来</strong>，而因此 Combiner 的输出必须要能够作为其它 Combiner 的输入。这和 java8-stream 的 reduce 操作非常类似。</p><p>为此，我们必须对 Mapper，Reducer 全部都进行重写以匹配 Combiner 的需求。</p><p>这里选择让 Mapper 的输出类似<code>01 [1,0,0,0,0]   01 [1,1,0,0,0]...</code>，Combiner 就合并同样的 KEY，得到<code>01 [1999,888,77,66,55]...</code>，然后 Reducer 再次进行再一次的合并操作，得到最终结果<span class="heimu">其实这样的话 Combiner 和 Reducer 的逻辑是基本一样的，差别在于最后的输出不一样</span>。</p><blockquote><p>书上使用 MapWritable，但是是当作 Bean 对象使用的…不知道性能如何。</p><p>使用 ArrayWritable 需要注意，<strong>如果该类型作为 Reducer 的输入类型，则需要定义其子类并给定空构造函数</strong>，传递该数组内的 Writable 的 class，因为其在运行时会通过反射创建该类，而默认的 ArrayWritable 不提供空构造函数。</p></blockquote>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">带上 Combiner 的 AggregationMRJob 代码</span></summary>        <blockquote><p>两个坑，第一个是 ArrayWritable 如果有反序列化的需求（如作为 Combiner，Reducer 的输入）的话，必须要继承和编写空构造函数才能用，第二个是<code>Array[IntWritable]</code>不能转换成<code>Array[Writable]</code>，<strong>Java 的数组不能逆变，协变</strong>。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntArrayWritable</span>(<span class="hljs-params"></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayWritable</span>(<span class="hljs-params">classOf[<span class="hljs-type">IntWritable</span>]</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">IntArrayWritable</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(values : <span class="hljs-type">Array</span>[<span class="hljs-type">Writable</span>]) : <span class="hljs-type">IntArrayWritable</span> = &#123;<br>    <span class="hljs-keyword">val</span> res = <span class="hljs-keyword">new</span> <span class="hljs-type">IntArrayWritable</span><br>    res.set(values)<br>    res<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Mapper 的输出为（月份， 标识符）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AggregationMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">IntArrayWritable</span>] </span>&#123;<br><br>  <span class="hljs-comment">// 为了让代码业务逻辑更明显，不使用类变量存储输出的 Writable 对象了</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">IntArrayWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">import</span> <span class="hljs-type">AirlineCol</span>._<br>    <span class="hljs-keyword">if</span> (value.toString.startsWith(<span class="hljs-string">&quot;Year&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">val</span> colGetter = <span class="hljs-type">AirlineCol</span>.build(value.toString.split(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    <span class="hljs-comment">// Scala 默认居然没有提供 padLeft……真的假的？</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">padLeft</span></span>(str : <span class="hljs-type">String</span>, len : <span class="hljs-type">Int</span>, c : <span class="hljs-type">Char</span>) : <span class="hljs-type">String</span> =<br>      str.reverse.padTo(len, c).reverse<br><br>    <span class="hljs-keyword">val</span> month = padLeft(colGetter(<span class="hljs-type">Month</span>), <span class="hljs-number">2</span>, &#x27;<span class="hljs-number">0</span>&#x27;)<br>    <span class="hljs-keyword">val</span> arrDelay = colGetter(<span class="hljs-type">ArrDelay</span>).toIntOption.getOrElse(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">val</span> depDelay = colGetter(<span class="hljs-type">DepDelay</span>).toIntOption.getOrElse(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">val</span> isCancelled = colGetter(<span class="hljs-type">Cancelled</span>) == <span class="hljs-string">&quot;1&quot;</span><br>    <span class="hljs-keyword">val</span> isDiverted = colGetter(<span class="hljs-type">Diverted</span>) == <span class="hljs-string">&quot;1&quot;</span><br><br>    context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(month), <span class="hljs-type">IntArrayWritable</span>(<span class="hljs-type">Array</span>(<br>      <span class="hljs-number">1</span>, <span class="hljs-keyword">if</span> (arrDelay &gt; <span class="hljs-number">0</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, <span class="hljs-keyword">if</span> (depDelay &gt; <span class="hljs-number">0</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, <span class="hljs-keyword">if</span> (isCancelled) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, <span class="hljs-keyword">if</span> (isDiverted) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>    ).map(<span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(_))))<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AggregationCombiner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">Text</span>, <span class="hljs-type">IntArrayWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">IntArrayWritable</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">Text</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">IntArrayWritable</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">Text</span>, <span class="hljs-type">IntArrayWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">IntArrayWritable</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">import</span> scala.jdk.<span class="hljs-type">CollectionConverters</span>.<span class="hljs-type">IterableHasAsScala</span><br>    <span class="hljs-keyword">val</span> result = values.asScala.map(_.get).foldLeft(<span class="hljs-type">Array</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)) &#123;(acc, cols) =&gt;<br>      cols.map(_.asInstanceOf[<span class="hljs-type">IntWritable</span>].get).zip(acc).map &#123;<span class="hljs-keyword">case</span> (a, b) =&gt; a + b&#125;<br>    &#125;<br>    context.write(key, <span class="hljs-type">IntArrayWritable</span>(result.map(<span class="hljs-keyword">new</span> <span class="hljs-type">IntWritable</span>(_))))<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AggregationReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">Text</span>, <span class="hljs-type">IntArrayWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">Text</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">IntArrayWritable</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">Text</span>, <span class="hljs-type">IntArrayWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 将 Java 的 Iterable 转换为 Scala 的 Iterable</span><br>    <span class="hljs-keyword">import</span> scala.jdk.<span class="hljs-type">CollectionConverters</span>.<span class="hljs-type">IterableHasAsScala</span><br><br>    <span class="hljs-keyword">val</span> <span class="hljs-type">Array</span>(recordCount,arrDelayCount,depDelayCount,cancelCount,divertCount) = values.asScala.map(_.get).foldLeft(<span class="hljs-type">Array</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)) &#123;(acc, cols) =&gt;<br>      cols.map(_.asInstanceOf[<span class="hljs-type">IntWritable</span>].get).zip(acc).map &#123;<span class="hljs-keyword">case</span> (a, b) =&gt; a + b&#125;<br>    &#125;.map(_.toDouble)<br><br>    <span class="hljs-keyword">val</span> result = recordCount.toString +<span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-type">List</span>(<br>      <span class="hljs-number">1</span> - arrDelayCount / recordCount, <span class="hljs-comment">// 准时到达</span><br>      arrDelayCount / recordCount, <span class="hljs-comment">// 延迟到达</span><br>      <span class="hljs-number">1</span> - depDelayCount / recordCount, <span class="hljs-comment">// 准时出发</span><br>      depDelayCount / recordCount, <span class="hljs-comment">// 延迟出发</span><br>      cancelCount / recordCount, <span class="hljs-comment">// 取消</span><br>      divertCount / recordCount <span class="hljs-comment">// 改航</span><br>    ).map(s =&gt; (s * <span class="hljs-number">100</span>).toString.take(<span class="hljs-number">5</span>) + <span class="hljs-string">&quot;%&quot;</span>).mkString(<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment">// 格式化一下</span><br>    context.write(key, <span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(result))<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote>            </details>  <h1 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h1><p>Partitioner 的作用一言以蔽之，就是<strong>将 Mapper 的中间结果进行分组，并将同一组的 KV 对发送给同一个 Reducer 处理</strong>，可以说 Partitioner 是为了<span style="color: #FF0000">负载均衡</span>。</p><p>MR 中默认的 Partitioner 为 HashPartitioner，实现如下。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashPartitioner</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Partitioner</span>&lt;K, V&gt; &#123;<br>  <span class="hljs-comment">/** Use &#123;<span class="hljs-doctag">@link</span> Object#hashCode()&#125; to partition. */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(K key, V value, <span class="hljs-type">int</span> numReduceTasks)</span> &#123;<br>    <span class="hljs-keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这意味着几件事——</p><ol><li>Partitioner 默认根据 KEY 的哈希值来进行分区，和 VALUE 无关，但可以自定义 Partitioner 使在分区时利用上 VALUE</li><li>一定的 KEY 一定会发送给一定的 Reducer</li><li>如果自定义 Bean 作为 Reducer 的 KEY，应当实现 hashCode，以保证同一个 KEY 一定发送给同一个 Reducer，不然的话默认按内存地址作为哈希值，相等的两个 KEY 可能会发送给不同的 Reducer，这会导致错误结果，比如对于 WordCount 程序，可能在输出中会出现<code>hello 93 ... hello 194</code>，出现了多个同样的 KEY，这结果是不符合预期的。</li><li>getPartition 应当是纯函数（是如此吗？）</li></ol><p>但 Partitioner 仍然在有时候有自定义的需求，比如，对于那些淡季旺季差别很明显的数据呢？考虑分析每月旅游业的一些数据，在 5 月至 10 月是旅游业的旺季，数据量非常大，特别是 5 月，10 月，和其它月份可能有上十倍的差距，而其他时间就是淡季。</p><p>这时候，HashPartitioner 是无法起到“负载均衡”的作用的，不同 Reducer 因为分到的月份不同，因此得到的数据量就有可能有很大差异，因而执行时间就会有差异，造成一定的资源浪费，这时候就非常适合根据业务需求自定义 Partitioner。</p><p>再比如，当我们想要让每个组生成独立的文件的时候，我们也可以自定义自己的 Partitioner，这时一般 Partitioner 和 ReduceTask 数量耦合。</p><p>需注意，<strong>Partitioner 的泛型为 Mapper 的输出类型</strong>（当然，也是 Combiner 的输出类型）。</p><h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><p>考虑将每个月的航班数据分离成独立的文件，从而能够方便对每月数据进行进一步分析这个需求，这里就很适合自定义 Partitioner。</p><p>首先，在 Driver 类中，需要指明 ReduceTask 的数量以及 Partitioner，根据需要，这里应当指定为 12 个——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">job.setNumReduceTasks(<span class="hljs-number">12</span>)<br>job.setPartitionerClass(classOf[<span class="hljs-type">MonthPartitioner</span>])<br></code></pre></div></td></tr></table></figure><p>自定义的 Partitioner 特别简单，将第 n 月分给第 n 个 Reducer 即可，注意 Reducer 的索引从 0 开始——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonthPartitioner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Partitioner</span>[<span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPartition</span></span>(key: <span class="hljs-type">Text</span>, value: <span class="hljs-type">Text</span>, numPartitions: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> =<br>    key.toString.toInt - <span class="hljs-number">1</span>   <span class="hljs-comment">// &quot;01&quot;对应 Reducer 0，&quot;02&quot;对应 Reducer 1...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitByMonthMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(key: <span class="hljs-type">LongWritable</span>, value: <span class="hljs-type">Text</span>, context: <span class="hljs-type">Mapper</span>[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">if</span> (value.toString.startsWith(<span class="hljs-string">&quot;Year&quot;</span>))<br>      <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">val</span> colGetter = <span class="hljs-type">AirlineCol</span>.build(value.toString.split(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    <span class="hljs-keyword">val</span> month = colGetter(<span class="hljs-type">AirlineCol</span>.<span class="hljs-type">Month</span>)<br>    context.write(<span class="hljs-keyword">new</span> <span class="hljs-type">Text</span>(month), value)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitByMonthReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>[<span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(key: <span class="hljs-type">Text</span>, values: lang.<span class="hljs-type">Iterable</span>[<span class="hljs-type">Text</span>], context: <span class="hljs-type">Reducer</span>[<span class="hljs-type">Text</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">NullWritable</span>, <span class="hljs-type">Text</span>]#<span class="hljs-type">Context</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// Reducer 能够收集到特定月的所有数据，这里什么都不需要做，直接输出即可</span><br>    values.forEach(context.write(<span class="hljs-type">NullWritable</span>.get, _))<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编写完成后进行运行，能看到输出文件夹下有 12 个结果文件，每个结果文件包含一定月的数据，如 00000 为 1 月，00001 为 2 月，00011 为 12 月，这种映射是不会改变的。<strong>但是每个结果文件内的数据并不有序</strong>。</p><p>该需求不需要 Combiner。</p><h1 id="MapReduce-Perspective"><a href="#MapReduce-Perspective" class="headerlink" title="MapReduce Perspective"></a>MapReduce Perspective</h1><p>一张图了事，细节之后再议。这里一个需要注意的地方是，<strong>Partitioner 的执行是在 Combiner 之前</strong>（这问题网上争论不一啊……经我本地的测试，确实是 Partitioner 先执行），所以是先分区，然后排序，然后再本地合并。</p><p>为啥是这样呢？我猜测是因为排序之后 Combine 操作才好进行，<strong>容易对每个 KEY 都并行，顺序地执行 Combine 操作</strong>（CPU 缓存友好？）；如果不排序的话就需要维护每个 KEY 的索引列表了，可能实现会更复杂些？这个过程在内存中进行，所以我认为这和硬盘是否顺序读写无关。</p><p><img src="/images/oss/20220306234133.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala 学习笔记——模式匹配</title>
    <link href="/2022/03-02Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html"/>
    <url>/2022/03-02Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html</url>
    
    <content type="html"><![CDATA[<p>Scala 确实很有趣，虽然它并非像 Haskell 那样优雅简洁，某些抽象，如代数数据类型，仍旧需要通过一些“模式”来实现，而它在 Haskell 中是能够非常优雅清晰地表述的，或许这是使用 OOP 对 FP 进行建模的必然结果吧？但了解它的抽象方式也是非常有趣的，相较于 Haskell 更为啰嗦这一点，也让我对一些之前学习 Haskell 时未曾理解的概念，如模式匹配的视图等有了更加深刻的理解。</p><p>总之，做一些关键概念的笔记，当前考虑几个需要重点了解的地方是——</p><ul><li>implicit, type class</li><li>trait，class，object，sealed 等的具体语义以及最佳实践</li><li>函数&#x2F;方法定义的各种语法及其差别</li><li>花括号&#x2F;括号的语义及最佳实践</li><li>模式匹配</li><li>Scala 类型系统</li></ul><p><strong>这里主要是记录一下关于 Scala 中模式匹配的使用方式，同时利用自己实现的一个 List 举一些例子</strong>，至于模式匹配的具体原理，那必须得从 PLT 着手了，当前是没有精力和能力去学习那种东西的。</p><span id="more"></span><h2 id="模式匹配——对数据的解构"><a href="#模式匹配——对数据的解构" class="headerlink" title="模式匹配——对数据的解构"></a>模式匹配——对数据的解构</h2><p>学习过 Haskell 的话，对模式匹配应当是非常熟悉的，比如，要获取列表的第二个元素，我们会直接这么写——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">second</span> :: [a] -&gt; <span class="hljs-type">Maybe</span> a<br><span class="hljs-title">second</span> (_:x:_) = <span class="hljs-type">Just</span> x<br><span class="hljs-title">second</span> _ = <span class="hljs-type">Nothing</span><br></code></pre></div></td></tr></table></figure><blockquote><p>在初学 Haskell 时，我曾以为解构的形式和结构的形式是一一对应的，比如，对于列表<code>data [] a = [] | a : [a]</code>，我曾以为在解构中就只能使用<code>:</code>和<code>[]</code>了；但这是错误的——ViewPattern 提供了创建更多解构符号的能力，在 Scala 中也能够实现类似的效果。</p></blockquote><p>在 Scala 中，也容易有等价的实现——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">second</span></span>[<span class="hljs-type">A</span>](lst : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] = lst <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> _ :: x :: _ =&gt; <span class="hljs-type">Some</span>(x)<br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span><br>&#125;<br></code></pre></div></td></tr></table></figure>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">关于 Scala 自定义操作符时的结合性问题</span></summary>        <blockquote><p>关于 Scala 自定义操作符时的结合性问题，（这里不考虑&#x3D;结尾的操作符）操作符默认为左结合，如果操作符的最右边是<code>:</code>，则右结合，如<code>1 +: 2 +: List()</code>，结合性为<code>1 +: (2 +: List())</code>。这里也可以认为，<code>:</code>符号贴近对象的先计算，可以通过 Seq 的<code>+:</code>，<code>:+</code>建立形象化的理解（想象一下我<del>抄袭</del>发明的&gt;&#x3D;&gt;符号，哈哈）——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-number">1</span> +: <span class="hljs-number">2</span> +: <span class="hljs-number">3</span> +: <span class="hljs-type">Nil</span> <br><span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) :+ <span class="hljs-number">4</span> :+ <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure></blockquote>            </details>  <p><strong>如果说构造函数用于构造数据，则模式匹配则是用于解构数据</strong>。</p><p>考虑这样一个数据类型——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShouJyo</span> (<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-class">  name: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-class">  age: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-class">  bestFriend: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-class"></span>)</span><br></code></pre></div></td></tr></table></figure><p>它是使用<code>case class</code>进行定义的，因此编译器会自动重写它的<code>toString</code>，<code>hashCode</code>，<code>equals</code>等方法；重写伴生对象的<code>apply</code>方法，使其同构造器一致；将所有类参数的访问暴露出来，因此我们可以通过伴生对象直接创建该类型的实例，并通过字段名直接访问它的数据——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> shoujyo = <span class="hljs-type">ShouJyo</span>(<span class="hljs-string">&quot;Chihaya&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;Haruka&quot;</span>)<br>println(<span class="hljs-string">s&quot;少女的名字是 <span class="hljs-subst">$&#123;shoujyo.name&#125;</span>，她的最好的朋友是 <span class="hljs-subst">$&#123;shoujyo.bestFriend&#125;</span>&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>那么，当我们需要将它的字段保存到变量中呢？如果对每个字段都分别创建变量的话需要三行，实在有点不够优雅，这里可以使用解构语法——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> shoujyo = <span class="hljs-type">ShouJyo</span>(<span class="hljs-string">&quot;Haruka&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;Chihaya&quot;</span>)<br><span class="hljs-keyword">val</span> <span class="hljs-type">ShouJyo</span>(name, age, _) = shoujyo<br>println(<span class="hljs-string">s&quot;名：<span class="hljs-subst">$name</span>，年龄：<span class="hljs-subst">$age</span>&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>这种写法同 Haskell 一致，我们通过“值构造器”把数据中的值取了出来，同时可以使用<code>_</code>符号来忽略值；同理，我们可以对 tuple 等数据结构进行解构。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> (a, b) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>println(a, b)<br><br><span class="hljs-keyword">val</span> x :: xs = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>println(xs) <span class="hljs-comment">// List(2, 3)</span><br></code></pre></div></td></tr></table></figure><p>这种解构不一定能够成功——比如对<code>[1,2]</code>解构成<code>x::y::z::xs</code>，这种解构必然会抛出一个<code>MatchError</code>。为了应付各种情况的解构，我们需要模式匹配语法。</p><h2 id="Scala-的模式匹配"><a href="#Scala-的模式匹配" class="headerlink" title="Scala 的模式匹配"></a>Scala 的模式匹配</h2><p>Scala 的模式匹配可以认为是 Haskell 的模式匹配以及守卫表达式的综合，下面的示例展示了模式匹配的一些语法——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">objectInfo</span> </span>(obj : <span class="hljs-type">Any</span>) = obj <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> d : <span class="hljs-type">Double</span> =&gt; <span class="hljs-string">s&quot;%d 是一个浮点数&quot;</span><br>  <span class="hljs-keyword">case</span> n : <span class="hljs-type">Int</span> <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> =&gt; <span class="hljs-string">s&quot;<span class="hljs-subst">$n</span> 是一个正整数&quot;</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ping&quot;</span> =&gt; <span class="hljs-string">&quot;pong!&quot;</span><br>  <span class="hljs-keyword">case</span> _ : <span class="hljs-type">String</span> =&gt; <span class="hljs-string">&quot;一个字符串&quot;</span><br>  <span class="hljs-keyword">case</span> lst @ (x :: xs) : <span class="hljs-type">List</span>[<span class="hljs-type">Any</span>] =&gt; <span class="hljs-string">s&quot;一个 list，第一个元素为<span class="hljs-subst">$x</span>，长度为<span class="hljs-subst">$&#123;lst.length&#125;</span>&quot;</span><br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;不造啊&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>该语法会从上到下匹配每一个 case，直到匹配成功，如果没有任何匹配，则抛出<code>MatchError</code>异常。</p><p><code>case d : Double =&gt; s&quot;%d 是一个浮点数&quot;</code>，这个 case 检查 obj 是否是 Double 类型，如果是，则将其赋值到变量 d，执行操作。</p><p><code>case n : Int if n &gt; 0 =&gt; s&quot;$n 是一个正整数&quot;</code>，这个 case 检查 obj 是否是 Int 类型，如果是，则将其赋值到变量 n，检查 n 是否大于 0，如果是则匹配，这里的行为类似 Haskell 的守卫表达式。</p><p><code>case &quot;ping&quot; =&gt; &quot;pong!&quot;</code>，这个 case 检查 obj 是否等于”ping”，如果等于则匹配。</p><p><code>case shouJyo@ShouJyo(name, age, _) =&gt; s&quot;$name 是少女，她的好朋友是$&#123;shouJyo.bestFriend&#125;&quot;</code>，该 case 有两个语法——@，语义同 Haskell 一致，解构的同时保留原对象；以及解构数据到变量中。</p><p><code>case _ : String =&gt; &quot;一个字符串&quot;</code>检查 obj 是否是字符串，如果是则匹配。</p><p><code>case _ =&gt; &quot;不造啊&quot;</code>是一个恒真的 case，它匹配任何值。</p><p>之前的例子<code>val ShouJyo(...) = ...</code>，其实等价于模式匹配语句，但只有一个 case。</p><span class="heimu">Haskell 做得到嘛！（战术后仰）</span><h2 id="解构的原理——以-List-为例子"><a href="#解构的原理——以-List-为例子" class="headerlink" title="解构的原理——以 List 为例子"></a>解构的原理——以 List 为例子</h2><p>考虑模仿 Scala 自定义一个 List，通过其了解模式匹配的机制。</p><p>使用 Haskell 的语法表述的话（符号用的 Idris 的），List 的定义为——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">List</span> a = <span class="hljs-type">Nil</span> | a :: <span class="hljs-type">List</span> a</span><br></code></pre></div></td></tr></table></figure><p>在 Scala 中，定义会更加复杂——类型构造器需要使用<code>sealed trait</code>或<code>sealed abstract class</code>来定义，类型参数设为<code>+A</code>，而值构造器，如果它的集合大小仅为 1，比如 Nil，则使用<code>case object</code>定义并继承类型构造器，类型参数设为<code>Nothing</code>，如果大于一，则使用<code>final case class</code>定义，类型参数设为<code>A</code>；类型的所有方法都放置在类型构造器中。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">List</span>[+<span class="hljs-type">A</span>] </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">head</span> </span>: <span class="hljs-type">A</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last</span> </span>: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Nil</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">List</span>[<span class="hljs-type">Nothing</span>] </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">head</span> </span>= <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">&quot;head of empty list&quot;</span>)<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last</span> </span>= <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">&quot;last of empty list&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 通过类参数直接覆盖了父类的方法</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span> [<span class="hljs-type">A</span>] (<span class="hljs-params">head : <span class="hljs-type">A</span>, last : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">List</span>[<span class="hljs-type">A</span>]</span><br><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">List</span> </span>&#123;<br>  <span class="hljs-comment">// 用于演示</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">A</span>](elems : <span class="hljs-type">A</span>*) : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>] =<br>    elems.foldRight(<span class="hljs-type">Nil</span>:<span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(<span class="hljs-type">Cons</span>.apply)<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意，这里的<code>Nil:List[A]</code>是类型标注（没错，值也可以做类型标注），而非类型转换，类型转换是 asInstanceOf 方法， 对应 Java 的强制转换，这种类型标注在 Java 中没有对应。</p></blockquote><p>有了这个定义后，我们已经可以通过 Cons 进行类型匹配了，下面的方法获取 List 的第二个元素。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">secondElem</span></span>[<span class="hljs-type">A</span>](lst : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] = lst <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(_, <span class="hljs-type">Cons</span>(x, _)) =&gt; <span class="hljs-type">Some</span>(x)<br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>但这好用吗？一点都不好用，就感觉自己像在写 Lisp，Scala 提供了我们另一种方式——自定义 ViewPattern——来解决这一问题（这个名词来自于 Haskell，不确定 Scala 有没有）。</p><p>但首先我们要看模式匹配的原理。进行模式匹配时，Scala 会试图去寻找匹配的类（在上面的例子里，为 Cons）的伴生对象的<code>unapply</code>方法，该方法的签名和 apply 正好对应——参数是该类的实例，返回值为所有数据的元组（使用 Option 包装，因为解构有失败的可能性），如上面的 Cons，它的 unapply 方法可能是这样的——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unapply</span></span>(lst : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : <span class="hljs-type">Option</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])] =<br>    <span class="hljs-keyword">if</span> (lst == <span class="hljs-type">Nil</span>) <span class="hljs-type">None</span> <span class="hljs-keyword">else</span> <span class="hljs-type">Some</span>((lst.head, lst.last))<br></code></pre></div></td></tr></table></figure><p>这就给我们一个想法——我们可以定义另外的 object 并重写 object，达到编写模式匹配中的模式的目的！比如，我们可以编写一个名为<code>::</code>的 object，它的实现和 Cons 的 unapply 一致——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 根据结合性的规则，:: 符号右结合</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> </span>:: &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unapply</span></span>[<span class="hljs-type">A</span>](lst : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : <span class="hljs-type">Option</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])] =<br>    <span class="hljs-keyword">if</span> (lst == <span class="hljs-type">Nil</span>) <span class="hljs-type">None</span> <span class="hljs-keyword">else</span> <span class="hljs-type">Some</span>((lst.head, lst.last))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用该“模式”重写 secondElem 方法——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">secondElem</span></span>[<span class="hljs-type">A</span>](lst : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] = lst <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> _ :: y :: _ =&gt; <span class="hljs-type">Some</span>(y) <br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>BINGO! 我们达到了和原生 Scala 代码一样的清晰度！</p><p>但我们也可以做的更多，超越（没有扩展的）Haskell 以及 js——谁说列表只能解构前缀呢？我们定义一下 Scala 同时提供的<code>:+</code>——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 根据结合性规则，左结合</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> </span>:+ &#123;<br>  <span class="hljs-comment">// 工具函数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldr</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] (lst : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>], zero : <span class="hljs-type">B</span>, acc : (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>) : <span class="hljs-type">B</span> = lst <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-keyword">case</span> x :: xs =&gt; acc(x, foldr(xs, zero, acc))<br>    <span class="hljs-keyword">case</span> _ =&gt; zero<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_last</span></span>[<span class="hljs-type">A</span>] (lst : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : (<span class="hljs-type">List</span>[<span class="hljs-type">A</span>], <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]) =<br>    foldr[<span class="hljs-type">A</span>, (<span class="hljs-type">List</span>[<span class="hljs-type">A</span>], <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>])](lst, (<span class="hljs-type">List</span>[<span class="hljs-type">A</span>](), <span class="hljs-type">Option</span>.empty), &#123;(x, acc) =&gt;<br>      <span class="hljs-keyword">val</span> (count, init) = acc<br>      <span class="hljs-keyword">if</span> (init.isEmpty) (<span class="hljs-type">Nil</span>, <span class="hljs-type">Some</span>(x))<br>      <span class="hljs-keyword">else</span> (<span class="hljs-type">Cons</span>(x, count), init)<br>    &#125;)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unapply</span></span>[<span class="hljs-type">A</span>](lst : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : <span class="hljs-type">Option</span>[(<span class="hljs-type">List</span>[<span class="hljs-type">A</span>], <span class="hljs-type">A</span>)] = &#123;<br>    <span class="hljs-keyword">val</span> (init, optionLast) = init_last(lst)<br>    optionLast.map((init, _))<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last3Elem</span></span>[<span class="hljs-type">A</span>](lst : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]) : <span class="hljs-type">Option</span>[(<span class="hljs-type">A</span>,<span class="hljs-type">A</span>,<span class="hljs-type">A</span>)] = lst <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> xs :+ x :+ y :+ z =&gt; <span class="hljs-type">Some</span>((x,y,z))<br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span><br>&#125;<br>last3Elem(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)) <span class="hljs-comment">// Some((3,4,5))</span><br></code></pre></div></td></tr></table></figure><p>精彩！这应该就是所谓的 View 模式，借助它，我们可以对那些实现并非 trival 的数据类型，比如 Map 进行模式匹配了！就是感觉要做的额外的类型标注有点多麻烦……怀疑是我的写法并非最佳实践</p><p>一个需要特别注意的一点是，结构和解构的方法并非是一一对应的——这里实现的<code>::</code>，<code>:+</code>仅能够用于解构，如果想实现结构操作，需要通过隐式参数等方式在 List 上实现同名方法！实现其的 apply 方法也是不能奏效的——如此只能实现类似<code>::(1, Nil)</code>的操作！<strong>Scala 能够在解构时把模式当作中缀操作符来看待，但结构时无法如此</strong>！</p><h1 id="关于-A"><a href="#关于-A" class="headerlink" title="关于+A"></a>关于<code>+A</code></h1><p>在这里的 List 的定义里，类型参数 A 中有一个<code>+</code>，这代表着该参数是<strong>协变</strong>的，这是说，该类型参数<code>A</code>的类型关系会被原样映射到<code>List[A]</code>，举个例子，假如<code>Dog</code>是<code>Animal</code>的子类，则<code>List[Dog]</code>是<code>List[Animal]</code>的子类。如果不给定该<code>+</code>，则<code>List[Dog]</code>和<code>List[Animal]</code>将没有继承关系了。</p><p>那么为什么使用协变呢？再重申一下上面的<code>List</code>的定义：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">List</span>[+<span class="hljs-type">A</span>] </span>&#123; <span class="hljs-comment">/* ... */</span>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Nil</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">List</span>[<span class="hljs-type">Nothing</span>] </span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span> [<span class="hljs-type">A</span>] (<span class="hljs-params">head : <span class="hljs-type">A</span>, last : <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">List</span>[<span class="hljs-type">A</span>]</span><br></code></pre></div></td></tr></table></figure><p>考虑我们需要定义一个<code>Int</code>的<code>List</code>的空列表，我们可能会这么写：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// 为什么类型使用 List[Int] 而非 Nil 呢？从 Haskell 来的话应该能知晓，List 是类型构造器，而 Cons 和 Nil 是值构造器，值构造器出现在类型签名中的话实在品味不太好，而且对于 Nil 的话，就根本无法表达这里的 Int 类型信息</span><br><span class="hljs-keyword">val</span> emptyIntList : <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Nil</span><br></code></pre></div></td></tr></table></figure><p>再回想一下我们在 Java 中是如何使用数据结构的——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; lst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br></code></pre></div></td></tr></table></figure><p>类比一下，就能够明确出来，<strong>为了满足类型的匹配，<code>Nil</code>必须是<code>List[Int]</code>的子类</strong>！而 Nil 本身是<code>List[Nothing]</code>的子类，因此，**<code>List[Nothing]</code>必须是<code>List[Int]</code>的子类**！而我们已知<code>Nothing</code>是所有类型的子类，因此它也是<code>Int</code>的子类，因此这里如果是协变的话，从<code>Nothing &lt;: Int</code>，就能够得到<code>Nil &lt;: List[Nothing] &lt;: List[Int]</code>。</p><blockquote><p><code>A &lt;: B</code>表示 A 是 B 的子类，类似 java 泛型的 extends，<code>A &gt;: B</code>表示 B 是 A 的子类，即 java 泛型的 super，可以认为这里的<code>&lt;</code>和<code>&gt;</code>表示是类型的“范围”的大小，越是子类，范围显然越小。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Zookeeper 的一些笔记</title>
    <link href="/2022/02-21Zookeeper%E7%AC%94%E8%AE%B0.html"/>
    <url>/2022/02-21Zookeeper%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>一些（真的是一些） zookeeper 的 java 客户端的代码见<a href="https://github.com/V-YOP/code-repository/tree/master/zookeeper">此</a>。最近在实际项目中也感觉到了能够使用 Zookeeper 的地方…显然，如果没有遇到过需要在分布式情况下进行同步的需求，就无法理解 Zookeeper “协调服务”的意义。</p></blockquote><p>Zookeeper 这个名词听到过无数遍了，服务发现、集群配置、负载均衡有它，分布式锁有它，大数据里也有它，可是 Zookeeper 究竟是个啥东西？</p><h2 id="是啥"><a href="#是啥" class="headerlink" title="是啥"></a>是啥</h2><p>Zookeeper 是一个开源的，分布式的，为分布式框架提供<span style="color: #FF0000">协调服务</span>的中间件。Zookeeper 基于发布-订阅模式——<strong>它会存储和管理一些重要数据，并允许特定对象对这些数据进行订阅，若这些数据的状态改变则向所有对该状态进行观测的对象发起通知</strong>。Zookeeper 使用自己的一个虚拟的文件系统来存储数据，可以认为——</p><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p><strong>Zookeeper &#x3D; 文件系统 + 监听&#x2F;通知机制</strong></p>            <i class="fa fa-quote-right"></i>          </blockquote><blockquote><p>尚硅谷的人说这是观察者模式，但普通的观察者模式中，消息的发布者是需要维护消息接受者的集合的，因此仍旧是一种松散的耦合，而 Zookeeper 应当是无耦合的——发布者（修改数据者）不知道有谁监听该数据，而接收者不知道是谁修改的该数据。因此我认为这是一个发布-订阅模式，其中发布者和接收者中间存在一个代理人 Broker，它就是 Zookeeper。</p></blockquote><p>一些特点——</p><ol><li>Zookeeper 是主从架构，其集群由一个 Leader 和多个 Follower 组成（但 Leader 是可变的，不会有单点故障）</li><li>集群中只要有<strong>半数以上</strong>（不包括半数，所以奇数的节点是比较好的）的节点还存活，则 Zookeeper 集群就能正常工作</li><li>Zookeeper 是 CP 原则，全局数据一致</li><li>同一个 Client 的请求按发送顺序执行</li><li><strong>数据更新是原子的</strong>（和 Redis 一样）</li><li>集群节点之间数据同步实时性高</li></ol><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>Zookeeper 的存储结构和 Unix 的文件系统类似，为树状结构，<strong>但不区分目录和文件，即不区分根节点和叶子节点</strong>，每个节点都称作 <code>ZNode</code>，默认存储 1M 数据，<strong>ZNode 通过路径唯一标识</strong>。</p><p><img src="/images/oss/20220220140033.png"></p><h2 id="生产环境下的部署"><a href="#生产环境下的部署" class="headerlink" title="生产环境下的部署"></a>生产环境下的部署</h2><p>并非集群中的每台机器都需要部署 zk 节点——</p><ul><li>10 台服务器：3 个 zk</li><li>20 台服务器：5 个 zk</li><li>100 台服务器：11 台 zk</li><li>200 台服务器：11 台 zk</li></ul><h2 id="客户端监听"><a href="#客户端监听" class="headerlink" title="客户端监听"></a>客户端监听</h2><p>客户端监听的事件分为两类：节点数据的变化；子节点的数量增减。</p><p>监听是一次性的，一旦监听到了事件，触发后监听就被取消了。</p><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>写操作发送给 Leader 的情况，Leader 有写权限，直接写自己，然后向 Follower 发起写请求，等待 ACK，当写的节点超过半数，则认为写成功，向客户端发送 ACK；发送后再继续向其他 Follower 发送写请求，等待 ACK，直到所有节点都写入。</p><p><img src="/images/oss/20220220220408.png"></p><p>写操作发送给 Follower 的话，Follower 直接把操作转发给 Leader，让 Leader 进行处理；Leader 自己先写，然后向该 Follower 发起写请求，等待 ACK；超过半数后，<strong>Leader 向该 Follower 发起 ACK，该 Follower 再把 ACK 发送给客户端</strong>（注意 ACK 的发送者必定是客户端请求的接受者）；之后操作同上面一致。</p><p><img src="/images/oss/20220220221008.png"></p><blockquote><p>猜测两个客户端同时对同一个节点进行写操作（比如分布式锁），必有一个失败，因为两个操作必须得到半数以上的节点都进行过写操作，这其中必然会出现版本号，ID 之类的冲突，这里总共有三种情况——两个操作都打到 Follower 上；两个操作都打到 Leader 上；两个操作分别打到 Follower，感觉三种情况都能在 Leader 处得到妥善处理。</p></blockquote><h2 id="关于选举"><a href="#关于选举" class="headerlink" title="关于选举"></a>关于选举</h2><p>第一次选举即服务器启动时，ID 最大的胜出；其后的选举（每一个节点新加进来都会发起选举，每一个节点的网络出现问题，使它以为 Leader 不存在时，会发起选举）中，按如下的规则选举——</p><p>每个节点有三个属性——选举轮次 EPOCH（选举了多少次，有的节点可能会“火星”，都不知道有发生过选举），事务 ID（每次进行修改都会增加事务 ID），服务器 ID（即 myid）。</p><ol><li>如果某节点选举轮次最大，则它获胜</li><li>选举轮次相同的，事务 ID 最大的获胜</li><li>事务 ID 相同的，myid 最大的获胜</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ZooKeeper</tag>
      
      <tag>Big Data</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello, MapReduce——Word Count</title>
    <link href="/2022/02-19MapReduce%E7%9A%84hello-world.html"/>
    <url>/2022/02-19MapReduce%E7%9A%84hello-world.html</url>
    
    <content type="html"><![CDATA[<p>感谢 Docker，对各种环境的反复试验和修改从而变得可行，折磨了三四天后，我总算弄出了一个好用的 docker…集群，它足够易自定义以方便我快速搭建 hadoop 的环境，让我能专心“业务”，从这些玩意上解放出来。</p><p><a href="https://github.com/V-YOP/yuuki-hadoop"><img src="https://gh-card.dev/repos/V-YOP/yuuki-hadoop.svg"></a></p><p>总之，在之前了解了 Hadoop 的 HDFS，学习了它的原理，终端的一些操作以及 JavaAPI（每个方法都受检，不愧是你！），现在到了真正解决问题的时候了——MapReduce。这里做下关于 MapReduce，以及它的第一课——WordCount 的笔记，主要参考 Hadoop 权威指南以及尚硅谷的视频（官方文档未免跳的太快）。</p><span id="more"></span><h2 id="MapReduce-是什么"><a href="#MapReduce-是什么" class="headerlink" title="MapReduce 是什么"></a>MapReduce 是什么</h2><p>MapReduce 是一个基于 Hadoop 平台的，高度并行的<strong>分布式运算框架</strong>（与此相对地，HDFS 是系统），它能充分利用多核处理器，并具有高度的容错性，能够处理海量的数据。用户只需继承简单的抽象类便可轻易嵌入自己的业务逻辑并交付给服务器（实际上是 Yarn，ResourceManager）执行。同时借助 Hadoop Stream，它可以使用其他语言对 Mapper，Reducer 进行编写。</p>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">关于 MapReduce 的优缺点</span></summary>        <blockquote><p>MapReduce 的优点如下——</p><ol><li>容易编程，对用户来说，他只需要关心 Map 和 Reduce 的业务逻辑即可，关于任务的调度和分配，各节点的通信等细节都是透明的（必须表扬这点：它对此做了足够的抽象，以至于相关代码在本地执行还是在远程的 HDFS 上执行对用户来说都是一样的，因此对其进行调试非常容易——在本地执行即可）</li><li>容易横向扩展</li><li>高容错性，即使特定节点的任务失败了，它仍旧能自动地将该任务分配给其它节点，不会导致整个任务直接挂掉</li><li>支持海量数据（TB 级，PB 级）的计算</li></ol><p>缺点如下——</p><ol><li>无法支持实时计算</li><li>不擅长流式计算——使用的数据必须预先准备，无法后续再添加；Spark 擅长此项</li><li>不擅长迭代式计算——后面的计算需要使用前面计算的结果的计算；Spark 擅长此项</li></ol></blockquote>            </details>  <p>关于 MapReduce 为什么叫 MapReduce，我认为这是因为它的执行过程典型地出现了 Map 和 Reduce 操作——</p><p>它首先会将任务划分成互相独立的多个部分，交与各节点去执行，得到一个输出，如果将任务的各部分看作一个集合，这就成为了一个典型的 Map 操作——<strong>对集合的每一个元素执行相同的操作，得到对应的结果并组成新的集合</strong>。划分任务由框架负责，而各节点执行的 Map 操作称为 <strong>MapTask</strong>，大小为块大小。</p><blockquote><p>但有一说一，MapTask执行的操作更像是<code>flatMap</code>，每一次执行Map操作时都能够向上下文中写入复数的数据，这些数据最终是扁平的。</p></blockquote><p>将各节点的输出结果进行汇总得到最终结果是算法的第二部分。如果将各 MapTask 的结果当成一个集合，则这就成为了一个典型的 Reduce 操作——<strong>将集合中每一个元素“积累”到一个值上</strong>，而每一个 Reducer 的行为实际上也是 reduce——将 Mapper 的中间结果中的“一类值”累积到一个值中；各节点要进行的 Reduce 操作称为 <strong>ReduceTask</strong>。</p><p>当然，<strong>问题远没有这么简单</strong>，比如这里想当然可以提一个问题——Reduce 操作怎么并行？<span class="heimu">答案应该可以概括为——每个 ReduceTask 处理“同一类”数据。</span>显然我们不能单单从函数式编程的角度来对 MapReduce 望文生义——在 MapReduce 的实际架构中，还得引入几个额外角色——<code>Combiner</code>，<code>Partitioner</code>；在 Map 和 Reduce 阶段中间，有着所谓的 shuffle 阶段；MapReduce 强迫数据必须使用 KV 对的形式……想必这些都是为了能最好地并行化。</p><p>一个需要特别注意的地方是，MapReduce 的输入，输出以及所有中间结果必须保存在硬盘上（但不一定保存在 HDFS 里，如 Map 的中间结果是不会落到 HDFS，而是落到本地文件系统中），这会增加许多 IO 时间，实际上让 Hadoop 难以处理实时计算任务。</p><blockquote><p><strong>不一定！如果自定义 OutputFormat，输出可以不是 HDFS，它可以是数据库，本地硬盘，或第三方系统！</strong></p></blockquote><p>题外话——关于并行的 reduce，我想到了 java8 stream 里的 reduce，它和 Java8-reduce 都为并行情况做了特殊处理，并且它们中都有个叫”Combiner”的角色，虽然其在两者中发挥的作用是不同的。为此，<a href="/2022/02-17%E5%85%B3%E4%BA%8EJava8-stream%E4%B8%AD%E7%9A%84reduce%E6%93%8D%E4%BD%9C.html" title="关于 Java8 的 stream 中的 reduce 操作">我去了解了一下关于 java8-reduce 的使用</a>。</p><h2 id="WordCount-一窥"><a href="#WordCount-一窥" class="headerlink" title="WordCount 一窥"></a>WordCount 一窥</h2><p>先从一个实例来看一看怎么编写 MapReduce 的业务代码，这里选择官方推荐的教程案例——wordCount，统计字符串中各单词的数量。</p><p>WordCount 程序可以这样描述——</p><ol><li>先将输入字符串按行切分成许多个 MapTask，分配给各节点处理</li><li>各节点将 MapTask 中的字符串每行按字符串划分，统计每行每个单词的出现，将结果输出</li><li>MapTask 的结果在本地预先进行一次聚集，经框架汇总和处理后被按特定顺序进行排序、分组、将每个组传递给特定的 ReduceTask，分配给各 Reducer 节点处理（MapTask 的数量和数据集的大小成正比，而 ReduceTask 的数量是独立指定的）</li><li>各节点统计各单词出现次数，输出结果到文件中</li><li>框架汇总输出文件，得到最终输出文件</li></ol><p><img src="/images/oss/20220218215040.png"></p><p>每个 ReduceTask 都包含所有 MapTask 的结果的一部分，比如说，假设它的 partitioner 是按字符串的“基数”进行分区，则 MapTask1，2，3 的结果中可能所有 A、B、C 开头的所有单词会传递给 ReduceTask1，D、E、F 开头的所有单词会传递给 ReduceTask2……<strong>但实际的 partitioner 一般使用哈希算法，以保证分区尽量均匀；而用户则需要保证每个 MapTask 的输出值尽量均匀，即每个 K 对应的 V 的数量尽量相同，从而保证每个 ReduceTask 的工作量基本相同</strong>。</p><p>另外，也是由于每个 ReduceTask 都需要拿到所有 MapTask 的结果的一部分，<strong>ReduceTask 因此享受不到数据本地化的优势——MapTask 的结果必须通过网络传输给 ReduceTask</strong>。</p><p>MapReduce 程序中，用户最少需要编写三个部分——<strong>Driver：程序的入口，创建配置和 job；Mapper：处理 MapTask 的业务类；Reducer：处理 ReduceTask 的业务类</strong>。</p><p><strong>Mapper 和 Reducer 使用和产生的数据都为 KV 对的形式</strong>，Mapper 的接口形如<code>Mapper&lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt;</code>，其中 KEYIN 为输入数据的标识符，VALUEIN 为输入数据，KEYOUT 结果数据的标识符，VALUEOUT 为结果数据，Mapper 中的 map 方法为我们需要重写的业务方法，它的签名为<code>void map(KEYIN, VALUEIN, Context)</code>（Context 为实现 MapperContext 的类，它包含了所有所需类型信息），<strong>map 方法对每一个输入数据的 KV 对都会调用一次</strong>，Context 负责对应输出文件等信息，看签名就知道，这方法的结果必须要通过 Context 写出去。</p><p>在 WordCount 实例中，KEYIN 是行的偏移量（不是行号，是该行相对于文件开头偏移多少字节），VALUEIN 是该行的内容。WordCount 的 Mapper 大概长这样——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// IntWritable 对应 Integer，Text 对应 String，Hadoop 为了提供更轻量级的序列化功能，为所有基本类型都做了一定的包装，使用它自己的一套序列化机制</span><br><span class="hljs-comment">// 可惜！倘若 Hadoop 使用 Scala，因而有 implicit 之类的机制，就可以直接使用原生类型了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCountMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outputK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IntWritable</span> <span class="hljs-variable">ONE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (String s : value.toString().split(<span class="hljs-string">&quot;\\s&quot;</span>)) &#123;<br>            outputK.set(s);<br>            <span class="hljs-comment">// write 应该是一个 append 操作，在文件尾部插入这样一个 KV 对</span><br>            <span class="hljs-comment">// 改变 outputK 的值是不要紧的，甚至是官方推荐的</span><br>            context.write(outputK, ONE);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            Mapper 看到的数据就像</span><br><span class="hljs-comment">            1 hello, happy world! hello, kokoro!</span><br><span class="hljs-comment">            2 happy! lucky! smile! yeah!</span><br><span class="hljs-comment">            Mapper 生成的数据就像</span><br><span class="hljs-comment">            hello 1</span><br><span class="hljs-comment">            happy 1</span><br><span class="hljs-comment">            world 1</span><br><span class="hljs-comment">            hello 1</span><br><span class="hljs-comment">            kokoro 1</span><br><span class="hljs-comment">            happy 1</span><br><span class="hljs-comment">            lucky 1</span><br><span class="hljs-comment">            ...</span><br><span class="hljs-comment">            虽然看起来很傻，但是 Hadoop 考虑过这种情况——Combiner</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">关于拉模式和推模式</span></summary>        <blockquote><p>Mapper 的 map 方法是典型的<strong>推模式</strong>——服务端，即任务的上下文，一行一行地把数据推给 mapper 的 map 方法，期待其做出动作，该操作就像处理 STDIN，消息队列的接受者，MVC 框架中的控制器……</p><p>而<strong>拉模式</strong>，则是把所需的数据直接拿到而进行处理，倘若重写 run 方法，就能得到所谓的拉模式了，也可以将每一行数据都暂存在成员变量中，在 cleanup 方法时一次性全处理掉，这似乎也可以称作一种拉模式？</p></blockquote>            </details>  <p>Reducer 接口的签名为<code>Reducer&lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt;</code>，它的输入的类型必须和 Mapper 的输出的类型一致。Reducer 的接口和 Mapper 的形状一样，但是它的行为和 Mapper 不同：<strong>Reducer 的业务方法 reduce 对“每一类”的对象，即 KEY 相同的所有 KV 对数据执行一次</strong>，这可以从 reduce 的方法签名中一窥——<code>void reduce(KEYIN, Iterable&lt;VALUEIN&gt;, Context)</code>。显然，框架必须在内部做一些分组的活。</p><p>Reducer 的示例大概长这样——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCountReducer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IntWritable</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 一个典型的 reduce 操作，values.reduce((acc, x) -&gt; acc + x.get(), 0)</span><br>        <span class="hljs-keyword">for</span> (IntWritable value : values) &#123;<br>            sum += value.get(); <br>        &#125;<br><br>        res.set(sum);<br>        context.write(key, res);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            （不考虑 Combiner 的话）reducer 看到的数据就像</span><br><span class="hljs-comment">            hello [1,1,1,1] </span><br><span class="hljs-comment">            world [1,1,1]</span><br><span class="hljs-comment">            ...</span><br><span class="hljs-comment">            reducer 生成的数据就像</span><br><span class="hljs-comment">            hello 4</span><br><span class="hljs-comment">            world 3</span><br><span class="hljs-comment">            ...</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>    <details style="margin-bottom:15px; margin-top:15px">        <summary><span style="font-size: 1.225em; font-weight: bold;border-bottom: 1px solid #ccc;color: var(--link-color);outline: 0;text-decoration: none;overflow-wrap: break-word;word-wrap: break-word;cursor: pointer">关于对官方示例的一个吐槽</span></summary>        <blockquote><p>Hadoop 的官方示例把用到的 Text 和 IntWritable 都作为成员变量了，这虽然性能会好一些（真的会好吗？在现在的 jvm 这样变态的优化下？），但是严重影响了代码的可理解性（任何有编码经验的人都知道把可变对象的引用传给别人后再对它进行修改绝不是好主意）。</p><p>为了强迫自己接受这种写法，这里必须记住一个前提——<code>context.write</code>方法接收到输入后会立刻进行某种复制（或持久化），因此它引用的数据，即 Text 和 IntWritable 即使修改了也不会产生任何影响。这个前提在细节上出现错误也不要紧，的确是这个效果就好。</p></blockquote>            </details>  <p>Driver 的示例平平无奇，这里是使用本地文件系统的情况。很棒的一点是，无论是直接跑还是打成 jar 包发到 hadoop 集群里跑，它的代码（甚至配置）是不需要做任何改动的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>        <span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> Job.getInstance(conf, <span class="hljs-string">&quot;word count&quot;</span>);<br>        job.setJarByClass(Main.class);<br>        job.setMapperClass(WordCountMapper.class);<br>        job.setCombinerClass(WordCountReducer.class);<br>        job.setReducerClass(WordCountReducer.class);<br>        job.setOutputKeyClass(Text.class);<br>        job.setOutputValueClass(IntWritable.class);<br>        FileInputFormat.addInputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;file:///Users/mememe/tmp/input&quot;</span>));<br>        FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;file:///Users/mememe/tmp/output&quot;</span>));<br>        System.exit(job.waitForCompletion(<span class="hljs-literal">true</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>示例代码<a href="https://github.com/V-YOP/code-repository/tree/master/hadoop_mapreduce/src/main/java">见此</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Java8 的 stream 中的 reduce 操作</title>
    <link href="/2022/02-17%E5%85%B3%E4%BA%8EJava8-stream%E4%B8%AD%E7%9A%84reduce%E6%93%8D%E4%BD%9C.html"/>
    <url>/2022/02-17%E5%85%B3%E4%BA%8EJava8-stream%E4%B8%AD%E7%9A%84reduce%E6%93%8D%E4%BD%9C.html</url>
    
    <content type="html"><![CDATA[<p>在之前再次学习折叠操作的时候，我曾做了一些<a href="/2022/01-30%E4%B8%80%E7%A7%8D%E6%96%B9%E4%BE%BF%E7%90%86%E8%A7%A3%E6%8A%98%E5%8F%A0%EF%BC%88fold%EF%BC%89%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E6%B3%95.html" title="一种方便理解折叠（fold）操作的方法">笔记</a>，并且使用 js 编写了一些示例。当时本打算同时也介绍一下 Java8 的 stream 中提供的 reduce 方法（以下简称 java8-reduce），但发现其行为和 js 中的相去甚远——<strong>为了高性能和并发支持，它的 reduce 方法是经过大量优化的，也引入了自己独有的所谓 Combiner</strong>，可谓是“Java 特色 reduce 操作”（哈哈！）。</p><p>最近学习 Hadoop 的 MapReduce 的时候，它的 Combiner 让我又回想起 java8-reduce 中的 Combiner（虽然其行为完全不是一回事就是了，MapReduce 中的 Combiner 的目的是预先进行一次本地的聚集，减少网络传输成本；java8-reduce 的 Combiner 的目的是归并各部分 reduce 的结果，得到最终值），因此这里又回过头来学习一波。</p><blockquote><p>咳咳，学过 MR 的 Combiner 后回过头来一看，发现它的行为（至少是接口）确实和 java8-reduce 的非常像，它们都需要保证输入和输出的签名是相同的以进行反复的 Combine。</p></blockquote><blockquote><p>咳咳，学到 Spark 又回过头来看，发现 RDD 的 Aggregate 和 java8-stream 的并发版的 reduce 的签名是一致的，令人感叹。</p></blockquote><blockquote><p>咳咳，学习函数式编程时，编写一个二叉树的 fold 方法，能发现它也需要一个 combiner方法，将左右子树得到的结果进行拼接。combiner 这个角色显然使用的地方是更加普遍的，它绝非仅是某种 Java 特色的产物，而是函数式编程在工程实践中发现出的一种模式。</p></blockquote><span id="more"></span><p>如果要说 java8-reduce 的最明显的特点，我认为有两个——</p><p>首先，它非常合适同 Java 的可变集合一起工作（collect 方法），这在其他语言里是见不到的，这样既符合 java 传统的编程模式，也能保证足够的性能，甚至在并发情况下也能够应付。</p><p>然后，它<strong>允许并发的 reduce 操作</strong>；java8-reduce 能把集合切分成多个部分，对每个部分并行地执行 reduce 操作，并通过所谓的 combiner 函数两两组合，得到最终结果；但显然使用并行的 reduce 操作时必须符合特定约束，以保证其能正确执行，无关切分情况或处理器核心数量。</p><p>挨个点名！</p><h2 id="The-easiest-way"><a href="#The-easiest-way" class="headerlink" title="The easiest way"></a>The easiest way</h2><p>最简单的 reduce 操作就是结果值和集合内的值同类型的 reduce 了，比如对集合求积，求和，Java 中干这事一样简单——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 不给定初始值也可，此时返回类型会变成 Optional&lt;Integer&gt;，这点还挺酷的，很“纯”。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).reduce(<span class="hljs-number">0</span>, (acc, x) -&gt; acc + x); <span class="hljs-comment">// or Integer::sum</span><br>System.out.println(sum);<br></code></pre></div></td></tr></table></figure><p>但 Java 未提供 reduceRight 方法，想必是认为其应用范围不广，事实也确实如此。</p><h2 id="Parallel-Where-thing-goes-wrong"><a href="#Parallel-Where-thing-goes-wrong" class="headerlink" title="Parallel: Where thing goes wrong"></a>Parallel: Where thing goes wrong</h2><p>上面是串行流，它的行为同其它语言一致，但若是并行流呢？试试下面的代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).parallel().reduce(<span class="hljs-number">1</span>, Integer::sum);<br>System.out.println(sum);<br></code></pre></div></td></tr></table></figure><p>结果是什么？如果是串行流的话，结果是肯定的——7，但这是并行流，我的电脑的结果是 9。也可以去尝试一下其它结果，最后会发现，只要 zero 参数（java 叫做 identity，这个名字兴许能给我们启发）不为 0，最后并行得到的结果和串行必然不一样。</p><p>那么，并行流的 reduce 究竟是怎么跑的？</p><p>我们知道，串行流的 reduce 可以描述成把集合中各元素通过一个二元操作符相连接，比如上面的求集合的和可以写成——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-number">0</span> &gt;=&gt; <span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>但是并行流显然不是这样干的，总的来说，并行流的 reduce 操作，会先把流切分成多个部分（具体切分数目由处理器核心数量决定），然后对每个部分各自并行执行 reduce 操作，然后<strong>再两两进行 Combine 操作</strong>，得到最终结果，这里的每个切分的部分，可以把它称作<code>ReduceTask</code>，比如对<code>[1,2,3,4,5].reduceParr(1, plus)</code>，它的计算过程可能是这样的——</p><ol><li>将<code>[1, 2, 3, 4, 5]</code>切分成四段，<code>[1]</code>，<code>[2]</code>，<code>[3]</code>，<code>[4, 5]</code></li><li>对每一段，并行调用 reduce 方法，即<code>[1].reduce(1, plus)</code>，<code>[2].reduce(1, plus)</code>……得到<code>2</code>，<code>3</code>，<code>4</code>，<code>10</code>。</li><li>对结果两两执行 combine 操作，<strong>这里的 combine 操作即 acc 操作</strong>，即 plus，<code>combine(combine(2, 3), combine(4, 10))</code></li><li>得到结果——19。（实践好像是分了 5 段，因此结果是 20）</li></ol><p>具体流程是我们不应该关心的，我们只需要知道，<strong>各个部分会分别 reduce，然后会两两 combine，最终得到最终结果</strong>。这里的“两两 combine”不是说从左往右依次 combine（这不就又是一个串行的 reduce 嘛），想象一下归并排序的迭代版，它自底向上，每次 combine 的都是更“大”的值。</p><p><strong>对于同类型的 reduce 操作，combine 函数同 acc 函数相同</strong>，所以<code>[1,2,3].reduce(0, Integer::sum)</code>也可以描述成<code>[1,2,3].reduce(0, Integer::sum, Integer::sum)</code>，表示它的合并和积累函数都是 sum。</p><h2 id="非同类型的-reduce"><a href="#非同类型的-reduce" class="headerlink" title="非同类型的 reduce"></a>非同类型的 reduce</h2><p>只有在非同类型的 reduce 操作中，combine 才会明确显示出来——它需要用户主动去定义，但我们先来看看 Java 特色的 reduce 操作。</p><p>非同类型的 reduce 操作有两个方法可用——</p><ul><li><p><code>reduce(identity : U, acc : (U, T) =&gt; U, combiner : (U, U) =&gt; U)</code></p></li><li><p><code>collect(supplier : () =&gt; U, acc : (U, T) =&gt; (), combiner : (U, U) =&gt; ())</code></p></li></ul><p>前者（reduce）用于累积的类型是不可变值的情况；后者（collect）用于累积的类型是可变值的情况。</p><h3 id="reduce-方法"><a href="#reduce-方法" class="headerlink" title="reduce 方法"></a>reduce 方法</h3><p>我们先来看看 reduce，下面的操作将集合反转——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; res = IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).boxed()<br>    .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(), (acc, x) -&gt; &#123;<br>        acc.addFirst(x);<br>        <span class="hljs-keyword">return</span> acc;<br>    &#125;, (a, b) -&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br></code></pre></div></td></tr></table></figure><p>在这里，第三个参数就是所谓的 combiner，这里因为是串行流，所以 combiner 不会被调用，可以直接返回 null。但 combiner 本身不能为 null，否则会抛空指针异常。</p><p>但若是并行流呢？我们凭第一印象，大概会这么写——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; res = IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).boxed().parallel()<br>    .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(), (acc, x) -&gt; &#123;<br>        acc.addFirst(x);<br>        <span class="hljs-keyword">return</span> acc;<br>    &#125;, (a, b) -&gt; &#123;<br>        a.addAll(b);<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;);<br></code></pre></div></td></tr></table></figure><p>但是这样是无法生效的，如果试图对该集合进行输出，它在输出时会抛出空指针异常！这说明它的结构被破坏了，我们遇到了线程安全问题！</p><p>但为什么会这样呢？原来，<strong>reduce 方法中所使用的 identity，会被每一个 ReduceTask 都共用</strong>！并且我们在 acc 函数中原样返回了累积值，因此它会被持续使用下去，如果在 combiner 中试图判断<code>a == b</code>，它也将是 true，因为 a 和 b 是同一个对象！</p><p>因此，reduce 方法只适合不可变对象，或者我们可以每次返回值都不改变原值，而是返回一个新的值，新的引用，但这对性能是极大的损耗，只有 string 这样的不可变类在 reduce 方法上才能得到运用。</p><h3 id="collect-方法"><a href="#collect-方法" class="headerlink" title="collect 方法"></a>collect 方法</h3><p>这时，使用<code>collect</code>方法就是一个更好的选择，我们再看一看 collect 的签名——</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-type">U</span> collect(supplier : () =&gt; <span class="hljs-type">U</span>, acc : (<span class="hljs-type">U</span>, <span class="hljs-type">T</span>) =&gt; (), combiner : (<span class="hljs-type">U</span>, <span class="hljs-type">U</span>) =&gt; ())<br></code></pre></div></td></tr></table></figure><p>这签名实际上把所有细节都描述出来了——<strong>我们通过一个 supplier，来让每一个 ReduceTask 都能拿到不一样的引用，从而避免共享数据问题；acc 和 combiner 都是没有返回值的，因此显然我们需要通过修改累积值来完成积累和合并操作</strong>。下面使用 collect 来进行一个 count 操作——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Map&lt;String, Integer&gt; count = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;me&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;yukina&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;happy&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br>    .parallel().collect(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>        (acc, x) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (!acc.containsKey(x))<br>                acc.put(x, <span class="hljs-number">0</span>);<br>            acc.compute(x, (k, v) -&gt; v + <span class="hljs-number">1</span>);<br>        &#125;, (a, b) -&gt; &#123;<br>            <span class="hljs-comment">// combine 时必须把第二个值合并到第一个值</span><br>            b.forEach((kb, vb) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (!a.containsKey(kb))<br>                    a.put(kb, <span class="hljs-number">0</span>);<br>                a.compute(kb, (ka, va) -&gt; va + vb);<br>            &#125;);<br>        &#125;);<br></code></pre></div></td></tr></table></figure><p>That’s it！了解这么多就足够了。<strong>使用原则是，当使用值类型，或不可变类型，如 String，Scala，Kotlin 的不可变集合，基本类型等的时候，使用 reduce 方法；使用引用类型，可变类型的时候，使用 collect 方法</strong>。虽然 combiner，acc，初始值的设置要遵循的一定的规律，但给出统一和容易理解的表述并不容易，具体问题具体分析吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 docker 集群互相之间的 ssh</title>
    <link href="/2022/02-10%E9%85%8D%E7%BD%AEdocker%E9%9B%86%E7%BE%A4%E4%BA%92%E7%9B%B8%E4%B9%8B%E9%97%B4%E7%9A%84ssh.html"/>
    <url>/2022/02-10%E9%85%8D%E7%BD%AEdocker%E9%9B%86%E7%BE%A4%E4%BA%92%E7%9B%B8%E4%B9%8B%E9%97%B4%E7%9A%84ssh.html</url>
    
    <content type="html"><![CDATA[<p>新！年！快！乐！从量变到质变的过程总是发生地很短暂。</p><p>最近搭建 hadoop 环境（感觉弄出来个还算好的集群，之后再加配置就轻松了！的时候碰上这样的需求——需要让 Docker 集群的不同容器之间能通过 ssh 互相访问，研究了几个晚上后终于是搞定了，相关配置虽然很简单，但是感觉仍旧是学到了一点东西，这里进行一些记录，</p><span id="more"></span><p>镜像使用 fedora，实现的原理是只生成一对密钥，所有机器都使用该密钥来进行 ssh，这样能大大方便 Dockerfile 的编写，本机也可以使用 ssh 来访问容器（但这没有必要，ssh 会导致 Dockerfile 中配置的环境变量失效，应当直接使用<code>docker exec</code>）。</p><h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p>首先须在本机生成一对密钥，只需在工作目录下执行<code>ssh-keygen -f id_rsa</code>即可（要求输入的地方直接回车），其会生成<code>id_rsa</code>和<code>id_rsa.pub</code>文件；然后执行<code>cat id_rsa.pub &gt; authorized_keys</code>，修改<code>authorized_keys</code>，**把最后的<code>user@host</code>改成<code>*@*</code>**。</p>    <div class="alertbox alertbox-note">      <p>这样修改是说 ssh 服务端将接受所有持有该公钥对应私钥的客户端。</p>    </div>  <p>生成完毕后，工作目录的文件列表如下——</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">id<span class="hljs-emphasis">_rsa</span><br><span class="hljs-emphasis">id_rsa.pub</span><br><span class="hljs-emphasis">authorized_</span>keys<br></code></pre></div></td></tr></table></figure><h2 id="创建-sshd-config"><a href="#创建-sshd-config" class="headerlink" title="创建 sshd_config"></a>创建 sshd_config</h2><p>在工作目录下创建<code>sshd_config</code>文件，插入如下内容——</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment"># 允许 root 远程登陆</span><br><span class="hljs-attribute">PermitRootLogin</span> <span class="hljs-literal">yes</span><br>UsePAM <span class="hljs-literal">yes</span><br></code></pre></div></td></tr></table></figure><h2 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> fedora<br><br><span class="hljs-comment"># 安装 ssh 的服务端和客户端，同时包括 ps 命令来帮助检查运行情况</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum install -y openssh-server procps openssh-clients</span><br><br><span class="hljs-comment"># 拷贝各种文件</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./sshd_config /etc/ssh/sshd_config</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./id_rsa /root/.ssh/id_rsa</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./id_rsa.pub /root/.ssh/id_rsa.pub</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./authorized_keys /root/.ssh/authorized_keys</span><br><br><span class="hljs-comment"># 需注意修改各种文件的权限！</span><br><span class="hljs-comment"># .ssh 路径：    700</span><br><span class="hljs-comment"># 公钥：    644</span><br><span class="hljs-comment"># 私钥，authorized_keys:     600</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> 700 /root/.ssh/ &amp;&amp;\</span><br><span class="language-bash">    <span class="hljs-built_in">chmod</span> 644 /root/.ssh/id_rsa.pub &amp;&amp;\</span><br><span class="language-bash">    <span class="hljs-built_in">chmod</span> 600 /root/.ssh/id_rsa /root/.ssh/authorized_keys &amp;&amp;\</span><br><span class="language-bash">    ssh-keygen -A</span><br><span class="hljs-comment"># ssh-keygen -A 是为了设置服务端自己持有的私钥位置，也可以在 sshd_config 中配置 HostKey /root/.ssh/id_rsa 来使用一样的密钥</span><br><span class="hljs-comment"># 服务端为什么需要自己的密钥对？可能是需要给客户端证明自己仍旧是自己吧</span><br><br><span class="hljs-comment"># 以守护进程的模式运行 sshd</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /usr/sbin/sshd -D </span><br></code></pre></div></td></tr></table></figure><h2 id="集群环境下测试"><a href="#集群环境下测试" class="headerlink" title="集群环境下测试"></a>集群环境下测试</h2><p>编写<code>docker-compose.yml</code>文件，只包括 hostname 就可（需要通过 hostname 来获取互相的 ip）——</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">ssh1:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">ssh1</span><br>  <span class="hljs-attr">ssh2:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">ssh2</span><br></code></pre></div></td></tr></table></figure><p>启动集群。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ docker-compose up -d --build<br></code></pre></div></td></tr></table></figure><p>进入<code>ssh1</code>，检查 ssh 连接。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">$ docker <span class="hljs-built_in">exec</span> -it ssh1 bash<br>$ ssh ssh1 <span class="hljs-comment"># 输入 yes</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 IDEA 中将项目部署到 Docker 中运行</title>
    <link href="/2022/02-02%E5%9C%A8IDEA%E4%B8%AD%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Docker%E4%B8%AD%E8%BF%90%E8%A1%8C.html"/>
    <url>/2022/02-02%E5%9C%A8IDEA%E4%B8%AD%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Docker%E4%B8%AD%E8%BF%90%E8%A1%8C.html</url>
    
    <content type="html"><![CDATA[    <div class="alertbox alertbox-exclamation">      <p>此方法无法使用 debug，且启动起来可能会非常缓慢！应当在需要进行远程部署，测试等情况下进行使用。</p>    </div>  <p>这几天折腾 Docker 的网络问题弄得心力交瘁，最后发现好像在 Mac 上的确是找不到合适的，客户端无感知的解决方案。今天突然灵机一动，想到我干脆可以把项目作为容器部署到 Docker 里，然后把客户端（消费者）的端口映射到本机。</p><span id="more"></span><p>经测试，该方法确实可行，且实现起来非常容易。网上的教程都要求把项目打成 JAR 包，创建相应镜像并运行，但这是不必要的——IDEA 提供了直接在 container 中运行项目的能力，它会先在本地中构建项目，然后直接将整个项目共享给容器并直接通过 java 运行相应的 class 文件，就和本地运行一样，容器只需要引入 JVM 即可。</p><p>但它有一个比较大的问题——<span color="color:red">无法 debug</span>，可能需要一些麻烦的配置吧，因此该方法显然不适合生产环境，但符合我当前的需求。<span class="heimu">有点怀疑无法 debug 是 mac 的问题。</span></p><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><ul><li>IDEA（当前版本自带 Docker 插件）</li><li>Docker</li><li>❤️</li></ul><h2 id="创建-IDEA-项目"><a href="#创建-IDEA-项目" class="headerlink" title="创建 IDEA 项目"></a>创建 IDEA 项目</h2><p>我们直接从 <a href="http://start.spring.io/">start.spring.io</a> 上创建一个 Spring Boot 项目，为了方便测试，引入 Spring Web。</p><p>创建后，在主启动类下写个接口，启动一次项目。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HigherApplication</span> &#123;<br><span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>String <span class="hljs-title function_">sayHi</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + request.getRemoteHost() + <span class="hljs-string">&quot;, It&#x27;s there a future?&quot;</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(HigherApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h2><p>在根目录下创建一个<code>Dockerfile</code>，文件内容如下——</p><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><br><br><span class="hljs-comment"># 的的确确只需要这一行，引入 Java 的运行时环境即 JVM 即可</span><br></code></pre></div></td></tr></table></figure><h2 id="配置启动项和-Docker"><a href="#配置启动项和-Docker" class="headerlink" title="配置启动项和 Docker"></a>配置启动项和 Docker</h2><p>启动完项目后，IDEA 应该会自动创建一个启动项，我们直接对该启动项进行编辑。</p><p>首先点击右上角的启动项菜单，选择<code>Edit Configurations...</code>，然后点击<code>Run on</code>菜单，选择<code>Docker...</code>。</p><p><img src="/images/oss/20220202174045.png"></p><p>在弹出的窗口中选择 Dockerfile 的文件路径，一路 next，finish 即可。第一次创建时会拉取该 image，可能会耗时很久。</p><blockquote><p>在这里也可以配置将要生成的 image 和 container，需注意的是如果配置了 container 中发布特定端口的时候，启动多个 container 会导致失败（因为端口冲突），而它的表现是应用在启动界面直接退出，正常返回 0，这一点非常误导人。</p></blockquote><h2 id="启动，测试"><a href="#启动，测试" class="headerlink" title="启动，测试"></a>启动，测试</h2><p>启动该启动项，在 Run 界面 IDEA 应该会提示类似<code>Application port 8080 is bound to local port 53248</code>的信息（端口每次都会改变），通过浏览器检查<code>localhost: 该端口</code>是否能得到结果。</p><p>然后再测试一下其它容器能否访问该容器（如果可以，则该容器应当也能够访问其他容器），我们首先获得该容器的 IP，再从其他容器向该 IP 发送请求，如果得到回应说明这些容器是连通的。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker ps <span class="hljs-comment"># 找到该容器的 ID，这里我找到的值是 e116cca34a13</span><br>$ docker inspect --format <span class="hljs-string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> e116cca34a13 <span class="hljs-comment"># 获取容器的 IP，我的是 172.17.0.2</span><br>$ docker run -it rancher/curl 172.17.0.2:8080 <span class="hljs-comment"># 随便拉的 curl 镜像，用来发送请求</span><br><span class="hljs-comment"># 结果：Hello, 172.17.0.3, It&#x27;s there a future?</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个在 OSX 环境下下通过 IP 访问 Docker 容器的解决方案</title>
    <link href="/2022/02-01%E4%B8%80%E4%B8%AA%E5%9C%A8OSX%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%B8%8B%E9%80%9A%E8%BF%87IP%E8%AE%BF%E9%97%AEDocker%E5%AE%B9%E5%99%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
    <url>/2022/02-01%E4%B8%80%E4%B8%AA%E5%9C%A8OSX%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%B8%8B%E9%80%9A%E8%BF%87IP%E8%AE%BF%E9%97%AEDocker%E5%AE%B9%E5%99%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    
    <content type="html"><![CDATA[    <div class="alertbox alertbox-exclamation">      <p>不建议使用这种方式，它实现起来不算方便，且实现后还需要配置终端的代理设置，在这里推荐我写（抄）的项目，虽然需要在本机安装额外的依赖，但是配置完后就基本无感知了！</p><p><a href="https://github.com/V-YOP/docker-network"><img src="https://gh-card.dev/repos/V-YOP/docker-network.svg"></a></p><p>如果是 VSCode<span class="heimu">或 JetBrain 家的 IDE</span>，也可以将项目部署到 container 内。</p>    </div>  <p>MacOS（以及 Windows）上的 Docker 由于<a href="https://docs.docker.com/desktop/mac/networking/">实现方式的原因</a>，在网络配置上有许多限制，最麻烦的地方是无法通过容器的 IP 直接访问 IP，这在搭建分布式系统环境时会造成很多麻烦。我经过一些研究，发现可以使用 Docker 提供的（实验性的）<code>socksProxyPort</code>配置和系统的 proxy 配置来使对特定网段的请求路由到 container。</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>配置 Docker 的<code>socksProxyPort</code>后，对该端口的请求将会被路由到 Container 中，因此我们可以通过配置代理让对特定网段如<code>172.172.0.0/16</code>的请求代理到<code>127.0.0.1:socketProxyPort</code>，让 Docker 引擎帮我们路由到具体的容器中。</p><p>这里的代理配置我们使用 Mac 的 PAC 配置进行实现，考虑到 Mac 暂时不支持从文件系统读取 PAC 文件，我们需要某种渠道将该文件托管到特定服务器中，这里使用 Mac 自带的 apache 的服务器（使用 nginx，nodejs 的 http-server 等也行）。</p><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><ul><li>Docker 环境</li><li>apache HttpServer（Mac 自带）</li><li>爱</li></ul><h2 id="配置-Docker"><a href="#配置-Docker" class="headerlink" title="配置 Docker"></a>配置 Docker</h2><p>我们首先需要配置 Docker 中的<code>socksProxyPort</code>配置项，该配置文件位于<code>~/Library/Group\ Containers/group.com.docker/settings.json</code>，可通过搜索找到<code>socksProxyPort</code>项，其默认值为 0，修改其为想要使用的端口，这里使用<code>8888</code>。</p><h2 id="编写-PAC-文件"><a href="#编写-PAC-文件" class="headerlink" title="编写 PAC 文件"></a>编写 PAC 文件</h2><p>然后我们编写一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Proxy_servers_and_tunneling/Proxy_Auto-Configuration_PAC_file">PAC 文件</a> 来配置代理信息，PAC 文件使用 js 编写，下面的代码是一个可直接使用的例子，它假设要使用的 Docker 容器占据的网段为<code>172.172.0.0/16</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FindProxyForURL</span>(<span class="hljs-params">url, host</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isInNet</span>(host, <span class="hljs-string">&#x27;172.172.0.0&#x27;</span>, <span class="hljs-string">&#x27;255.255.0.0&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;SOCKS5 127.0.0.1:8888&#x27;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;DIRECT&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>isInNet(host, &#39;172.172.0.0&#39;, &#39;255.255.0.0&#39;)</code>检查请求的地址是否满足<code>172.172.*.*</code>，如果满足（说明是对 Docker 容器的访问），则将其通过 SOCKS5 代理路由到<code>127.0.0.1:8888</code>，即 Docker 中配置的<code>socksProxyPort</code>端口。</p><p>如果不满足，则将该请求直接“放行”。</p><p>编写完成 PAC 文件后，将其保存在<code>/Library/WebServer/Documents</code>目录下，假设文件名称为<code>docker.pac</code>。</p><h2 id="配置-HttpServer-的端口和-type"><a href="#配置-HttpServer-的端口和-type" class="headerlink" title="配置 HttpServer 的端口和 type"></a>配置 HttpServer 的端口和 type</h2><p>HttpServer 默认使用 80 端口，这对我们来说可能会造成一些麻烦，所以我们应修改该端口。</p><p>只需编辑<code>/etc/apache2/httpd.conf</code>，搜索<code>Listen</code>，把那一堆奇怪的 XML 标签删掉，改成<code>Listen 你想用的端口</code>就行，这里使用<code>11451</code>（可惜只有 5 位！）。 </p><p>这里同时还需为 pac 文件配置 type，如果没有该配置，该文件可能会不被识别，最终配置见下。</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment"># ...</span><br><br><span class="hljs-attribute">Listen</span> <span class="hljs-number">11451</span><br><span class="hljs-comment"># PAC files e.g proxy.pac</span><br>AddType application/x-ns-proxy-autoconfig .pac<br><br><span class="hljs-comment"># ...</span><br></code></pre></div></td></tr></table></figure><h2 id="启动-HttpServer"><a href="#启动-HttpServer" class="headerlink" title="启动 HttpServer"></a>启动 HttpServer</h2><p>我们首先使用如下命令启动 HttpServer 服务——</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo apachectl start<br></code></pre></div></td></tr></table></figure><p>然后使用<code>curl</code>测试一下是否启动了，如果这个命令正确返回了我们编写的 pac 文件的信息就说明启动成功。</p><blockquote><p>如果没启动，请百度😂。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ curl localhost:11451/docker.pac<br></code></pre></div></td></tr></table></figure><h2 id="配置系统的-PAC-配置"><a href="#配置系统的-PAC-配置" class="headerlink" title="配置系统的 PAC 配置"></a>配置系统的 PAC 配置</h2><p>前往<code>System Preferences</code> -&gt; <code>Network</code> -&gt; <code>Advanced</code> -&gt; <code>Proxy</code>，勾选<code>Automatic Proxy Configuration</code>，在 URL 中填入地址<code>localhost:11451/docker.pac</code>。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们首先创建一个 Docker 的子网，再在该子网中创建一个 nginx 容器来检查能否通过 IP 进行访问。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker network create --subnet 172.172.0.0/16 --gateway 172.172.0.1 my_network<br>$ docker run -d --network my_network --ip 172.172.0.101 nginx<br></code></pre></div></td></tr></table></figure><p>在浏览器中访问<code>172.172.0.101</code>（或者使用终端），如果出现 nginx 界面则配置成功。</p><p>https_proxy&#x3D;<a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a><br>http_proxy&#x3D;<a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a><br>all_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7890</p>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种方便理解折叠（fold）操作的方法</title>
    <link href="/2022/01-30%E4%B8%80%E7%A7%8D%E6%96%B9%E4%BE%BF%E7%90%86%E8%A7%A3%E6%8A%98%E5%8F%A0%EF%BC%88fold%EF%BC%89%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
    <url>/2022/01-30%E4%B8%80%E7%A7%8D%E6%96%B9%E4%BE%BF%E7%90%86%E8%A7%A3%E6%8A%98%E5%8F%A0%EF%BC%88fold%EF%BC%89%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<p>虽然之前对折叠操作进行过一些了解<a href="/2021/10-15%E5%B7%A6%E6%8A%98%E5%8F%A0%E5%92%8C%E5%8F%B3%E6%8A%98%E5%8F%A0.html" title="左折叠和右折叠">（见此）</a>，但是仍然对其不甚熟悉，没法立刻写出定义，最近突然发现一种能方便理解折叠操作的方法，这里对其进行一些记录，使用 js 来进行描述。</p><span id="more"></span><p>该方法似乎无法用来说明为何<code>foldr</code>能处理无穷列表。</p><h2 id="啥子是折叠？"><a href="#啥子是折叠？" class="headerlink" title="啥子是折叠？"></a>啥子是折叠？</h2><p>对集合的操作，最常用的也就那三种——<code>map</code>，<code>filter</code>，<code>reduce</code>&#x2F;<code>fold</code>（后面全部使用<code>fold</code>）。其中，<code>map</code>对集合的每一个元素进行相同的映射，返回一个映射后的新集合；<code>filter</code>对集合中的每一个元素进行判断，筛选出符合条件的元素组成返回的集合；而<code>fold</code>操作迭代一个集合，并将每个元素“积累”到同一个值中。</p><p><code>fold</code>操作就是所谓的折叠操作。折叠操作是最<strong>原子</strong>的——<code>map</code>，<code>filter</code>，<code>flatMap</code>&#x2F;<code>bind</code>操作都可以由它来实现；折叠操作也可以用于实现某些高层次的业务相关的操作，如 count，groupBy 等。</p><p>所以，究竟什么是折叠？根据折叠操作的描述，我们可以认为那些签名为<code>[a] =&gt; b</code>的函数都是折叠操作，比如我们有个<code>sum</code>函数，它能够计算一个集合内所有元素的和，这就是一个折叠操作，它的函数签名为<code>[number] =&gt; number</code>。</p><p>我们规定<code>sum(null) === 0, sum([]) === 0</code>，容易得到<code>sum</code>函数的递归实现——</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// sum : [number] =&gt; number</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">lst</span>) &#123;<br>  <span class="hljs-keyword">if</span> (lst == <span class="hljs-literal">null</span> || lst.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> [x, ...xs] = lst<br>  <span class="hljs-keyword">return</span> x + <span class="hljs-title function_">sum</span>(xs)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>再考虑一个<code>product</code>函数，它计算一个集合内所有元素的积，我们规定<code>product(null) === 1, product([]) === 1</code>，容易得到它的递归实现——</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// product : [number] =&gt; number</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">product</span>(<span class="hljs-params">lst</span>) &#123;<br>  <span class="hljs-keyword">if</span> (lst == <span class="hljs-literal">null</span> || lst.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">const</span> [x, ...xs] = lst<br>  <span class="hljs-keyword">return</span> x * <span class="hljs-title function_">product</span>(xs)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以发现，这两个函数的形式基本一致，我们可以再抽象一层，整出一个所谓的<code>foldr</code>函数。在这里，参数<code>fn</code>就是上面的<code>sum</code>函数的<code>+</code>，<code>product</code>函数的<code>*</code>，我们乘其为折叠函数，init 就是初始值，对<code>sum</code>来说是 0，对<code>product</code>来说是 1。<code>foldr</code>是递归的折叠操作。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// foldr : ((a, b) =&gt; b, b, [a]) =&gt; b</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foldr</span>(<span class="hljs-params">fn, init, lst</span>) &#123;<br>  <span class="hljs-keyword">if</span> (lst == <span class="hljs-literal">null</span> || lst.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> init<br>  <span class="hljs-keyword">const</span> [x, ...xs] = lst<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(x, <span class="hljs-title function_">foldr</span>(fn, init, xs))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>foldr 使用 Haskell 的中缀函数的形式会容易看许多——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">myFoldr</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b<br><span class="hljs-title">myFoldr</span> _ init [] = init<br><span class="hljs-title">myFoldr</span> fn init (x : xs) = x `fn` myFoldr fn init xs<br></code></pre></div></td></tr></table></figure><p>但我们也知道，这些函数也是能够写成尾递归的形式的，这些形式能够抽象成折叠操作吗？答案是 yes，这样尾递归形式（或者就 SICP 的语境上来说，迭代）的折叠操作，我们称为<code>foldl</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">zero, lst</span>) &#123;<br>  <span class="hljs-keyword">if</span> (lst == <span class="hljs-literal">null</span> || lst.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> zero<br>  <span class="hljs-keyword">const</span> [x, ...xs] = lst<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">sum</span>(zero + x, xs)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">product</span>(<span class="hljs-params">zero, lst</span>) &#123;<br>  <span class="hljs-keyword">if</span> (lst == <span class="hljs-literal">null</span> || lst.<span class="hljs-property">zero</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> zero<br>  <span class="hljs-keyword">const</span> [x, ...xs] = lst<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">product</span>(zero + x, xs)<br>&#125;<br><span class="hljs-comment">// foldl : ((b, a) =&gt; b, b, [a]) =&gt; b</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foldl</span>(<span class="hljs-params">fn, zero, lst</span>) &#123;<br>  <span class="hljs-keyword">if</span> (lst == <span class="hljs-literal">null</span> || lst.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> zero<br>  <span class="hljs-keyword">const</span> [x, ...xs] = lst<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foldl</span>(fn, <span class="hljs-title function_">fn</span>(zero, x), xs)<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>显然，在一般的语言中，foldl 的性能会好于 foldr，因为前者是尾递归形式，能够被优化成循环。</p></blockquote><p>定义姑且是提出来了，但<code>foldl</code>和<code>foldr</code>的区别和对其的感性认识呢？Keep going。</p><h2 id="形象表述"><a href="#形象表述" class="headerlink" title="形象表述"></a>形象表述</h2><p>一切折叠操作，都可以表示为<strong>数组中各元素连同初始值使用特定二元操作符两两连接</strong>的形式，而左折叠和右折叠会决定初始值的位置以及该二元操作符的结合性——<strong>对于左折叠来说，初始值在最左，该操作符左结合；对于右折叠来说，初始值在最右，该操作符右结合</strong>。下面展示一个示例。</p><p>考虑一个<strong>左折叠</strong>操作，假设初始值为 100；折叠函数为<code>&gt;=&gt;</code>，我们可以叫它 fish，简称 f，<code>1 &gt;=&gt; 2</code>等价于<code>f(1, 2)</code>；要折叠的数组为<code>[1, 2, 3]</code>，我们可以这样描述这个折叠操作——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-number">100</span> &gt;=&gt; <span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span><br>=&gt; ((<span class="hljs-number">100</span> &gt;=&gt; <span class="hljs-number">1</span>) &gt;=&gt; <span class="hljs-number">2</span>) &gt;=&gt; <span class="hljs-number">3</span> # 左折叠，左结合<br>=&gt; f(f(f(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>), <span class="hljs-number">2</span>), <span class="hljs-number">3</span>)     # 转换成函数调用的形式<br>=&gt; foldl(f, <span class="hljs-number">100</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></div></td></tr></table></figure><p>右折叠也是如此——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span> &gt;=&gt; <span class="hljs-number">100</span> <br>=&gt; <span class="hljs-number">1</span> &gt;=&gt; (<span class="hljs-number">2</span> &gt;=&gt; (<span class="hljs-number">3</span> &gt;=&gt; <span class="hljs-number">100</span>))<br>=&gt; f(<span class="hljs-number">1</span>, f(<span class="hljs-number">2</span>, f(<span class="hljs-number">3</span>, <span class="hljs-number">100</span>)))<br>=&gt; foldr(f, <span class="hljs-number">100</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></div></td></tr></table></figure><blockquote><p>右折叠可以使用类似<code>&lt;=&lt;</code>的符号来描述，能很形象地表示运算顺序。</p></blockquote><p>这种形式如何进行推导呢？我们先将其转换为使用<code>&gt;=&gt;</code>（其他符号也行）进行连接的形式，根据结合性按顺序进行函数应用。举个小小的例子——考虑定义一个集合的除法操作，对集合<code>[2,3,4]</code>, 得到<code>1/2/3/4</code>，我们显然要使用左折叠——</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">arrDiv</span>(<span class="hljs-params">lst</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">div</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a / b &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foldl</span>(div, <span class="hljs-number">1</span>, lst)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">arrDiv([2,3,4])</span><br><span class="hljs-comment">=&gt; foldl(div, 1, [2,3,4])</span><br><span class="hljs-comment">=&gt; 1 &gt;=&gt; 2 &gt;=&gt; 3 &gt;=&gt; 4  # 用某种普遍形式进行表述</span><br><span class="hljs-comment">=&gt; 0.5 &gt;=&gt; 3 &gt;=&gt; 4 # 从左往右依次计算，这里计算 1 &gt;=&gt; 2 即 div(1, 2) 得到 0.5</span><br><span class="hljs-comment">=&gt; 0.16666 &gt;=&gt; 4 # 0.5 &gt;=&gt; 3 === 0.16666...</span><br><span class="hljs-comment">=&gt; 0.04166</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>但折叠操作可不止这点能耐！<strong>假如这里的二元操作符左右两边类型不同呢？</strong>考虑下面的代码——</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">magic</span>(<span class="hljs-params">lst</span>) &#123;<br>  <span class="hljs-comment">// 返回一个新数组，该数组为旧数组 lst 头部加上元素 elem，如 addFirst([2,3,4], 1) === [1,2,3,4]</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addFirst</span>(<span class="hljs-params">lst, elem</span>) &#123; <span class="hljs-keyword">return</span> [elem, ...lst] &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foldl</span>(addFirst, [], lst)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>magic([1,2,3])</code>是什么结果？推导下便知。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">magic</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>=&gt; foldl(addFirst, [], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>=&gt; [] &gt;=&gt; <span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span><br>=&gt; [<span class="hljs-number">1</span>] &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span><br>=&gt; [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>] &gt;=&gt; <span class="hljs-number">3</span><br>=&gt; [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><p>可以注意到，对于左折叠，结果的类型同折叠函数的第一个（左边的）参数相同，<strong>这个参数一般命名为 acc，意为累加</strong>；对于右折叠，结果的类型则同第二个相同了。折叠函数的参数顺序结合这里的表示方法是容易理解的。</p><h2 id="js-中的折叠操作"><a href="#js-中的折叠操作" class="headerlink" title="js 中的折叠操作"></a>js 中的折叠操作</h2><p>js 中为数组（Array）提供了 reduce 和 reduceRight 方法，API 介绍可以看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">这里</a>，其中 reduce 代表左折叠，reduceRight 代表右折叠。</p><p>同时，对这两个方法，初始值可以不给定，这时 js 会选择使用第一个或最后一个元素作为初始值。但是不给定初始值的折叠操作对于空数组会抛出异常，这在某些时候不是我们所期望的。<strong>而且如果不给定初始值，则返回值必须是该数组中的类型</strong>，<span class="heimu">但如果你想给其他程序员造成<em>惊喜</em>，也可以试着这么干！梗 <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">见此</a></span>。</p><p>需注意的是，reduceRight 方法接受的折叠函数的参数里，acc 在前，x 在后，同 reduce 方法一致，这和上面编写的 foldr 不同。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>上面的描述或许仍显抽象，唯一的方式是拿更多的例子来进行推导，在实践中出真知。下面的示例中一概使用 js 的 reduce 进行描述。</p><h3 id="map-filter-flatMap"><a href="#map-filter-flatMap" class="headerlink" title="map, filter, flatMap"></a>map, filter, flatMap</h3><p>先来点开胃菜，通过 reduce 实现 map，filter，flatMap，这几个比较简单。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">map</span>(<span class="hljs-params">fn, lst</span>) &#123;<br>  <span class="hljs-keyword">return</span> lst.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, x</span>) =&gt;</span> [...acc, <span class="hljs-title function_">fn</span>(x)], [])<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">predicate, lst</span>) &#123;<br>  <span class="hljs-keyword">return</span> lst.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, x</span>) =&gt;</span> <span class="hljs-title function_">predicate</span>(x) ? [...acc, x] : acc, [])<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatMap</span>(<span class="hljs-params">fn, lst</span>) &#123;<br>  <span class="hljs-keyword">return</span> lst.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, x</span>) =&gt;</span> [...acc, ...<span class="hljs-title function_">fn</span>(x)], [])<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面仅推导一下 filter。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">// 检查是否奇数<br><span class="hljs-title">const</span> isOdd = x =&gt; x % <span class="hljs-number">2</span> === <span class="hljs-number">1</span><br><span class="hljs-title">filter</span>(isOdd, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>=&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].reduce(..., [])<br>=&gt; [] &gt;=&gt; <span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span> &gt;=&gt; <span class="hljs-number">4</span><br>=&gt; [<span class="hljs-number">1</span>] &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span> &gt;=&gt; <span class="hljs-number">4</span> // <span class="hljs-number">1</span> 是奇数，被添加到尾部<br>=&gt; [<span class="hljs-number">1</span>] &gt;=&gt; <span class="hljs-number">3</span> &gt;=&gt; <span class="hljs-number">4</span> // <span class="hljs-number">2</span> 不是奇数，被省略<br>=&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>] &gt;=&gt; <span class="hljs-number">4</span><br>=&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]<br></code></pre></div></td></tr></table></figure><p>为什么 reduce 操作能构造 map，filter 等操作呢？因为 map，filter 等操作生成新集合，而 reduce 操作生成一个值——值这个概念显然是比集合更加广泛的。</p><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h3><p>groupBy 函数负责将元素按特定标识符进行分组，比如将一个学生列表按班级进行分组——</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> studentList = <br>  [&#123;<span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;clazz&quot;</span> : <span class="hljs-string">&quot;101&quot;</span>&#125;,<br>   &#123;<span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Wick&quot;</span>, <span class="hljs-string">&quot;clazz&quot;</span> : <span class="hljs-string">&quot;102&quot;</span>&#125;,<br>   &#123;<span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-string">&quot;clazz&quot;</span> : <span class="hljs-string">&quot;101&quot;</span>&#125;,<br>   &#123;<span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Prophet&quot;</span>, <span class="hljs-string">&quot;clazz&quot;</span> : <span class="hljs-string">&quot;102&quot;</span>&#125;,<br>   &#123;<span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Anderson&quot;</span>, <span class="hljs-string">&quot;clazz&quot;</span> : <span class="hljs-string">&quot;103&quot;</span>&#125;,<br>   &#123;<span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Smith&quot;</span>, <span class="hljs-string">&quot;clazz&quot;</span> : <span class="hljs-string">&quot;101&quot;</span>&#125;]<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">groupBy</span>(<span class="hljs-params">keyMapFn, lst</span>) &#123;<br>  <span class="hljs-keyword">return</span> lst.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, x</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-title function_">keyMapFn</span>(x)<br>    <span class="hljs-keyword">if</span> (!acc.<span class="hljs-title function_">has</span>(key)) acc.<span class="hljs-title function_">set</span>(key, [])<br>    acc.<span class="hljs-title function_">get</span>(key).<span class="hljs-title function_">push</span>(x)<br>    <span class="hljs-keyword">return</span> acc <span class="hljs-comment">// 最“函数式”的方案不允许改变原 acc 的值，而是根据旧的 acc 构造新的 acc</span><br>  &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>())<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">groupBy</span>(<span class="hljs-function"><span class="hljs-params">stud</span>=&gt;</span>stud.<span class="hljs-property">clazz</span>, studentList))<br></code></pre></div></td></tr></table></figure><p>推导过程如下——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">groupBy</span>(stud=&gt;stud.clazz, studentList)<br>=&gt; lst.reduce(..., new <span class="hljs-type">Map</span>())<br>=&gt; &#123;&#125; &gt;=&gt; &#123;<span class="hljs-string">&quot;John&quot;</span> , <span class="hljs-string">&quot;101&quot;</span>&#125; &gt;=&gt; &#123;<span class="hljs-string">&quot;Wick&quot;</span>, <span class="hljs-string">&quot;102&quot;</span>&#125; &gt;=&gt; &#123;<span class="hljs-string">&quot;Neo&quot;</span>,<span class="hljs-string">&quot;101&quot;</span>&#125; &gt;=&gt; ...<br>=&gt; &#123; <span class="hljs-number">101</span> -&gt; [&#123;<span class="hljs-string">&quot;John&quot;</span> , <span class="hljs-string">&quot;101&quot;</span>&#125;] &#125; &gt;=&gt; &#123;<span class="hljs-string">&quot;Wick&quot;</span>, <span class="hljs-string">&quot;102&quot;</span>&#125; &gt;=&gt; &#123;<span class="hljs-string">&quot;Neo&quot;</span>,<span class="hljs-string">&quot;101&quot;</span>&#125; &gt;=&gt; ...<br>=&gt; &#123; <span class="hljs-number">101</span> -&gt; [&#123;<span class="hljs-string">&quot;John&quot;</span> , <span class="hljs-string">&quot;101&quot;</span>&#125;], <span class="hljs-number">102</span> -&gt; [&#123;<span class="hljs-string">&quot;Wick&quot;</span>, <span class="hljs-string">&quot;102&quot;</span>&#125;] &#125; &gt;=&gt; &#123;<span class="hljs-string">&quot;Neo&quot;</span>,<span class="hljs-string">&quot;101&quot;</span>&#125; &gt;=&gt; ...<br>=&gt; &#123; <span class="hljs-number">101</span> -&gt; [&#123;<span class="hljs-string">&quot;John&quot;</span> , <span class="hljs-string">&quot;101&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;Neo&quot;</span>,<span class="hljs-string">&quot;101&quot;</span>&#125;] , <span class="hljs-number">102</span> -&gt; [&#123;<span class="hljs-string">&quot;Wick&quot;</span>, <span class="hljs-string">&quot;102&quot;</span>&#125;] &#125; &gt;=&gt; ...<br>// 写不下了！<br></code></pre></div></td></tr></table></figure><h3 id="last-butLast"><a href="#last-butLast" class="headerlink" title="last, butLast"></a>last, butLast</h3><p>如同 last 这样的函数也能够通过 fold 实现。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 找到最后的元素</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">last</span>(<span class="hljs-params">lst</span>) &#123;<br>  <span class="hljs-keyword">return</span> lst.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, x</span>) =&gt;</span> x)<br>&#125;<br><br><span class="hljs-comment">// 找到倒数第二个元素，未找到则返回 null</span><br><span class="hljs-comment">// 方法是在 acc 中维护两个数组中的元素，到了头后第一个元素就是倒数第二个元素</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">butLast</span>(<span class="hljs-params">lst</span>) &#123;<br>  <span class="hljs-keyword">return</span> lst.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">[a, b], x</span>) =&gt;</span> [b, x], [<span class="hljs-string">&quot;empty list&quot;</span>, <span class="hljs-string">&quot;singleton list&quot;</span>]) [<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">butLast</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>=&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].reduce(..., [<span class="hljs-string">&quot;empty list&quot;</span>, <span class="hljs-string">&quot;singleton list&quot;</span>])[<span class="hljs-number">0</span>]<br>=&gt; ([<span class="hljs-string">&quot;empty list&quot;</span>, <span class="hljs-string">&quot;singleton list&quot;</span>] &gt;=&gt; <span class="hljs-number">1</span> &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span>) [<span class="hljs-number">0</span>]<br>=&gt; ([<span class="hljs-string">&quot;singleton list&quot;</span>, <span class="hljs-number">1</span>] &gt;=&gt; <span class="hljs-number">2</span> &gt;=&gt; <span class="hljs-number">3</span>) [<span class="hljs-number">0</span>]<br>=&gt; ([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] &gt;=&gt; <span class="hljs-number">3</span>) [<span class="hljs-number">0</span>]<br>=&gt; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] [<span class="hljs-number">0</span>]<br>=&gt; <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>将一个函数数组组合成一个函数，即类似这样<code>[f, g, h] -&gt; (x =&gt; f(g(h(x))))</code>，这种操作很 trick，只有弱类型语言才办得到。compose 函数要结合柯里化函数来使用才能发挥效果。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">fnLst</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">input</span> =&gt;</span> fnLst.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">acc, x</span>) =&gt;</span> <span class="hljs-title function_">x</span>(acc), input)<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">const</span> toUpper = str =&gt; str.toUpperCase()<br><span class="hljs-title">const</span> removeChar = removedChar =&gt; str =&gt; str.replaceAll(removedChar, <span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-title">compose</span>([toUpper, removeChar(<span class="hljs-string">&quot;h&quot;</span>)])(<span class="hljs-string">&quot;hello, happy world!&quot;</span>)<br>=&gt; [toUpper, removeChar(<span class="hljs-string">&quot;h&quot;</span>)].reduceRight(..., <span class="hljs-string">&quot;hello, happy world!&quot;</span>)<br>=&gt; toUpper &gt;=&gt; remoreChar(<span class="hljs-string">&quot;h&quot;</span>) &gt;=&gt; <span class="hljs-string">&quot;hello, happy world!&quot;</span><br>=&gt; toUpper &gt;=&gt; <span class="hljs-string">&quot;ello, appy world&quot;</span><br>=&gt; <span class="hljs-string">&quot;ELLO, APPY WORLD&quot;</span><br></code></pre></div></td></tr></table></figure><hr><p>总之，我认为这种形式对于理解和使用折叠操作都是有很大帮助的，将来必可活用于实践中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式笔记——命令模式，状态模式，访问者模式</title>
    <link href="/2022/01-16%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%8C%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <url>/2022/01-16%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%8C%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>一个类依赖其它的类进行某种操作时，一般是直接调用其的接口的特定方法。该类称为请求的发送者，依赖的类称为请求的接受者。命令模式在请求发送者和请求接受者之间增加一层抽象层，使请求的接受者能够对请求的发送者不可见，降低耦合性。借由策略模式，我们能够忽略请求接受者的具体的实现类，只关心相应接口；借由命令模式，我们能够忽略请求接受者的接口，只关心具体的命令或命令的接口。如此，请求发送者和请求接受者就完全解耦了。命令模式将请求本身封装成对象（数据 &lt;-&gt; 过程），从而使能够将请求当作对象来处理，完成回滚，日志，排队，异步化，可重做等操作。命令模式也称作事务模式，这是说可以将一系列请求作为一个命令传递，很有趣。</p><blockquote><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p></blockquote><p>我能够想到两个实例——线程池和 js 的事件，它们都不关心请求的接受者究竟姓甚名谁。对前者，命令是<code>Ruunable</code>，<code>Callable</code>，对后者，命令是回调函数，对 ui 进行操作时不是直接将该操作传递给什么玩意（这是用户决定的），而是触发一个事件，通过事件监听器间接进行一定的行为。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>命令模式包含四个角色——</p><ul><li><strong>请求发送者</strong>——即客户端。</li><li><strong>命令</strong>——客户端发送的请求，为客户端所依赖。命令分为抽象命令和具体命令。</li><li><strong>命令执行者（Invoker）</strong>，执行命令的对象。命令执行者只负责处理命令，对具体的请求接受者不关心。命令执行者也可以负责记录命令的历史，重做，回滚，<del>发现请求接受者</del>等功能。</li><li><strong>请求接受者</strong>——在命令中被依赖的对象。</li></ul><p>比如，对一个使用了线程池的客户端，客户端本身为请求发送者，命令为客户端提供给命令执行者的 Runnable 或 Callable，命令执行者为线程池，请求接受者为 Task 依赖的对象，如果没有依赖的对象则没有请求接受者。这样，命令本身就将执行请求发送者所需的所有业务逻辑。</p><p>对浏览器上的 js，请求发送者为用户的操作，命令为回调函数，命令执行者为 js 的事件驱动机制，请求接受者为回调函数捕获的对象，以及用户操作的 ui。</p><p>在 IoC 容器中，借助 DI，客户端即业务代码中只需要关心命令和命令处理者，不需也不应该关心请求接受者究竟是什么东西，而只有命令知晓请求接受者姓甚名谁（不太确定，感觉命令处理者知晓请求接受者在某些时候也是需要的）。</p><p>需注意的是，命令模式强调将命令交由命令执行者这样一个特定的地方执行，从而使能够对命令进行统一的操作，如 try-catch，日志，重做等。</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p>命令模式（的变种）的应用感觉到处都是，实在是找不出一个贴近实际同时又具有典型性的范例，干脆直接放弃思考，在书上（《Scala 和 Clojure 函数式编程模式》）的范例基础上改进一下下。考虑一个收银机，对其的操作包括增加现金，减少现金，显示现金，以及特定命令的集合（时髦的话说，事务），并且在命令发生错误的时候<strong>提供回滚操作</strong>。</p><p>我们首先定义 Command 接口——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 若 execute 过程中抛出异常，执行该方法。不考虑该方法抛出异常的情况</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们的请求接受者，即收银机的定义如下，这里为方便，提供简单的复制和回滚操作。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashRegister</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">cash</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCash</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123; <span class="hljs-built_in">this</span>.cash += amount; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeCash</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (amount &gt; cash)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(String.format(<span class="hljs-string">&quot;请求取出金额 %d 大于当前金额 %d&quot;</span>, amount, cash));<br>        <span class="hljs-built_in">this</span>.cash -= amount;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCash</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> cash; &#125;<br><br>    <span class="hljs-comment">// 方便进行回滚</span><br>    <span class="hljs-keyword">public</span> CashRegister <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CashRegister</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRegister</span>();<br>        copy.cash = <span class="hljs-built_in">this</span>.cash;<br>        <span class="hljs-keyword">return</span> copy;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">(CashRegister copy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cash = copy.cash;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后，我们着手实现四种具体 Command，需要记住——Command 有能力独自执行，这是说它自己就持有自己的所有依赖。</p><p>首先是添加现金的命令。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCashCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CashRegister cashRegister;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> amount;<br><br>    <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddCashCommand</span><span class="hljs-params">(CashRegister cashRegister, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cashRegister = cashRegister;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> CashRegister copy;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        copy = cashRegister.copy();<br>        cashRegister.addCash(amount);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">()</span> &#123;<br>        cashRegister.restore(copy);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后是取走现金的命令，这里实际上已经能看出某种模式了—— <strong>使用抽象类或者闭包来引用 cashRegister 和 amount</strong> 可以减少这里的重复代码。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TakeCashCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CashRegister cashRegister;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> amount;<br><br>    <span class="hljs-comment">// 依赖注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TakeCashCommand</span><span class="hljs-params">(CashRegister cashRegister, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cashRegister = cashRegister;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> CashRegister copy;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        copy = cashRegister.copy();<br>        cashRegister.takeCash(amount);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">()</span> &#123;<br>        cashRegister.restore(copy);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>显示现金的命令非常容易。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisplayCashCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CashRegister cashRegister;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DisplayCashCommand</span><span class="hljs-params">(CashRegister cashRegister)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cashRegister = cashRegister;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;当前现金：&quot;</span> + cashRegister.getCash());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最麻烦的是命令集（我们称它为事务），回滚操作需要被小心处理。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CashTransactionCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Command&gt; cashCommands;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashTransactionCommand</span><span class="hljs-params">(List&lt;Command&gt; cashCommands)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cashCommands = cashCommands;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 该字段用于标识最后执行的 command 的 index，如果抛出异常，则需要从后往前依次执行该 command 之前的回滚</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span> (Command command : cashCommands) &#123;<br>            command.execute();<br>            lastIndex++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lastIndex; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            cashCommands.get(i).restore();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后是命令执行者，它的代码比较简单——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任务执行者可以有更加丰富的操作，看业务吧</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandInvoker</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Command command)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            command.execute();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            command.restore();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>完成了！我们整个 demo 试试，这里为了简单没有使用依赖注入。工程实践时肯定不是这样的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 客户端不应该直接看到 CashRegister，这里为了方便直接 new 了</span><br>        <span class="hljs-type">CashRegister</span> <span class="hljs-variable">cashRegister</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRegister</span>();<br>        <span class="hljs-type">CommandInvoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommandInvoker</span>();<br><br>        <span class="hljs-comment">// 命令不应该直接通过 new 创建，而应当通过建造者/高阶函数的方式，从而使能够无视 cashRegister 依赖</span><br>        invoker.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AddCashCommand</span>(cashRegister, <span class="hljs-number">100</span>));<br>        invoker.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayCashCommand</span>(cashRegister));<br><br>        invoker.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TakeCashCommand</span>(cashRegister, <span class="hljs-number">200</span>));<br>        invoker.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayCashCommand</span>(cashRegister));<br><br>        invoker.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CashTransactionCommand</span>(Arrays.asList(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddCashCommand</span>(cashRegister, <span class="hljs-number">200</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TakeCashCommand</span>(cashRegister, <span class="hljs-number">300</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayCashCommand</span>(cashRegister)<br>        )));<br>        invoker.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayCashCommand</span>(cashRegister));<br>        <br>        <span class="hljs-comment">// 假设 CashRegister 是单例的，理想的调用形式应该类似——</span><br>        <span class="hljs-type">CashCommandBuilder</span> <span class="hljs-variable">cashCommandBuilder</span> <span class="hljs-operator">=</span> ContextUtil.getBean(CashCommandBuilder.class);<br>        invoker.execute(cashCommandBuilder.add(<span class="hljs-number">200</span>).take(<span class="hljs-number">300</span>).display().build());<br><br>        <span class="hljs-comment">// 或者——</span><br>        <span class="hljs-type">CashCommandFactory</span> <span class="hljs-variable">cashCommandFactory</span> <span class="hljs-operator">=</span> ContextUtil.getBean(CashCommandFactory.class);<br>        invoker.execute(cashCommandFactory.addCommand(<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当然，我们也可以让命令调用者来“发现”请求的接收者，在执行命令时对命令注入其依赖，为此我们需要修改命令的接口——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 需修改接口，在参数中注入依赖</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(CashRegister cashRegister)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">(CashRegister cashRegister)</span>;<br>&#125;<br><br><span class="hljs-type">CommandInvoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommandInvoker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRegister</span>());<br>invoker.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AddCashCommand</span>(<span class="hljs-number">300</span>));<br><span class="hljs-comment">// ...</span><br></code></pre></div></td></tr></table></figure><p>这样就能够离开 DI 框架也能使用了。</p><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>关于命令模式，我们只需要关心它的核心思想——<strong>将请求当作对象来操作</strong>，这完全是在说一等函数！我们可以用<code>Unit -&gt; Unit</code>或<code>Unit -&gt; a</code>（需要命令有返回值的情况，Invoker 可以进行进一步的操作，如将其转为异步）之类的来充当 Command 接口。结合柯里化函数，建造者模式等来构造 Command 我认为这对实践是会有帮助的。至于回滚之类的操作…那可太复杂了，“想想数据库的事务日志吧！”</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><blockquote><p>不换思想就换人。</p></blockquote><p>状态模式也是个很简单的模式。通常，我们通过更改对象的状态（配置）来变更它的行为，比如对一个密码加密工具（假设它有状态），我们可能会通过字符串或枚举来标识其使用的加密算法，比如 <code>&quot;md5&quot;</code>，<code>EncryptType.SHA256</code> 等。可以想像，在加密的业务逻辑中，它肯定使用条件语句来选择具体使用的算法，比如可能是这样——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (encryptType) &#123;<br>    <span class="hljs-keyword">case</span> MD5:<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">/*...*/</span>;<br>    <span class="hljs-keyword">case</span> SHA256:<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">/*...*/</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-comment">/*..*/</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">/*...*/</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个违反了开闭原则——增加新的算法就需要修改源码了。一个可能的解决方案是使用策略模式和工厂方法模式（或简单工厂模式）来解决这一问题——建立枚举到策略类的映射，通过工厂进行这个映射。</p><p>再考虑另一个问题——编写一个电梯的逻辑，现在假设电梯有四个操作——开门，关门，上行，下行，有四个状态——开门，停止，上行，下行。每个操作在每个状态下都会有不同的行为，同时有可能改变自己的状态。</p><p>比如，对上行操作，我们可能会这么写——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lift</span> &#123;<br>    <span class="hljs-keyword">private</span> LiftState state;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">goUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">switch</span> (state) &#123;<br>        <span class="hljs-keyword">case</span> OPEN:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;开门状态不能移动！&quot;</span>);<br>        <span class="hljs-keyword">case</span> UP:<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">case</span> DOWN:<br>            hrow <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;上行状态不能下行！&quot;</span>);<br>        <span class="hljs-keyword">case</span> STOP:<br>            System.out.println(<span class="hljs-string">&quot;停止上行&quot;</span>);<br>            state = LiftState.STOP;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">switch</span> (state) &#123;<br>        <span class="hljs-keyword">case</span> OPEN:<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">case</span> UP:<br>        <span class="hljs-keyword">case</span> DOWN:<br>            hrow <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;移动状态不能开门！&quot;</span>);<br>        <span class="hljs-keyword">case</span> STOP:<br>            System.out.println(<span class="hljs-string">&quot;关门&quot;</span>);<br>            state = LiftState.STOP;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>可以注意到，每个操作的形式都符合一种“模式”——整个方法体里只有一个 switch，对每个状态都有特定操作。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这种情况该如何进行抽象？状态模式给予了我们答案——将状态内化到类（的逻辑）本身，通过切换类的实现来修改行为。这是说，我们可以为每一个特定的状态都定义一个类，来表达这个状态的情况下类应该有的行为，比如我们对开门状态下的实现可能会有这样的逻辑——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiftState</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">goUp</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">goDown</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiftState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LiftState</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenState</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;开门状态不能移动！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goDown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;开门状态不能移动！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;关门&quot;</span>);<br>        <span class="hljs-comment">// 无法编译！</span><br>        setThis(StopState.INSTANCE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StopState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiftState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LiftState</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopState</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goUp</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上行&quot;</span>);<br>        setThis(GoUpState.INSTANCE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goDown</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;下行&quot;</span>);<br>        setThis(GoDownState.INSTANCE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开门&quot;</span>);<br>        setThis(OpenState.INSTANCE);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们找到解决方法（的一部分）了！<strong>只需要对每个状态都定义在这个状态下的各种操作以及状态变化，我们就能够将原本的 switch 逻辑切分到一个个状态类中了</strong>。</p><p>可是该代码无法编译——这又不是 C++，类是无法改变自己的引用的，因此<code>setThis(xxx)</code>是实现不了的！</p><p>解决方案是使用一个环境（Context，标准翻译是上下文）来包裹状态，在状态中委托上下文来修改状态。用户则仅使用该上下文。上下文可以和状态具有一样的接口，也可以不一样。</p><p>为了让状态中能够使用上下文，我们可以选择将上下文作为函数参数传入，或者作为状态所持有的字段，在构造时传入，我们选择前者，为此需要重写 LiftState 接口。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(LiftState liftState)</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiftState</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">goUp</span><span class="hljs-params">(Context context)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">goDown</span><span class="hljs-params">(Context context)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(Context context)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LiftContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">LiftState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> StopState.INSTANCE;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(LiftState liftState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = liftState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goUp</span><span class="hljs-params">()</span> &#123;<br>        state.goUp(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goDown</span><span class="hljs-params">()</span> &#123;<br>        state.goDown(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        state.stop(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        state.open(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiftState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LiftState</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenState</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goUp</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;开门状态不能移动！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goDown</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;开门状态不能移动！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(Context context)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;关门&quot;</span>);<br>        context.setState(StopState.INSTANCE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Context context)</span> &#123; &#125;<br>&#125;<br><span class="hljs-comment">// 各种具体的 State...</span><br></code></pre></div></td></tr></table></figure><p>各个状态和状态之间的转换关系也可以使用一张二维表来进行表示，最典型的例子莫过于有限状态机了。</p><p>状态模式亦可用于需要改变引用的情况，比如需要实现<code>CopyOnWrite</code>的集合的时候。但这是否属于状态模式？我认为是。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyOnWriteMap</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;K, V&gt; realMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        Map&lt;K, V&gt; copiedMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(realMap);<br>        copiedMap.put(key, value);<br><br>        realMap = copiedMap;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="FP-的观点"><a href="#FP-的观点" class="headerlink" title="FP 的观点"></a>FP 的观点</h3><p>无论是把上下文当作函数参数传入，还是通过构造函数传入上下文，对状态本身来说实际上增加了额外的复杂度——它需要知晓上下文的存在。我们可以接纳函数式编程中不可变的思想，返回新的状态来替代原本修改上下文中的状态，这样可以消灭 Context 接口，并且让上下文使用和状态一样的接口。</p><p>有趣的是，这样的状态模式其形式非常类似装饰器模式和代理模式（甚至可能只能从语义上来区分，在代码层面上无法区分），只不过其侧重点不一样罢了。或许这几种模式都是对于委托（delegate）模式的应用吧。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果有某种返回值，也可以通过返回元组的形式来实现，如 Pair&lt;T, LiftState&gt;</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiftState</span> &#123;<br>    LiftState <span class="hljs-title function_">goUp</span><span class="hljs-params">()</span>;<br>    LiftState <span class="hljs-title function_">goDown</span><span class="hljs-params">()</span>;<br>    LiftState <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>;<br>    LiftState <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LiftContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiftState</span> &#123;<br>    <span class="hljs-keyword">private</span> LiftState state;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> LiftState <span class="hljs-title function_">goUp</span><span class="hljs-params">()</span> &#123;<br>        state = state.goUp();<br><br>        <span class="hljs-comment">// 是该返回 this 还是返回 state？</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> LiftState <span class="hljs-title function_">goDown</span><span class="hljs-params">()</span> &#123;<br>        state = state.goDown();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> LiftState <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        state = state.stop();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> LiftState <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        state = state.open();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiftState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LiftState</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenState</span>();<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> LiftState <span class="hljs-title function_">goUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;开门状态不能移动！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> LiftState <span class="hljs-title function_">goDown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;开门状态不能移动！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> LiftState <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;关门&quot;</span>);<br>        <span class="hljs-keyword">return</span> StopState.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> LiftState <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>状态模式的内涵似乎不止这些，之后还需要继续研究。</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p><strong>对数据类型的扩展有两个维度——在已有的数据类型的实现上添加新的方法；给已有的数据类型添加新的实现</strong>。在 OOP 语言中，实现后者轻而易举，而前者则需要使用静态工具类，而在静态工具类不满足需求的情况下（需要对特定实现添加特定方法，而非对接口添加方法），访问者模式则要走上舞台。</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>考虑一个场景——我们试图在 Java 的 List 上加入一些新的操作，同时希望该操作对不同的 List 实现（ArrayList，LinkedList 等）有不同的效果，我们马上会想到的一定是创建一个静态工具类并提供相关操作——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListOps</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ListOps</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;you bad bad&quot;</span>); &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">op</span><span class="hljs-params">(ArrayList&lt;?&gt; lst)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;对 ArrayList 进行操作&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">op</span><span class="hljs-params">(LinkedList&lt;?&gt; lst)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;对 ArrayList 进行操作&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">op</span><span class="hljs-params">(List&lt;?&gt; lst)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;只提供对 ArrayList 和 LinkedList 的操作！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Client</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Object&gt; lst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        ListOps.op(lst);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>感觉这样就 OK 啦？IDEA 用它的高亮告诉我们，最后被执行的 op 方法是<code>void op(List&lt;?&gt;)</code>而非我们想要的<code>void op(LinkedList&lt;?&gt;)</code>！这种情况是我们（我？）对 Java 的重载&#x2F;多态机制了解不够导致的，这个情况下 Java 选择调用的方法是<strong>依据对象的声明类型而非引用类型（静态分派）</strong>。</p><p>最简单的方案是仅创建<code>void op(List&lt;?&gt;)</code>方法，通过 instanceof 和 if-else 来“分发”方法调用——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">op</span><span class="hljs-params">(List&lt;?&gt; lst)</span> &#123;<br>    <span class="hljs-keyword">if</span> (lst <span class="hljs-keyword">instanceof</span> ArrayList) &#123;<br>        System.out.println(<span class="hljs-string">&quot;对 ArrayList 进行操作&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lst <span class="hljs-keyword">instanceof</span> LinkedList) &#123;<br>        System.out.println(<span class="hljs-string">&quot;对 ArrayList 进行操作&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;只提供对 ArrayList 和 LinkedList 的操作！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这既不优雅也不符合开闭原则。我们必须找到方法，让 Java 能够<strong>通过引用类型</strong>来调用我们的函数（动态分派），而这时候访问者模式就派上用场了。</p><h3 id="介绍-amp-amp-栗子"><a href="#介绍-amp-amp-栗子" class="headerlink" title="介绍 &amp;&amp; 栗子"></a>介绍 &amp;&amp; 栗子</h3><p>访问者模式简而言之，就是<strong>在对象上开一个洞，在洞里把自己暴露给一个称为访问者的对象</strong>，比如这样——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SomeInterface</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 洞</span><br>    &lt;T&gt; T <span class="hljs-title function_">visit</span><span class="hljs-params">(Visitor&lt;T&gt; visitor)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SomeInterface</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">visit</span><span class="hljs-params">(Visitor&lt;T&gt; visitor)</span> &#123;<br>        <span class="hljs-keyword">return</span> visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SomeInterface</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">visit</span><span class="hljs-params">(Visitor&lt;T&gt; visitor)</span> &#123;<br>        <span class="hljs-keyword">return</span> visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>两个具体类的实现看上去是一样的，能不能把 visit 方法定为 default 的？不行，因为<strong>在每个成员的 visit 方法体中，this 的类型都是已知的，仍旧走的静态分派</strong>，因此倘若定义在接口中，则必定走的是下面 Visitor 的 default 的 visit 方法。只有用户从外部调用SomeInterface的visit方法的时候才是动态分派，即找到特定的具体类。</p></blockquote><p>而<strong>访问者则需要知晓所有具体类</strong>——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteClass1 concreteClass1)</span>;<br>    T <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteClass2 concreteClass2)</span>;<br><br>    <span class="hljs-comment">// 倘若再添加一个 ConcreteClass3，被执行的 visit 就将是这个了，这倒符合上面的预期</span><br>    <span class="hljs-keyword">default</span> T <span class="hljs-title function_">visit</span><span class="hljs-params">(SomeInterface someInterface)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;需添加访问者接口&quot;</span>+Visitor.class.getName()+<span class="hljs-string">&quot;对类&quot;</span> + someInterface.getClass().getName() + <span class="hljs-string">&quot;的 visit 方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span>&lt;Void&gt; &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteClass1 concreteClass1)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Concrete Class 1&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteClass2 concreteClass2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Concrete Class 2&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>客户端代码则是这样——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Visitor&lt;Void&gt; visitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteVisitor1</span>();<br>        <span class="hljs-type">SomeInterface</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteClass1</span>();<br>        <span class="hljs-type">SomeInterface</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteClass2</span>();<br>        <span class="hljs-type">SomeInterface</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteClass3</span>();<br><br>        obj1.visit(visitor); <span class="hljs-comment">// Hello, Concrete Class 1</span><br>        obj2.visit(visitor); <span class="hljs-comment">// Hello, Concrete Class 2</span><br>        obj3.visit(visitor); <span class="hljs-comment">// RuntimeException : 需添加访问者接口 me.ykn.hello.Visitor 对类 me.ykn.hello.ConcreteClass3 的 visit 方法</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实践证明这个方法可行。为什么呢？可以发现，在进行<code>obj1.visit(visitor)</code>这样一个方法调用时，Java 通过引用类型来找到<code>obj1</code>的实际类型——即<code>ConcreteClass1</code>——中的方法<code>visit</code>并执行<code>visitor.visit(this)</code>代码，而这里的<code>this</code>的类型是可知的，因此调用的<code>visitor</code>的<code>visit</code>方法也是可知的，BINGO！</p><p><strong>每一个访问者，实际上都是在不改变原有代码的基础上给已有的数据类型添加一个新的方法</strong>。可惜，在 Java 中我们大概只能找到这种方法了。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>访问者模式的适用范围并不广（我认为一般来说静态工具类已经足以满足要求），在大多数时候我们都可以不去使用它，而且当我们试图访问的类的源代码并不能被我们修改时，应用访问者模式甚至是不可能的（或许通过适配器模式可以做到）。且访问者模式的使用有一个重要的条件——被访问者的类继承结构应当稳定，即用户很少增加被访问的类型的实现。倘若增加了，则所有的 Visitor 都需要新增对应该实现的访问方法，这是访问者对所有实现类都必须知晓的必然结果。</p><p>在 Java 中，访问者模式应用在了 Stream 的 collect 方法上，该方法允许用户使用各种方式去折叠流，其甚至模拟了一些类型类才有的操作，比如仅对<code>Stream&lt;String&gt;</code>才可用的<code>Collector.joining</code>。</p><p>另外，Scala，Kotlin 在对类的方法进行扩展上都有自己的一套方法论，其都不需要修改源代码，对它们的了解是必须的。</p><h3 id="来自未来的吐槽"><a href="#来自未来的吐槽" class="headerlink" title="来自未来的吐槽"></a>来自未来的吐槽</h3><p>访问者模式中的 Visitor，如果在将其传递给对象时使用匿名实现类的方式，然后使用 lambda 去构造这个匿名实现类，会得到怎样的效果？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MaybeVisitor</span>&lt;T, A&gt; &#123;<br>    <span class="hljs-keyword">default</span> T <span class="hljs-title function_">visit</span><span class="hljs-params">(Maybe&lt;A&gt; maybe)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Impossible&quot;</span>);<br>    &#125;<br>    T <span class="hljs-title function_">visit</span><span class="hljs-params">(Just&lt;A&gt; just)</span>;<br>    T <span class="hljs-title function_">visit</span><span class="hljs-params">(Nothing&lt;A&gt; nothing)</span>;<br><br>    <span class="hljs-keyword">static</span> &lt;T, A&gt; MaybeVisitor&lt;T, A&gt; <span class="hljs-title function_">match</span><span class="hljs-params">(</span><br><span class="hljs-params">            Function&lt;Just&lt;A&gt;, T&gt; onJust,</span><br><span class="hljs-params">            Function&lt;Nothing&lt;A&gt;, T&gt; onNothing</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MaybeVisitor</span>&lt;T, A&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> T <span class="hljs-title function_">visit</span><span class="hljs-params">(Just&lt;A&gt; just)</span> &#123;<br>                <span class="hljs-keyword">return</span> onJust.apply(just);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> T <span class="hljs-title function_">visit</span><span class="hljs-params">(Nothing&lt;A&gt; nothing)</span> &#123;<br>                <span class="hljs-keyword">return</span> onNothing.apply(nothing);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Maybe</span>&lt;A&gt; &#123;<br>    &lt;T&gt; T <span class="hljs-title function_">visit</span><span class="hljs-params">(MaybeVisitor&lt;T, A&gt; visitor)</span>;<br>    <span class="hljs-keyword">static</span> &lt;B&gt; Maybe&lt;B&gt; <span class="hljs-title function_">ofNullable</span><span class="hljs-params">(B a)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Just</span>&lt;&gt;(a);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Nothing</span>&lt;&gt;();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Just</span>&lt;A&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Maybe</span>&lt;A&gt; &#123;<br>    <span class="hljs-keyword">public</span> A value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Just</span><span class="hljs-params">(A value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">visit</span><span class="hljs-params">(MaybeVisitor&lt;T, A&gt; visitor)</span> &#123;<br>        <span class="hljs-keyword">return</span> visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Nothing</span>&lt;A&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Maybe</span>&lt;A&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">visit</span><span class="hljs-params">(MaybeVisitor&lt;T, A&gt; visitor)</span> &#123;<br>        <span class="hljs-keyword">return</span> visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Maybe.&lt;Integer&gt;ofNullable(<span class="hljs-literal">null</span>).visit(MaybeVisitor.match(<br>                just -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;not null!&quot;</span>);<br>                    <span class="hljs-keyword">return</span> just.value;<br>                &#125;,<br>                nothing -&gt; <span class="hljs-number">1000000</span><br>        ));<br><br>        <span class="hljs-comment">// 这居然能过编译？？？</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Maybe.ofNullable(<span class="hljs-number">1</span>).visit(MaybeVisitor.match(<br>                just -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;value: &quot;</span> + just.value.floatValue());<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;,<br>                nothing -&gt; <span class="hljs-literal">null</span><br>        ));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>模式匹配：天呐，这根本就是我！但这也启发了在 OOP 语言中去抽象模式匹配的方式（但我直接定义一个接受两个函数的方法，在Just和Nothing中调用特定一个不就好了吗（全恼）？</p><hr><p>了解的越多，越觉得给这些模式下确切的定义是没有必要，和模式创建出来的原意反而背道而驰的了，毕竟其在使用中总是要经过一些修改，抽象和确切的定义就显得多余和无意义了，反而不如直接甩出一堆例子和解决方案，用大家都能听懂的话来描述。从实践出发才是真正的硬道理，而模式的作用反而更多的是提供一些名词来方便描述代码的组织。</p><p><img src="/images/oss/20210822231117.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 TypeReference</title>
    <link href="/2022/01-08%E5%85%B3%E4%BA%8ETypeReference.html"/>
    <url>/2022/01-08%E5%85%B3%E4%BA%8ETypeReference.html</url>
    
    <content type="html"><![CDATA[<p>Java 中的 TypeReference 的使用方法比较奇怪，想要寻根问底，必须要更加了解 Java 的泛型擦除机制。</p><p>我们知道，Java 中的泛型是编译期的，在运行时其会被擦除掉，比如我们编写代码<code>List&lt;Integer&gt; lst = new ArrayList&lt;&gt;();</code>，从运行时看来将会是<code>List lst = new ArrayList();</code>，只留下了原始类型（raw type）。</p><p>但考虑这样的情况：在一个 servlet 应用里（为什么是 servlet？因为 spring mvc 遇不到这个问题），我们要求前端使用 JSON 来发送请求，并规定了请求的格式——</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span><span class="hljs-string">&quot;search&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;该字段可自定义&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure><p>为此，对应的 POJO 为——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestDto</span>&lt;T&gt; &#123;<br>    String type;<br>    T data;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 servlet 中，我们需要将请求体字符串转换为特定的<code>RequestDto&lt;T&gt;</code>。比如某个接口要求前端发送<code>RequestDto&lt;List&lt;Integer&gt;&gt;</code>。我们在 servlet 中可能得这么写——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ...</span><br><span class="hljs-type">String</span> <span class="hljs-variable">requestBody</span> <span class="hljs-operator">=</span> getBody(request);<br><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br><span class="hljs-comment">// 转换 string 为相应对象</span><br>RequestDto&lt;List&lt;Integer&gt;&gt; req = objectMapper.readValue(requestBody, RequestDto&lt;List&lt;Integer&gt;&gt;.class);<br><span class="hljs-comment">// ...</span><br></code></pre></div></td></tr></table></figure><p>但这个通不过编译——所谓的<code>RequestDto&lt;List&lt;Integer&gt;&gt;.class</code>是不存在的，因为在运行时不存在泛型类型，我们只能得到<code>RequestDto.class</code>，所以只能这么写——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">RequestDto&lt;List&lt;Integer&gt;&gt; req = objectMapper.readValue(requestBody, RequestDto.class);<br></code></pre></div></td></tr></table></figure><p>虽然有个恼火的警告，但至少能编译了。我们整个 demo 试试——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">RequestDto&lt;List&lt;Integer&gt;&gt; req = objectMapper.readValue(<br>    <span class="hljs-string">&quot;&#123;\&quot;type\&quot;: \&quot;search\&quot;, \&quot;data\&quot;: [1, 2, 3]&#125;&quot;</span>, RequestDto.class);<br>req.getData().forEach(System.out::println);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>成了！我们再试试错误的输入？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">RequestDto&lt;List&lt;Integer&gt;&gt; req = objectMapper.readValue(<br>    <span class="hljs-string">&quot;&#123;\&quot;type\&quot;:\&quot;search\&quot;, \&quot;data\&quot;: \&quot;hello world!\&quot;&#125;&quot;</span>, RequestDto.class);<br>req.getData().forEach(System.out::println);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Exception in thread &quot;main&quot; java.lang.ClassCastException: class java.lang.String cannot be cast to class java.util.List (java.lang.String and java.util.List are in module java.base of loader &#x27;bootstrap&#x27;)</span><br><span class="hljs-comment">at com.optimagrowth.license.LicenseServiceApplication.main(LicenseServiceApplication.java:41)</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>抛异常了！这符合预期，但是却是在<code>req.getData()</code>时抛的 cast 异常，而非 json 转换时抛出异常。</p><p>这是肿么回事呢？从运行时看来，我们是在试图将字符串<code>&#123;&quot;type&quot;:&quot;search&quot;, &quot;data&quot;: &quot;hello world!&quot;&#125;</code>转换成类型 RequestDto，即——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestDto</span> &#123;<br>    String type;<br>    Object data;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这河里吗？可太合理了，既然是<code>Object</code>，那是任何类型都是可以的了。但这显然是不符合我们的需要的——如果类型的错误必须要在我们使用的时候才能暴露出来，那这和动态类型语言何异？</p><p>问题就出在 Java 的泛型擦除机制。我们有什么手段来规避它吗？库函数的设计者告诉我们，有！</p><p>Java 的泛型擦除机制实际上至少在两个地方没有擦掉——方法的参数和返回值；继承泛型类的类。</p><p>获取其的 demo 如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">someMethod</span><span class="hljs-params">(List&lt;Boolean&gt; lst)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> Foo.class.getDeclaredMethods()[<span class="hljs-number">0</span>];<br>System.out.printf(<span class="hljs-string">&quot;方法参数：%s\n&quot;</span>, method.getGenericParameterTypes()[<span class="hljs-number">0</span>]);<br>System.out.printf(<span class="hljs-string">&quot;方法返回值：%s\n&quot;</span>,method.getGenericReturnType());<br>&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">方法参数：java.util.List&lt;java.lang.Boolean&gt;</span><br><span class="hljs-comment">方法返回值：java.util.List&lt;java.util.List&lt;java.lang.Integer&gt;&gt;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestDto</span>&lt;Integer&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.printf(<span class="hljs-string">&quot;父类的泛型类型：%s\n&quot;</span>, Bar.class.getGenericSuperclass());<br>&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">父类的泛型类型：me.ykn.RequestDto&lt;java.lang.Integer&gt;</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>前者显然为 Spring mvc 所利用——控制器的接口能够正确处理泛型类，而后者则是为所谓的 TypeReference 所利用的——通过继承的方式来保存泛型信息。我们可以通过匿名实现类来在行内（inline）直接拿到该信息。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 这里向下转型是为 demo 展示需要，实际使用时一般只需要使用 Type 类型即可</span><br>    <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">genericType</span> <span class="hljs-operator">=</span> (ParameterizedType) <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestDto</span>&lt;Integer&gt;()&#123;&#125;.getClass().getGenericSuperclass();<br>    System.out.printf(<span class="hljs-string">&quot;实际类型：%s\n&quot;</span>, genericType);<br>    System.out.printf(<span class="hljs-string">&quot;泛型参数：%s\n&quot;</span>, genericType.getActualTypeArguments()[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">实际类型：me.ykn.RequestDto&lt;java.lang.Integer&gt;</span><br><span class="hljs-comment">泛型参数：class java.lang.Integer</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>这样，我们实际上就能够间接地表示<code>RequestDto&lt;Integer&gt;.class</code>了。对上面的 json 反序列化的代码，我们可以使用 TypeReference 的匿名实现类而非 class 来保留泛型信息——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">RequestDto&lt;List&lt;Integer&gt;&gt; req = objectMapper.readValue(<br>    <span class="hljs-string">&quot;&#123;\&quot;type\&quot;:\&quot;search\&quot;, \&quot;data\&quot;: \&quot;hello world!\&quot;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;RequestDto&lt;List&lt;Integer&gt;&gt;&gt;()&#123;&#125;);<br>req.getData().forEach(System.out::println);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Exception in thread &quot;main&quot; com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize instance of `java.util.ArrayList&lt;java.lang.Integer&gt;` out of VALUE_STRING token</span><br><span class="hljs-comment"> at [Source: (String)&quot;&#123;&quot;type&quot;:&quot;search&quot;, &quot;data&quot;: &quot;hello world!&quot;&#125;&quot;; line: 1, column: 27] (through reference chain: com.optimagrowth.license.RequestDto[&quot;data&quot;])</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>我们仍旧会得到一个异常，但这个异常是符合预期的，容易理解的，是在进行反序列化中抛出的！这说明泛型信息确实得到利用了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式和函数式编程——策略模式</title>
    <link href="/2022/01-07%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html"/>
    <url>/2022/01-07%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<p>半年没有学习设计模式了，这半年以来主要做的框架开发工作，也算是有一些实践经验（虽然远远不够），同时也是了解了很多函数式编程的概念，写的代码里状态越来越少，代码风格越来越声明式（好久没写过原生的 for 和 while 了 hhh），也开始觉得一些设计模式变得臃肿起来了。现在继续回来学习设计模式，顺便看看它们结合函数式编程中的概念会对样板代码有如何的简化。</p><span id="more"></span><blockquote><p>今年第一篇笔记。</p></blockquote><p>这里我选择了策略模式进行学习，之后是命令模式和状态模式，选择其的原因是因为这三个模式经由借助 Java8 所提供的函数式的工具——函数式接口和闭包——能很大程度地简化。</p><h2 id="函数式接口和闭包"><a href="#函数式接口和闭包" class="headerlink" title="函数式接口和闭包"></a>函数式接口和闭包</h2><p>函数式接口结合 Lambda 表达式，使我们能够书写作为值&#x2F;字面量的函数。这样，将函数作为值来看待，作为入参传入，作为返回值等使用方法都变得明显和符合直觉了。曾经我们只能够传递“名词”给函数，而现在我们能传递“动词”了。</p><p>而闭包使我们能够捕获外部作用域的变量，从而构造一个“穷人的类”——就如同类是数据和行为的一个聚合一样，闭包函数也是这样一个聚合，只不过行为只有一种罢了，比如说下面两个 Counter 完全可以认为是等价的——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">IntSupplier <span class="hljs-title function_">counter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Java 限制捕获的值必须是不变的，或者说“实际上 final”的</span><br>    <span class="hljs-comment">// 因此如果要想改变捕获的变量的值的话，必须让变量作为引用类型，而值作为该类型包含的状态</span><br>    <span class="hljs-comment">// 最佳实践是使用长度为 1 的数组，将状态包裹在数组中，对其进行修改不会改变 count 的值（即该引用）</span><br>    <span class="hljs-comment">// 但倘若类型中有泛型，创建其的数组是无法实现的，可以考虑将变量捕获为特定类的状态</span><br>    <span class="hljs-type">int</span>[] count = &#123;<span class="hljs-number">0</span>&#125;; <br>    <span class="hljs-keyword">return</span> () -&gt; &#123;<br>        <span class="hljs-keyword">return</span> count[<span class="hljs-number">0</span>]++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count++;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>再考虑另一个情形——我们试图用多线程执行某个 task，而这个 task 有一个依赖的对象。如果在上古时代的 Java，我们必须创建一个实现 Runnable 的类来包含相应依赖，比如需要这么写——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SomeDependency someDependency;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SomeTask</span><span class="hljs-params">(SomeDependency someDependency)</span> &#123;<br>        <span class="hljs-built_in">this</span>.someDependency = someDependency;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        someDependency.call();<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SomeDependency</span> <span class="hljs-variable">someDependency</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeDependency</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeTask</span>(someDependency)).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>这里故意没有使用匿名实现类，但其实使用匿名实现类的话也需要用到闭包。</p></blockquote><p>需要多加一个类！如果这个类只用一次的话，那也太麻烦了！而在 Java 8 里，我们可以这么写——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SomeDependency</span> <span class="hljs-variable">someDependency</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeDependency</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-comment">// ...</span><br>        someDependency.call(); <span class="hljs-comment">// 通过闭包直接捕获 someDependency，优雅极了，而且也挺符合直觉</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果我们有多个 task 都会利用这个依赖呢？旧时代的 Java 就只能对每个 task 都创建一个类了。我们可以用方法引用（本质上也是匿名函数）来解决这个问题——建立一个类来包含依赖的对象，把每个 task 作为一个方法并在方法中使用该依赖，如 taskA，taskB。</p><p>或者也可以通过函数参数来注入依赖，如 taskC，使用时使用匿名函数对该 task 进行调用，注入依赖。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskContainer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SomeDependency someDependency;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">TaskContainer</span><span class="hljs-params">(SomeDependency someDependency)</span> &#123;<br>        <span class="hljs-built_in">this</span>.someDependency = someDependency;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TaskContainer <span class="hljs-title function_">inject</span><span class="hljs-params">(SomeDependency someDependency)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskContainer</span>(someDependency);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">taskA</span><span class="hljs-params">()</span> &#123;<br>        someDependency.call();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">taskB</span><span class="hljs-params">()</span> &#123;<br>        someDependency.call();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">taskC</span><span class="hljs-params">(SomeDependency someDependency)</span> &#123;<br>        someDependency.call();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SomeDependency</span> <span class="hljs-variable">someDependency</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeDependency</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; TaskContainer.inject(someDependency).taskA()).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(TaskContainer.inject(someDependency)::taskB).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; TaskContainer.taskC(someDependency)).start();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>容易发现，这样的代码虽然更加简短，但是却是破坏了开闭原则的——各种 Task 都定义在这个类里，如果要增加新的 Task，则必须要修改源代码。但这在实践上真的会造成影响吗？应当具体问题具体分析。</p><p>也需要知道的是，虽然 Java 8 为函数式编程做了一些努力，但它的完善程度仍旧是远远不够的，它仍旧试图把函数都当作特定类型的对象来对待，这样即使两个函数的函数签名相同，它们两个也未必是能够互换使用的。这在异常处理，函数组合等地方都带来了很大的麻烦，而 Scala 或 Kotlin 在这方面做的很好——首先函数的签名就是函数的类型，这在很多时候甚至比<strong>被迫的</strong>命名还要清晰——<code>Int -&gt; Int</code>可比<code>IntUnaryOperator</code>要好理解的多了；而且函数仍被当作类来看待，因此也具有自己的方法——和其他的函数进行组合等。这是 Java 做不到的（Java 提供的函数式接口似乎普遍包含了一个组合方法<code>andThen</code>，<code>Function</code>接口包含了<code>compose</code>，但是并不统一），即使能做到也缺乏泛用性。而试图进行柯里化等操作时，得到的函数签名更是不忍直视，比如<code>Int -&gt; Int -&gt; Int -&gt; Int</code>会得到<code>Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt;</code>，并且调用时也得<code>fn.apply(1).apply(2).apply(3)</code>，实在难以使用。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p></blockquote><p>策略模式就本质上说来，就是将为特定目的&#x2F;接口的算法封装在同样接口的类中，使我们能够方便添加新的算法，以及更换&#x2F;切换使用的算法。策略模式无论是从面向对象的角度还是从函数式的角度都是非常容易理解的。一个简单的例子就是，JDBC 如何适配多个数据库？答案是提供同样的接口，为每个数据库都对该接口进行实现，在运行时选择使用的数据库的对应的实现类。</p><p>考虑这样的一个简单情景——我们在维护一个电影院的售票系统，现在我们要根据用户的年龄和类型来计算票价（假设票价只和用户的年龄和类型相关，和电影等其它属性无关）。根据票价的规则，我们快速整出来一个原型——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TicketService</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 票价算法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> type)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) <span class="hljs-keyword">return</span> base - <span class="hljs-number">10</span>;<br>                <span class="hljs-keyword">return</span> base;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (base * <span class="hljs-number">0.9</span> - <span class="hljs-number">10</span>);<br>                <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (base * <span class="hljs-number">0.9</span>);<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> base / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;错误的 type&quot;</span>); <span class="hljs-comment">// 该函数可能抛出异常，这说明它是一个偏函数。我们可以通过函数式的手段解决它</span><br>        &#125; <br>    &#125;<br><br>    <span class="hljs-comment">// 客户端代码</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">buyTicket</span><span class="hljs-params">(User user, Movie movie)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> getPrice(user.getAge(), user.getType());<br>        System.out.printf(<span class="hljs-string">&quot;用户%s 的票价为：%s\n&quot;</span>, user.getName(), price);<br>        <span class="hljs-comment">// do some bussiness......</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>We did it！代码很简单，可是它真能“不忘初心”吗？non non 哒哟！基础价变了怎么办？成年人的定义变了怎么办？遇上节日了不打折吗？会员的折扣变了怎么办？显然，这代码可抵抗不了业务的变化，它必须得动。</p><h2 id="介绍和示例"><a href="#介绍和示例" class="headerlink" title="介绍和示例"></a>介绍和示例</h2><p>能够发现，当我们进行对计算规则进行改变的时候，我们实际上只需要改变 getPrice 方法中的内容，而 buyTicket 方法，以及 getPrice 的签名（接口）都是不变的。答案很显然了，我们把 getPrice 抽象成接口，而让具体的算法去实现这样的接口就行了，而 buyTicket 则利用该接口对具体算法进行使用。这样的接口就称为策略（Strategy）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PriceStrategy</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> type)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PriceStrategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> type)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PriceStrategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> type)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 很平等（</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TicketService</span> &#123;<br>    <span class="hljs-keyword">private</span> PriceStrategy priceStrategy;<br><br>    <span class="hljs-comment">// 非 Spring 环境下当然也可以进行依赖注入</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPriceStrategy</span><span class="hljs-params">(PriceStrategy priceStrategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.priceStrategy = priceStrategy;<br>    &#125;<br><br>    <span class="hljs-comment">// 客户端代码</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">buyTicket</span><span class="hljs-params">(User user, Movie movie)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> priceStrategy.getPrice(user.getAge(), user.getType());<br>        System.out.printf(<span class="hljs-string">&quot;用户%s 的票价为：%s\n&quot;</span>, user.getName(), price);<br>        <span class="hljs-comment">// do some bussiness......</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样，当业务有调整的时候，只需要编写新的策略，并通过配置文件等形式修改注入的具体策略即可，甚至能够在运行时对使用的策略进行修改。我们还可以让策略之间互相依赖，比如对另外一个策略的票价再打个折之类的。</p><p>总而言之（真快啊！），策略模式中出现三种角色——<strong>上下文</strong>（context），使用策略的地方，即客户端；<strong>抽象策略</strong>，或者说策略的接口，其将被上下文所使用；<strong>具体策略</strong>，顾名思义。</p><h2 id="FP-的观点"><a href="#FP-的观点" class="headerlink" title="FP 的观点"></a>FP 的观点</h2><p>从函数式编程的角度来看，这一个个的具体的策略类实际上是一个个具有同样的接口&#x2F;签名的函数，它们被命名，被保存了。于是，我们可以<strong>通过函数来表示具体策略，让函数的签名来代替抽象策略</strong>，从而消灭抽象策略这一角色，在上下文中直接使用符合该函数签名的函数作为具体策略。比如，这里的 getPrice 函数，它的签名为<code>(int, int) -&gt; int</code>，或者从 Java 的话说，<code>BiFunction&lt;Integer, Integer, Integer&gt;</code>或<code>Function&lt;Tuple2&lt;Integer, Integer&gt;, Integer&gt;</code>，抽象策略的类就可直接使用该函数类来代替，而具体策略只需要实现该接口的示例。比如我们可以这么写——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TicketService</span> &#123;<br><br>    <span class="hljs-comment">// 应当通过依赖注入的方式传入，这样也能在函数体中通过闭包来引入依赖。</span><br>    <span class="hljs-keyword">private</span> BiFunction&lt;Integer, Integer, Integer&gt; getPrice = (age, type) -&gt; &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125;;<br><br>    <span class="hljs-comment">// 客户端代码</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">buyTicket</span><span class="hljs-params">(User user, Movie movie)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> priceStrategy.apply(user.getAge(), user.getType());<br>        System.out.printf(<span class="hljs-string">&quot;用户%s 的票价为：%s\n&quot;</span>, user.getName(), price);<br>        <span class="hljs-comment">// do some bussiness......</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>对同一个接口，需要能够切换多个实现的情况下使用策略模式非常适合，比如前面说到的票价计算场景，以及选择使用介质的缓存（本地，内存，磁盘，网络），统一不同的文件系统等。需注意的是如果策略包含多个方法，则还是使用面向对象的手段更方便些。</p><h2 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h2><p>我们可以通过函数组合的方法对不同策略进行组合，达到复用代码，或者对结果进行“代理”的目的。比如我们可以让策略的返回值来乘以一个数来模拟打折情况——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BiFunction&lt;Integer, Integer, Integer&gt; beforeStrategy = (age, type) -&gt; &#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">42</span>;<br>&#125;;<br>BiFunction&lt;Integer, Integer, Integer&gt; afterStrategy0 = (age, type) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (beforeStrategy.apply(age, type) * <span class="hljs-number">0.9</span>);<br>&#125;;<br>BiFunction&lt;Integer, Integer, Integer&gt; afterStrategy1 = beforeStrategy.andThen(price -&gt; (<span class="hljs-type">int</span>) (price * <span class="hljs-number">0.9</span>));<br></code></pre></div></td></tr></table></figure><p>我们也可以通过流式接口等形式来创建策略的工厂类，通过 DSL 来描述业务，最终创建出最后的服务，比如可能可以这样——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 随便写写</span><br>BiFunction&lt;Integer, Integer, Integer&gt; someStrategy = <br>    PriceStrategyFactory<br>        .from((age, type) -&gt; <span class="hljs-number">42</span>)<br>        .precondition((age, type) -&gt; age &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">0</span> &lt;= type &amp;&amp; type &lt;= <span class="hljs-number">3</span>)<br>        .andThen(price -&gt; price + <span class="hljs-number">100</span>)<br>        .onError(Exception::printStackTrace)<br>        .build();<br></code></pre></div></td></tr></table></figure><p>甚至利用动态语言等的特性，嵌入个 lua 虚拟机整整活？这里还会有无数的骚操作，但是我想不出来了，告辞！</p><h2 id="关于函数组合"><a href="#关于函数组合" class="headerlink" title="关于函数组合"></a>关于函数组合</h2><p>什么是函数组合？我们知道，数学上的函数是两个集合之间的映射，如 f(x) &#x3D; x + 1 （x ∈ R）为一个实数集到实数集的映射。而类型可以认为是一个数据的集合，如 int 型代表……-1, 0, 1, ……的集合，char 型代表’a’, ‘b’, ……的集合。计算机中的函数因此也可表示从集合到集合的映射，如上面的 getPrice 函数，其可以表达为<code>(int, int) -&gt; int</code>，即一个<code>(int, int)</code>——int 型和 int 型的笛卡尔积——的集合到 int 型的映射。</p><p>如果我们有一个函数<code>f : A -&gt; B</code>，其中 A 为输入值的类型，B 为输出值的类型，又有一个函数<code>g : B -&gt; C</code>，这样我们就可以组合这两个函数，得到函数<code>g . f : A -&gt; C</code>。其中<code>(g . f)(x) = g(f(x))</code>。</p><p>扯这些有啥用呢？我们可以通过函数签名来对函数进行组合，从而把简单的函数组装成复杂的函数，以更声明式的手段表达业务逻辑。比如在 Java 中，我们可以写<code>Stream.of(1, 2, 3).filter(i -&gt; i % 2 == 1).map(i -&gt; i * 3).reduce(0, Integer::sum)</code>，而在函数式语言中，我们会写<code>sum . map (* 3) . filter (\i -&gt; div i 2 == 1)</code>。一个 js 的例子如下——</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 首先定义 filter，map 的柯里化形式——</span><br><span class="hljs-comment">// filter : (Int -&gt; Bool) -&gt; [Int] -&gt; [Int]</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">filter</span> = algo =&gt; <span class="hljs-function"><span class="hljs-params">lst</span> =&gt;</span> lst.<span class="hljs-title function_">filter</span>(algo)<br><span class="hljs-comment">// map : (Int -&gt; Int) -&gt; [Int] -&gt; [Int]</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">map</span> = algo =&gt; <span class="hljs-function"><span class="hljs-params">lst</span> =&gt;</span> lst.<span class="hljs-title function_">map</span>(algo)<br><span class="hljs-comment">// sum : [Int] -&gt; Int</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = lst =&gt; lst.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// compose : (B -&gt; C) -&gt; (A -&gt; B) -&gt; (A -&gt; C)</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">compose</span> = b2c =&gt; <span class="hljs-function"><span class="hljs-params">a2b</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// A -&gt; C，x 类型是 A</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">b2c</span>(<span class="hljs-title function_">a2b</span>(x))<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 考虑到 compose 这个函数太难看了（看起来像 Lisp），这里也给定了 haskell 形式的描述</span><br><span class="hljs-comment">// someAlgo : [Int] -&gt; Int = sum . map (* 3) . filter (\i -&gt; div i 2 == 1)</span><br><span class="hljs-keyword">const</span> someAlgo = compose (sum) (compose (map (<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i * <span class="hljs-number">3</span>)) (filter (<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)))<br></code></pre></div></td></tr></table></figure><p>在 Java 中，我们对数据进行链式的处理，而在函数式编程中，我们通过组合小的，易理解、处理、证明的函数来构造最终的复杂函数并将其应用到数据上。显然后者是形式更加清晰（至少在 Haskell 里是这样的……），测试更为容易，更加容易进行复用的。</p><p><img src="/images/oss/20210926020709.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐观锁的简单实现</title>
    <link href="/2021/12-10%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.html"/>
    <url>/2021/12-10%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<p>基于线程和共享内存的并发模型向来都是难于编写，难于调试的。但是在 Web 应用里它又是如此常见，因此仍旧有必要去做深入了解。更现代的并发模型（Actor，Channel，函数式，STM……）要学，线程和锁的并发模型也要学，这才称得上是健全！</p><span id="more"></span><p>这里记录一下对乐观锁的学习以及对使用乐观锁的<code>AtomicInteger</code>简单实现。我自认为我的实现会比网络上流传的更通俗易懂些（使用递归进行自旋而非无限循环）。但考虑到我们无法在代码层面直接实现原子的 CAS，这里必须得加锁。所以这里的代码其实并无任何实用意义，仅能用作学习了。</p><h2 id="乐观和悲观"><a href="#乐观和悲观" class="headerlink" title="乐观和悲观"></a>乐观和悲观</h2><blockquote><p>  Happy，Lucky，Smile，Yeah！</p></blockquote><p>就看待 data race 的态度（同样也是方式）而言，锁可以分为悲观锁和乐观锁。其中，悲观锁假设自己在操作数据时一定有其他线程试图对数据进行修改，所以必须要能够独占数据；而乐观锁假设操作时数据不会被修改，仅在最终修改数据前检查数据是否被改变。</p><p>悲观锁在 Java 中即为常见，如 synchronized 关键字就是给方法或代码块加上这种悲观锁。当一个线程进入 synchronized 的代码块，它就将获得对应（对象）的锁，从而便能够独占数据，保证当前操作是同步、原子的。而乐观锁的典型实现是 concurrent 包下的各种 Atomic 类，其使用乐观锁保证对其的操作为原子操作，从而保证对其使用是线程安全的。其最常使用在计数等操作中。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>乐观锁的实现依赖所谓的 CAS（Compare And Set）操作，即在操作数据前，先将数据的原始值保存，再对数据进行拷贝和操作，获取结果值，然后检查这过程中数据是否改变，如果未改变则设置数据为新值，否则认为操作失败，进行自旋或其他操作（自旋其实就是递归执行自己，这时的基线条件就是操作成功，但使用循环应该会性能更高）。其中该检查和设置的过程即为 CAS，其必须是原子的。它的代码描述比文字描述或许更通俗易懂——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 不知道究竟有无必要保证可见性，但是加了其实也没啥损失</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCounter</span> <span class="hljs-operator">=</span> counter; <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCounter</span> <span class="hljs-operator">=</span> oldCounter + <span class="hljs-number">1</span>; <span class="hljs-comment">// 操作</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> compareAndSet(oldCounter, newCounter);<br>    <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    increment(); <span class="hljs-comment">// 自旋</span><br>&#125;<br><span class="hljs-comment">// 注意加了锁！在 Java 中，该操作利用了现代处理器上相应指令，因而是原子操作，性能远好于锁</span><br><span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span> newValue)</span> &#123;<br>    <span class="hljs-keyword">if</span> (oldValue == counter) &#123; <span class="hljs-comment">// compare</span><br>        counter = newValue; <span class="hljs-comment">// set</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码实际上已经可以跑了 w，这里的“操作”也可以看出一种模式，我们来进行一些抽象——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">operateAndGet</span><span class="hljs-params">(IntUnaryOperator operation)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCounter</span> <span class="hljs-operator">=</span> counter;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCounter</span> <span class="hljs-operator">=</span> operation.applyAsInt(oldCounter);<br>    <span class="hljs-keyword">if</span> (compareAndSet(oldCounter, newCounter))<br>        <span class="hljs-keyword">return</span> newCounter; <span class="hljs-comment">// 如果是 getAndOperate，则返回 oldCounter</span><br>    <span class="hljs-keyword">return</span> operateAndGet(operation); <span class="hljs-comment">// 自旋</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="ABOAOBA"><a href="#ABOAOBA" class="headerlink" title="ABOAOBA"></a>ABOAOBA</h2><p>上面的 CAS 操作已能满足大多数需求，但仍旧存在一个问题——如果当前线程在操作数据时，数据从 A 变成 B 再变成 A，当前线程在 CAS 操作时是感受不到这种变化的，它会认为数据没有被改变，因此会应用自己的操作。这称为 ABA 问题，它在某些场景下可能造成问题。</p><p>ABA 问题的解决方案是使用一个单独的数据（称为 Version）来描述数据的状态，对数据的任何操作都将改变 Version，从而利用 Version 而非数据本身来检查数据是否改变。下面的代码是一个<code>AtomicInteger</code>的实现，其使用版本号来进行比较。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAtomicInteger</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">operateAndGet</span><span class="hljs-params">(IntUnaryOperator operation)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">oldVersion</span> <span class="hljs-operator">=</span> version;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCounter</span> <span class="hljs-operator">=</span> counter;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCounter</span> <span class="hljs-operator">=</span> operation.applyAsInt(oldCounter);<br>        <span class="hljs-keyword">if</span> (compareAndSet(oldVersion, newCounter))<br>            <span class="hljs-keyword">return</span> newCounter;<br>        <span class="hljs-keyword">return</span> operateAndGet(operation);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">long</span> oldVersion, <span class="hljs-type">int</span> newValue)</span> &#123;<br>        <span class="hljs-keyword">if</span> (oldVersion == version) &#123;<br>            counter = newValue; <span class="hljs-comment">// 设置数据</span><br>            version = oldVersion + <span class="hljs-number">1</span>; <span class="hljs-comment">// 设置 Version</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 进行简单的测试，使用并行流模拟并发情况</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyAtomicInteger</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAtomicInteger</span>();<br>        IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>).parallel().forEach(__ -&gt; counter.operateAndGet(i -&gt; i + <span class="hljs-number">1</span>));<br>        System.out.println(counter.get());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>乐观锁在数据库中也比较常用，Mybatis-Plus 提供了对乐观锁的插件支持，其原理是使用实体的其中一个字段充当 Version，在 Update 时将版本号也作为查询条件，这时若影响行数为 0，便说明版本号不对应，操作失败了。</p><p>顺便，对上面的 AtomicInteger 的实现，concurrent 包下的 AtomicInteger 的实现和使用 synchronized 对操作进行包装的 int 进行比较，检查其执行一亿次自增所耗时间，得到了如下的结果——</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">MyAtomicInteger:</span> <span class="hljs-number">4996</span><br><span class="hljs-attr">AtomicInteger:</span>   <span class="hljs-number">1675</span><br><span class="hljs-attr">synchronized:</span>    <span class="hljs-number">4841</span><br></code></pre></div></td></tr></table></figure><p>funny，这说明 compareAndSet 操作是这里的性能瓶颈，毕竟加了锁。</p><p><img src="/images/oss/2021/07/142021-07-14.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《七周七语言》笔记——Ruby</title>
    <link href="/2021/12-07%E3%80%8A%E4%B8%83%E5%91%A8%E4%B8%83%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ruby.html"/>
    <url>/2021/12-07%E3%80%8A%E4%B8%83%E5%91%A8%E4%B8%83%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ruby.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>不会有第二篇了，认真去学 Scala，将来若有需要可能回去碰碰 Rust 和 Scheme&#x2F;Racket。</p><p>—— 2021-12-27</p></blockquote><p>开始认真看《七周七语言》这书，主要目的是了解下各个编程范式在实践上的一些具体差别，同时了解一下各种语言的骚操作，如 Ruby 的模板元编程，scala 的 Actor，erlang 的……快速失败？Io 的基于原型的面向对象编程……总之按照书中的顺序挨个 peek 一下，首先是 Ruby。</p><span id="more"></span><blockquote><p>  考虑了很久，决定这书先放下，先学一门灵活又强大，既能用于实践也能用于各种形式抽象的语言，并对其进行深入学习，达到和 Java 一样的上手程度，能随手写出实例，也能拿来进行工程实践。</p><p>  Haskell 先 pass，因为它难以用于实践；Kotlin 很有趣，let，apply 等方法精妙绝伦，但又略有工业气息（比如？语法糖，我还是希望它提供一个真正的 Optional），且进行函数式编程并不方便（写个柯里化的函数试试？）；最终我还是选择 Scala，它的抽象能力足以模拟 Haskell 中各种骚操作，兼具面向对象和函数式编程特性让它在这两方面都可堪用，Actor 的并发模型也是我想关注的对象之一，而且在将来甚至还有实践意义，所以选择 Scala 是完全合理的。</p></blockquote><h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>我讨厌动态类型语言，讨厌鸭子类型（就如讨厌实用主义），因此对 Ruby 自然也没啥兴趣，但它的语法显然受 Perl 之类的影响很多（而函数命名则受到了 Scheme 的影响，从谓词后面带着的问号就能看出来），优美流畅如同自然语言，特别是单行的 if&#x2F;unless，以及 while&#x2F;until。其中 unless 等价于 if not。我始终想不到 unless 翻译成中文该怎么说，“若非”有点怪。</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">answer = <span class="hljs-number">42</span> <span class="hljs-comment"># 变量无需声明</span><br>puts <span class="hljs-string">&quot;correct!&quot;</span> <span class="hljs-keyword">if</span> answer == <span class="hljs-number">42</span> <span class="hljs-comment"># Ruby 里，一切语句都有返回值，我喜欢这一点</span><br><span class="hljs-comment"># 等价于</span><br>puts <span class="hljs-string">&quot;correct!&quot;</span> <span class="hljs-keyword">unless</span> answer != <span class="hljs-number">42</span><br><span class="hljs-comment"># 等价于</span><br>answer == <span class="hljs-number">42</span> &amp;&amp; puts <span class="hljs-string">&quot;correct!&quot;</span> <span class="hljs-comment"># 类似 js 的用法</span><br><span class="hljs-comment"># 一切操作符都是对象的方法，如 answer == 42 本质是 answer.== 42，这点同 scala（但是我不太喜欢这种形式，更喜欢 typeclass 那种，更像是定义了两个对象的“关系”）</span><br><br>i = <span class="hljs-number">0</span><br>(puts i; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">until</span> i == <span class="hljs-number">10</span> <br><span class="hljs-comment"># 等价于</span><br><span class="hljs-keyword">until</span> i == <span class="hljs-number">10</span><br>    puts i<br>    i = i + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment"># 等价于</span><br>(puts i; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">10</span> <br></code></pre></div></td></tr></table></figure><p>必须承认，这单行的循环还是有点麻烦的……正经人谁写循环啊。</p><p>然后，这是基本 for 循环——</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span>  <span class="hljs-comment"># (1..5).class == Range</span><br>    puts i<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>这是 forEach 形式，语法非常像 Kotlin 的尾 lambda 形式——</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">(<span class="hljs-number">1</span>..<span class="hljs-number">5</span>).each <span class="hljs-keyword">do</span> |<span class="hljs-params">elem</span>|<br>    puts elem<br><span class="hljs-keyword">end</span><br><br>(<span class="hljs-number">1</span>..<span class="hljs-number">5</span>).each &#123; |<span class="hljs-params">elem</span>| puts elem &#125; <span class="hljs-comment"># 这就完全一样了</span><br></code></pre></div></td></tr></table></figure><p>足够做第一天的题目了，开始吧。</p><ul><li><strong>打印字符串”Hello, world.”。</strong></li></ul><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">puts <span class="hljs-string">&quot;Hello, world.&quot;</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>在字符串”Hello, Ruby.”中，找出”Ruby.”所在下标。</strong></li></ul><p>这题首先想到的就是使用 find 或 indexOf 之类的方法，借助 tab 真让我补全到了——</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">puts <span class="hljs-string">&#x27;Hello, Ruby.&#x27;</span>.index /<span class="hljs-title class_">Ruby</span>\./ <span class="hljs-comment"># 输出 7，返回 nil</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>打印你的名字十遍。</strong></li></ul><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-number">10</span>.times &#123;puts <span class="hljs-string">&#x27;✯_G∀ZER&#x27;</span>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>打印字符串”This is sentence number 1.”，其中的数字 1 会一直变化到 10。</strong></li></ul><p>利用字符串格式化。</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">(<span class="hljs-number">1</span>..<span class="hljs-number">10</span>).each <span class="hljs-keyword">do</span> |<span class="hljs-params">i</span>|<br>    puts <span class="hljs-string">&quot;This is sentence number <span class="hljs-subst">#&#123;i&#125;</span>.&quot;</span> <span class="hljs-comment"># 需要格式化字符串时，使用双引号，使用#&#123;&#125;引用变量</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>从文件运行 Ruby 程序。</strong></li></ul><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-comment"># hello.rb</span><br>puts <span class="hljs-string">&quot;hello, world&quot;</span><br><br><span class="hljs-comment"># shell</span><br><span class="hljs-variable">$ </span>ruby hello.rb<br>hello, world<br></code></pre></div></td></tr></table></figure><ul><li><strong>加分题：如果你感觉意犹未尽，还可以写一个选随机数的程序。该程序让玩家猜随机数是多少，并告诉玩家是猜大了还是猜小了。</strong></li></ul><p>这个语言的函数调用非常有趣，当把函数名写出来的时候，就是对函数的调用了。也就是说对于一个<code>() -&gt; a</code>的函数，其是直接进行了函数的调用，而非对函数本身求值。这在其他语言里是见不到的，Haskell 的 IO Monad 倒是在这上面和它现象一致，但本质肯定是不同的，在赋值时就能看出来了。如果想要在下面的 Haskell 里达到和 Ruby 一样的效果，需要<code>a = unsafePerformIO randomIO</code>才行。下面的 a 是求值 randomIO 的结果，而非是 perform randomIO 的结果。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-type">Prelude</span>&gt; <span class="hljs-keyword">import</span> System.Random<br><span class="hljs-type">Prelude</span> <span class="hljs-type">System</span>.<span class="hljs-type">Random</span>&gt; randomIO <span class="hljs-comment">-- randomIO :: IO Int</span><br><span class="hljs-type">Prelude</span> <span class="hljs-type">System</span>.<span class="hljs-type">Random</span>&gt; randomIO<br><span class="hljs-number">6879460589617617602</span><br><span class="hljs-type">Prelude</span> <span class="hljs-type">System</span>.<span class="hljs-type">Random</span>&gt; randomIO<br>-<span class="hljs-number">2890844218392729664</span><br><span class="hljs-type">Prelude</span> <span class="hljs-type">System</span>.<span class="hljs-type">Random</span>&gt; randomIO<br>-<span class="hljs-number">7445306786419155406</span><br><span class="hljs-type">Prelude</span> <span class="hljs-type">System</span>.<span class="hljs-type">Random</span>&gt; a = randomIO<br><span class="hljs-type">Prelude</span> <span class="hljs-type">System</span>.<span class="hljs-type">Random</span>&gt; a<br>-<span class="hljs-number">9077188816176212561</span><br><span class="hljs-type">Prelude</span> <span class="hljs-type">System</span>.<span class="hljs-type">Random</span>&gt; a<br><span class="hljs-number">8564549844481012240</span><br><span class="hljs-type">Prelude</span> <span class="hljs-type">System</span>.<span class="hljs-type">Random</span>&gt; a<br>-<span class="hljs-number">6436459373760545118</span><br></code></pre></div></td></tr></table></figure><p>咳咳，总之专注题目。Haskell 的环境搭建太烦人了，依赖总是找不到，Stack 也总是配置不好，下次干脆 tm 用 purescript 算了。</p><p>这个问题需要将输入转换为整数，测试发现字符串的 to_i 方法能够进行转换。经过上面的描述，可以得到一个非常有趣（以及离谱）的解决方案——<code>gets.to_i</code>。这种形式简直离谱😂。</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">r = rand <span class="hljs-number">100</span><br>puts <span class="hljs-string">&#x27;猜一个从 0 到 100 的数&#x27;</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span><br>    puts <span class="hljs-string">&#x27;输入：&#x27;</span><br>    input = gets.to_i <span class="hljs-comment"># Magic！</span><br>    puts <span class="hljs-string">&#x27;小了！&#x27;</span> <span class="hljs-keyword">if</span> input &lt; r<br>    puts <span class="hljs-string">&#x27;大了！&#x27;</span> <span class="hljs-keyword">if</span> input &gt; r<br>    (puts <span class="hljs-string">&#x27;you got it！&#x27;</span>; <span class="hljs-keyword">return</span>) <span class="hljs-keyword">if</span> input == r <span class="hljs-comment"># return，就如其他 c 系语言</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>我佛啦。</p><h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>Ruby 的数组和 Python 的数组极为相似。形如<code>1..10</code>这种形式的对象为<code>Range</code>。数组可以通过 Range 来获得子数组。</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Peach&quot;</span>, <span class="hljs-string">&quot;Lemon&quot;</span>]<br>puts fruits[<span class="hljs-number">0</span>..<span class="hljs-number">1</span>] <span class="hljs-comment"># 前闭后闭</span><br></code></pre></div></td></tr></table></figure><p>有趣（但也挺 trival）的地方是，<code>[]</code>和<code>[]=</code>（设置特定索引的值）也是数组的方法。</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">puts fruits.[] <span class="hljs-number">0</span><br>fruits.[]= <span class="hljs-number">0</span>, <span class="hljs-string">&quot;What the Fuck?&quot;</span> <span class="hljs-comment"># 多个参数通过逗号分隔，不能使用括号</span><br></code></pre></div></td></tr></table></figure><p>有趣的地方是函数的多个参数是通过逗号分隔的……这么说我们如果要强调一个函数优先调用，得这么干——<code>(puts 1, 2, 3)</code>而非<code>puts (1, 2, 3)</code>。突然又像 Lisp 了，好家伙。</p><p>举一反三，我们定义数组的时候，其实是调用了这样的函数——</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">fruits = <span class="hljs-title class_">Array</span>.[] <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Peach&quot;</span>, <span class="hljs-string">&quot;Lemon&quot;</span><br></code></pre></div></td></tr></table></figure><p>我实在不太喜欢这样……</p><p>哈希表的语法是这样的，好像和 Python 的类似。冒号前缀的数据类型称为符号，类似 Lisp 的 quote，或者其他 C 系语言的枚举。其通过 to_s 和 to_sym 方法可以和字符串互相转换，</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">map = &#123;<span class="hljs-string">&quot;answer&quot;</span> =&gt; <span class="hljs-number">42</span>, <span class="hljs-string">&quot;value&quot;</span> =&gt; <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-symbol">:symbol</span> =&gt; <span class="hljs-string">&quot;like Lisp!&quot;</span>&#125;<br>map[<span class="hljs-string">&quot;answer&quot;</span>] <span class="hljs-comment"># 42</span><br>map[<span class="hljs-symbol">:symbol</span>] <span class="hljs-comment"># &quot;like Lisp!&quot;</span><br></code></pre></div></td></tr></table></figure><p>前一天中{}包围的代码称为代码块。代码块是 Ruby 中的匿名函数。下面的代码顾名思义——</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-number">3</span>.times &#123; puts <span class="hljs-string">&quot;三回啊三回&quot;</span> &#125;<br></code></pre></div></td></tr></table></figure><p>do-end 结构和代码块是否是同一种东西？</p><p>我们可以通过在运行时给 Integer 添加新的方法以构造我们自己的 time 方法，通过类似 Python 的 yield。yield 大概使函数变成了迭代器。</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_times</span><br>        i = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span><br>            i = i - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">yield</span> <br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>yield 本身不算难理解，可是它生成的是谁？self？i？如果是 self，对 i 的修改直接改变了 self？我们做一些测试——</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tst</span><br>        i = <span class="hljs-variable language_">self</span><br>        i = i + <span class="hljs-number">100</span><br>        puts i == <span class="hljs-variable language_">self</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-number">3</span>.tst <span class="hljs-comment"># false</span><br></code></pre></div></td></tr></table></figure><p>看上去是后者，那 yield 是怎样“选中”i 的？最近一条表达式的返回值？哈人啊朋友！</p><p>Ruby 的带参数的函数定义同其他 C 系语言一致——</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">something</span>(<span class="hljs-params">n</span>) <span class="hljs-comment"># 有趣的事情是 def 语句本身返回和函数名相同的 symbol</span><br>    n + <span class="hljs-number">100</span><br><span class="hljs-keyword">end</span><br><br>something <span class="hljs-number">2</span> <span class="hljs-comment"># 102</span><br><br><span class="hljs-symbol">:something</span>.to_proc.call <span class="hljs-literal">nil</span>, <span class="hljs-number">100</span> <span class="hljs-comment"># 通过这种形式能够将符号转换成原函数（它称为过程，又是从 Lisp 来的），至于调用时传递的 nil，怀疑是某种上下文，就像是 js 的 funcall，apply 之类</span><br></code></pre></div></td></tr></table></figure><p>而关于代码块如何传递的问题，Ruby 对其的处理类似…找不到类似，总之很丑陋——给相应参数前加上&amp;符号，再次传递时也是。</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">twice</span>(<span class="hljs-params">&amp;block</span>)<br>    block.call<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-params">&amp;block</span>)<br>    twice(&amp;block)<br><span class="hljs-keyword">end</span><br><br>proxy &#123;puts <span class="hljs-string">&quot;wtf&quot;</span>&#125;<br></code></pre></div></td></tr></table></figure><p>有趣的是，根据错误提示，代码块好像不属于函数参数的一部分，只能说十分奇怪了。</p><hr><p>把 Ruby 后面的内容粗略翻了一遍……老实说没有什么我感兴趣的东西，而且在 kotlin 和 scala 里我已见过更漂亮的语法了，跳过！模版元编程什么的等 Haskell 再去学吧。下一个是 Io，一门简单的原型编程语言。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Ruby</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 语言学习笔记 1——Hello, World 和基本集合类型</title>
    <link href="/2021/11-11go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94hello,%20world%EF%BC%9B%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.html"/>
    <url>/2021/11-11go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94hello,%20world%EF%BC%9B%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.html</url>
    
    <content type="html"><![CDATA[<blockquote><p> 不会有 2 了，没有学 go 的动机了。</p><p>—— 2021.12.27</p></blockquote><hr><blockquote><p>师爷，屁股在树上呢！</p></blockquote><p>定下决心——我当前有三门语言需要学习：GO，Haskell，英语（嘿嘿）。Haskell 是为了学懂弄通函数式编程，英语是为了能看懂英文文献以及其他，而 GO…见下。</p><hr><p>来学点 go。最初看的书籍是《GO 语言圣经》，实在难以看下去——行文和我期待的差太远，缺少和其他语言的比较之类的。现在试图看《GO 语言实战》，当前感觉还好。</p><h1 id="为什么是-GO？"><a href="#为什么是-GO？" class="headerlink" title="为什么是 GO？"></a>为什么是 GO？</h1><p>为什么是 GO 语言？首要目的当然是增强自身的……竞争力了。当今互联网方向，除了 Java，也就只有 GO 语言有市场了。而 GO 语言方面的竞争强度……当然远远比 Java 小了。这是最大的目的。</p><p>再从 GO 语言本身来看，它的<strong>并发</strong>支持，基于组合的更优雅，更具有复用性的面向对象，简洁优雅的语法（老实说，我讨厌它）使对它的学习有一定意义——了解一种新的并发模式；了解一种新的形式的面向对象范式，或者说新的代码组织，代码复用的方式。</p><p>这些是 GO 所值得学习的地方。而这语言也有我不喜欢的地方——对函数式编程支持很差。函数是一等公民？确实，但仅此而已。没有 map，filter，reduce，没有泛型（至少目前没有。没有泛型也意味着前面说的函数都无法轻易被用户实现），没有方便的 lambda 表达式（但是有函数类型这一点已经走在 Java 前面）。这让它的吸引力实在大打折扣。但是出于上面的原因，它仍旧值得学习。</p><p>当然，像并发或是面向对象之类的东西，至少得在熟悉 GO 语言的基础的前提下再进行。变量，函数啥的概念我们早就驾轻就熟，我们直接从更实践的地方——GO 的集合类型以及控制流开始。而在此之前，这里先来一个 Hello World 以及一个 fib 的实现，以一窥那些最基本的东西。</p><h1 id="Hello-World-It’s-a-neo-future-or-no-future"><a href="#Hello-World-It’s-a-neo-future-or-no-future" class="headerlink" title="Hello, World.  It’s a neo-future or no future?"></a>Hello, World.  It’s a neo-future or no future?</h1><p><img src="/images/oss/20211120012148.png"></p><p>下面是一个典型的 go 的 hello world 实现。main 包下的 main 函数是程序的真正入口。而 init 函数在包初始化的时候执行。所有依赖包的 init 函数将先执行，然后才是 main。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// hello world!</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> ( <span class="hljs-comment">// 导入依赖包</span><br>    <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">// i.e. format</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;program initializing...&quot;</span>) <span class="hljs-comment">// 依赖包中的函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, World. It&#x27;s a neo-future or no future?&quot;</span>) <span class="hljs-comment">// world 并不 happy，所以这里也不 happy</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是一个 fib 函数的实现。需要注意的是，go 语言没有尾递归优化，所以定义尾递归形式的 fib 是不经济的。且函数变量无法递归调用，令人感叹。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 函数大写意味着其将被包导出，就像 public</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    a := <span class="hljs-number">0</span><br>    b := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        a, b = b, a + b <span class="hljs-comment">// 右边的表达式先求值，之后再按顺序赋给左边的变量</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面的 Counter 例子演示了 go 的匿名函数和闭包。函数定义的语法为<code>func 函数名（参数列表） 返回值 &#123;</code>… 在这里，返回值是另一个函数，这个函数的类型是<code>func() int</code>，意味着它接受 0 个参数，返回一个 int 值。用户也可以定义变量为这种匿名函数。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Counter</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>        count++<br>        <span class="hljs-keyword">return</span> count<br>    &#125;<br><br>    <span class="hljs-comment">// 等价于——</span><br>    fn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>        count++<br>        <span class="hljs-keyword">return</span> count<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里同时也展示了另一种定义变量的方式——前面使用<code>:=</code>定义变量同时赋值。这时变量的类型将自动判断。这里显式地指定了变量 count 的类型 int，其将默认被赋予该变量的零值（zero value）——对数值，是<code>0</code>，对字符串，是<code>&quot;&quot;</code>，对布尔是<code>false</code>，其他类型（一般来说是引用类型）则为<code>nil</code>，即其他语言的 null。也有<code>var count = 0</code>这种形式。或许写 JS 的人喜欢这样。</p><blockquote><p>nil is a predeclared identifier representing the zero value for a pointer, channel, func, interface, map, or slice type.</p></blockquote><p>go 的函数可以返回多个值。这时候必须使用对应数量的变量来接受函数的返回值。一种常见设计是把结果值和可能的错误返回。当错误值不为 nil 时说明发生错误。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">someOpt</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">100</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>, fmt.Errorf(<span class="hljs-string">&quot;值 n 不能大于 100！当前值：%d&quot;</span>, n) <span class="hljs-comment">// Errorf 函数通过格式化的字符串构造一个 error</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> n + <span class="hljs-number">10</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span></span> &#123;<br>    res, err := someOpt(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(res)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我在网络上看到对该种形式的错误处理的批判——其认为不应该使用积类型来表示结果和可能的错误（即将结果和错误包裹在同一个对象中来返回，积类型指将两个类型（的值的集合）做笛卡尔积所得到的新的类型），而是使用和类型，即类似 Haskell 中的 Either 类型来进行处理。毕竟，结果和错误其中必有一个值为空或无意义。</p><h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>go 语言提供了如下集合类型——数组，slice，map，其中，数组设计和其他语言的不同，需要特别注意；slice 代表可变长数组；map 即哈希表。这些基本集合类型虽不算多，但已能够满足所有需求。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在 go 的世界里，数组代表着<strong>定长</strong>数组，<strong>且其长度必须是编译期可知的</strong>，就像 C 语言所做的那样，但是它比 C 语言更严格——<strong>定长数组的长度是包含在类型签名中的</strong>，它无法通过类型转换改变长度，无法转换为不定长数组。这意味着它的表现类似于（数学上的而非 python 上的）<strong>元组</strong>，但是其只能有同样的类型。数组的类型为<code>[length]type</code>，比如<code>[3]int</code>，意为长度为 3 的数组。</p><p>构造数组则采用<code>[length]type&#123;elems&#125;</code>的语法，如果元素的数量少于长度，剩余的以 0 值补全，比如<code>[3]int&#123;1,2&#125;</code>将得到<code>&#123;1,2,0&#125;</code>。同时可以使用<code>...</code>来替代长度，使长度和元素数量一致，如<code>[...]int&#123;1,2,3,4&#125;</code>得到长度为 4 的数组。</p><p>上面说到数组的行为类似于元组，这也表现为其如果作为函数参数，则函数参数和值必须为同样长度，同样类型的数组。如下面的代码是不合法的——</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 试图接受一个长度为 2 的定长数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">algo0</span><span class="hljs-params">(arr [2]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 试图接受一个长度不定的数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">algo1</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>    algo0(arr) <span class="hljs-comment">//不合法！错误信息是：Cannot use &#x27;arr&#x27; (type [3]int) as the type [2]int</span><br>    algo1(arr) <span class="hljs-comment">// 仍然不合法，即使这看上去很合理。错误信息是：Cannot use &#x27;arr&#x27; (type [3]int) as the type []int</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的 algo1 调用居然不合法，这显然是有些违背直觉的。这是因为，不定长数组的类型是 slice 而非数组。可见，将定长数组当作同类型的元组看待是合情合理的。</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>上面的例子证明定长数组的使用范围是比较窄的。看来更多的我们得使用不定长数组。而不定长数组在 go 里被称为<strong>切片</strong>（slice）。很有趣的名字，但从行为上来说这个名字很合适——每个切片代表内存（一个巨大数组）的一部分，每个切片可以对边界进行扩充，多个切片可以重叠……</p><p>切片的类型签名同数组基本相同，唯一不同在于其长度处为空，比如<code>[]int</code>代表保存 int 值的切片。<code>[]int&#123;1,2,3&#125;</code>为一个包含三个值的切片。</p><p>切片也可以通过类似 python 中的<code>[start:end]</code>语法构建（python 的该语法中 start 和 end 必须为常量，go 语言中的可以为变量），其前闭后开以简化使用。下面的代码实现了 tail 函数——获取数组除头部外的其他元素。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tail</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;you bad bad&quot;</span>))<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 等价于 arr[1:len(arr)]</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>但这种语法是需要极为注意的——该操作并非是另开辟一个内存空间并将结果切片的值复制到该内存空间中，而是直接重用原切片的内存位置！这虽然极大地提高性能，但是也意味着对新切片的操作会改变原切片！下面的代码将证明这一点——</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; <span class="hljs-comment">// 切片和数组均可</span><br>tailArr := tail(arr)<br>tailArr[<span class="hljs-number">0</span>] = <span class="hljs-number">1000</span><br>fmt.Println(arr) <span class="hljs-comment">// [1 1000 3]</span><br></code></pre></div></td></tr></table></figure><p>可见，对 tailArr 进行操作改变了 arr 的值。这种自由度是有些恐怖的，一定需要某种最佳实践来约束对<code>[:]</code>的使用。</p><p>slice 的可变性体现在哪里？当然是对它长度的变化了！go 语言并未提供像 Java 那样的 add，remove 等方法（它也做不到），而是提供了 append 和<code>[:]</code>，两者都并非是对一个 slice 的值进行改变（即基于副作用），而是返回一个新的 slice。</p><p>比如当我们需要向数组尾部插入元素，就使用形如<code>arr = append(arr, 100)</code>的方式，当我们需要从头部删除元素，就使用<code>arr = arr[1:]</code>。使用这种形式的好处在于，其能够改变 arr 指向的内存地址（这是基于副作用的方法办不到的），从而提供更加丰富的功能。</p><p>append 操作也是需要注意的——如果这个切片为某个切片&#x2F;数组的子切片的话，append 行为也可能会导致原切片&#x2F;数组被更改！考虑下面的代码——</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>subArr := arr[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br>arrr := <span class="hljs-built_in">append</span>(subArr, <span class="hljs-number">10</span>)<br>fmt.Println(subArr) <span class="hljs-comment">// [1 10]</span><br>fmt.Println(arr) <span class="hljs-comment">// [1 10 3]</span><br></code></pre></div></td></tr></table></figure><p>可见，append 操作把原切片的值覆盖掉了。老实说这行为太 evil 了。</p><p>再考虑下面的代码，猜猜输出结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>subArr := arr[<span class="hljs-number">1</span>:]<br>subArr = <span class="hljs-built_in">append</span>(subArr, <span class="hljs-number">1000</span>)<br>subArr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br>fmt.Println(arr)<br></code></pre></div></td></tr></table></figure><p>结果有点出人意料，但又是合情合理的，不是吗？当 subArr 的尾部已到达 arr 的尾部，append 操作就无法再试图在 arr 内部找到生存空间了。它必须另寻他路，也就是再另外创建一个更大的数组，把原 arr 的所有值都 copy 进去并在尾部添上新值。</p><p>这就引入了切片的 cap 属性——切片的最大“容积”，当切片的长度（即 len 函数所获得的那个玩意）和 cap 相等的时候，再想要 append 就必须要找新的市场了（市场，哈哈哈），即开辟一片更大的新的内存空间将所有值都复制一份过去。显然，从一个数组&#x2F;切片中切出来的切片，其 cap 小于等于其原数组的 cap。</p><p>我真的十分好奇 slice 这种构造该如何正确避免内存泄漏，如何正确使用，它看上去和指针一样危险。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>go 语言只提供了 Map，没有提供 Set，但是 Set 借助 Map 和 go 的零值初始化机制是容易实现的（事实上 Java 中的 HashSet 也是通过 HashMap 实现的）。</p><p>map 的类型签名形如<code>map[key 类型]value 类型</code>，如<code>map[int]string</code>为键为 int 型，值为 string 型的 map。</p><p>map 的初始化有两种方式——第一种是使用内置的 make 函数，第二种是使用字面量进行初始化。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">aMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>) <span class="hljs-comment">// 严重抗议——凭什么标准库有范型，默认却不提供范型？</span><br><br>anotherMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-number">13</span> : <span class="hljs-string">&quot;devil&quot;</span>, <span class="hljs-comment">// 通过字面量初始化</span><br>    <span class="hljs-number">42</span> : <span class="hljs-string">&quot;answer&quot;</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于 get，put 方法，go 语言完全使用<code>[]</code>操作符来进行。作为左值时即为 put，作为右值时即为 get。如果试图 get 一个不存在的 key，则其将返回 value 类型的零值。同时也可以给定第二个返回值来知道是否取到值。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">aMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>aMap[<span class="hljs-number">13</span>] = <span class="hljs-string">&quot;devil&quot;</span> <span class="hljs-comment">// put</span><br>someStr := aMap[<span class="hljs-number">13</span>] <span class="hljs-comment">// get</span><br>aMap[<span class="hljs-number">42</span>] == <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// true</span><br>_, ok := aMap[<span class="hljs-number">42</span>]<br><span class="hljs-keyword">if</span> !ok &#123;<br>    fmt.Println(<span class="hljs-string">&quot;not found&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>至于 set 的实现，使用<code>map[...]bool</code>即可。当我们试图将元素加入 set 中，put 一个 true 值进去即可。而当我们试图检查元素是否在 set 中，直接使用 get 即可——如果不存在，根据零值初始化规则，其将返回 false；如果存在，则返回 true。</p><p>下一节我将学习 go 语言中的控制流和函数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>GO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Monad 的&gt;&gt;=实现&lt;$&gt;和&lt;*&gt;</title>
    <link href="/2021/10-28%E4%BD%BF%E7%94%A8Monad%E5%AE%9A%E4%B9%89Functor%E5%92%8CApplicative%E7%9A%84%E8%BF%90%E7%AE%97.html"/>
    <url>/2021/10-28%E4%BD%BF%E7%94%A8Monad%E5%AE%9A%E4%B9%89Functor%E5%92%8CApplicative%E7%9A%84%E8%BF%90%E7%AE%97.html</url>
    
    <content type="html"><![CDATA[<p>惊为天人，惊为天人啊，没想到仅使用 Monad 的<code>&gt;&gt;=</code>和<code>return</code>便可以实现<code>&lt;$&gt;</code>和<code>&lt;*&gt;</code>！下面描述一下我的心路历程。</p><span id="more"></span><p>在一切发生之前，先来梳理一下我们手头的工具。我们只能使用 Monad 中直接定义的方法，即——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b<br><span class="hljs-title">return</span> :: a -&gt; m a<br></code></pre></div></td></tr></table></figure><p>就这些！开始表演魔法吧。</p><h1 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;$&gt;"></a>&lt;$&gt;</h1><p>首先是<code>&lt;$&gt;</code>即<code>fmap</code>，先看其签名——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fmap</span> :: (a -&gt; b) -&gt; m a -&gt; m b<br></code></pre></div></td></tr></table></figure><p>在这里，函数<code>a -&gt; b</code>和变量<code>m a</code>就是我们的已知量，我们要用这两个素材得到<code>m b</code>。容易意识到，我们只需要对函数<code>a -&gt; b</code>进行变换，根据这个函数构造一个函数<code>a -&gt; m b</code>即可，这样得到的函数签名刚好就是<code>flip (&gt;&gt;=)</code>。</p><p>而如何进行这种构造？整个 lambda，在 lambda 上下文中调用函数<code>a -&gt; b</code>并返回一个<code>m b</code>即可！</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">magic</span> :: <span class="hljs-type">Monad</span> m =&gt; (a -&gt; b) -&gt; (a -&gt; m b)<br><span class="hljs-title">magic</span> fn = \a -&gt; return $ fn a<br></code></pre></div></td></tr></table></figure><p>这个形式可以化简，但为了明确，这里不化简。</p><p>有了这个 magic，我们就能够构造 fmapM 了！</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fmapM</span> :: <span class="hljs-type">Monad</span> m =&gt; (a -&gt; b) -&gt; m a -&gt; m b<br><span class="hljs-title">fmapM</span> fn ma = (&gt;&gt;=) ma $ magic fn<br></code></pre></div></td></tr></table></figure><h1 id="lt-gt-1"><a href="#lt-gt-1" class="headerlink" title="&lt;*&gt;"></a>&lt;*&gt;</h1><p><code>&lt;*&gt;</code>的签名如下——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">(&lt;*&gt;) :: <span class="hljs-type">Monad</span> m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b<br></code></pre></div></td></tr></table></figure><p> 这里，最关键的问题是，该如何把这个<code>a -&gt; b</code>从 Monad 的上下文里拿出来（否则无法进行使用！）。</p><p>显然，<code>a -&gt; b</code>（以及任何其它变量）是不能直接赤果果直接放到“全局作用域”的——它们在上下文中，只能通过模式匹配或 getter 拿出来，甚至对于 IO，这些手段也是无效的。</p><p>但是它又确实是能拿出来的……之前一切的学习都没有否定这一点…这就意味着，把它拿出来必须要有一定条件，也就是说，要在一定上下文中！显然，离开具体的数据类型，我们能构造的唯一的上下文就是 lambda 了！</p><p>于是我们又开始重新查看手头的工具，好像<code>(&gt;&gt;=)</code>给我们提供了这样一个上下文！再次查看<code>(&gt;&gt;=)</code>的签名——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">(&gt;&gt;=) :: <span class="hljs-type">Monad</span> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b<br></code></pre></div></td></tr></table></figure><p>我们看到了什么？<code>m a</code>中的值<code>a</code>在<code>(a -&gt; m b)</code>函数中被进行应用了！</p><p><code>(&gt;&gt;=)</code>能提供我们这样的上下文！把值取出来，进行特定操作，再放回上下文中！</p><p>比如，我们有一个<code>Just 1</code>，我们想给它加 1，于是我们可以这样用——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">res</span> = (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>) &gt;&gt;= (\a -&gt; return $ a + <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>然后我们查看 fmap 的签名，好像 fmap 也能干这事！</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">res</span> = (\a -&gt; a + <span class="hljs-number">1</span>) &lt;$&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>于是破案了，纠结这么久，真实原因是我太傻，对 lambda 的意义了解不够深刻，遇上复杂问题就抓瞎了！</p><p>带着我们的新思路，再次查看我们所要实现的东西——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">&lt;*&gt; :: <span class="hljs-type">Monad</span> m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b<br></code></pre></div></td></tr></table></figure><p>显然，通过上面的工具，我们能在 lambda 里把<code>m (a -&gt; b)</code>中的<code>a -&gt; b</code>解出来，比如这样——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">allApp</span> :: <span class="hljs-type">Monad</span> m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b<br><span class="hljs-title">allApp</span> mf ma = mf &gt;&gt;= (\f -&gt; _)<br></code></pre></div></td></tr></table></figure><p>这里的 f 就是<code>a -&gt; b</code>！在这个 lambda 的上下文里，我们有<code>a -&gt; b</code>，有<code>m a</code>，显然这里该用<code>fmap</code>了！</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">allApp</span> mf ma = mf &gt;&gt;= (\f -&gt; fmap f ma)<br></code></pre></div></td></tr></table></figure><p>BINGO！</p><p>但是稍微再瞅瞅呢？我们把 fmap 重新展开成使用<code>&gt;&gt;=</code>和<code>return</code>构造的形式（以及删掉一些括号）——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">allApp</span> :: <span class="hljs-type">Monad</span> m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b<br><span class="hljs-title">allApp</span> mf ma = mf &gt;&gt;= \f<br>                    -&gt; ma &gt;&gt;= \a<br>                        -&gt; return $ f a<br></code></pre></div></td></tr></table></figure><p>这为什么合法？加点括号——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">allApp</span> :: <span class="hljs-type">Monad</span> m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b<br><span class="hljs-title">allApp</span> mf ma = mf &gt;&gt;= (\f<br>                    -&gt; (ma &gt;&gt;= \a<br>                        -&gt; (return $ f a)))<br></code></pre></div></td></tr></table></figure><p><code>(ma &gt;&gt;= \a -&gt; (return $ f a))</code>先执行，返回一个<code>m b</code>，结果直接作为<code>(\f -&gt; _)</code>的返回值。真正的计算已经结束（如果有<code>Nothing</code>之类的，那就根本没有计算），得到的值会一直往外传递，最终作为<code>allMap</code>函数的返回值。</p><p>显然，这里存在着某种模式——我们可以<del>同时</del>将多个 Monad 中的值取出来并进行操作，最后再封装成新的 Monad。</p><p>使用这个思想，我们重新实现一下 fmap——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fmapM&#x27;</span> :: <span class="hljs-type">Monad</span> m =&gt; (a -&gt; b) -&gt; m a -&gt; m b<br><span class="hljs-title">fmapM&#x27;</span> fn ma = ma &gt;&gt;= \a <br>                    -&gt; return $ fn a<br></code></pre></div></td></tr></table></figure><p>清晰！</p><h1 id="一些更酷的东西"><a href="#一些更酷的东西" class="headerlink" title="一些更酷的东西"></a>一些更酷的东西</h1><p>更酷（或许没有再酷了！）的是，do 语法糖是可以翻译成<code>&gt;&gt;</code>和<code>&gt;&gt;=</code>的！见下面的代码——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>  putStrLn <span class="hljs-string">&quot;input value 1&quot;</span><br>  val1 &lt;- readInt<br>  putStrLn <span class="hljs-string">&quot;input value 2&quot;</span><br>  val2 &lt;- readInt<br>  <span class="hljs-keyword">let</span> res = val1 + val2<br>  <span class="hljs-keyword">let</span> doubleRes = res * <span class="hljs-number">2</span><br>  print $ mconcat [<span class="hljs-string">&quot;2 * (&quot;</span>, show val1,<span class="hljs-string">&quot; + &quot;</span>,show val2, <span class="hljs-string">&quot;) = &quot;</span>, show doubleRes]<br><br><span class="hljs-comment">-- 特意组织成这样的结构，使其映射更为清晰</span><br><span class="hljs-title">main&#x27;</span> =<br>  putStrLn <span class="hljs-string">&quot;input value 1&quot;</span> &gt;&gt; <br>  readInt &gt;&gt;= \val1 -&gt;<br>  putStrLn <span class="hljs-string">&quot;input value 2&quot;</span> &gt;&gt; <br>  readInt &gt;&gt;= \val2 -&gt;<br>  <span class="hljs-keyword">let</span> res = val1 + val2 <span class="hljs-keyword">in</span> <br>  <span class="hljs-keyword">let</span> doubleRes = <span class="hljs-number">2</span> * res <span class="hljs-keyword">in</span> <br>  print $ mconcat [<span class="hljs-string">&quot;2 * (&quot;</span>, show val1,<span class="hljs-string">&quot; + &quot;</span>,show val2, <span class="hljs-string">&quot;) = &quot;</span>, show doubleRes]<br></code></pre></div></td></tr></table></figure><p>当我们要副作用的时候，我们使用<code>&gt;&gt;</code>，当我们要从一个 Monad 里取出值的时候，我们使用<code>&gt;&gt;=</code>，do 就是这样！</p><p>另一个很酷的地方是，列表推导式也是可以通过 do 进行描述的！比如下面的两个使用是等价的——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">someList</span> = <span class="hljs-keyword">do</span><br>  val1 &lt;- [<span class="hljs-number">1</span> .. <span class="hljs-number">10</span>]<br>  val2 &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]<br>  <span class="hljs-keyword">if</span> val1 * val2 &lt; <span class="hljs-number">50</span> <br>    <span class="hljs-keyword">then</span> [val1 * val2]<br>    <span class="hljs-keyword">else</span> [] <br><br><span class="hljs-title">someList&#x27;</span> = [val1 * val2 | val1 &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], val2 &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], val1 * val2 &lt; <span class="hljs-number">50</span>]<br></code></pre></div></td></tr></table></figure><p>令人感叹，令人感叹啊。再次感叹 Haskell 设计的精巧。顺便，据群里大佬所说，使用 Monad 实现<code>&lt;*&gt;</code>是”SKI 那个 S”，只能说虽不明但觉厉。该沉下心来继续学习了！</p><h1 id="关于-gt-gt"><a href="#关于-gt-gt" class="headerlink" title="关于&gt;&gt;"></a>关于&gt;&gt;</h1><blockquote><p><code>&gt;&gt;</code>的行为其实没必要说那么多，它的定义就足够了——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">(&gt;&gt;) :: <span class="hljs-type">Monad</span> m =&gt; m a -&gt; m b -&gt; m b<br><span class="hljs-title">m</span> &gt;&gt; k = m &gt;&gt;= (\_ -&gt; k)<br><span class="hljs-comment">-- 翻译成 do，就是——</span><br><span class="hljs-title">do</span> <br>  ma<br>  mb<br><span class="hljs-comment">-- 或者可以这样理解——</span><br><span class="hljs-title">do</span><br>  _ &lt;- ma<br>  mb <br></code></pre></div></td></tr></table></figure><p>因此，当 m 本身为 <code>[]</code> 或 <code>Nothing</code>等的时候，这计算本身就不会再进行下去了。要理解<code>&gt;&gt;</code>，直接从定义出发就好。于是归根结底，还是要回到<code>&gt;&gt;=</code>，还是要回到 bind，还是要回到flatMap。</p><p>同时，从这个方面来看，下面的guard函数就十分容易理解了，考虑护卫语句的定义，它可能返回一个<code>m ()</code>，也可能返回一个<code>mzero</code>。在列表的上下文里，即<code>[()]</code>或<code>[]</code>。当为前者的时候，它有一个值，因此计算成功继续；为后者的时候，没有值就无法进行了。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">do</span><br>  i &lt;- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>  guard $ i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <br>  i<br></code></pre></div></td></tr></table></figure><p>在这里，<code>guard $ i % 2 == 0</code> 要么返回<code>[()]</code>，要么返回<code>[]</code>，因此整个代码可以理解为</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">do</span><br>  i &lt;- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>  _ &lt;- <span class="hljs-keyword">if</span> i `mod` <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> [()] <span class="hljs-keyword">else</span> [] <span class="hljs-comment">-- 当然，_在这里是不合法的！</span><br>  return i<br></code></pre></div></td></tr></table></figure><p>结果是显然的。</p><p>—— 2022.04.04</p></blockquote><p>我曾以为<code>&gt;&gt;</code>是干脆地丢弃前者的结果，返回后者，但事实证明这是错误的——前者的值对后者将会有影响——下面两个例子可见一般——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-type">Nothing</span> &gt;&gt; <span class="hljs-type">Just</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- Nothing</span><br><span class="hljs-type">Just</span> <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-type">Just</span> <span class="hljs-number">2</span> <span class="hljs-comment">-- Just 2</span><br>[] &gt;&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <span class="hljs-comment">-- []</span><br>[<span class="hljs-number">1</span>] &gt;&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <span class="hljs-comment">-- [1,2,3]</span><br></code></pre></div></td></tr></table></figure><p>显然，当前者为 mempty（实际上是 mzero）的时候，值为后者，否则为 mempty。</p><p>因此，我们可以试图定义自己的 guard——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">guard&#x27;</span> :: <span class="hljs-type">MonadPlus</span> m =&gt; <span class="hljs-type">Bool</span> -&gt; m ()<br><span class="hljs-title">guard&#x27;</span> <span class="hljs-type">True</span> = return ()<br><span class="hljs-title">guard&#x27;</span> <span class="hljs-type">False</span> = mzero<br><br><span class="hljs-title">abc</span> ::  [<span class="hljs-type">Integer</span>]<br><span class="hljs-title">abc</span> = <span class="hljs-keyword">do</span><br>    i &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">100</span>]<br>    guard&#x27; $ i `mod` <span class="hljs-number">5</span> == <span class="hljs-number">0</span><br>    return i<br></code></pre></div></td></tr></table></figure><p>至于这里的 MonadPlus 究竟是个什么东西……我们之后再说吧。</p><h1 id="Monad-In-Java（大雾"><a href="#Monad-In-Java（大雾" class="headerlink" title="Monad In Java（大雾"></a>Monad In Java（大雾</h1><p>Java 8 紧跟时髦，添加了 Optional（即 Maybe）和 Stream（类似列表）这两种 Monad，其中 bind 操作被命名为 flatmap，其的使用类似 do 对应的原始代码。下面的代码展示了 Optional Monad 的使用。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 关于 Optional 的使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">Unit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Optional&lt;V&gt; <span class="hljs-title function_">getMaybe</span><span class="hljs-params">(Map&lt;K, V&gt; map, K k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(k))<br>            <span class="hljs-keyword">return</span> Optional.of(map.get(k));<br>        <span class="hljs-keyword">return</span> Optional.empty();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Integer&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>);<br>            put(<span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">2</span>);<br>        &#125;&#125;;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        “等价”于——</span><br><span class="hljs-comment">        do</span><br><span class="hljs-comment">          println &quot;hello! Optional Monad!&quot; -- 这显然不是合法的 Haskell 代码</span><br><span class="hljs-comment">          a &lt;- getMaybe &quot;hello&quot;</span><br><span class="hljs-comment">          println a</span><br><span class="hljs-comment">          b &lt;- getMaybe &quot;world&quot;</span><br><span class="hljs-comment">          println b</span><br><span class="hljs-comment">          return a + b</span><br><span class="hljs-comment">        */</span><br>        Optional&lt;Integer&gt; res =<br>            Optional.of(Unit).flatMap(__ -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;hello! Optional Monad!&quot;</span>);<br>            <span class="hljs-keyword">return</span> getMaybe(map, <span class="hljs-string">&quot;hello&quot;</span>).flatMap(a -&gt; &#123;<br>            System.out.println(a);<br>            <span class="hljs-keyword">return</span> getMaybe(map, <span class="hljs-string">&quot;world&quot;</span>).flatMap(b -&gt; &#123;<br>            System.out.println(b);<br>            <span class="hljs-keyword">return</span> Optional.of(a + b);&#125;);&#125;);&#125;); -- 这一堆分号有点恐怖！如果是在 kotlin 里，这代码会干净漂亮很多，只有花括号了<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而下面的代码展示了 Stream Monad 和列表推导式的等价。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">假设我们要求 [z * z | x &lt;- [1 .. 100], y &lt;- [1 .. 50],</span><br><span class="hljs-comment">    let z = x + y, ord x, even y]</span><br><span class="hljs-comment">为方便理解，先转换成 do 形式</span><br><span class="hljs-comment">do</span><br><span class="hljs-comment">    x &lt;- [1 .. 100]</span><br><span class="hljs-comment">    y &lt;- [1 .. 50]</span><br><span class="hljs-comment">    let z = x + y</span><br><span class="hljs-comment">    guard $ ord x &amp;&amp; even y</span><br><span class="hljs-comment">    return $ z * z</span><br><span class="hljs-comment">再转换成原始形式</span><br><span class="hljs-comment">*/</span><br>IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>).flatMap(x -&gt;<br>IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">51</span>).flatMap(y -&gt; &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> x + y;<br><span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; y % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> IntStream.of(z * z);<br><span class="hljs-keyword">return</span> IntStream.empty();<br>&#125;));<br></code></pre></div></td></tr></table></figure><p>路长的很，不能膨胀。</p><p><img src="/images/oss/20210814203458.jpg"></p><p><img src="/images/oss/20210822231117.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【翻译】Working with type in a context</title>
    <link href="/2021/10-25%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Working-with-type-in-a-context.html"/>
    <url>/2021/10-25%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Working-with-type-in-a-context.html</url>
    
    <content type="html"><![CDATA[<p><img src="/images/oss/20220104220223.png"></p><p>发现《Get Programming with Haskell》这本书中对 Functor，Applicative，Monad 的概念的引入非常直观有趣，在这里进行一波翻译。我是 Haskell 初学者，且英语水平也不高，所以难免拉垮，望读者海涵并给予意见。文章最后粘贴了英文原文的图片。</p><p>在文章中，我将 type 翻译作类型，type class 翻译作类型类，但作者有时会把 Maybe，IO 等称作类型，令人<del>感叹</del>迷惑，总之忠于原文。我一些我拿不准的地方则把英文原文也贴上了。</p><span id="more"></span><hr><p>在这个单元里，你将关注 Haskell 的三个最具威力，但同时也最迷惑人的类型类：<code>Functor</code>，<code>Applicative</code>和<code>Monad</code>。这些类型类名字有趣，但其目的却相对的明确。它们中的每一个都建立在前一个之上，并提供你在诸如<code>IO</code>等上下文中进行操作的能力。在单元 4 里，你大量使用了<code>Monad</code>类型类以操作<code>IO</code>。在这个单元里，你将更深刻地理解其工作原理。为更好地感受这些抽象的类型类的行为，（在这里）你将把类型当作形状来看待。</p><p>理解函数的一种方式是认为其将一种类型转换成另一种类型。让我们把两个类型可视化为两个形状，一个圆和一个正方形，就如图 1 所示。</p><p><img src="/images/oss/20211025202006.png"></p><p>这些形状可以代表任意两个类型，比如<code>Int</code>和<code>Double</code>，<code>String</code>和<code>Text</code>，<code>Name</code>和<code>FirstName</code>以及其他。当你试图将一个圆转换成一个正方形的时候，你就在使用函数。你可以把函数可视化为两个形状间的一种连接（connector），如图 2 所示。</p><blockquote><p>  译者：显然，这两个形状也可以代表同一个类型。</p></blockquote><p><img src="/images/oss/20211025202336.png"></p><p>这个连接可以代表任何从一个类型到另一个类型的函数。它可以代表<code>(Int -&gt; Double)</code>，<code>(String -&gt; Text)</code>，<code>(Name -&gt; FirstName)</code>，诸如此类。当你试图应用一个转换时，你可以可视化地将连接器置于初始值（在当前的情形下，是一个圆形）以及期望值（一个正方形）之间；见图 3。</p><p><img src="/images/oss/20211025202753.png"></p><p>当每个形状都正确匹配，你就能完成你所期望的转换。</p><p>在这个单元，你将关注如何操作处于上下文（context）中的类型。你已经见过的两个关于上下文中的类型的最好的例子是<code>Maybe</code>类型和<code>IO</code>类型。<code>Maybe</code>类型代表这样一种上下文，即其中的值可能不存在；<code>IO</code>类型代表着这样一种上下文，即其中的值将同 I&#x2F;O 交互（the value has interacted with I&#x2F;O）。放到我们的可视化语言中，你可以想象上下文中的类型将像图 4 这样表述。</p><p><img src="/images/oss/20211025203400.png"></p><p>这些形状可以代表诸如<code>IO Int</code>，<code>IO Double</code>，<code>Maybe String</code>，<code>Maybe Text</code>，<code>Maybe Name</code>，<code>Maybe FirstName</code>等的类型。因为这些类型是处于一定的上下文中的，你不能用你的原有的连接去进行转换。当前，在本书中你曾依赖过那些输入和输出都处在同样的上下文中的函数。而为对上下文中的类型进行转换，你需要一个类似图 5 的连接。</p><p><img src="/images/oss/20211025203947.png"></p><p>这个连接代表那些类型签名形如<code>(Maybe Int -&gt; Maybe Double)</code>，<code>(IO String -&gt; IO Text)</code>和<code>(IO Name -&gt; IO FirstName)</code>的函数。通过该连接，你很容易对上下文中的类型进行转换，就如图 6 所示。</p><p><img src="/images/oss/20211025204346.png"></p><p>这看上去像是一个完美的解决方案，但是这里有个问题。让我们看下面这个函数<code>halve</code>，它的类型是<code>Int -&gt; Double</code>，其行为就如我们所期望的，对半分（halve）输入参数<code>Int</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">halve</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Double</span><br><span class="hljs-title">halve</span> n = fromIntegral n / <span class="hljs-number">2.0</span><br></code></pre></div></td></tr></table></figure><p>这个函数很直白，但假设你想对半分一个<code>Maybe Int</code>呢？仅用手头的工具，你必须对这个函数编写一个包装器（wrapper）以使它能够对<code>Maybe</code>类型起作用。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">halveMaybe</span> :: <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Double</span><br><span class="hljs-title">halveMaybe</span> <span class="hljs-type">Nothing</span> = <span class="hljs-type">Nothing</span><br><span class="hljs-title">halveMaybe</span> (<span class="hljs-type">Just</span> n) = <span class="hljs-type">Just</span> (halve n)<br></code></pre></div></td></tr></table></figure><p>在这个例子里，写一个简单的包装器并非难事。但若是对一大片的现存的<code>a -&gt; b</code>函数，想要使用它们中的任意一个操作<code>Maybe</code>类型都需要编写几乎同样的包装器。更糟糕的是你无法编写对<code>IO</code>类型的包装器！</p><blockquote><p>  译者：为什么无法编写<code>IO</code>的包装器？你需要对<code>IO</code>类型的实例进行解构并获取它的值，再重新构造它，而解构这一步是无法做到的——这意味着 Haskell 将会提供诸如<code>IO Int -&gt; Int</code>这样签名的函数，这是不安全的——你不能保证函数是纯函数了！假设你又有一个函数<code>Int -&gt; IO Int</code>（这是容易做到的，通过<code>return</code>之类），你就可以将两个函数组合，使其具有<code>Int -&gt; Int</code>之类的函数签名，但是在内部做 dirty work。当然，Haskell 的确提供了这样的 unsafe 函数就是了。</p></blockquote><p>于是，我们的<code>Functor</code>，<code>Applicative</code>和<code>Monad</code>来到了！你可以认为这些类型类是适配器（adapter），它们允许你在底层（underlying）类型（圆和正方形）相同的情况下使用不同的连接（You can think of these type classes as adapters that allow you to work with different connectors so long as the underlying types (circle and square) are the same）。比如在<code>halve</code>中，你关心转换你的基本的<code>Int</code>到<code>Double</code>（的函数），使它能够适配以工作在上下文的类型中。这是<code>Functor</code>类型类的工作，如图 7。</p><p><img src="/images/oss/20211025212503.png"></p><blockquote><p>  译者：图中文字为：<code>Functor</code>类型类能够解决上下文中的类型和连接不匹配的问题。</p><p>  这也就是说<code>Functor</code>能够使类型<code>a -&gt; b</code>的函数将<code>(Functor f) =&gt; f a</code>类型转化为<code>(Functor f) =&gt; f b</code>。换句话说，<code>Functor</code>能够将<code>a -&gt; b</code>转化成<code>(Functor f) =&gt; f a -&gt; f b</code>。</p><p>  如果你曾了解过<code>Functor</code>的方法（是这么叫吗？）<code>fmap</code>，查看它的签名<code>fmap :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code>，就容易发现上面的“换句话说”两边的描述其实就是对<code>fmap</code>的不同诠释。</p></blockquote><p>（<code>Functor</code>能解决一种类型不匹配问题），但仍有其它三种类型不匹配问题。<code>Applicative</code>能解决其中两种。其中第一种情况是连接的第一部分在上下文中，而结果不在，如图 8。</p><p><img src="/images/oss/20211025213211.png"></p><p>另一种情形则是整个函数都在上下文中。比如函数<code>Maybe (Int -&gt; Double)</code>意味着这个函数本身可能不存在。这（函数被包裹在上下文中）听起来奇怪，但它很有可能发生在对<code>Maybe</code>和<code>IO</code>的偏调用中。图 9 描述了这一有趣的情形。</p><p><img src="/images/oss/20211025213436.png"></p><p>然后还有最后一种可能的函数和上下文中类型不匹配的情形。这种情况是参数不在上下文中，而结果在上下文中。这种情形比你想象中的更加普遍。如<code>Map.lookup</code>和<code>putStrLn</code>的类型签名都是这样。这个问题被<code>Monad</code>类型类解决，见图 10。</p><p><img src="/images/oss/20211025213739.png"></p><p>当你结合使用这三个类型类，只要底层类型匹配，你能把所有函数应用到诸如<code>Maybe</code>，<code>IO</code>等上下文。这可是件了不起的事——你可以在上下文中应用任何你想做的计算，并能够不同的上下文中重用大量的现存代码。</p><hr><p><img src="/images/oss/20211025214242.png"></p><p><img src="/images/oss/20211025214329.png"></p><p><img src="/images/oss/20211025214418.png"></p><p><img src="/images/oss/20211025214443.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左折叠和右折叠</title>
    <link href="/2021/10-15%E5%B7%A6%E6%8A%98%E5%8F%A0%E5%92%8C%E5%8F%B3%E6%8A%98%E5%8F%A0.html"/>
    <url>/2021/10-15%E5%B7%A6%E6%8A%98%E5%8F%A0%E5%92%8C%E5%8F%B3%E6%8A%98%E5%8F%A0.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>写了半天，信誓旦旦以为 haskell 的 fold 的表现和 lisp 里的是一致的，结果被打脸了……尴尬。但终究是学习到了。</p></blockquote><p>fold 操作分为<code>foldl</code>和<code>foldr</code>，就理论上来说，它们的区别用一句话概括的话就是，<code>foldl</code>是尾递归，而<code>foldr</code>是递归。其中以 SICP 的语境来说，<code>foldl</code>是<strong>迭代</strong>操作，其状态改变维护在函数参数中，<code>foldr</code>是<strong>递归</strong>操作，参数被放到了栈中。</p><p>下面是迭代和递归的求阶乘函数，其对求值过程进行了展开。可以明显看到它们的区别。</p><figure class="highlight scheme"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scheme"><span class="hljs-comment">;;; 递归版</span><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">factorial</span> n)<br>  (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">=</span></span> n <span class="hljs-number">1</span>) <br>      <span class="hljs-number">1</span> <br>      (<span class="hljs-name"><span class="hljs-built_in">*</span></span> n (<span class="hljs-name">factorial</span> (<span class="hljs-name"><span class="hljs-built_in">-</span></span> n <span class="hljs-number">1</span>)))))<br><br>(<span class="hljs-name">factorial</span> <span class="hljs-number">6</span>)<br>(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">6</span> (<span class="hljs-name">factorial</span> <span class="hljs-number">5</span>))<br>(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">6</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name">factorial</span> <span class="hljs-number">4</span>)))<br>(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">6</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">4</span> (<span class="hljs-name">factorial</span> <span class="hljs-number">3</span>))))<br>(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">6</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">4</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">3</span> (<span class="hljs-name">factorial</span> <span class="hljs-number">2</span>)))))<br>(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">6</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">4</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">3</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">2</span> (<span class="hljs-name">factorial</span> <span class="hljs-number">1</span>))))))<br>(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">6</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">4</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">3</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>)))))<br>(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">6</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">4</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>))))<br>(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">6</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">4</span> <span class="hljs-number">6</span>)))<br>(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">6</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> <span class="hljs-number">24</span>))<br>(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">6</span> <span class="hljs-number">120</span>)<br><span class="hljs-number">720</span><br><br><span class="hljs-comment">;;; 迭代版</span><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">factorial</span> n)<br>  (<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">helper</span> acc n)<br>    (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">=</span></span> n <span class="hljs-number">1</span>)<br>        acc<br>        (<span class="hljs-name">helper</span> (<span class="hljs-name"><span class="hljs-built_in">*</span></span> n acc) (<span class="hljs-name"><span class="hljs-built_in">-</span></span> n <span class="hljs-number">1</span>))))<br>  (<span class="hljs-name">helper</span> <span class="hljs-number">1</span> n))<br><br>(<span class="hljs-name">factorial</span> <span class="hljs-number">6</span>)<br>(<span class="hljs-name">helper</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span>)<br>(<span class="hljs-name">helper</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span>)<br>(<span class="hljs-name">helper</span> <span class="hljs-number">30</span> <span class="hljs-number">4</span>)<br>(<span class="hljs-name">helper</span> <span class="hljs-number">120</span> <span class="hljs-number">3</span>)<br>(<span class="hljs-name">helper</span> <span class="hljs-number">360</span> <span class="hljs-number">2</span>)<br>(<span class="hljs-name">helper</span> <span class="hljs-number">720</span> <span class="hljs-number">1</span>)<br><span class="hljs-number">720</span><br></code></pre></div></td></tr></table></figure><p>显然可以看到，递归版的阶乘函数先展开成<code>1 * 2 * ... * n</code>的形式才开始进行运算，而迭代版的看不到这种展开——它已经被运算完，作为新的参数进行下一次迭代了。</p><p>但是这是 lisp，haskell 由于其非严格求值的特性，表现和 lisp 不一样（<strong>甚至完全相反</strong>！）。</p><p><code>foldr</code>表面上看起来无必要——既然都有尾递归操作了，为什么还要用浪费空间（可能还有时间）的普通递归操作呢？一个原因是，由于其参数被放到栈中，这意味着<strong>计算是被延迟了的</strong>，当它与 haskell 的非严格求值相结合，便导致了一个威力无比的特性——<strong>它能够处理无穷长度的列表</strong>。比如对一个<code>[1..]</code>，我们可以看做是<code>1:2:3:4:...</code>，这种结构显然是类似于那种递归结构的，如果我们构造出的结果符合这种形式，就可以利用 haskell 的特性进行部分取值。</p><p>下面是一个自己的 foldr 的实现——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">myFoldr</span> f zero [] = zero<br><span class="hljs-title">myFoldr</span> f zero (x:xs) = f x $ myFoldr f zero xs<br></code></pre></div></td></tr></table></figure><p>当我们使用<code>:</code>进行调用时——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">myFoldr</span> (:) [] [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-number">1</span>:(myFoldr (:) [] [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br><span class="hljs-number">1</span>:(<span class="hljs-number">2</span>:(myFoldr (:) [] [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]))<br><span class="hljs-number">1</span>:(<span class="hljs-number">2</span>:(<span class="hljs-number">3</span>:(myFoldr (:) [] [<span class="hljs-number">4</span>])))<br><span class="hljs-number">1</span>:(<span class="hljs-number">2</span>:(<span class="hljs-number">3</span>:(<span class="hljs-number">4</span>:(myFoldr (:) [] []))))<br><span class="hljs-number">1</span>:(<span class="hljs-number">2</span>:(<span class="hljs-number">3</span>:(<span class="hljs-number">4</span>:[]))) <span class="hljs-comment">-- 这个括号形式很有意思</span><br><span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">3</span>:<span class="hljs-number">4</span>:[] <span class="hljs-comment">-- 考虑到：是右结合的，括号可以省略</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]  <span class="hljs-comment">-- 语法糖</span><br></code></pre></div></td></tr></table></figure><p>bingo！容易认识到，无限的列表也能进行这种操作，因为 haskell 只要拿到需要的数据就 OK。</p><p>下面是<code>foldl</code>的实现——</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">myFoldl f zero [] = zero<br>myFoldl f zero <span class="hljs-comment">(x:xs)</span> = myFoldl f <span class="hljs-comment">(f zero x)</span> xs<br><br>myFoldl <span class="hljs-comment">(-)</span> <span class="hljs-number">0</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>myFoldl <span class="hljs-comment">(-)</span> <span class="hljs-comment">(0 - 1)</span> [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>myFoldl <span class="hljs-comment">(-)</span> <span class="hljs-comment">((0 - 1)</span> - <span class="hljs-number">2</span>) [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>myFoldl <span class="hljs-comment">(-)</span> <span class="hljs-comment">(((0 - 1)</span> - <span class="hljs-number">2</span>) - <span class="hljs-number">3</span>) [<span class="hljs-number">4</span>]<br>myFoldl <span class="hljs-comment">(-)</span> <span class="hljs-comment">((((0 - 1)</span> - <span class="hljs-number">2</span>) - <span class="hljs-number">3</span>) - <span class="hljs-number">4</span>) []<br><span class="hljs-comment">((((0 - 1)</span> - <span class="hljs-number">2</span>) - <span class="hljs-number">3</span>) - <span class="hljs-number">4</span>) -- 为什么这样表示？因为在 haskell 里，恐怕就要导致这样的结果！<br><span class="hljs-number">-10</span><br></code></pre></div></td></tr></table></figure><p>顺带一提，关于<code>foldl</code>和<code>foldr</code>的性质，下面这个实例很有趣，只消注意 zero 和括号的情况——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">foldl</span> (-) <span class="hljs-number">0</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>((((<span class="hljs-number">0</span> - <span class="hljs-number">1</span>) - <span class="hljs-number">2</span>) - <span class="hljs-number">3</span>) - <span class="hljs-number">4</span>)<br>-<span class="hljs-number">10</span><br><br><span class="hljs-title">foldr</span> (-) <span class="hljs-number">0</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>(<span class="hljs-number">1</span> - (<span class="hljs-number">2</span> - (<span class="hljs-number">3</span> - (<span class="hljs-number">4</span> - <span class="hljs-number">0</span>))))<br>-<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><hr><p>有趣的事情来了——<strong>在 haskell 里，<code>foldr</code>比<code>foldl</code>效率更高！</strong><code>foldl</code>的计算会被延迟（<code>foldl</code>：老子不是尾递归吗！），导致递归般的效率，而<code>foldr</code>反而能够保证一定的效率。而且 foldl 因此不能对无穷列表进行折叠，因为其最左边的先计算，导致如果要生成列表则必定是反转的（除非用<code>++</code>，但 haskell 表示不是<code>:</code>它不认），这让<code>foldl</code>无法处理无限长列表——无限的东西可没法反转。而具体细节…嗯哼。</p><p>总之，在 haskell 中，对<code>fold</code>操作进行使用时，考虑遵循这些原则——</p><ol><li>如果要进行 reduce 操作（即生成一个“原子”的值），则使用严格求值的<code>foldl&#39;</code>。这是考虑到左折叠一般来说更易懂，更明显。</li><li>否则，用<code>foldr</code>。</li><li>不要使用<code>foldl</code>。</li></ol><p>对其他语言来说，当然还是考虑多使用左折叠了。</p><p>Over~</p><p><img src="/images/oss/20211015234009.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 lambda 演算</title>
    <link href="/2021/10-09%E5%85%B3%E4%BA%8Elambda%E6%BC%94%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0.html"/>
    <url>/2021/10-09%E5%85%B3%E4%BA%8Elambda%E6%BC%94%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>  这书最终还是没看下去 w，太啰嗦了实在是。而且感觉关注的重点有些偏离实践。</p></blockquote><p>试图看《Haskell Programming From First Principles》，它居然从 lambda 演算作为起始点，令人感叹。因此进行一些学习。</p><p>什么是函数？函数是输入的集合到输出的集合的映射。”<strong>Understanding functions in this way——as a mapping of a set of inputs to a set of outputs——is crucial to understanding functional programming.</strong>“</p><p>演算（calculus）指某种计算或推理的方法。lambda 演算是一种（对特定事物进行）形式化（描述）的方法。比如，它可以对图灵机进行描述，从而能够做到同冯诺依曼姬一样图灵完备。命令式编程语言从冯诺依曼体系出发，函数式编程语言从 lambda 演算出发（当然，底层仍旧是冯诺依曼体系的，硬件基础决定必须如此）。</p><p>就如四则运算有数字和运算符两种元素，lambda 演算有三个基本元素——expression，variable，abstraction。</p><p>expression 是所有东西的父集。它可以是 variable 的名字，abstraction，或是它们的组合。最简单的 expression 是单个变量，比如<code>x</code>。</p><p>variable <strong>没有特定的意义或值</strong> <del>（真正的值，即特定的 lambda 表达式的语义不能从 lambda 演算本身中找到，而要从外界找到）</del>，它只是一个名字——对函数的可能输入赋予的名字。</p><p>abstraction 是函数。它包括函数头，函数体。它可以应用单个 argument——单个输入。在当前的语境下，大可把 abstraction 当作函数的同义词。</p><p>abstraction 的一个实例如下——</p><p><code>𝜆x.x</code></p><p>其中𝜆后的 x 表示 variable（parameter）的名称，<code>.</code>后的东西为函数体。这个 abstraction 用数学语言大可以表述为<code>f(x) = x</code>，或者通过 haskell 表述——<code>(\x -&gt; x)</code>。</p><blockquote><p>  显然，lambda 演算中的 abstraction 是比数学中的函数更加抽象，一般化的——它的输入值是没有任何限定的，无论输入值是一个数字，字符串，或是另一个函数，它都能作为入参并进行替换。</p></blockquote><p>绑定（bind），当我们对函数应用一个参数的时候，函数体中的每一个 x 都会被替换成该参数。也可以说，x 绑定在该参数上了。参数的值为何，x 就会被替换为何值。被绑定的 x 变量称为约束变量。</p><p>约束变量的名字是可以随意替换的，比如<code>𝜆x.x</code>，可以替换成<code>𝜆y.y</code>，<code>𝜆z.z</code>。这是显然的——x，y，z 只是名字，代号而已，它们会被具体的值替换，因此命名如何无关紧要。这种性质称为** alpha 等价**。</p><p>这里的 abstraction <code>𝜆x.x</code>没有名字 ，因此它是一个匿名函数（anonymous function）。</p><p>abstraction 之所以叫 abstraction，是因为它进行了一定的抽象——通过<strong>让名字代表具体的值</strong>来抽象出特定形式；在应用中<strong>以具体的值替换名字</strong>——从而让一定的形式能具有更加广泛的意义。如果离开了这种替换，形如<code>x + 1</code>这种形式的表达式是没有任何意义的，因为 x 只是一个奇怪的符号而已。</p><p>这里的“应用”也有自己的语法——(M N)，其中 M 为应当为 abstraction，而 N 为一个任意 lambda 元素（项）。比如<code>(𝜆x.(x + 1) 2)</code>就是一个应用，2 将作为参数应用到该 abstraction，将 x 替换为 2，最终得到 (2 + 1) 这个表达式。这称为** Beta 化简**。显然这是将 abstraction 转换成表达式的基础。</p><p>parameter 和 argument——定义的语境称作 parameter，应用的语境称为 argument。绑定的是 parameter，接受的是 argument。实践中这两个词通常可以混用，都冠以“参数”为名。但 argument 更倾向于表示传递给函数的<strong>值</strong>。</p><blockquote><p>  这里的 1，2，+应该考虑为某种标识符，或某种变量名，不考虑它的具体语义。</p></blockquote><p>对<code>𝜆x.x</code>，将其应用到入参<code>1</code>和<code>𝜆y.y</code>，能够得到<code>1</code>和<code>𝜆y.y</code>。下面列出了<code>(𝜆𝑦.𝑦)</code>求解过程，其中<code>[𝑥 ∶= (𝜆𝑦.𝑦)]</code>表示 x 将替换为<code>(𝜆𝑦.𝑦)</code>，或者说 x 和这个值绑定了。</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode"><span class="hljs-comment">(𝜆𝑥.𝑥)</span><span class="hljs-comment">(𝜆𝑦.𝑦)</span><br>[𝑥 ∶= <span class="hljs-comment">(𝜆𝑦.𝑦)</span>]<br>𝜆𝑦.𝑦<br></code></pre></div></td></tr></table></figure><p>又比如对<code>(𝜆𝑥.𝑥)(𝜆𝑦.𝑦)𝑧</code>，能容易看出来其结果为 z。<code>(𝜆𝑥.𝑥)</code>显然为 identity 函数。容易得到 const 函数——<code>(𝜆x.𝜆y.x)</code>。</p><p>变量绑定和替换就是 lambda 演算的核心规则。在 lambda 演算里，变量只是名字，函数只是一个等待替换输入参数并返回一个表达式的“模版”。对 lambda 表达式进行化简的过程称为解析（resolve）。解析将在无法再次进行 Beta 化简时停止，即找不到 abstraction，或者找不到参数。无法进行 Beta 化简的表达式称为<code>beta normal form</code>。这种形式是计算完全的表达式。</p><p>但是并非所有表达式都能转化为 beta normal form，比如这个——<code>(𝜆x.xx)(𝜆x.xx)</code>，对其进行 Beta 化简会得到它本身，因而能够无限地化简下去。这种表达式是<code>diverge</code>发散的。很好奇这是否涉及到停机问题。</p><p>同时出现在函数头和函数体的名字称为约束变量，而未出现在函数头却出现在函数体中的名字称为自由变量。编程中自由变量是常见的——引用的上层作用域或全局作用域的变量。</p><p>函数是单参数的，就如 Haskell 的函数定义一样，但也同 haskell 一样允许使用“语法糖”——形如<code>𝜆xy.xy</code>的函数实质上是<code>𝜆x.(𝜆y.xy)</code>。顺便，这里的<code>xy</code>没有任何意义，只是两个名字放在一起罢了，具体语义没有被定义。可以认为类似数学上那种乘法表述，<code>f(x)=2x</code>。但若是 x 被应用到了另一个函数，这将成为一次函数的应用。</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">𝜆xy<span class="hljs-selector-class">.xy</span> (𝜆z.a) <span class="hljs-number">1</span><br>(𝜆x(𝜆y.xy)) (𝜆z.a) <span class="hljs-number">1</span><br><span class="hljs-selector-attr">[x := (𝜆z.a)]</span><br>(𝜆y.(𝜆z.a)y) <span class="hljs-number">1</span><br><span class="hljs-selector-attr">[z := y]</span><br>(𝜆y.a) <span class="hljs-number">1</span><br><span class="hljs-selector-attr">[y := 1]</span><br><span class="hljs-selector-tag">a</span> <br></code></pre></div></td></tr></table></figure><p>当然，对于多参数的应用，大可以直接一次性全部替换。只是这种替换对人脑友好，对计算机不友好罢了。</p><p>lambda 演算中的计算（evaluation）就是化简。这对一个只有纯函数形式的“语言”来说是显然的。</p><p><strong>组合子</strong>（Combinator）是没有自由变量的 lambda 项。它代表一类这样的 lambda——它只能对它的 argument 进行组合。</p><p>lambda 表达式的计算顺序遵循<code>normal order</code>。”<strong>Normal order is a common evaluation strategy in lambda calculi. Normal order means evaluating (ie, applying or beta reducing) the leftmost outermost lambdas first, evaluating terms nested within after you’ve run out of arguments to apply</strong>.”</p><p>就这样了。将来如果有必要再深化。lambda 演算比我想象的还要简单，看来是之前看的书，文章太过堆砌概念了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 haskell 的一些笔记</title>
    <link href="/2021/10-08%E5%85%B3%E4%BA%8Ehaskell%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0.html"/>
    <url>/2021/10-08%E5%85%B3%E4%BA%8Ehaskell%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>  国庆学了个爽，把记录的一些东西贴一下。</p></blockquote><p>data 关键字定义新的 type，其形如这种形式——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Bool</span> = <span class="hljs-type">True</span> | <span class="hljs-type">False</span></span><br></code></pre></div></td></tr></table></figure><p>这里的 Bool 即为类型，True 和 False 称为<code>Value Constructor</code>，<strong>其列出了该类型所有可能的值</strong>。</p><p>就“列出所有可能的值”这一点来说，我们可以这样定义 Int——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Int</span> = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647  </span><br></code></pre></div></td></tr></table></figure><p>仅仅是一种比喻而已，实际并非如此。</p><p>自己定义的类型则必须基于已有的六种基本类型。比如这里定义一个 Shape，那些 Float 代表这些形状各边的长度。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Shape</span> = <span class="hljs-type">Circle</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> | <span class="hljs-type">Rectangle</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span></span><br><span class="hljs-comment">&#123;-</span><br><span class="hljs-comment">&gt;&gt;&gt; :t Circle</span><br><span class="hljs-comment">Circle :: Float -&gt; Float -&gt; Float -&gt; Shape</span><br><span class="hljs-comment">&gt;&gt;&gt; :t Rectangle</span><br><span class="hljs-comment">Rectangle :: Float -&gt; Float -&gt; Float -&gt; Float -&gt; Shape</span><br><span class="hljs-comment">-&#125;</span><br></code></pre></div></td></tr></table></figure><p><code>data Shape = Circle Float Float Float | Rectangle Float Float Float Float</code>，这段的意思应当理解为，定义了一个名为 Shape 的 type，其包含 Circle 和 Rectangle 两个 Value Constructor（同时，Circle 和 Rectangle 是 Shape 的值……我不懂为什么），其中 Circle 包含三个字段——xy 坐标，半径，Rectangle 包含四个字段——左上和右下点的坐标（喂，没有旋转嘛！），都为 Float 类型。</p><p>可以看到，<code>Value Constructor</code>就像构造函数一样的存在。但是就语义来说，其应当被连带参数（字段）当作一个整体，即像<code>(Circle 1 2 3)</code>这样看待。这种情况实际上是因为——<strong>其文字形式表述和其定义形式是一致的</strong>。</p><p>这么来说，对所有<code>(Circle a b c)</code>，其中 a，b，c 都为 Float，其都是 Shape，或者都属于 Shape 这个 type。<code>(Circle a b c)</code>之于 Shape，就像 True 之于 Bool——就像字面量，只不过 Shape 在三个方向或四个方向上能够很大地延展下去罢了（指能取很多值）。</p><p>自定义的 type 也可以被模式匹配，下面展示了求形状的面积的函数——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">surface</span> :: <span class="hljs-type">Shape</span> -&gt; <span class="hljs-type">Float</span><br><span class="hljs-title">surface</span> (<span class="hljs-type">Circle</span> _ _ r) = pi * r ^ <span class="hljs-number">2</span><br><span class="hljs-title">surface</span> (<span class="hljs-type">Rectangle</span> x0 y0 x1 y1) = abs $ (x0 - x1) * (y0 - y1)<br></code></pre></div></td></tr></table></figure><p>我们写不出<code>fn :: Circle -&gt; Float</code>这样的函数，因为 Circle 不是 Type，Shape 才是，正如我们不能写出<code>True -&gt; Int</code>的函数，不能写出<code>1 -&gt; Int</code>的函数。</p><p>type 当然也是可以层层抽象的……而且 Haskell 会聪明地帮我们进行模式匹配（再多几层怎么办？用 where 吧……）</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Point</span> = <span class="hljs-type">Point</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Shape</span> = <span class="hljs-type">Circle</span> <span class="hljs-type">Point</span> <span class="hljs-type">Float</span> | <span class="hljs-type">Rectangle</span> <span class="hljs-type">Point</span> <span class="hljs-type">Point</span> <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span><br><br><span class="hljs-title">surface</span> :: <span class="hljs-type">Shape</span> -&gt; <span class="hljs-type">Float</span><br><span class="hljs-title">surface</span> (<span class="hljs-type">Circle</span> (<span class="hljs-type">Point</span> _ _ )  r) = pi * r ^<span class="hljs-number">2</span><br><span class="hljs-title">surface</span> (<span class="hljs-type">Rectangle</span> (<span class="hljs-type">Point</span> x0 y0) (<span class="hljs-type">Point</span> x1 y1)) = abs $ (x0 - x1) * (y0 - y1)<br></code></pre></div></td></tr></table></figure><p>考虑到 Value Constructor 也是函数，可以利用其定义一些其他函数用来生成 Shape……比如来一个在原点的圆！</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">centerCircle</span> = <span class="hljs-type">Circle</span> $ <span class="hljs-type">Point</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <br><span class="hljs-comment">&#123;-</span><br><span class="hljs-comment">&gt;&gt;&gt; centerCircle 5</span><br><span class="hljs-comment">Circle (Point 0.0 0.0) 5.0</span><br><span class="hljs-comment">-&#125;</span><br></code></pre></div></td></tr></table></figure><hr><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span> &#123;</span><br><span class="hljs-class">    <span class="hljs-title">firstName</span> :: <span class="hljs-type">String</span>,</span><br><span class="hljs-class">    <span class="hljs-title">lastName</span> :: <span class="hljs-type">String</span>,</span><br><span class="hljs-class">    <span class="hljs-title">age</span> :: <span class="hljs-type">Int</span>,</span><br><span class="hljs-class">    <span class="hljs-title">height</span> :: <span class="hljs-type">Float</span>,</span><br><span class="hljs-class">    <span class="hljs-title">phoneNumber</span> :: <span class="hljs-type">String</span>,</span><br><span class="hljs-class">    <span class="hljs-title">flavor</span> :: <span class="hljs-type">String</span></span><br><span class="hljs-class">&#125; <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span><br></code></pre></div></td></tr></table></figure><p>为字段命名，这种形式称为<code>record</code>，haskell 会为每一个字段生成“getter”。</p><p>同时，构造 Person 时，可以使用被称为<code>Record Construction</code>的语法——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-type">Person</span> &#123;firstName=<span class="hljs-string">&quot;rua&quot;</span>,lastName=<span class="hljs-string">&quot;www&quot;</span>,age=<span class="hljs-number">12</span>,height=<span class="hljs-number">170</span>,phoneNumber=<span class="hljs-string">&quot;1111111111&quot;</span>,flavor=<span class="hljs-string">&quot;wtf&quot;</span>&#125;<br></code></pre></div></td></tr></table></figure><p>这种构造必须给定全部字段，有遗漏的会有 error。</p><hr><blockquote><p>   We usually use type parameters when the type that’s contained inside the data type’s various value constructors isn’t really that important for the type to work.</p></blockquote><p>如上，当我们对 type 所包含的某个值的具体 type 不在意，即其的 type 对我们并不造成影响时，我们就用 type parameter。</p><p>比如，Map 的 k 和 v 就是应该应用 type parameter 的时候。</p><hr><p><strong>Functor 代表越过容器对内容进行操作的能力，Applicative 代表合并两个容器内容的能力</strong>。</p><hr><p>Lisp 厨欢喜！</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">List</span> a = <span class="hljs-type">Empty</span> | <span class="hljs-type">Cons</span> a (<span class="hljs-type">List</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Eq</span>, <span class="hljs-type">Show</span>, <span class="hljs-type">Read</span>, <span class="hljs-type">Ord</span>)</span><br><br><span class="hljs-title">car</span> :: <span class="hljs-type">List</span> a -&gt; a<br><span class="hljs-title">car</span> <span class="hljs-type">Empty</span> = error <span class="hljs-string">&quot;cao!&quot;</span><br><span class="hljs-title">car</span> (<span class="hljs-type">Cons</span> a _) = a<br><br><span class="hljs-title">cdr</span> :: <span class="hljs-type">List</span> a -&gt; <span class="hljs-type">List</span> a<br><span class="hljs-title">cdr</span> <span class="hljs-type">Empty</span> = <span class="hljs-type">Empty</span><br><span class="hljs-title">cdr</span> (<span class="hljs-type">Cons</span> _ a) = a<br></code></pre></div></td></tr></table></figure><p>将 Cons 中置，我们就得到了：，而 Empty 就是 []——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">lst</span> = <span class="hljs-number">1</span> `<span class="hljs-type">Cons</span>` (<span class="hljs-number">2</span> `<span class="hljs-type">Cons</span>` (<span class="hljs-number">3</span> `<span class="hljs-type">Cons</span>` <span class="hljs-type">Empty</span>))<br></code></pre></div></td></tr></table></figure><hr><p>可以定义中置运算符——必须为全符号且指定优先级——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-keyword">infixl</span> <span class="hljs-number">5</span> **** <span class="hljs-comment">--- 这个签名称为 fixity，这里的 infixl 表示中置左结合</span><br>(****) :: <span class="hljs-type">Num</span> a =&gt; a -&gt; a -&gt; a<br><span class="hljs-title">a</span> **** b = a * b * b * b<br></code></pre></div></td></tr></table></figure><p>在定义 data 时可以<strong>使用中置运算符</strong>作为 Value Constuctor——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-keyword">infixr</span> <span class="hljs-number">5</span> :-:<br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">List</span> a = <span class="hljs-type">Empty</span> | a :-: (<span class="hljs-type">List</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Eq</span>, <span class="hljs-type">Show</span>, <span class="hljs-type">Read</span>, <span class="hljs-type">Ord</span>)</span><br><span class="hljs-comment">&#123;-</span><br><span class="hljs-comment">&gt;&gt;&gt; 3 :-: 4 :-: 5 :-: Empty</span><br><span class="hljs-comment">3 :-: (4 :-: (5 :-: Empty))</span><br><span class="hljs-comment">-&#125;</span><br></code></pre></div></td></tr></table></figure><p>这玩意着实有点 geek。</p><hr><p>模式匹配匹配的是什么？<strong>Value Constructor</strong>！这样的话，对数字，对 char 进行匹配就非常有趣了——丘奇数！</p><p>对 List 进行模式匹配时，能够使用<code>(x:xs)</code>这种形式也是符合逻辑的——<code>:</code>就是一个值构造器！只不过是中缀函数的形式罢了！所以也可以这么使用——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;</span> :: <span class="hljs-type">Num</span> p =&gt; [p] -&gt; p<br><span class="hljs-title">sum&#x27;</span> [] = <span class="hljs-number">0</span><br><span class="hljs-title">sum&#x27;</span> ((:) x xs) = x + sum&#x27; xs  <span class="hljs-comment">-- 就像 Cons 的使用法</span><br></code></pre></div></td></tr></table></figure><p><code>[]</code>也同理——它也是值构造器。不得不感叹，Haskell 的设计太好了。</p><hr><p>将 type 作为 typeclass 的实例的时候，对于带类型参数的 type constructor，有一些东西需要注意。</p><p>考虑<code>data Either a b = Left a | Right b</code>，它是一个 Functor 的实例。fmap 对其表现在于对 Left 则无作用，对 Right 则返回<code>Right $ f r</code>，其中 r 为<code>(Right r)</code>。因此 haskell 建议使用 Left 包装错误，使用 Right 包装值。</p><p>这是 Either 对 Functor 的实现。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> (<span class="hljs-type">Either</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">where</span></span><br>    fmap f (<span class="hljs-type">Right</span> r) = <span class="hljs-type">Right</span> $ f r<br>    fmap _ (<span class="hljs-type">Left</span> l) = <span class="hljs-type">Left</span> l<br></code></pre></div></td></tr></table></figure><p>这里为什么使用·<code>EIther a</code>？考虑 fmap 的签名——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fmap</span> :: <span class="hljs-type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b<br></code></pre></div></td></tr></table></figure><p>这里的 f 是实现了 fmap 的 type，从签名中可以看到，f 应当是一个接受单参数的 type constructor。</p><p>于是，Either a 就能够解释了——对 Either 进行偏调用，获取一个接受单参数的 type constructor——可以说 fmap 的函数签名可以这样表示——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fmap</span> :: <span class="hljs-type">Functor</span> f =&gt; (a -&gt; b) -&gt; (<span class="hljs-type">Either</span> c) a -&gt; (<span class="hljs-type">Either</span> c) b<br></code></pre></div></td></tr></table></figure><p>这里的 c 其具体类型是无关紧要的——对 fmap，它不可见。</p><p>于是这就加上了一个限制——对实现 fmap 的 type，只有最右边的 type parameter 是可以在 fmap 中被改变的（从 a 到 b），而前面的 c 是改不了的，无论是它的 type 还是 value（type 不可变是因为这在函数签名中已经限定，value 不可变是因为该方法无法获取关于 c 的任何信息，任何操作）。比如，我们想用 Left 来存数据，想用 Right 来存错误，这就是不可行的——Left 没得变。真坏！</p><hr><p>然后是 kind 概念……</p><p>如果说 type 是 value 的标签的话，kind 就是 type 的标签。type 标识一个 value 的集合，kind 标识一个 type 的集合。</p><p>kind 的形式化表述很像 type 构造器的签名——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">-- &gt;&gt;&gt; :k Either</span><br><span class="hljs-type">Either</span> :: * -&gt; * -&gt; *<br><br><span class="hljs-comment">-- &gt;&gt;&gt; :k Either Int </span><br><span class="hljs-type">Either</span> <span class="hljs-type">Int</span> :: * -&gt; *<br><br><span class="hljs-comment">-- &gt;&gt;&gt; :k Either Int String</span><br><span class="hljs-type">Either</span> <span class="hljs-type">Int</span> <span class="hljs-type">String</span> :: *<br></code></pre></div></td></tr></table></figure><p>*表示具体类型（just type， concrete type， star type），可以看到 Either 接受两个具体类型，返回一个具体类型。</p><p>使用：t 来获取 value 的 type，使用：k 获取 type 的 kind。</p><blockquote><p>haskell 的错误提示里 type 是 data constructor</p></blockquote><p>关于 Functor 的例子，用 kind 的形式来说，Functor 接受一个<code>* -&gt; *</code>的 type，而 Either 是一个<code>* -&gt; * -&gt; *</code> 的 type，因此需要进行一个偏调用。</p><blockquote><p>一个问题——:k 对 typeclass 也有效吗？看这签名，好像是根据 kind 生成约定的样子。</p></blockquote><p>事情变得抽象了——type parameter 可以是具体类型，也可以是 type constructor（显然这两样是同质的，之后一概以 type 称呼，顶多分成具体 type 和抽象 type）</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Frank</span> a b = <span class="hljs-type">Frank</span> &#123;<span class="hljs-title">frankField</span> :: <span class="hljs-title">b</span> <span class="hljs-title">a</span>&#125; <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span><br></code></pre></div></td></tr></table></figure><p>根据其 body，b 是一个<code>* -&gt; *</code>，a 是一个<code>*</code>，于是 Frank 是——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-type">Frank</span> :: * -&gt; (* -&gt; *) -&gt; *<br></code></pre></div></td></tr></table></figure><p>卧槽！</p><p>请问这样奇怪的 type 哪个 typeclass 愿意收呢（恼</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Tohu</span> t <span class="hljs-keyword">where</span></span><br>    tofu :: j a -&gt; t a j<br></code></pre></div></td></tr></table></figure><p>这里的 Tohu typeclass，其中的 j 就是<code>* -&gt; *</code>，t 的类型根据 t a j 能够推导出来——<code>* -&gt; (* -&gt; *) -&gt; *</code></p><p>一个重点是去了解函数&#x2F;类型签名和函数体的关系——签名再怎么花哨也行，对函数体不会有影响。</p><p>kind 能够形式化表述 type 的类型参数，type declaration 形式化表述 function 和 value 的参数。</p><hr><p>haskell 中的 Unit 使用 () 即空的 tuple 表示。</p><hr><p>return 将值包装成 Monad。这可以用在 IO Monad 里，<code>name &lt;- return xxx</code>来绑定值到……名字上，也可以用在其他 Monad 里，比如<code>return 1 :: Maybe Int</code>，能拿到一个<code>Just 1</code>。但是没必要。</p><hr><blockquote><p>Don’t think of a function like <strong>putStrLn</strong> as a function that takes a string and prints it to the screen. Think of it as a function that takes a string and returns an I&#x2F;O action.</p></blockquote><p>不要把带副作用的函数看作接受参数并进行操作的“过程”，而是将这些函数看作接受参数，返回 IO action 的函数！这种看法是为了更好的组合操作，把代码&#x2F;过程当作数据来看待……</p><hr><p>随机数是有副作用的——对同一个获取随机数的函数，每次调用都是不同结果。</p><p>但这只是表面上的——随机数是通过某种显式或隐式的状态生成的。</p><p>haskell 允许通过一个整数（作为种子）来生成一个随机数生成器——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-comment">--- &gt;&gt;&gt; gen = mkStdGen 42</span><br><span class="hljs-type">StdGen</span> &#123;unStdGen = <span class="hljs-type">SMGen</span> <span class="hljs-number">9297814886316923340</span> <span class="hljs-number">13679457532755275413</span>&#125;<br><br><span class="hljs-comment">--- &gt;&gt;&gt; random gen :: (Integer, StdGen)</span><br>(<span class="hljs-number">1275548033995301424</span>,<span class="hljs-type">StdGen</span> &#123;unStdGen = <span class="hljs-type">SMGen</span> <span class="hljs-number">4530528345362647137</span> <span class="hljs-number">13679457532755275413</span>&#125;)<br><br><span class="hljs-comment">--- &gt;&gt;&gt; random gen :: (Integer, StdGen)</span><br>(<span class="hljs-number">1275548033995301424</span>,<span class="hljs-type">StdGen</span> &#123;unStdGen = <span class="hljs-type">SMGen</span> <span class="hljs-number">4530528345362647137</span> <span class="hljs-number">13679457532755275413</span>&#125;)<br><br><span class="hljs-comment">--- &gt;&gt;&gt; random gen :: (Integer, StdGen)</span><br>(<span class="hljs-number">1275548033995301424</span>,<span class="hljs-type">StdGen</span> &#123;unStdGen = <span class="hljs-type">SMGen</span> <span class="hljs-number">4530528345362647137</span> <span class="hljs-number">13679457532755275413</span>&#125;)<br><br><span class="hljs-comment">--- &gt;&gt;&gt; random gen :: (Double, StdGen)</span><br>(<span class="hljs-number">0.930852402521634</span>,<span class="hljs-type">StdGen</span> &#123;unStdGen = <span class="hljs-type">SMGen</span> <span class="hljs-number">4530528345362647137</span> <span class="hljs-number">13679457532755275413</span>&#125;)<br></code></pre></div></td></tr></table></figure><p>可见，无论多少次，这玩意都返回同样结果，是纯函数。</p><p>然后就是有趣的地方——haskell 不止返回了随机数的值，也返回了一个（或者说下一个）随机数生成器，这下一个的值也是一样的……</p><p>于是，函数式的随机数解决方案来了！把生成随机数所需的状态作为参数传递嘛！太聪明了！这样的话只需要在生成最初的生成器的时候要求外界输入了！</p><p>这也可以看作是一种妥协方案……当然也可以在 IO 里进行随机数的生成。</p><p>同时，考虑到每次都要拿新的种子生成器很麻烦，可以整一个获取随机数列表的函数（haskell 有原生实现，randoms）——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">randoms</span> gen = value : randoms nextGen  <span class="hljs-comment">--- 没有边界条件，显然是个利用懒求值的无限流</span><br>    <span class="hljs-keyword">where</span> (value, nextGen) = random gen<br></code></pre></div></td></tr></table></figure><hr><p>模式匹配匹配的是值的形式（也就是值构造器）而非值的内容（值本身），所以模式这个词非常符合。</p><hr><p>小小的感受——对那些只被模块内部使用的函数，且能够清晰规划出哪些情况将会被使用，那些情况将不会的情况下，使用 error 标识不可能的情况是合理的（当然，如果这个函数仅被使用过 1 次，考虑将其放到 where 子句中。</p><hr><p>函数有着自己的 type constructor——<code>(-&gt;)</code>。这是一个中缀的 Type Constructor。</p><hr><p>可以认为，通过 fmap 的偏调用，可以把一个 (a -&gt; b) 的函数转换成 (f a -&gt; f b) 的函数——稍微重新诠释一下 fmap 函数的签名即可——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fmap</span> :: (a -&gt; b) -&gt; (f a -&gt; f b)<br></code></pre></div></td></tr></table></figure><hr><p>自定义 type 要成为 Functor 的实例，有两条规则需要遵守，第一条是——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fmap</span> id = id<br></code></pre></div></td></tr></table></figure><p>比如，<code> fmap id (Just 1) == id (Just 1)</code></p><p>第二条是——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fmap</span> (f . g) = fmap f . fmap g<br></code></pre></div></td></tr></table></figure><p>比如对 Maybe 的 Just 的推导如下——</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">fmap f . fmap g $ Just <span class="hljs-keyword">x</span><br>    <span class="hljs-operator">=</span> fmap f $ Just (g <span class="hljs-keyword">x</span>)<br>    <span class="hljs-operator">=</span> Just (f (g <span class="hljs-keyword">x</span>))<br>fmap (f . g) $ Just <span class="hljs-keyword">x</span><br>    <span class="hljs-operator">=</span> Just ((f . g) <span class="hljs-keyword">x</span>)<br>    <span class="hljs-operator">=</span> Just (f (g <span class="hljs-keyword">x</span>))<br></code></pre></div></td></tr></table></figure><p>一个不合理的 Functor 的实例 type 如下，其中 C 意为 Counter，该 type 试图保存至今为止被映射的次数——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">CMaybe</span> a = <span class="hljs-type">CNothing</span> | <span class="hljs-type">CJust</span> <span class="hljs-type">Int</span> a <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)  </span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">CMaybe</span> <span class="hljs-keyword">where</span></span><br>    fmap _ <span class="hljs-type">CNothing</span> = <span class="hljs-type">CNothing</span><br>    fmap f (<span class="hljs-type">CJust</span> counter a) = <span class="hljs-type">CJust</span> (counter + <span class="hljs-number">1</span>) $ f a<br></code></pre></div></td></tr></table></figure><p>这个实现不符合第一条规则——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fmap</span> id (<span class="hljs-type">CJust</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>) == <span class="hljs-type">CJust</span> <span class="hljs-number">1</span> <span class="hljs-number">10</span><br><span class="hljs-title">id</span> (<span class="hljs-type">CJust</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>)      == <span class="hljs-type">CJust</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><blockquote><p>If a type obeys the functor laws, we know that calling <code>fmap</code> on a value of that type will only map the function over it, <strong>nothing more</strong>.</p></blockquote><p>也可以理解为，Functor 是在一个特定的上下文中对值进行映射&#x2F;修改。这个上下文不止包括数据所对应的 value Constructor，还可以包括更多东西，比如对 IO，它包括整个世界。（这里的上下文 context 指的是计算上下文 computation context 吗？）</p><hr><hr><p>Applicative 全称是 Applicative Functor，这意味着一个 type 如果是 Applicative，则它必然也是 Functor，这可见于 Applicative 的定义——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>) =&gt; <span class="hljs-type">Applicative</span> f <span class="hljs-keyword">where</span></span><br>    pure :: a -&gt; f a<br>    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b<br></code></pre></div></td></tr></table></figure><p>pure 函数之所以名叫 pure，是因为该函数将其放入了一个特定的，最小化的，默认的上下文（也就是那个“box”，可以认为像 Maybe，Either 这样的 Functor 实际上是定义了一个盒子来保存一定的东西，这个盒子也就是一定的上下文）。默认，default，也叫 pure。</p><blockquote><p>  最小化体现在哪里？<code>pure 42 :: [Int]</code>会得到<code>[42]</code>。这显然不是真正最小的——那是<code>[]</code>，可是<code>[]</code>是无法储存值的，就如 Maybe 的 Nothing 一样，所以最小在这里指单例的列表。</p></blockquote><blockquote><p>  A better way of thinking about <code>pure</code> would be  to say that it takes a value and puts it in some sort of default (or  pure) context—a minimal context that still yields that value.</p></blockquote><p><code>&lt;*&gt;</code>就是 Applicative 的“业务”函数，它的签名值得和 fmap 对比看——<code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>。</p><p>查看 Monad 的定义，发现更加有趣的事实，感情 Monad 是 Functor 一步一步“增强”的结果。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-type">Prelude</span>&gt; :i <span class="hljs-type">Monad</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Monad</span> :: (* -&gt; *) -&gt; <span class="hljs-type">Constraint</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Applicative</span> m =&gt; <span class="hljs-type">Monad</span> m <span class="hljs-keyword">where</span></span><br>  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b<br>  (&gt;&gt;) :: m a -&gt; m b -&gt; m b<br>  return :: a -&gt; m a<br>  <span class="hljs-meta">&#123;-# MINIMAL (&gt;&gt;=) #-&#125;</span><br>      <span class="hljs-comment">-- Defined in ‘GHC.Base’</span><br></code></pre></div></td></tr></table></figure><hr><p>把值放在 Functor 里容易，取出来却不容易。比如 IO Monad（当然，它也是 Functor），它持有的值是拿不出来的。<del>除非使用 unsafe 的方式</del>。 这是为了保证副作用不扩散。</p><hr><blockquote><p>  Applicative functors and the applicative style of doing <code>pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt;</code> … allow us to take a function that expects parameters that aren’t  necessarily wrapped in functors and use that function to operate on  several values that are in functor contexts. </p></blockquote><p>pure 和&lt;*&gt;结合使用，能达到这样的效果——使原本用于一般的值的函数能够应用在 functor 的上下文中，比如下面展示了对 Maybe（Just）中包裹的元素进行操作。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-type">Prelude</span>&gt; pure div &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">5</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">2</span> <span class="hljs-comment">-- 对一般的值，是 div 5 2</span><br><span class="hljs-type">Just</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>也可以认为<code>pure f &lt;*&gt; x</code>等价于<code>fmap f x</code>，于是对于<code>pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code>，可以表示为<code>fmap f x &lt;*&gt; y &lt;*&gt; ...</code>。而 haskell 提供了<code>&lt;$&gt;</code>函数——<code>f &lt;$&gt; x = fmap f x</code>。</p><p>于是对<code>pure div &lt;*&gt; Just 5 &lt;*&gt; Just 2</code>，可以将其表示为<code> fmap div (Just 5) &lt;*&gt; Just 2</code>  ，或者<code>div &lt;$&gt; Just 5 &lt;*&gt; Just 2 </code>，显然最后的形式是最合适，最易懂的，它就像普通的函数调用中间插入一些奇怪玩意。</p><hr><p>对 List，它的 Applicative 的定义是这样的——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> [] <span class="hljs-keyword">where</span></span>  <br>    pure x = [x]  <br>    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]  <br></code></pre></div></td></tr></table></figure><p>List 的<code>&lt;*&gt;</code>的行为很奇怪，做了个“笛卡尔积”，如果认为<code>[1,2,3]</code>这种形式表示某个值的可能取值为 1，2，3，则该操作符表达了所有可能的结果——<code>[(+) 1,(+) 2, (+) 3]</code>和<code>[4,5,6]</code>这两个“非确定”的值组合得到的“非确定”的结果。使用<code>&lt;*&gt;</code>能在一定程度上替代 List 推导式。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-type">Prelude</span>&gt; (+) &lt;$&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] &lt;*&gt; [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br></code></pre></div></td></tr></table></figure><hr><p>对 IO，它的 Applicative 的实现为——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> <span class="hljs-type">IO</span> <span class="hljs-keyword">where</span></span>  <br>    pure = return  <br>    a &lt;*&gt; b = <span class="hljs-keyword">do</span> <span class="hljs-comment">-- &lt;*&gt; :: IO (a -&gt; b) -&gt; IO a -&gt; IO b</span><br>        f &lt;- a  <br>        x &lt;- b  <br>        return (f x)  <br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 haskell 的.和$运算符</title>
    <link href="/2021/09-26%E5%85%B3%E4%BA%8Ehaskell%E7%9A%84dot%E5%92%8Cdollar%E8%BF%90%E7%AE%97%E7%AC%A6.html"/>
    <url>/2021/09-26%E5%85%B3%E4%BA%8Ehaskell%E7%9A%84dot%E5%92%8Cdollar%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
    
    <content type="html"><![CDATA[<p><img src="/images/oss/20210926020709.png"></p><p>函数应用是左结合的且优先级最高，然后是<code>.</code>运算符，最后是<code>$</code>运算符。</p><p>所以对表达式——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">sum</span> . map product $ [[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]]<br></code></pre></div></td></tr></table></figure><p>首先是 map 进行调用，其以 product 为参数——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">sum</span> . (map product) $ [[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]]<br></code></pre></div></td></tr></table></figure><p>这里，假设$先调用，则会变成这样的结果——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">sum</span> . ((map product) [[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])<br><span class="hljs-comment">--- 等价于 sum . [42]</span><br></code></pre></div></td></tr></table></figure><p>这显然是离谱的，因此，<code>.</code>将首先调用，形成这样的结果——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">sum</span> ((map product) $ [[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])<br><span class="hljs-comment">--- 等价于 sum [42]</span><br></code></pre></div></td></tr></table></figure><p>Bingo！</p><p>在这里，<code>$</code>运算符的意义在于，避免最靠近参数的函数直接计算出了结果，而是延迟到计算结果的前一刻（也就是得到以输入参数为唯一参数的函数），待<code>.</code>运算符将各个函数组合后再进行真正的运算。</p><p>可以认为，$把原表达式变成这样了——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">(sum . map product) [[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]]<br></code></pre></div></td></tr></table></figure><p>这或许是对该运算符的最容易理解的诠释。</p><p>用 kotlin 的话来说，它代表这样的链式调用——</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 可大剌剌地直接理解为——</span><br>&#123;&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;&#125; <span class="hljs-comment">// 应当是 List.of，这里只是为了清晰</span><br>.let (v -&gt; map(product, v))<br>.let (v -&gt; sum(v));<br><br><span class="hljs-comment">// 柯里化的形式，复杂但更加接近实质</span><br>&#123;&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;&#125; <br>    .let (v -&gt; &#123;<br>        <span class="hljs-keyword">val</span> tmpFn = (v1) -&gt; &#123;<br>            map(product, v1)<br>        &#125;<br>        tmpFn(v)<br>    &#125;).let (v -&gt; &#123;<br>        <span class="hljs-keyword">val</span> tmpFn = (v1) -&gt; &#123; <span class="hljs-comment">// 可以直接 val tmpFn = sum</span><br>            sum(v1)<br>        &#125; <br>        tmpFn(v)<br>    &#125;);<br></code></pre></div></td></tr></table></figure><p>如果最近的函数的入参有多个怎么办？考虑<code>$</code>的签名：<code>($) :: (a -&gt; b) -&gt; a -&gt; b</code>，其左边应该是函数，右边应该是参数，事情变得明了起来了——将<code>$</code>加到最后一个参数前面，比如下面的示例，它定义了一个获取坐标到原点距离的函数——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">distance</span> :: <span class="hljs-type">Floating</span> c =&gt; c -&gt; c -&gt; c<br><span class="hljs-title">distance</span> x y = sqrt . squareSum x $ y<br>    <span class="hljs-keyword">where</span> squareSum x y = x ^ <span class="hljs-number">2</span> + y ^ <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>我觉得这在代码结构上实在不太优雅，但或许之后会有改变。转换成 Kotlin，对<code>distance 3 4</code>，即<code>sqrt . squareSum 3 $ 4</code>，有这样的等价代码——</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">4.</span>let(v -&gt; &#123;<br>    <span class="hljs-keyword">val</span> tmpFn = (v1) -&gt; &#123;<br>        squareSum(<span class="hljs-number">3</span>, v1)<br>    &#125;<br>    tmpFn(v)<br>&#125;)).let(v -&gt; &#123;<br>    <span class="hljs-keyword">val</span> tmpFn = (v1) -&gt; &#123;<br>        sqrt (v1)<br>    &#125;<br>    tmpFn(v)<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>对参数是表达式的情况，也可以使用<code>$</code>来减少括号——</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fib</span> (<span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span>)<br><span class="hljs-comment">--- 等价于 fib $ 3 + 4 + 5</span><br></code></pre></div></td></tr></table></figure><p>因为<code>$</code>最低的优先级，<code>3+4+5</code>将被先计算。当然，这特性可无法用在<code>fib (n - 1) + fib (n - 2)</code>中。</p><p>顺带一提，<code>.</code>运算符的签名如下，可见其组合的函数必须是接受单参数的，且最终组合的函数，接受参数为最内的函数的参数的类型，返回结果为最外的函数的返回值的类型。</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl">(.) :: (<span class="hljs-function"><span class="hljs-title">b</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">c</span>) -&gt;</span> (<span class="hljs-function"><span class="hljs-title">a</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">b</span>) -&gt;</span> <span class="hljs-function"><span class="hljs-title">a</span> -&gt;</span> c<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】面向对象随想——多用组合来代替继承</title>
    <link href="/2021/09-15%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%9A%8F%E6%83%B3%E2%80%94%E2%80%94%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E6%9D%A5%E4%BB%A3%E6%9B%BF%E7%BB%A7%E6%89%BF.html"/>
    <url>/2021/09-15%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%9A%8F%E6%83%B3%E2%80%94%E2%80%94%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E6%9D%A5%E4%BB%A3%E6%9B%BF%E7%BB%A7%E6%89%BF.html</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.kbasm.com/blog/cn/oop-prefer-composition-over-inheritance">https://www.kbasm.com/blog/cn/oop-prefer-composition-over-inheritance</a></p><h1 id="面向对象随想-–-多用组合来代替继承"><a href="#面向对象随想-–-多用组合来代替继承" class="headerlink" title="面向对象随想 – 多用组合来代替继承"></a>面向对象随想 – 多用组合来代替继承</h1><p>面向对象设计中，很多时候用组合来代替继承会更好。本文主要讨论了组合和继承的对比以及各自的优缺点。</p><h2 id="什么是继承和组合"><a href="#什么是继承和组合" class="headerlink" title="什么是继承和组合"></a>什么是继承和组合</h2><p>让我们先来简单看看什么是继承和组合。只是例子，不是概念。<br> 假设有三个特性（模块）， ModuleA, ModuleB, ModuleC。有两个类 ClassA 和 ClassB 需要使用它们。ClassA 会用到 ModuleA 和 ModuleB，ClassB  会用到全部三个特性。而且我们还假设现在全部 A，B 和 C 模块会只被 ClassA 和 ClassB 用到。  </p><p>继承：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span> &#123;  <br>    functions of ModuleA;  <br>    functions of ModuleB;  <br>&#125;;  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassB</span> extends ClassA &#123;  <br>    functions of ModuleC;  <br>&#125;;  <br></code></pre></div></td></tr></table></figure><p>组合：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModuleA</span> &#123;&#125;;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModuleB</span> &#123;&#125;;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModuleC</span> &#123;&#125;;  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span> &#123;  <br>    ModuleA ma;  <br>    ModuleB mb;  <br>&#125;;  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassB</span> &#123;  <br>    ModuleA ma;  <br>    ModuleB mb;  <br>    ModuleC mc;  <br>&#125;;  <br><br><span class="hljs-comment">//或者：  </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassB</span> &#123;  <br>    ClassA ca;  <br>    ModuleC mc;  <br>&#125;;  <br></code></pre></div></td></tr></table></figure><p>两种方法都重用了模块。</p><p>对于组合，我们一般把模块叫做组件。<br>在游戏开发中，这样的组合又叫做基于组件的实体系统。  </p><h2 id="组合比继承有哪些优势？"><a href="#组合比继承有哪些优势？" class="headerlink" title="组合比继承有哪些优势？"></a>组合比继承有哪些优势？</h2><ol><li>组合允许将问题分割成互不依赖的子元件。每个元件可以由不同的开发者开发。我们可以让三个程序员来同时开发 ModuleA， ModuleB 以及 ModuleC。</li><li>元件可以在运行时被替换，删除，或者添加（动态绑定）。与之相反，继承不能或者非常难（取决于编程语言）在运行时替换，删除，或者添加特性（静态绑定）。</li><li>组合比继承有更少的耦合。继承强制了 ClassB 和 ClassA 之间的耦合，但组合不会。</li><li>组件可以被用在其它的组合当中用以构成不同的行为。在继承中则没有办法只重用一个单个特性。继承强制了父类的所有特性被带入到了子类。</li><li>更少的代码冗余。继承比较容易导致冗余。B 继承自 A，通常 B 只需要 A 的部分特性，不需要的部分就成了冗余。如果 B 是由 A 的部分元件组合来的，那么 B 可以舍弃不需要的元件来避免冗余。</li><li>更好的封装。组合是基于公开接口的。每个元件不知道其它元件的内部细节。这正是封装所指的。而继承则把父类的内部细节（保护的接口）透露给了子类。更糟的是，子类通常会对父类做某些假设，而且父类也会假设子类会尊重它要求的接口。</li><li>容易更改。在组合中，任何元件都可以被更改而保证对其它元件影响很小，只要保持公开的接口。继承则强制了很紧密耦合的层次链。对于层次链任何节点的改变都将影响整个链。</li><li>小模块和原子模块。组合中，大的模块是由小的模块组成的，因此模块的层次可以得到控制。有可能我们只有两个层次，原子模块，和真实的功能模块，因  而层次非常平坦。在继承中，大的模块来自从小的模块继承。想要一个模块？继承吧，得到一个新的层级。这就可能造成有很多的层级，导致系统的模块层次非常复 杂且难以理解。</li></ol><h2 id="对于-“is-a”-关系我们应该用继承？是，也不是。"><a href="#对于-“is-a”-关系我们应该用继承？是，也不是。" class="headerlink" title="对于 “is a” 关系我们应该用继承？是，也不是。"></a>对于 “is a” 关系我们应该用继承？是，也不是。</h2><p>虽然我们被教导继承要 “is a”，组合要 “has a”，在很多情况下 “is a” 也可以被理解为 “has a”。比如说，程序员是一种人，所以程序员从人继承。但如果我们把程序员当成是一种具有编程工作的人，那么程序员就可以由人和编程工作来组合。  </p><h2 id="组合的不足之处："><a href="#组合的不足之处：" class="headerlink" title="组合的不足之处："></a>组合的不足之处：</h2><p>唯一的不足之处大概就是我们最终会得到非常多的模块（类）。这个很难说是不足，而且从其它角度看，这个其实是益处。对于 C++，大量的小类完全没有影响， 不会让代码变大，也不会让运行变缓慢。对于 Java，C#，Objective  C，这可能会增大代码。但除非你是工作在资源有限的设备上，这个不是大问题。  </p><h2 id="何时用组合："><a href="#何时用组合：" class="headerlink" title="何时用组合："></a>何时用组合：</h2><ol><li>当 ClassB 使用 ClassA 而不是实现 ClassA 时。</li><li>当元件会被改变时（添加，替换，删除）。</li><li>即使 ClassB 和 ClassA 具有 “is a”  的关系，如果这种关系在未来会发生变化，我们应该用组合而不是继承。一个程序员是人，但未来他可以选择别的工作，比如股票经纪。如果程序员是从人继承而  来，那么当工作变化时我们就比较麻烦。因此用组合。程序员只是一个普通的人，一个有着编程工作的普通人。</li><li>当继承不是必须的时候。没错，我们要多用组合来代替继承。</li></ol><h2 id="何时用继承："><a href="#何时用继承：" class="headerlink" title="何时用继承："></a>何时用继承：</h2><ol><li>当 ClassB 是实现 ClassA 而不是使用 ClassA。比如说，ClassA 可能是具有多态函数的抽象对话框，有着显示隐藏等函数。ClassB 是一个文件对话框需要实现这些多态函数。</li><li>当 ClassB 和 ClassA 有明显的 “is a” 关系而且这种关系不会在运行时改变时。也就是说，绑定永远是静态的。虽然猫可以被当成是一个具有动物特征和猫特征的物体，但这两个特征永远不会改变。把猫特征换成狗特征会产生狗而不是猫。所以这种绑定是静态的，关系也是固定的 “is a”，所以让猫从动物继承是很自然的。</li><li>当 ClassA 的接口也是 ClassB 的接口时。这个其实很难讲。如果用组合实现其实也可以，ClassB 可以重写代理接口来重定向到 ClassA 上。</li><li>当 ClassB 会被用到使用 ClassA 的地方时。这个也暗喻了 ClassB “is a” ClassA。 然而，对于支持类型多态（泛型编程）的语言，比如 C++，可以通过用模板类型来避免继承。</li></ol><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>我展示了我们应该多用组合而不是继承。而且如果你 google “composition inheritance”（无引号），上百万的网页会支持这个观点。但这绝不是说在组合对继承的斗争中组合是赢家。不，而且根本没有斗争。对于适当的问题我们要选择适当的方法，保证自然和逻辑性。没有什么是绝对的好或者坏，对或者错。</p>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《两周自制脚本语言》笔记 5——关于语法分析器生成器的实现</title>
    <link href="/2021/09-05%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <url>/2021/09-05%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><blockquote><p> 好像好多地方的 Literal 都拼写成 Literial 了……只能说这是一个 feature。</p></blockquote><h1 id="Parser-的组成和原理"><a href="#Parser-的组成和原理" class="headerlink" title="Parser 的组成和原理"></a>Parser 的组成和原理</h1><p>这里模仿该作者的 Parser 库，对 LL(1) 语法分析器生成器（后面都称其为 Parser）进行实现。这里因为我觉得作者的代码结构非常复杂且难以理解，因此就按照自己的意愿进行了修改。再次确认其功能——<strong>根据用户给定的匹配模式（Element 序列）对 Token 序列进行匹配，生成一定的抽象语法树</strong>。</p><p>语法分析最终生成的 AST 可以认为包含四种元素——</p><ol><li><strong>Token</strong>：来自词法分析的 Token 将会成为 ASTLeaf，即叶节点的成员，每一个叶节点都将对应一个 Token；</li><li><strong>ASTList <strong>和</strong> ASTLeaf</strong>：没有被给予更丰富信息的原始 AST 节点。ASTList 将持有一个 ASTree 的数组，ASTLeaf 将持有 Token；</li><li><strong>继承节点类</strong>：<strong>用户和库中</strong>预先定义的一些节点类，比如 NumberLiterial，WhileStatement，PrimaryExpr 等，这些类将继承 ASTList 或 ASTLeaf 类，同时对 eval 方法进行实现（这并非语法分析的范畴）。这个类群是 AST 中最重要的部分——对 AST 的编译或解释执行必须要利用其<strong>类型信息</strong>。如果想要对语言进行扩展，就必须要在该类群中编写新类，同时将其在 Parser 中引入。甚至可以要求不允许使用原生 ASTList，ASTLeaf，而必须完全使用继承节点类来构造 AST。</li><li><strong>ParserPattern</strong>：用户自定义的语法分析器，其实质是一种<strong>匹配模式</strong>，其将通过 Java 方法的链式调用对 EBNF 进行表达，同时<strong>规定其将生成的 AST 节点的根结点以及子节点的信息</strong>。</li></ol><p>Parser 所要做的，就是提供给用户这些功能——</p><ol><li>通过 Java 代码对 EBNF 进行直接描述。</li><li>在能够描述 EBNF 的基础上，能够在进行匹配时，自定义能够保留哪些内容，生成哪些内容，也就是说自定义子树序列的结构（总不能把匹配到的东西全都拿走吧？）。</li><li>在能够描述 EBNF 的基础上，能够自定义生成的子树根结点的类型，或者推断出一个类型（这里说的类型指上面的第三种元素）。</li></ol><p>这些功能总结来说，就是<strong>让用户能够根据 EBNF 和 Java 代码定义语法规则以及生成 AST 结构</strong>。</p><p>关于第 2 步的具体含义，这里举用作者的 Parser 库一个例子——对这样一个 BNF 范式——</p><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">adder : <span class="hljs-built_in">NUMBER</span> <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-built_in">NUMBER</span><br></code></pre></div></td></tr></table></figure><p>使用下面两种 Parser 代码，对字符串<code>25 + 17</code>能够生成两种不同结构的 AST——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> rule(PlusExpr.class)<br>    .number().sep(<span class="hljs-string">&quot;+&quot;</span>).number();  <span class="hljs-comment">// sep 表示匹配分隔符，因此将丢弃</span><br></code></pre></div></td></tr></table></figure><svg width="164pt" height="132pt" viewBox="0.00 0.00 164.00 131.60" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 127.6)"><title>g</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-127.6 159.9998,-127.6 159.9998,4 -4,4"></polygon><!-- ROOT --><g id="node1" class="node"><title>ROOT</title><polygon fill="none" stroke="#000000" points="43.8344,-87.1 43.8344,-123.1 111.1654,-123.1 111.1654,-87.1 43.8344,-87.1"></polygon><text text-anchor="middle" x="77.4999" y="-101" font-family="Times,serif" font-size="14.00" fill="#000000">PlusExpr</text></g><!-- LEAF_A --><g id="node2" class="node"><title>LEAF_A</title><polygon fill="none" stroke="#000000" points="0,-.5 0,-50.1 68.9998,-50.1 68.9998,-.5 0,-.5"></polygon><text text-anchor="middle" x="34.4999" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">ASTLeaf</text><polyline fill="none" stroke="#000000" points="0,-25.3 68.9998,-25.3 "></polyline><text text-anchor="middle" x="34.4999" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">token=25</text></g><!-- ROOT&#45;&gt;LEAF_A --><g id="edge1" class="edge"><title>ROOT-&gt;LEAF_A</title><path fill="none" stroke="#000000" d="M67.7425,-86.9921C63.311,-78.768 57.9193,-68.7621 52.779,-59.2225"></path><polygon fill="#000000" stroke="#000000" points="55.792,-57.4357 47.9671,-50.2927 49.6297,-60.7563 55.792,-57.4357"></polygon></g><!-- LEAF_C --><g id="node3" class="node"><title>LEAF_C</title><polygon fill="none" stroke="#000000" points="87,-.5 87,-50.1 155.9998,-50.1 155.9998,-.5 87,-.5"></polygon><text text-anchor="middle" x="121.4999" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">ASTLeaf</text><polyline fill="none" stroke="#000000" points="87,-25.3 155.9998,-25.3 "></polyline><text text-anchor="middle" x="121.4999" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">token=17</text></g><!-- ROOT&#45;&gt;LEAF_C --><g id="edge2" class="edge"><title>ROOT-&gt;LEAF_C</title><path fill="none" stroke="#000000" d="M87.4842,-86.9921C92.0188,-78.768 97.5359,-68.7621 102.7958,-59.2225"></path><polygon fill="#000000" stroke="#000000" points="105.9559,-60.7397 107.7195,-50.2927 99.826,-57.3598 105.9559,-60.7397"></polygon></g></svg><p>可以看到，这个 AST 中<code>+</code>被舍弃掉了，如果想要对这个 AST 进行计算，则必须利用 PlusExpr 这个根结点的<strong>类型信息</strong>。下面是另一种实现——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> rule(Expr.class)<br>    number().identifier(<span class="hljs-string">&quot;+&quot;</span>).number(); <span class="hljs-comment">// identifier 表示匹配且保留特定标识符</span><br></code></pre></div></td></tr></table></figure><svg width="251pt" height="132pt" viewBox="0.00 0.00 251.00 131.60" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 127.6)"><title>g</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-127.6 246.9998,-127.6 246.9998,4 -4,4"></polygon><!-- ROOT --><g id="node1" class="node"><title>ROOT</title><polygon fill="none" stroke="#000000" points="94.4999,-87.1 94.4999,-123.1 148.4999,-123.1 148.4999,-87.1 94.4999,-87.1"></polygon><text text-anchor="middle" x="121.1065" y="-101" font-family="Times,serif" font-size="14.00" fill="#000000">Expr</text></g><!-- LEAF_A --><g id="node2" class="node"><title>LEAF_A</title><polygon fill="none" stroke="#000000" points="0,-.5 0,-50.1 68.9998,-50.1 68.9998,-.5 0,-.5"></polygon><text text-anchor="middle" x="34.4999" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">ASTLeaf</text><polyline fill="none" stroke="#000000" points="0,-25.3 68.9998,-25.3 "></polyline><text text-anchor="middle" x="34.4999" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">token=25</text></g><!-- ROOT&#45;&gt;LEAF_A --><g id="edge1" class="edge"><title>ROOT-&gt;LEAF_A</title><path fill="none" stroke="#000000" d="M101.7583,-86.9921C92.145,-78.1745 80.2988,-67.3086 69.2404,-57.1654"></path><polygon fill="#000000" stroke="#000000" points="71.4829,-54.473 61.7476,-50.2927 66.7512,-59.6316 71.4829,-54.473"></polygon></g><!-- LEAF_B --><g id="node3" class="node"><title>LEAF_B</title><polygon fill="none" stroke="#000000" points="87.4578,-.5 87.4578,-50.1 155.542,-50.1 155.542,-.5 87.4578,-.5"></polygon><text text-anchor="middle" x="121.4999" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">ASTLeaf</text><polyline fill="none" stroke="#000000" points="87.4578,-25.3 155.542,-25.3 "></polyline><text text-anchor="middle" x="121.4999" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">token=+</text></g><!-- ROOT&#45;&gt;LEAF_B --><g id="edge2" class="edge"><title>ROOT-&gt;LEAF_B</title><path fill="none" stroke="#000000" d="M121.4999,-86.9921C121.4999,-79.1071 121.4999,-69.5843 121.4999,-60.4049"></path><polygon fill="#000000" stroke="#000000" points="125,-60.2927 121.4999,-50.2927 118,-60.2927 125,-60.2927"></polygon></g><!-- LEAF_C --><g id="node4" class="node"><title>LEAF_C</title><polygon fill="none" stroke="#000000" points="174,-.5 174,-50.1 242.9998,-50.1 242.9998,-.5 174,-.5"></polygon><text text-anchor="middle" x="208.4999" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">ASTLeaf</text><polyline fill="none" stroke="#000000" points="174,-25.3 242.9998,-25.3 "></polyline><text text-anchor="middle" x="208.4999" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">token=17</text></g><!-- ROOT&#45;&gt;LEAF_C --><g id="edge3" class="edge"><title>ROOT-&gt;LEAF_C</title><path fill="none" stroke="#000000" d="M141.2415,-86.9921C150.8548,-78.1745 162.701,-67.3086 173.7594,-57.1654"></path><polygon fill="#000000" stroke="#000000" points="176.2486,-59.6316 181.2522,-50.2927 171.5169,-54.473 176.2486,-59.6316"></polygon></g></svg><p>显然，这个实现更具一般性，能够表达所有的双目运算。而且还能玩花活——中间的 ASTLeaf 可以被替换成树，或者说，表达式！返回一个中缀运算符的表达式！就如同下面的 Scheme 代码一样。</p><figure class="highlight scheme"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> a-plus-abs-b (<span class="hljs-name">a</span> b)<br>  ((<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">&gt;</span></span> b <span class="hljs-number">0</span>) + -) a b))<br></code></pre></div></td></tr></table></figure><h1 id="Parser-的设计和实现"><a href="#Parser-的设计和实现" class="headerlink" title="Parser 的设计和实现"></a>Parser 的设计和实现</h1><p>Parser 库的编写包括两个部分——ParserElement，ParserPattern，其关系就像原作者代码中的 Element 和 Parser，只不过将其分离到不同文件中。</p><h2 id="ParserElement-以及一些例子"><a href="#ParserElement-以及一些例子" class="headerlink" title="ParserElement 以及一些例子"></a>ParserElement 以及一些例子</h2><p>ParserElement 表示解析器的“元素”，ParserPattern 由 ParserElement 序列组成，利用其来表示一整个模式，<strong>模式也是一种“元素”</strong>。任何 EBNF 都将表示为 ParserElement 的序列，并能够依序进行解析。</p><p>ParserElement 的定义如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ParserElement</span> &#123;<br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ASTree</span>&gt; getTargetClass(); <span class="hljs-comment">// 目标类应当是继承 ASTree 接口的，这是毋庸置疑的——它要充当 AST 中的特定节点</span><br>    Optional&lt;ASTree&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(Lexer lexer)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(Lexer lexer)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>每一个 ParserElement 都代表一种特定的匹配规则的实现，这种规则通常能够和 EBNF 中的元符号对应。ParserElement 有三个方法——getTargetClass：标识这个模式元素进行匹配后返回的 AST 子树的类型；parse：对该模式元素进行应用，通过词法分析器获取到 ASTree 并返回。这里使用了 Optional，标识其可能返回空值——就如上面示例中的 sep 方法；match：查看是否可以解析。</p><p>下面举几个示例——NumberLiterialElement，SepElement。</p><p>首先是 SepElement，它能够读取和丢弃非终结符。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 识别形如&quot;&#123;&quot;，&quot;)&quot;的终止符的 Parser 元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SepElement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ParserElement</span> &#123;<br>    String[] sepNames;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SepElement</span><span class="hljs-params">(String[] names)</span> &#123;<br>        sepNames = names;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ASTree</span>&gt; getTargetClass() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不返回结果，直接丢弃</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Optional&lt;ASTree&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!match(lexer)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParseException</span>(lexer.peek(<span class="hljs-number">0</span>));<br>        lexer.read();<br>        <span class="hljs-keyword">return</span> Optional.empty();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!lexer.peek(<span class="hljs-number">0</span>).isIdentifier())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (String name : sepNames)<br>            <span class="hljs-keyword">if</span> (Objects.equals(name, lexer.peek(<span class="hljs-number">0</span>).getText()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后是 NumberLiterialElement，它能够读取一个数值字面量并返回一个 NumberLiteral——这是预先定义的一个继承 ASTLeaf 的类——如果没有特别指定返回类型的话。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberLiteralElement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ParserElement</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ASTLeaf</span>&gt; clazz;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumberLiteralElement</span><span class="hljs-params">(Class&lt;? extends ASTLeaf&gt; clazz)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clazz = clazz;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumberLiteralElement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.clazz = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ASTree</span>&gt; getTargetClass() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.clazz;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Optional&lt;ASTree&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>        <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> Optional.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberLiteral</span>(lexer.read()));<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ASTree</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(Token.class).newInstance(lexer.read());;<br>            <span class="hljs-keyword">return</span> Optional.of(res);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> Optional.empty();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>        <span class="hljs-keyword">return</span> lexer.peek(<span class="hljs-number">0</span>).isNumber();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>显然，ParserPattern 也应当是 ParserElement——元素实际上也是一种模式，模式也可以当作一个元素来看待，其也能够和其他元素相组合成为更复杂的模式。</p><h2 id="ParserPattern"><a href="#ParserPattern" class="headerlink" title="ParserPattern"></a>ParserPattern</h2><p>ParserPattern 是最主要的类——用户通过声明和构造特定 ParserPattern 来使其能够和特定 EBNF 范式对应。ParserPattern 实际上也是一种 ParserElement，区别在于其并非是原子的，而是包括了一个 Element 序列，其本身不负责具体的匹配（但是仍旧是保存有返回类型的），而是将匹配工作<strong>委托</strong>给其 Element 序列去执行。</p><p>下面是 ParserPattern 的源代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParserPattern</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ParserElement</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;ParserElement&gt; parserElems;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ASTree</span>&gt; clazz;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ParserPattern</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ParserPattern</span><span class="hljs-params">(Class&lt;? extends ASTList&gt; rootClazz)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clazz = rootClazz;<br>        <span class="hljs-built_in">this</span>.parserElems = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ParserPattern <span class="hljs-title function_">rule</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> rule(<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ParserPattern <span class="hljs-title function_">rule</span><span class="hljs-params">(Class&lt;? extends ASTList&gt; rootClazz)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParserPattern</span>(rootClazz);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ASTree</span>&gt; getTargetClass() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.clazz;<br>    &#125;<br><br>    <span class="hljs-comment">// 可见，其将委托给 Element 序列进行匹配并返回结果</span><br>    <span class="hljs-comment">// 这里强制要求，ParserPattern 必须返回 ASTList 及其子类</span><br>    <span class="hljs-comment">// 这是非常不优雅的，解决方案有几个——要么在创建过程时就进行修正，要么在创建完成后进行操作。否则这会对求值造成影响</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Optional&lt;ASTree&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>        List&lt;ASTree&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (ParserElement elem : parserElems)<br>            elem.parse(lexer).ifPresent(res::add);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.clazz == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> Optional.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ASTList</span>(res));<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ASTree</span> <span class="hljs-variable">tmpTree</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(res.getClass()).newInstance(res);<br>            <span class="hljs-keyword">return</span> Optional.of(tmpTree);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> Optional.empty();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>        <span class="hljs-keyword">if</span> (parserElems.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> parserElems.get(<span class="hljs-number">0</span>).match(lexer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ParserPattern <span class="hljs-title function_">sep</span><span class="hljs-params">(String...sepNames)</span> &#123;<br>        parserElems.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SepElement</span>(sepNames));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ParserPattern <span class="hljs-title function_">number</span><span class="hljs-params">(Class&lt;? extends ASTLeaf&gt; clazz)</span> &#123;<br>        parserElems.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberLiteralElement</span>(clazz));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ParserPattern <span class="hljs-title function_">number</span><span class="hljs-params">()</span> &#123;<br>        parserElems.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberLiteralElement</span>(<span class="hljs-literal">null</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><span class="hljs-comment">// ....</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>ParserPattern 的使用方法上面已经描述了。匹配简单的终结符的 Element 是容易编写的，但是那些复杂的呢？对非终结符如何处理？[]，{}，|元符号该如何处理？这才是最大的考验。</p><h2 id="必须的非终结符（ast）"><a href="#必须的非终结符（ast）" class="headerlink" title="必须的非终结符（ast）"></a>必须的非终结符（ast）</h2><p>首先解决非终结符。非终结符的实现还是容易想到的——它也是用户所定义的 ParserPattern，因此它甚至都不需要另外定义，加一个方法即可——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParserPattern</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ParserElement</span> &#123;<br>    <span class="hljs-comment">// ....</span><br><span class="hljs-keyword">public</span> ParserPattern <span class="hljs-title function_">ast</span><span class="hljs-params">(ParserPattern parserPattern)</span> &#123;<br>        parserElems.add(parserPattern);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面对其进行一下测试，看能否行得通，试一个非常简单的 EBNF——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">adder : NUMBER add NUMBER<br>add   : add1<br>add1  : <span class="hljs-string">&quot;+&quot;</span><br></code></pre></div></td></tr></table></figure><p>对应的定义代码如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这里其实没必要这样定义——只有在有递归定义的时候才需要这样。但这样清晰些</span><br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">adder_</span> <span class="hljs-operator">=</span> rule();<br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">add_</span> <span class="hljs-operator">=</span> rule();<br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">add1_</span> <span class="hljs-operator">=</span> rule();<br><br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> adder_.number().ast(add_).number();<br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> add_.token(add1_);<br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">add1</span> <span class="hljs-operator">=</span> add1_.sep(<span class="hljs-string">&quot;+&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>对字符串<code>25 + 17</code>最终结果如图。</p><svg width="247pt" height="291pt" viewBox="0.00 0.00 247.00 291.20" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 287.2)"><title>g</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-287.2 242.9998,-287.2 242.9998,4 -4,4"></polygon><!-- ROOT --><g id="node1" class="node"><title>ROOT</title><polygon fill="none" stroke="#000000" points="87.3898,-246.7 87.3898,-282.7 151.61,-282.7 151.61,-246.7 87.3898,-246.7"></polygon><text text-anchor="middle" x="119.4999" y="-260.6" font-family="Times,serif" font-size="14.00" fill="#000000">ASTList</text></g><!-- LEAF_A --><g id="node2" class="node"><title>LEAF_A</title><polygon fill="none" stroke="#000000" points="0,-160.1 0,-209.7 68.9998,-209.7 68.9998,-160.1 0,-160.1"></polygon><text text-anchor="middle" x="34.4999" y="-193.1" font-family="Times,serif" font-size="14.00" fill="#000000">ASTLeaf</text><polyline fill="none" stroke="#000000" points="0,-184.9 68.9998,-184.9 "></polyline><text text-anchor="middle" x="34.4999" y="-168.3" font-family="Times,serif" font-size="14.00" fill="#000000">token=25</text></g><!-- ROOT&#45;&gt;LEAF_A --><g id="edge1" class="edge"><title>ROOT-&gt;LEAF_A</title><path fill="none" stroke="#000000" d="M100.2121,-246.5921C90.8199,-237.7745 79.2459,-226.9086 68.4417,-216.7654"></path><polygon fill="#000000" stroke="#000000" points="70.8074,-214.1856 61.1212,-209.8927 66.0162,-219.289 70.8074,-214.1856"></polygon></g><!-- LEAF_B0 --><g id="node3" class="node"><title>LEAF_B0</title><polygon fill="none" stroke="#000000" points="87.3898,-166.9 87.3898,-202.9 151.61,-202.9 151.61,-166.9 87.3898,-166.9"></polygon><text text-anchor="middle" x="119.4999" y="-180.8" font-family="Times,serif" font-size="14.00" fill="#000000">ASTList</text></g><!-- ROOT&#45;&gt;LEAF_B0 --><g id="edge2" class="edge"><title>ROOT-&gt;LEAF_B0</title><path fill="none" stroke="#000000" d="M119.4999,-246.5921C119.4999,-236.6953 119.4999,-224.2181 119.4999,-213.0786"></path><polygon fill="#000000" stroke="#000000" points="123,-212.9362 119.4999,-202.9362 116,-212.9362 123,-212.9362"></polygon></g><!-- LEAF_C --><g id="node6" class="node"><title>LEAF_C</title><polygon fill="none" stroke="#000000" points="170,-160.1 170,-209.7 238.9998,-209.7 238.9998,-160.1 170,-160.1"></polygon><text text-anchor="middle" x="204.4999" y="-193.1" font-family="Times,serif" font-size="14.00" fill="#000000">ASTLeaf</text><polyline fill="none" stroke="#000000" points="170,-184.9 238.9998,-184.9 "></polyline><text text-anchor="middle" x="204.4999" y="-168.3" font-family="Times,serif" font-size="14.00" fill="#000000">token=17</text></g><!-- ROOT&#45;&gt;LEAF_C --><g id="edge5" class="edge"><title>ROOT-&gt;LEAF_C</title><path fill="none" stroke="#000000" d="M138.7877,-246.5921C148.1799,-237.7745 159.7539,-226.9086 170.5581,-216.7654"></path><polygon fill="#000000" stroke="#000000" points="172.9836,-219.289 177.8786,-209.8927 168.1924,-214.1856 172.9836,-219.289"></polygon></g><!-- LEAF_B1 --><g id="node4" class="node"><title>LEAF_B1</title><polygon fill="none" stroke="#000000" points="87.3898,-87.1 87.3898,-123.1 151.61,-123.1 151.61,-87.1 87.3898,-87.1"></polygon><text text-anchor="middle" x="119.4999" y="-101" font-family="Times,serif" font-size="14.00" fill="#000000">ASTList</text></g><!-- LEAF_B0&#45;&gt;LEAF_B1 --><g id="edge3" class="edge"><title>LEAF_B0-&gt;LEAF_B1</title><path fill="none" stroke="#000000" d="M119.4999,-166.7921C119.4999,-156.8953 119.4999,-144.4181 119.4999,-133.2786"></path><polygon fill="#000000" stroke="#000000" points="123,-133.1362 119.4999,-123.1362 116,-133.1362 123,-133.1362"></polygon></g><!-- LEAF_B2 --><g id="node5" class="node"><title>LEAF_B2</title><polygon fill="none" stroke="#000000" points="85.4578,-.5 85.4578,-50.1 153.542,-50.1 153.542,-.5 85.4578,-.5"></polygon><text text-anchor="middle" x="119.4999" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">ASTLeaf</text><polyline fill="none" stroke="#000000" points="85.4578,-25.3 153.542,-25.3 "></polyline><text text-anchor="middle" x="119.4999" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">token=+</text></g><!-- LEAF_B1&#45;&gt;LEAF_B2 --><g id="edge4" class="edge"><title>LEAF_B1-&gt;LEAF_B2</title><path fill="none" stroke="#000000" d="M119.4999,-86.9921C119.4999,-79.1071 119.4999,-69.5843 119.4999,-60.4049"></path><polygon fill="#000000" stroke="#000000" points="123,-60.2927 119.4999,-50.2927 116,-60.2927 123,-60.2927"></polygon></g></svg><p>虽然实现了，但是这种嵌套有点离谱——这是 ParserPattern 返回 ASTList 导致的必然结果。因此对其的修改势在必行，但是现在先把所有功能都搭起来先。</p><h2 id="元符号-（or）"><a href="#元符号-（or）" class="headerlink" title="元符号|（or）"></a>元符号|（or）</h2><p>|是原始 BNF 范式中仅有的元符号。其的实现也是容易理解的——它保存一个 ParserPattern 集合。在进行匹配时，遍历集合，找到同其能够进行匹配的 ParserPattern 并利用其进行解析。考虑到这里实现的语法分析器是 LL(1) 的，因此并不考虑有多匹配的情况（这么看起来，好像 LL(k) 实现起来并不复杂）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrElement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ParserElement</span> &#123;<br>    <span class="hljs-comment">// ....</span><br><span class="hljs-keyword">private</span> ParserPattern <span class="hljs-title function_">choose</span><span class="hljs-params">(Lexer lexer)</span> &#123; <span class="hljs-comment">// 选择 parser 的方法</span><br>            <span class="hljs-keyword">for</span> (ParserPattern parser : parsers)<br>                <span class="hljs-keyword">if</span> (parser.match(lexer))<br>                    <span class="hljs-keyword">return</span> parser;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Optional&lt;ASTree&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>        <span class="hljs-type">ParserPattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> choose(lexer);<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParseException</span>(lexer.peek(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 一个都没找到说明出现语法错误</span><br>        <span class="hljs-keyword">return</span> p.parse(lexer);<br>    &#125;<br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>实验 or 的方法比较简单——处理不定长度的字符串试试。测试的 BNF 和 Java 定义如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// adder : &quot;+&quot; expr | EOL // 试了好多次，终于写出来啦……</span><br><span class="hljs-comment">// expr : NUMBER adder</span><br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">adder_</span> <span class="hljs-operator">=</span> rule();<br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">expr_</span> <span class="hljs-operator">=</span> rule();<br><br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> adder_.or(<br>    rule().token(<span class="hljs-string">&quot;+&quot;</span>).ast(expr_),<br>    rule().sep(<span class="hljs-string">&quot;\\n&quot;</span>) <span class="hljs-comment">// 似乎不使用 EBNF 的话，必须要给定空终结符才能进行这种递归…</span><br>);<br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">expr</span> <span class="hljs-operator">=</span> expr_.number().ast(adder_);<br></code></pre></div></td></tr></table></figure><p>对<code>1 + 2 + 3 + 4 + 5 + 6</code>，其生成的 AST 令人感叹——<code>(1 ((+ (2 ((+ (3 ((+ (4 ((+ (5 ((+ (6 (())))))))))))))))))</code>，图就不画了，总之验证这种写法确实达到了效果。出现这种情况的原因是 ASTList 默认的创建方式——把所有生成的 AST 节点全当成子树。</p><p>接下来还有{}元符号，[] 元符号，其分别对应 repeat 方法，maybe 和 option 方法。在这里，关于 repeat 方法需要注意的是，其是贪婪的，将会持续进行匹配直到不再合法，书中好像没有明确体现这一点。对其的实现留待之后吧。毕竟到周一啦。</p><blockquote><p>  进行了更多思考，觉得对于 Parser 的设计，应当只提供一些最基本的方法——即能够对非终结符，终结符，各种 EBNF 元符号进行表述的方法，并要求用户来提供&#x2F;自定义其他方法（无论是通过继承还是通过组合，委托都可），从而给予用户最大的可扩展性。</p></blockquote><hr><p>自上次写这玩意已经过了两个星期了，本打算另开文章再水一篇笔记，想想还是算了，同时决定从实践的角度再次重新看待我正在学习的东西。</p><p>我学习编译原理的目的并非是做出来一个通用编程语言——当前对其的学习只是为了让我能够对编程语言的底层，如符号表，作用域之类的概念能够有更加深刻的理解，仅此而已，编写新语言既困难也无必要——而是帮助我能够更好地利用编译原理的知识**编写 DSL **来辅助特定工作。考虑到我总是一头扎进技术细节里，必须时时刻刻提醒自己这一点。</p><h1 id="其他元符号"><a href="#其他元符号" class="headerlink" title="其他元符号"></a>其他元符号</h1><p>接下来的任务是解决、{}和、[] 元符号，其意义分别是：<strong>贪婪地</strong>匹配 0 次或无数次；匹配 0 次或一次。这里使用 repeat 和 maybe 为这两个元符号命名。</p><p>当前的 Stone 语言中 block 和 statement 比较典型地使用了这两个元符号——</p><figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim"><span class="hljs-keyword">block</span>: <span class="hljs-string">&quot;&#123;&quot;</span> [ statement ] &#123;(<span class="hljs-string">&quot;;&quot;</span> | <span class="hljs-type">EOL</span>) [statement]&#125; <span class="hljs-string">&quot;&#125;&quot;</span> <br>statement: <span class="hljs-string">&quot;if&quot;</span> <span class="hljs-type">expr</span> <span class="hljs-keyword">block</span> [ <span class="hljs-string">&quot;else&quot;</span> <span class="hljs-keyword">block</span> ]<br>| <span class="hljs-string">&quot;while&quot;</span> <span class="hljs-type">expr</span> <span class="hljs-keyword">block</span><br>| simple<br></code></pre></div></td></tr></table></figure><p>其在作者的 Java 代码表述如下。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Parser</span> <span class="hljs-variable">block</span> <span class="hljs-operator">=</span> rule(BlockStmnt.class)<br>    .sep(<span class="hljs-string">&quot;&#123;&quot;</span>).option(statement0)<br>    .repeat(rule().sep(<span class="hljs-string">&quot;;&quot;</span>, Token.EOL).option(statement0))<br>    .sep(<span class="hljs-string">&quot;&#125;&quot;</span>);<br><span class="hljs-type">Parser</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> statement0.or(<br>    rule(IfStmnt.class).sep(<span class="hljs-string">&quot;if&quot;</span>).ast(expr).ast(block)<br>    .option(rule().sep(<span class="hljs-string">&quot;else&quot;</span>).ast(block)),<br>    rule(WhileStmnt.class).sep(<span class="hljs-string">&quot;while&quot;</span>).ast(expr).ast(block),simple);<br></code></pre></div></td></tr></table></figure><h2 id="元符号、-——repeat"><a href="#元符号、-——repeat" class="headerlink" title="元符号、{}——repeat"></a>元符号、{}——repeat</h2><p>首先需要明确，repeat 和 maybe 解析的结果是什么？这是容易想到的——repeat 应当返回一个 ASTList，因为其可能匹配多次，需要保存这无数次匹配之结果，maybe 可以返回一个 ASTLeaf，也可以返回一个 ASTList，通过其子树数量为 0 还是 1 来表示其是否匹配到了，这里使用 ASTList。</p><blockquote><p>  <code>expr : factor &#123; OP factor &#125;</code>也是一个、{}符号使用的一个典型例子，但是对其不适合直接使用 repeat 方法：能拿它的解析结果——一个 factor 和一个 ASTList——整什么花活？它生成的 AST 没有任何意义！比如对<code>1 + 2 * 3 + 4 / 5</code>，它将生成<strong>类似</strong>这样的 AST，它显然是没有任何价值的——</p><p>  <img src="/images/oss/20210904214746.svg"></p><p>  为此，作者专门提供了 expression 方法用来对表达式进行描述。其使用了算符优先分析法。这个在之后再进行实现（大概罢！）。</p></blockquote><p>repeat 的实现仍旧是简单的——匹配过程中维护一个 ASTree 的 List，不断循环进行匹配，保存匹配结果直到无法再匹配下去，然后返回一个以该 List 为子树集合的 ASTList。其关键 Java 代码如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Optional&lt;ASTree&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>    <span class="hljs-type">ASTList</span> <span class="hljs-variable">lst</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASTList</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    <span class="hljs-keyword">while</span> (pattern.match(lexer)) &#123; <span class="hljs-comment">// 贪婪！</span><br>        lst.children().add(pattern.parse(lexer).get());<br>    &#125;<br>    <span class="hljs-keyword">return</span> Optional.of(lst);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对前面实现过的四则运算语言，其将这样表述——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    factor:NUMBER | &quot;(&quot; expr &quot;)&quot;</span><br><span class="hljs-comment">    term:factor &#123; (&quot;*&quot; | &quot;/&quot;) factor &#125;</span><br><span class="hljs-comment">    expr:term &#123; (&quot;+&quot; | &quot;-&quot;) term &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">factor_</span> <span class="hljs-operator">=</span> rule();<br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">term_</span> <span class="hljs-operator">=</span> rule();<br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">expr_</span> <span class="hljs-operator">=</span> rule();<br><br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> factor_.or(<br>    rule().number(),<br>    rule().sep(<span class="hljs-string">&quot;(&quot;</span>).ast(expr_).sep(<span class="hljs-string">&quot;)&quot;</span>)<br>);<br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">term</span> <span class="hljs-operator">=</span> term_.ast(factor_).repeat(rule().token(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>).ast(factor_));<br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">expr</span> <span class="hljs-operator">=</span> expr_.ast(term_).repeat(<br>    rule().or(rule().token(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>).ast(term_))<br>);<br></code></pre></div></td></tr></table></figure><p>下图展示了<code>1 + 2 * 3</code>，<code>1 * 2 + 3</code>“修剪”后所代表 AST，可以看到其优先级确实被表达了，且其结构较为规整，通过后序遍历仍旧可以得到结果——</p><p><img src="/images/oss/20210904234812.svg"></p><p>显然，repeat 的局限性很大——它生成的 AST 结构有时候会比较复杂，难以理解。因此应当被用到<strong>有序并列</strong>结构的表达，如代码块中各语句，就极其适合使用 repeat。</p><h2 id="元符号、-——maybe"><a href="#元符号、-——maybe" class="headerlink" title="元符号、[]——maybe"></a>元符号、[]——maybe</h2><p>既然 repeat 已经能够实现，maybe 的实现也不是问题——匹配到就匹配到，匹配不到就给个空的 ASTList。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">ASTree</span>&gt; <span class="hljs-title function_">parse</span>(<span class="hljs-params">Lexer lexer</span>) &#123;<br><span class="hljs-keyword">if</span> (pattern.<span class="hljs-title function_">match</span>(lexer))<br>    <span class="hljs-keyword">return</span> pattern.<span class="hljs-title function_">parse</span>(lexer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Optional</span>.<span class="hljs-title function_">of</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ASTList</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()));<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">Lexer lexer</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在实现一个 if-then-else 进行测试。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ifStmnt : &quot;if&quot; expr &quot;then&quot; expr [&quot;else&quot; expr]</span><br><span class="hljs-type">ParserPattern</span> <span class="hljs-variable">ifStmnt</span> <span class="hljs-operator">=</span> <br>    rule().sep(<span class="hljs-string">&quot;if&quot;</span>).ast(expr).sep(<span class="hljs-string">&quot;then&quot;</span>).ast(expr)<br>    .maybe(rule().sep(<span class="hljs-string">&quot;else&quot;</span>).ast(expr));<br></code></pre></div></td></tr></table></figure><p>其生成 AST 是可以预料的，因此不进行展示。</p><blockquote><p>  决定就到这里，虽然对这个语法分析器生成器的实现很不满意，但是我认为没必要钻得更深，使用现成的如 JavaCC 之类的开源工具即可。对这本书的学习也告一段落，去研究 DSL 去，这对框架编写可能会有帮助。</p></blockquote><p><img src="/images/oss/20210822231117.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 graphviz 的使用（残卷）</title>
    <link href="/2021/08-21%E5%85%B3%E4%BA%8Egraphviz%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <url>/2021/08-21%E5%85%B3%E4%BA%8Egraphviz%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>最近学习编译原理，苦于使用 draw.io 这样的软件绘制示意图的时候特别麻烦，于是试图找到更为简单的方案，而 <a href="https://graphviz.org/">graphviz</a> 就是一个很舒爽的解决方案——它提供了一个名为 dot 的 DSL 用以生成 svg，png 以及其他图像格式的文件。所以这里对它进行一些学习。这软件或许在其他地方也能够使用，比如绘制流程图，状态转移图之类的时候。</p><p>先尝尝鲜——下面是一个表示<code>(19+2)*2</code>的语法树的 dot 代码——</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dot">// 单行和多行注释同 Java<br>// graph 定义无向图<br>graph &#123;<br>    // 节点可以预先定义，也可以直接进行使用，这时其显示的内容就是其名称<br>    MUL [label=&quot;*&quot;]; // [] 中的内容对节点进行描述，显然这里定义了节点所显示的标签<br>    PLUS [label=&quot;+&quot;];<br>    NUM2 [label=2];<br>    NUM2_1 [label=2];<br><br>    PLUS -- NUM2; // --标识相连，绘制树的话，左边深度较浅<br>    PLUS -- 19;  // 直接定义和描述了一个新节点<br>    MUL -- &#123;PLUS NUM2_1&#125;; // 等价于 MUL -- PLUS; MUL -- NUM2_1;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其使用 dot 生成的对应的图如下——</p><svg width="170pt" height="188pt" viewBox="0.00 0.00 170.00 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)"><title>%0</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-184 166,-184 166,4 -4,4"></polygon><!-- MUL --><g id="node1" class="node"><title>MUL</title><ellipse fill="none" stroke="#000000" cx="99" cy="-162" rx="27" ry="18"></ellipse><text text-anchor="middle" x="99" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">*</text></g><!-- PLUS --><g id="node2" class="node"><title>PLUS</title><ellipse fill="none" stroke="#000000" cx="63" cy="-90" rx="27" ry="18"></ellipse><text text-anchor="middle" x="63" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">+</text></g><!-- MUL&#45;&#45;PLUS --><g id="edge3" class="edge"><title>MUL--PLUS</title><path fill="none" stroke="#000000" d="M90.2854,-144.5708C84.6253,-133.2506 77.2784,-118.5568 71.6343,-107.2687"></path></g><!-- NUM2_1 --><g id="node4" class="node"><title>NUM2_1</title><ellipse fill="none" stroke="#000000" cx="135" cy="-90" rx="27" ry="18"></ellipse><text text-anchor="middle" x="135" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">2</text></g><!-- MUL&#45;&#45;NUM2_1 --><g id="edge4" class="edge"><title>MUL--NUM2_1</title><path fill="none" stroke="#000000" d="M107.7146,-144.5708C113.3747,-133.2506 120.7216,-118.5568 126.3657,-107.2687"></path></g><!-- NUM2 --><g id="node3" class="node"><title>NUM2</title><ellipse fill="none" stroke="#000000" cx="27" cy="-18" rx="27" ry="18"></ellipse><text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">2</text></g><!-- PLUS&#45;&#45;NUM2 --><g id="edge1" class="edge"><title>PLUS--NUM2</title><path fill="none" stroke="#000000" d="M54.2854,-72.5708C48.6253,-61.2506 41.2784,-46.5568 35.6343,-35.2687"></path></g><!-- 19 --><g id="node5" class="node"><title>19</title><ellipse fill="none" stroke="#000000" cx="99" cy="-18" rx="27" ry="18"></ellipse><text text-anchor="middle" x="99" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">19</text></g><!-- PLUS&#45;&#45;19 --><g id="edge2" class="edge"><title>PLUS--19</title><path fill="none" stroke="#000000" d="M71.7146,-72.5708C77.3747,-61.2506 84.7216,-46.5568 90.3657,-35.2687"></path></g></svg><p>说使用 dot 生成，是因为 graphviz 实际上提供了多种命令来生成图，其代表各种不同的<strong>布局引擎</strong>，其各有特点——</p><table><thead><tr><th>命令</th><th>特性</th></tr></thead><tbody><tr><td>dot</td><td>渲染的图具有明确方向性。</td></tr><tr><td>neato</td><td>渲染的图缺乏方向性。</td></tr><tr><td>twopi</td><td>渲染的图采用放射性布局。</td></tr><tr><td>circo</td><td>渲染的图采用环型布局。</td></tr><tr><td>fdp</td><td>渲染的图缺乏方向性。</td></tr><tr><td>sfdp</td><td>渲染大型的图，图片缺乏方向性。</td></tr></tbody></table><p>下面通过一些实例和注释描述其使用。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>这里试图展示 Lisp 中的 cons&#x2F;list 的结构。一般来说这种结构使用所谓的“箱子表示法 ”（box notation），如下图来自《ANSI Common Lisp》。</p><p><img src="/images/oss/20210821222756.png"></p><p>这里，每一个 node 都有两个“箱子”（之后都这么称呼），dot 中使用 record 类型的 shape 可以让 node 如此展示。其使用方法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dot">digraph g &#123;<br>    node [shape = record]; // 可以使用这种方法设定所有 node 的属性<br>    node0[label = &quot;&#123;\&lt;interface\&gt; \n AInterface| |+ hello():void&#125;&quot;];  // 可以使用一些标识符<br>    node1[label = &quot;&lt;f0&gt; A|&lt;f1&gt; BCD&quot;]; <br>    node0 -&gt; node1:f0;<br>&#125;<br></code></pre></div></td></tr></table></figure><svg width="112pt" height="173pt" viewBox="0.00 0.00 112.19 173.20" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 169.2)"><title>g</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-169.2 108.1896,-169.2 108.1896,4 -4,4"></polygon><!-- node0 --><g id="node1" class="node"><title>node0</title><polygon fill="none" stroke="#000000" points="0,-73.5 0,-164.7 93.4928,-164.7 93.4928,-73.5 0,-73.5"></polygon><text text-anchor="middle" x="46.7464" y="-148.1" font-family="Times,serif" font-size="14.00" fill="#000000">&lt;interface&gt; </text><text text-anchor="middle" x="46.7464" y="-131.3" font-family="Times,serif" font-size="14.00" fill="#000000"> AInterface</text><polyline fill="none" stroke="#000000" points="0,-123.1 93.4928,-123.1 "></polyline><text text-anchor="middle" x="46.7464" y="-106.5" font-family="Times,serif" font-size="14.00" fill="#000000"> </text><polyline fill="none" stroke="#000000" points="0,-98.3 93.4928,-98.3 "></polyline><text text-anchor="middle" x="46.7464" y="-81.7" font-family="Times,serif" font-size="14.00" fill="#000000">+ hello():void</text></g><!-- node1 --><g id="node2" class="node"><title>node1</title><polygon fill="none" stroke="#000000" points="33.3032,-.5 33.3032,-36.5 104.1896,-36.5 104.1896,-.5 33.3032,-.5"></polygon><text text-anchor="middle" x="46.3565" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">A</text><polyline fill="none" stroke="#000000" points="59.4098,-.5 59.4098,-36.5 "></polyline><text text-anchor="middle" x="81.7997" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">BCD</text></g><!-- node0&#45;&gt;node1 --><g id="edge1" class="edge"><title>node0-&gt;node1:f0</title><path fill="none" stroke="#000000" d="M46.7464,-73.2248C46.7464,-64.632 46.7464,-55.5681 46.7464,-46.7299"></path><polygon fill="#000000" stroke="#000000" points="50.2465,-46.5 46.7464,-36.5 43.2465,-46.5 50.2465,-46.5"></polygon></g></svg><p>上面的代码试图展示一个 UML 类图。需要注意的是 node0 中 label 的内容。其包含三个元符号——{}，&lt;&gt;和|。</p><p>其中，|可以认为是各个箱子的分隔符；{}则是对特定数量箱子起作用，其将更改箱子排列的方向（这个元符号用以构造结构更为复杂的箱子）。&lt;&gt;用来定义“锚点”，使可以被 edge 所引用。</p><p>为实现箱型表示法，还有一点需要实现——默认排列是从上到下的，需要改成从左到右，这是通过 graph 的 rankdir 属性实现的。需要注意的是，rankdir 会改变 record 的默认方向。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dot">digraph g &#123;<br>    rankdir=LR;// 方向<br>    node [shape = record]; // 默认所有 node 都是 record<br>    edge [tailclip=false]; // edge 不会被 clip——这是为了保证箭头从内部伸出<br>    node0[label = &quot;&#123;a | &lt;A&gt;&#125;&quot;]; <br>    node1_0[label = &quot;&#123;&lt;A&gt;|&lt;B&gt;&#125;&quot;];<br>    node1_1[label = &quot;&#123;b|&lt;B&gt;&#125;&quot;];<br>    node2[label = &quot;&#123;c|nil&#125;&quot;];<br>    node3[label = &quot;&#123;d|nil&#125;&quot;];<br>    node0:A:c -&gt; node1_0; // :c 是 node 默认提供的“锚点”，表示从中心开始<br>    node1_0:A:c -&gt; node1_1;<br>    node1_1:A:c -&gt; node2;<br>    node1_0:B:c -&gt; node3;<br>    // &#123;rank=same;node1_0;node1_1;&#125; 这玩意有 bug，对 record 会报错！<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/images/oss/20210821235744.png"></p><p>……看起来要表达规则的图形的时候这玩意并不太适合。</p><blockquote><p>  先就这样吧……这玩意出现的 bug 浇灭了我继续的兴趣。反正当前学到的东西足够画 AST 了。</p></blockquote><p><img src="/images/oss/20210814203458.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Graphviz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《两周自制脚本语言》笔记 4——Stone 语法的设计</title>
    <link href="/2021/08-21%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94Stone%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1.html"/>
    <url>/2021/08-21%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94Stone%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><h1 id="Stone-语法的设计"><a href="#Stone-语法的设计" class="headerlink" title="Stone 语法的设计"></a>Stone 语法的设计</h1><p>借助 BNF，现在对 Stone 语言进行设计。首先确认程序中的终结符——程序终究要“收敛”到终结符的集合——NUMBER，IDENTIFIER，STRING，OP，EOL，其分别代表整型字面量、标识符、字符串字面量、双目运算符、换行符。</p><blockquote><p>  显然，双目运算符应当从标识符中分化出来……或是说修改 Token？</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">primary: <span class="hljs-string">&quot;(&quot;</span> expr <span class="hljs-string">&quot;)&quot;</span> | NUMBER | IDENTIFIER | STRING<br><span class="hljs-built_in">factor</span>: <span class="hljs-string">&quot;-&quot;</span> primary | primary<br>expr: <span class="hljs-built_in">factor</span> &#123; OP <span class="hljs-built_in">factor</span> &#125;<br><span class="hljs-built_in">block</span>: <span class="hljs-string">&quot;&#123;&quot;</span> [ statement ] &#123;(<span class="hljs-string">&quot;;&quot;</span> | EOL) [statement]&#125; <span class="hljs-string">&quot;&#125;&quot;</span> # 这个 <span class="hljs-built_in">block</span> 合法吗？感觉在<span class="hljs-string">&quot;&#125;&quot;</span>前需要一个&#123;<span class="hljs-string">&quot;;&quot;</span> | EOL&#125;，还是说识别时，其中的 Token 会被忽略？<br>simple: expr<br>statement: <span class="hljs-string">&quot;if&quot;</span> expr <span class="hljs-built_in">block</span> [ <span class="hljs-string">&quot;else&quot;</span> <span class="hljs-built_in">block</span> ]<br>| <span class="hljs-string">&quot;while&quot;</span> expr <span class="hljs-built_in">block</span><br>| simple<br><span class="hljs-built_in">program</span>: [ statement ](<span class="hljs-string">&quot;;&quot;</span> | EOL) # 单行语句，或者 <span class="hljs-built_in">block</span> 外的语句<br></code></pre></div></td></tr></table></figure><ul><li>primary：最基本的“值”。</li><li>factor：这里的目的是引入负数操作符。</li><li>expr：表达式——程序最基本的表达部分。</li><li>block：代码块。</li><li>simple：expr 的别名。</li><li>statement：所谓的语句，这里只实现了 if，while，以及表达式（我们知道，表达式也是语句，可以独立地作为一行出现，虽然其没有任何意义）。</li><li>program：单个语句。</li></ul><p>该书作者编写了通过 Java 代码生成语法分析器的库，这里先不究其细节（在将来再去研究！），直接去研究，statement 生成如何的 AST，如何去求值。</p><h1 id="生成-AST"><a href="#生成-AST" class="headerlink" title="生成 AST"></a>生成 AST</h1><p>语句所生成的 AST 非常类似，下面展示了一些语句的 AST。</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">if</span> a == <span class="hljs-number">100</span> &#123;<br><span class="hljs-number">3</span> + <span class="hljs-number">4</span>;<br><span class="hljs-number">100</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">200</span> + <span class="hljs-number">300</span> * <span class="hljs-number">400</span><br>&#125;<br><span class="hljs-comment">// =&gt; (if (a == 100) ((3 + 4) 100) else ((200 + (300 * 400)))) </span><br></code></pre></div></td></tr></table></figure><p>为了生成 AST，需要对每一种可能的<strong>语句</strong>进行定义——其最终都会作为 AST 中一个子树存在。这段代码出现了如下语句定义——</p><ul><li>IfStatement：其子树包含 Condition 表达式，thenCondition 语句块，elseCondition 语句块（可选）。</li><li>BlockStatement：语句块，其子树包含任意数量的语句。</li><li>BinaryExpr：其子树包含 Left 表达式，Op 运算符，Right 表达式。</li><li>以及一些“值”，这里不表。</li></ul><p>考虑到这些语句所拥有的子树数量是不一致，甚至是不确定的，因此不能采用固定的树形结构。这里为图简易，使用 List 来保存子树，并给定访问特定子树（子语句）的方法。</p><h1 id="Parser-原理"><a href="#Parser-原理" class="headerlink" title="Parser 原理"></a>Parser 原理</h1><p>作者编写的库提供了一切这里所需的方法，使能够生成正确的子树，这其中包括获取正确的根结点，以及生成正确的子树的集合。比如，通过其表述的 block 的 parser 如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Parser</span> <span class="hljs-variable">block</span> <span class="hljs-operator">=</span> rule(BlockStmnt.class) <span class="hljs-comment">// rule 方法指定根结点的类型，每种类型都应当有自己的处理方法</span><br>        .sep(<span class="hljs-string">&quot;&#123;&quot;</span>).option(statement0) <span class="hljs-comment">// option 和 repeat 方法都将获取非终结符作为子树（也就是将结果添加到 list 中）！</span><br>        .repeat(rule().sep(<span class="hljs-string">&quot;;&quot;</span>, Token.EOL).option(statement0))<br>        .sep(<span class="hljs-string">&quot;&#125;&quot;</span>);<br><br><span class="hljs-type">Parser</span> <span class="hljs-variable">program</span> <span class="hljs-operator">=</span> rule().or(statement, rule(NullStmnt.class)).sep(<span class="hljs-string">&quot;;&quot;</span>, Token.EOL); <span class="hljs-comment">// 如果 rule 没有 Class 参数，则说明其只是一个“中间产物”——它的根结点为普通的节点类型，也就是说不保存任何内容</span><br></code></pre></div></td></tr></table></figure><p>每一个 Parser 都拥有两个成员——AST 工厂和 Element 数组，其中，Element 数组为保存所有匹配模式的集合——所有模式！它要保存用于进行语法分析的一切模式，除 rule 外任何方法都将“充实”这个集合，比如下面列出了读取非终结符和读取分隔符的方法，其中 Skip 和 Tree 都是 Element。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Parser <span class="hljs-title function_">sep</span><span class="hljs-params">(String... pat)</span> &#123;<br>    elements.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Skip</span>(pat)); <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><span class="hljs-keyword">public</span> Parser <span class="hljs-title function_">ast</span><span class="hljs-params">(Parser p)</span> &#123;<br>    elements.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>(p));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一切 Element 都负责进行特定的模式匹配——Skip 将匹配并丢弃特定的标识符，Tree 将持有一个 Parser，用来匹配非终结符……这样的 Element 的序列就能够负责特定 Parser 的解析工作。</p><p>AST 工厂为利用 Element 序列构造 AST 节点的类。其主要操作是统一的——根据 Class 动态构造工厂；获取构造函数；通过特定输入参数和构造函数构造 AST 节点。需要这样实现的原因是进行抽象——不同 AST 节点的构造函数可能是不同的，这就意味着其不能通过接口来对节点的创建方法进行约束（如果硬要这么干，那这方法的输入参数得是 Object，而这是非常不好的）。</p><blockquote><p>  为什么要这么干？我的第一想法是无论是语句还是原子，全都使用同一种输入，即 AST 节点序列，原子使用特定标识，其有且仅有一个子树。这样似乎是合法的……就像 haskell 那样，一切皆函数，只不过这个函数不接受参数，返回常值而已。并且这样生成的 AST 在之后还能被优化成和使用书上方法所生成 AST 一致。</p></blockquote><p>下面展示了生成 AST 工厂的静态方法——rule 方法将会间接调用该方法。如果传入 class，将生成构造该类型 AST 节点的工厂；如果不传入 Class，则 clazz 为 null，因此 get 方法返回 null，最后生成的 AST 子树的根节点将没有特定类型。</p><blockquote><p>  怀疑这里的描述可能会有错误。等之后手写语法分析器的时候再思考吧！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Factory <span class="hljs-title function_">getForASTList</span><span class="hljs-params">(Class&lt;? extends ASTree&gt; clazz)</span> &#123;<br>    <span class="hljs-type">Factory</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> get(clazz, List.class);<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory</span>() &#123;<br>            <span class="hljs-keyword">protected</span> ASTree <span class="hljs-title function_">make0</span><span class="hljs-params">(Object arg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                List&lt;ASTree&gt; results = (List&lt;ASTree&gt;) arg;<br>                <span class="hljs-keyword">if</span> (results.size() == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> results.get(<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASTList</span>(results);<br>            &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可见，其如果其只有一个子树，则其将忽略该根结点，直接返回其子树（许多 Parser 都依赖这一行为来减少树深度！）；如果有多个子树，则原样返回——也就是说最后构造的子树的根结点是原始的 ASTList 实例。</p><p>下面展示了<code>x + -y</code>的 AST，这书又犯了错误——<strong>左右写反了</strong>。</p><p><img src="/images/oss/20210821010212.png"></p><p>再比如，下面图片（<strong>根结点应当为 ASTList！这书为什么总是犯错误？</strong>）中，对应的 BNF 为<code>adder: NUMBER &quot;+&quot; NUMBER</code>，其根结点没有任何多余信息（<strong>这让我想起 Lisp 的 quote</strong>)。</p><p><img src="/images/oss/20210821005158.png"></p><p>该框架在进行表达式识别的时候能够方便地规定运算符的优先级以及结合性（左结合，右结合），它使用的是算符优先分析法（之前有提到过），这也是之后需要去了解下的。</p><p>这里对 Stone 的语法以及进行了一些描述，接下来是 AST 的解释执行——实际上就是根据各个子树的根结点的类型，编写相应 eval 方法并递归执行直到得到结果。其中，有的将利用其副作用——输出，变量&#x2F;函数定义、赋值等，有的则将利用其返回值。副作用是一个语言所必须的东西——否则它不会对外界造成任何影响，自然也不会有任何意义。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《两周自制脚本语言》笔记 3——LL(1) 语法分析及一个四则运算语言的实现</title>
    <link href="/2021/08-19%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94LL(1)%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%8F%8A%E4%B8%80%E4%B8%AA%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <url>/2021/08-19%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94LL(1)%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%8F%8A%E4%B8%80%E4%B8%AA%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>前面提到使用 BNF 来进行语法分析，实际上正则表达式也可用作语法表述，其能够表达部分 BNF 定义的语法（我们知道，正则表达式不能表达一些嵌套或递归的语法，比如括号匹配）。正则表达式表述的语法称为<strong>正则文法</strong>，BNF 表述的语法成为<strong>上下文无关文法</strong>。</p><p>正则用于字符串匹配，BNF 用于 Token 序列匹配，但若是将一个个字符作为 Token 看待，则 BNF 可以和正则本质相同——都是模式匹配。比如下面是一个例子。这里，number 可以是<code>digit</code>，可以是<code>digit digit</code>，可以是<code>digit digit digit</code>… 总之能够这样无限展开，无限递归下去。</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+ <span class="hljs-comment"># 或 [0-9][0-9]*</span><br>digit: <span class="hljs-string">&quot;0&quot;</span> | <span class="hljs-string">&quot;1&quot;</span> | <span class="hljs-string">&quot;2&quot;</span> | ... | <span class="hljs-string">&quot;8&quot;</span> | <span class="hljs-string">&quot;9&quot;</span><br><span class="hljs-built_in">number</span>: digit | digit <span class="hljs-built_in">number</span> <span class="hljs-comment"># 使用 EBNF 的话就是 digit &#123; digit &#125; ……兄啊这不是数字啊</span><br></code></pre></div></td></tr></table></figure><p>能够像 number 这样进行<strong>尾部递归</strong>，或者<strong>循环展开</strong>的定义都可以通过正则文法表示。但若是像<code>expr : &quot;(&quot; expr &quot;)&quot; | ...</code>这样的就无法通过正则表达了。</p><h1 id="语法分析的算法"><a href="#语法分析的算法" class="headerlink" title="语法分析的算法"></a>语法分析的算法</h1><p>如果某种 BNF 定义的语法不是正则文法，则必须使用特定算法进行语法分析。</p><p>常见的语法分析算法可以分为<strong>向上分析算法</strong>和<strong>向下分析算法</strong>，其分别称为<strong>自底向上语法分析</strong>和<strong>自顶向下语法分析</strong>。</p><p>向上分析算法首先组合相邻单词，创建子表达式，并逐步组合，构造出整体结构，LR（Left-to-right，Rightmost derivation）算法是一个著名的自底向上分析算法，但其实现比较复杂。著名的 yacc 使用 LALR 语法分析。（gcc，JavaCC 使用什么算法？）</p><p>向下分析算法则是从整体结构开始向下分析。LL 语法分析（Left-to-right，Leftmost derivation）是其代表。LL 语法分析实现简单，是<strong>利用递归调用</strong>实现的<strong>递归下降语法分析器</strong>。</p><p>在学习编译原理时（我们好像只学了递归下降语法分析？），曾看到过 LL(1) 这样的术语，其意义为使用向下分析算法，但仅允许<strong>预读</strong>一次。LL(k) 似乎能满足大部分需要。关于预读的意义，这里先不阐述。</p><h1 id="四则运算的-LL-1-语法"><a href="#四则运算的-LL-1-语法" class="headerlink" title="四则运算的 LL(1) 语法"></a>四则运算的 LL(1) 语法</h1><p>下面对四则运算的 LL(1) 递归下降分析进行实现。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">factor</span>:NUMBER | <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-built_in">expr</span> <span class="hljs-string">&quot;)&quot;</span><br>term:<span class="hljs-built_in">factor</span> &#123; (<span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;/&quot;</span>) <span class="hljs-built_in">factor</span> &#125;<br><span class="hljs-built_in">expr</span>:term &#123; (<span class="hljs-string">&quot;+&quot;</span> | <span class="hljs-string">&quot;-&quot;</span>) term &#125;<br></code></pre></div></td></tr></table></figure><p>再次确认——语法分析的意义是什么？生成抽象语法树。四则运算的抽象语法树是容易理解的——每一个子树都以加减乘除为根结点，以值为子树（或者只有一个值），其结果为一个值。</p><p>自底向下分析的大体流程是什么？前面说到，是“从整体结构向下分析”。也就是说，首先将源代码（Token 序列）看作一个整体——在这里当然是 expr 了，然后通过这个整体不断细分，尝试划分出更细的“单元”，这个过程同时也是不断构造 AST 的过程，直到完全由终结符组成。</p><h1 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h1><p>其的代码实现也是容易的——每个非终结符都对应一个函数&#x2F;方法，其将试图获取 Token，查看其是否匹配其对应的模式。其中，{}和|元符号也是能够转换成相应的代码模式的。比如，下面展示了 term 方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ASTree <span class="hljs-title function_">term</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ASTree</span> <span class="hljs-variable">leftOrRootTree</span> <span class="hljs-operator">=</span> factor(); <span class="hljs-comment">// 根据 BNF 来的。这里故意使用了长命名，因为 term 可能有两种情况——如果后面接了操作符，则这个变量将为生成的 AST 的左结点（为什么？因为四则运算符的语法树就是这样！），如果后面没接操作符，那么这个变量的值就为生成 AST 的根结点</span><br>    <span class="hljs-keyword">while</span> (isToken(<span class="hljs-string">&quot;*&quot;</span>) || isToken(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        <span class="hljs-type">ASTree</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASTree</span>(readAToken());<br>        <span class="hljs-type">ASTree</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> factor();<br>        leftOrRootTree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryExpr</span>(leftOrRootTree, op, right); <span class="hljs-comment">// 递归定义，无论哪次迭代，leftOrRootTree 总为根结点，而前次的 leftOrRootTree 则为本次的左子树。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> leftOrRootTree;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>该方法首先调用 factor 方法——对 factor 非终结符进行识别的方法。这方法将会通过词法分析器读取一个或多个 Token 并试图获取一个 factor。获取后返回结果——也就是说，它是有副作用的（！）。</p><blockquote><p>   需要注意的是，读取 Token 后，词法分析器的“指针”将会移动。isToken 方法除外——它只负责“瞧”一下指针当前所处位置的 Token。</p></blockquote><p>获取一个 factor 后，其有两种可能——这个 term 已经结束了，可直接返回；这 term 还有内容，需要进一步操作。究竟是哪种可能，看一眼其后的 token 便可——如果它是乘号或除号，则必定仍旧有内容，需要继续操作。</p><blockquote><p>  看来，在编写语法分析树的时候，需要考虑最后拿到的 Token 要生成怎样的 AST。就比如这里操作符是放在中间的，如果是 lisp 那样的前缀表达式，运算符就放到第一个了（但生成的 AST 还是一样的）</p></blockquote><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>下面是四则运算的语法分析器的全部代码。在这里，所谓的预读指的就是 peek 方法。为了能够进行分支，语法分析必须进行预读。这里只调用了 peek(0)——其的意义是获取<strong>下一个</strong>会获取到的 Token，**因此该实现为 LL(1)**。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 负责四则运算的语法分析器——实际工作中不应当使用这种方式，而是通过工具生成</span><br><span class="hljs-comment">// 这里不为 Token 进行更复杂抽象——书中抽象出了双目运算符进行使用，仅通过原始 ASTree 对象进行使用。</span><br><span class="hljs-comment">// 这里的 AST 是一个典型的二叉树，节点的值为 Token</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExprParser</span> &#123;<br>    <span class="hljs-keyword">private</span> Lexer lexer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ExprParser</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lexer = lexer;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ASTree <span class="hljs-title function_">parse</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> expr();<br>    &#125;<br><br><span class="hljs-comment">// expr:term &#123; (&quot;+&quot; | &quot;-&quot;) term &#125;</span><br>    <span class="hljs-keyword">public</span> ASTree <span class="hljs-title function_">expr</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ASTree</span> <span class="hljs-variable">leftOrRootTree</span> <span class="hljs-operator">=</span> term();<br>        <span class="hljs-keyword">while</span> (isIdentifierNamed(<span class="hljs-string">&quot;+&quot;</span>) || isIdentifierNamed(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>            <span class="hljs-type">Token</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> lexer.read();<br>            <span class="hljs-type">ASTree</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> term();<br>            leftOrRootTree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASTree</span>(op, leftOrRootTree, right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftOrRootTree;<br>    &#125;<br>        <br><span class="hljs-comment">// term:factor &#123; (&quot;*&quot; | &quot;/&quot;) factor &#125;</span><br>    <span class="hljs-keyword">public</span> ASTree <span class="hljs-title function_">term</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ASTree</span> <span class="hljs-variable">leftOrRootTree</span> <span class="hljs-operator">=</span> factor();<br>        <span class="hljs-keyword">while</span> (isIdentifierNamed(<span class="hljs-string">&quot;*&quot;</span>) || isIdentifierNamed(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>            <span class="hljs-type">Token</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> lexer.read();<br>            <span class="hljs-type">ASTree</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> factor();<br>            leftOrRootTree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASTree</span>(op, leftOrRootTree, right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftOrRootTree;<br>    &#125;<br>    <span class="hljs-comment">// factor:NUMBER | &quot;(&quot; expr &quot;)&quot;</span><br>    <span class="hljs-keyword">public</span> ASTree <span class="hljs-title function_">factor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Token</span> <span class="hljs-variable">nextToken</span> <span class="hljs-operator">=</span> lexer.peek(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (nextToken.isNumber()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASTree</span>(lexer.read());<br>        ignoreToken(<span class="hljs-string">&quot;(&quot;</span>);<br>        <span class="hljs-type">ASTree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> expr();<br>        ignoreToken(<span class="hljs-string">&quot;)&quot;</span>);<br>        <span class="hljs-keyword">return</span> tree;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ignoreToken</span><span class="hljs-params">(String tokenName)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isIdentifierNamed(tokenName))<br>            lexer.read();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LSException</span>(<span class="hljs-string">&quot;ignored Token have false Name &quot;</span> + tokenName);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdentifierNamed</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">Token</span> <span class="hljs-variable">currentToken</span> <span class="hljs-operator">=</span> lexer.peek(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> currentToken.isIdentifier() &amp;&amp; currentToken.getText().equals(name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ASTree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExprParser</span>(Lexer.fromLines(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;(1+2)*3+4&quot;</span>&#125;)).parse();<br>        System.out.println(ExprEvaluator.eval(tree));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是对 AST 进行解释的代码，其实现是非常容易的——对二叉树后序遍历并运算。这过程实际上是进行<strong>语义分析</strong>并执行的过程。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExprEvaluator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(ASTree tree)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tree.isLeaf()) <span class="hljs-keyword">return</span> tree.getValue().getNumber();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> eval(tree.getLeft());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightValue</span> <span class="hljs-operator">=</span> eval(tree.getRight());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> tree.getValue().getText();<br>        <span class="hljs-keyword">switch</span> (op) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                <span class="hljs-keyword">return</span> leftValue + rightValue;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                <span class="hljs-keyword">return</span> leftValue - rightValue;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                <span class="hljs-keyword">return</span> leftValue * rightValue;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                <span class="hljs-keyword">return</span> leftValue / rightValue;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;这不可能！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>关于数学运算和表达式运算，还存在一种名为<strong>算符优先分析法</strong>（operator precedence parsing），其是一个弱化的 LR(1)，非常适合用来对表达式进行语法分析，实际上其也在很多情况下嵌入到自底向下语法分析器中。但是这里先不赘述了。</p><h1 id="关于实现中的问题"><a href="#关于实现中的问题" class="headerlink" title="关于实现中的问题"></a>关于实现中的问题</h1><p>一个需要注意的地方是，这里生成的 AST 的结构是固定的二叉树——根结点为操作符，左右两个子树为值，<strong>这样的结构是和四则运算的规律紧紧耦合的</strong>。复杂语言的 AST 是不能这样的——它一般来说不是二叉树，且计算所需信息一般都存储在子节点中。这时，根结点就负责表示 AST 节点的类型（这也意味着其的处理方法被规定了）。</p><p>AST 树中每个节点都有其类型，有其计算法。比如，一个 if 语句块的 AST 可能这样表示——</p><p><img src="/images/oss/20210821134802.png"></p><p>标识双目运算的 AST 可能这样表示——</p><p><img src="/images/oss/20210821134952.png"></p><p>面对这样的树，它的计算方法是容易编写的，下面试图编写 IfStatement 的 eval 方法，其中 children 为子树的 List。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Result <span class="hljs-title function_">eval</span><span class="hljs-params">(ASTree ifStatement)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ifStatement.children.get(<span class="hljs-number">0</span>).eval()) &#123; <span class="hljs-comment">// Condition 的值</span><br>        eval(ifStatement.children.get(<span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (Statement.children.length == <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">// 如果有 elseCase</span><br>            eval(ifStatement.children.get(<span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> UnitResult; <span class="hljs-comment">// If 对 Java 来说没有返回值</span><br>&#125; <br></code></pre></div></td></tr></table></figure><blockquote><p>  <del>关于下一步的目标，我打算学习 stone 中的语法分析器（的生成器）的实现，编写一个内部 DSL 用以生成语法分析器代码。这流程是复杂的，可能是难以实现，需要借助外力（指书上的实现）的，但是学习它是有趣的 w</del>。</p><p>  <del>本想先继续跟着它的进度来，然后发现了一个麻烦的问题——我用的抽象结构和它的不一样，导致不能直接使用它提供的 Parser，这搞得有点尴尬。现在考虑跟着另一本书《自制编译器》进行学习，在完成后回过头来，从头再来，带着自己更为深刻的理解重新学习。</del></p><p>  还是继续吧，从它的代码继续——我可不想再次重蹈当初学习并发编程的覆辙了。</p></blockquote><p><img src="/images/oss/20210820001704.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《两周自制脚本语言》笔记 2——语法分析和 BNF</title>
    <link href="/2021/08-17%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8CBNF.html"/>
    <url>/2021/08-17%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8CBNF.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>程序被分割为 Token 后，下一步是根据 Token 序列构造抽象语法树（AST 或 ASTree，Abstract Syntax Tree），这一步称为<strong>语法分析</strong>。语法分析的任务是<strong>分析 Token 间关系</strong>，比如判断 Token 所属表达式和语句，处理标识符的配对等，同时会检查程序是否存在语法错误。</p><h1 id="语法，BNF"><a href="#语法，BNF" class="headerlink" title="语法，BNF"></a>语法，BNF</h1><p>抽象语法树的结构如何，已经无需再提。任何节点都是操作符，任何叶子都是值。</p><p>比如<code>(13 + x) * 2)</code>，能得到<code>(* (+ 13 x) 2)</code>这样一个树，其图形化表述如下。可以看到，一切根结点都是操作符&#x2F;函数之类，一切叶节点都是值（也可以是函数）。</p><p><img src="/images/oss/20210815202957.png"></p><p>语言处理器（即将源代码转换为可执行程序的程序）为了构造抽象语法树，需要按照特定规则将 Token 序列读入，这种规则就是程序设计语言的<strong>语法</strong>（syntax）。</p><p>语法通过** BNF<strong>（Backus-Naur Form，巴科斯范式）进行表述。其将规定</strong> Token 的组合规则<strong>。比如，双目运算符要由表达式，操作符，表达式组成。比如 while 要由 while 关键字，表达式，语句块组成。</strong>BNF 与上下文无关文法等价**。</p><p>下面代码展示了一个提供四则运算，整型字面量以及括号的语法的 BNF，其使用了 BNF 的扩展版本 EBNF——</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">factor:</span>NUMBER | <span class="hljs-string">&quot;(&quot;</span> expression <span class="hljs-string">&quot;)&quot;</span><br><span class="hljs-symbol">term:</span><span class="hljs-title class_">factor</span> <span class="hljs-punctuation">&#123;</span> (<span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;/&quot;</span>) factor <span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">expression:</span><span class="hljs-title class_">term</span> <span class="hljs-punctuation">&#123;</span> (<span class="hljs-string">&quot;+&quot;</span> | <span class="hljs-string">&quot;-&quot;</span>) term <span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure><p>BNF 中，冒号左侧称为<strong>元变量</strong>或<strong>非终结符</strong>，右侧为一个用于匹配的模式，其通过<strong>元符号</strong>，<strong>终结符</strong>以及<strong>非终结符</strong>进行表示。左侧内容和右侧等价，即左侧的非终结符转化成右边的模式。终结符代表预先定义的 Token，比如上面的”(“，”)”，NUMBER，“+”。上面的|，()，{}等都是元符号，其<strong>具有特定语义</strong>，能够对模式进行丰富的表达，就像正则表达式中的。*?+|之类。下面给出各元符号的语义——</p><table><thead><tr><th>元符号</th><th>语义</th></tr></thead><tbody><tr><td>{ pat }</td><td>模式 pat 出现 0 次或更多次</td></tr><tr><td>[ pat ]</td><td>模式 pat 出现 0 次或 1 次</td></tr><tr><td>pat1 | pat 2</td><td>匹配 pat1 或 pat2。｜的优先级是最低的——即其最后执行，就像一道厚障壁 w</td></tr><tr><td>( … )</td><td>将括号中内容识别为一个模式</td></tr></tbody></table><blockquote><p>  最初的 BNF 似乎无法使用{}的样子，因此只能使用|和 () 来进行递归定义，比如 expression 可以表述成为——</p><p>  <del><code>expression: term | term (&quot;+&quot; | &quot;-&quot;) expression</code></del>（应有误，这种 BNF 对 LL(1) 是完成不了的）</p></blockquote><p>比如，有一个表达式——</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span>+ <span class="hljs-number">4</span> * <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>词法分析后得到这样的 Token 序列（当然，这里的”+”和”*”都是标识符）。</p><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">NUMBER</span> <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-built_in">NUMBER</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-built_in">NUMBER</span><br></code></pre></div></td></tr></table></figure><p>下面给出其匹配流程——</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">// 就像编译原理课上写的那样……但是实际的匹配过程肯定不是这样，这里只是举例子罢了<br>NUMBER <span class="hljs-string">&quot;+&quot;</span> NUMBER <span class="hljs-string">&quot;*&quot;</span> NUMBER<br>=&gt; factor <span class="hljs-string">&quot;+&quot;</span> factor <span class="hljs-string">&quot;*&quot;</span> factor// <span class="hljs-string">&quot;*&quot;</span>旁边的两个 factor 先化简——<span class="hljs-string">&quot;+&quot;</span>化简的话最后得不到正确结果<br>=&gt; factor <span class="hljs-string">&quot;+&quot;</span> term<br>=&gt; term <span class="hljs-string">&quot;+&quot;</span> term<br>=&gt; expression// correct!<br>// 试图先从<span class="hljs-string">&quot;+&quot;</span>化简<br>NUMBER <span class="hljs-string">&quot;+&quot;</span> NUMBER <span class="hljs-string">&quot;*&quot;</span> NUMBER<br>=&gt; factor <span class="hljs-string">&quot;+&quot;</span> factor <span class="hljs-string">&quot;*&quot;</span> factor// <span class="hljs-string">&quot;*&quot;</span>旁边的两个 factor 先化简——<span class="hljs-string">&quot;+&quot;</span>化简的话最后得不到正确结果<br>=&gt; term <span class="hljs-string">&quot;+&quot;</span> term <span class="hljs-string">&quot;*&quot;</span> factor<br>=&gt; expression <span class="hljs-string">&quot;*&quot;</span> factor // 这里之后无法再化简了……似乎，除非能让 expression <span class="hljs-symbol">:</span> <span class="hljs-string">&quot;(&quot;</span> expression <span class="hljs-string">&quot;)&quot;</span>？不确定<br></code></pre></div></td></tr></table></figure><p><img src="/images/oss/20210815232910.png"></p><blockquote><p>  书中将 factor 称为因子，term 称为项，expression 称为表达式。可以注意到，这里已经体现出四则运算的优先级了。但是也可以通过其他方式对优先级进行处理。</p></blockquote><p>于是，可以根据这样的语法分析的结果构造抽象语法树——</p><p><img src="/images/oss/20210815235613.png"></p><p>就记录到这里。下一步是学习一下<strong>语法分析的各种算法，以及一个 LL(1) 语法分析器的手动编写</strong>。</p><p><img src="/images/oss/2021/07/142021-07-14.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《两周自制脚本语言》笔记 1——基于正则表达式的词法分析</title>
    <link href="/2021/08-14%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0.html"/>
    <url>/2021/08-14%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<p><img src="/images/oss/20210814203349.jpg"></p><!--Hello, Happy World--><p>该书的目标是<strong>使用 Java 语言</strong>实现一门简单的脚本语言——更具体的来说，是实现一个简单的<strong>脚本语言</strong>的<strong>语言处理器</strong>，其主体是一个解释器（就像 python），但内部通过编译器提高性能。</p><p>该语言处理器的<strong>大体</strong>流程和编译原理课上的所学大同小异——先将源代码通过<strong>词法分析</strong>转换成 <strong>Token</strong> 序列，再将 Token 通过<strong>语法分析</strong>生成<strong>抽象语法树（AST）</strong>，再通过编译器或解释器对语法树进行编译或执行。</p><blockquote><p>AST 是什么？联想 Lisp 罢！</p></blockquote><p><img src="/images/oss/20210814000737.png"></p><p>该书将此语言命名为 Stone——Perl 是珍珠（大概），Ruby 是红宝石，而它则只是一颗小石子。</p><blockquote><p>  等什么时候我真的去写一门喜欢的语言，就自己给它取名吧。</p></blockquote><h1 id="Stone-的基本语法"><a href="#Stone-的基本语法" class="headerlink" title="Stone 的基本语法"></a>Stone 的基本语法</h1><p>Stone 仍旧是 C 系语言，它在某些地方和 python 相近，某些地方又同传统的语言相近——</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// 注释使用//，传统！<br>even = 0 // 变量定义，类似 python，单行语句不需加分号，不需要定义变量类型<br>odd = 0<br>i = 1<br>while i &lt; 10 &#123; // if 和 while 的条件不需要括号，类似 python<br>if i % 2 == 0 &#123;<br>even = even + i // 偶数<br>&#125; else &#123;<br>odd = odd + i<br>&#125;<br>  i = i + 1<br>&#125;<br>even + odd // 不需要 return，最后表达式为返回值<br><br>&#123; x = 1; y = 2 &#125; // 分号是语句间的分隔符，这种形式是合法的<br>// 没有多行注释<br></code></pre></div></td></tr></table></figure><p>语句的换行如果要能够允许各种情况，会导致实现的复杂化，因此对换行情况做尽量多限制——左花括号必须不换行，else 必须和右花括号在同一行。</p><blockquote><p>如果强制要求除代码块以外，语句必须以分号结束，实现会变得容易，但是这并不现代。</p></blockquote><p>Stone 语言要求 if 和 while 的语句体必须使用花括号包括——这导致 else if 是不合法的！可以模仿 python，使用类似 elif 的关键字来实现 else if。</p><blockquote><p>如果之后有条件，我想为其提供一些我喜欢的特性，比如一切皆表达式，尾 lambda……</p></blockquote><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>词法分析是语言处理器的第一个组成部分，其负责将源代码（也就是保存在文本文件里的，符合特定规范的一长串字符串）进行切割，划分为多个子字符串，生成相应** Token**。</p><p>比如<code>if i == &quot;me&quot; &#123;</code>这样一行代码，其将会被拆分成<code>&quot;if&quot; &quot;i&quot; &quot;==&quot; &quot;&quot;me&quot;&quot; &quot;&#123;&quot;</code>，<strong>空白和注释都会被去除</strong>。</p><p>Token 当然不能是简单的 String 对象，其要保存更多信息，包括但不限于 Token 的值，<strong>类型</strong>，行号等。每个 Token 类型都需要被小心定义，规定怎样的字符串才能合法构成特定类型 Token。</p><p>Stone 语言定义 Token 有三种类型——标识符（Identifier），数字（Number），字符串（String）。</p><p>标识符代表变量名，函数名，类名等，运算符以及各种括号，标点符号也属于标识符。数字和字符串都通过字面量进行表示。考虑到 Stone 对换行是比较敏感的，换行符也为标识符。</p><blockquote><p>似乎有时候（或者是一般来说？）保留字（关键字）和标点符号会被归为另一种类型的 Token。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">num = 0<br>hello = &quot;world&quot;<br>while 1 &#123;<br>num = num + 100<br>&#125;<br><br>// num, =, hello, while, &#123;, +, &#125;为标识符<br>// 0, 1, 100 为数字字面量，其代表数字 0, 1, 100（当然，也可以用 two、one、three，0x01、0x02、0x03，ひとつ、ふたつ、みっつ等字面量来定义 1，2，3 等数字！）<br>// &quot;world&quot;为字符串字面量，其表示字符串值 Java（同理，也可以使用其它符号如单引号来标记字符串）<br></code></pre></div></td></tr></table></figure><h2 id="Token-的定义"><a href="#Token-的定义" class="headerlink" title="Token 的定义"></a>Token 的定义</h2><p>下面给 Token 一个总的定义——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Token</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Token</span> <span class="hljs-variable">EOF</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(-<span class="hljs-number">1</span>)&#123;&#125;; <span class="hljs-comment">// 文件结尾</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EOL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\n&quot;</span>; <span class="hljs-comment">// 行结尾</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lineNumber;<br>  <br>  <span class="hljs-comment">// 使用 protected 保证不会被外界直接实例化，同时子类又可以重写</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Token</span><span class="hljs-params">(<span class="hljs-type">int</span> lineNumber)</span> &#123; <br>        <span class="hljs-built_in">this</span>.lineNumber = lineNumber;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLineNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> lineNumber;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdentifier</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 为数字时能够获取到其代表的数值</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StoneException</span>(<span class="hljs-string">&quot;not number token&quot;</span>); <span class="hljs-comment">// 为自己实现的一个 Exception</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 为字符串或标识符时，通过该方法能够取到其文本</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>关于 Token 的定义（即规定各个类型 Token 的合法值），使用 java 的正则表达式的库并遵循其定义方式——</p><p>首先是最简单的数字的字面量——<code>[0-9]+</code>（没错，这里没有小数！负数则通过负号运算符进行定义……大概吧）。</p><p>然后是关于标识符的定义，首先是关于保留字，变量，函数，类的命名，其必须使用大写或小写字母，下划线开头，只能出现数字和字母，下划线——<code>[A-Z_a-z][A-Z_a-z0-9]*</code>。</p><p>然后则是各种标点符号，其包括&#x3D;&#x3D;，&lt;&#x3D;，&gt;&#x3D;，&amp;&amp;，||等双字节的符号，也包括更多单字节符号，其为<code>==|&lt;=|&gt;=|&amp;&amp;|\|\||\p&#123;Punct&#125;</code>，这里的<code>\p&#123;Punct&#125;</code>表示与任意符号字符匹配。因此关于标识符的总的正则表达式为<code>[A-Z_a-z][A-Z_a-z0-9]*|==|&lt;=|&gt;=|&amp;&amp;|\|\||\p&#123;Punct&#125;</code>。</p><p>然后是字符串字面量的定义，其为<code>&quot;(\\&quot;|\\\\|\\n|[^&quot;\n])*&quot;</code>，这代表字符串中的值能包括、&quot;，\\，\n（作为字面量写出来的，两个字符的、n，而非真正的换行符），以及除”，换行符以外其他字符（”和换行符会打断字符串。书中居然没有匹配换行符，为什么？）。</p><p>Java 需要对”和、进行转义，最终编写在 Java 文件里的正则表达式如下。需要记住的是，<strong>下面的字符串最后应当得到的目标字符串是上面的正则</strong>，因此这其中有<code>字面量 Java 字符串-&gt;实际正则表达式字符串</code>这一层转换——比如正则表达式要匹配<code>\n</code>这个回车符，对应 Java 代码就要<code>\\n</code>，其将成为原生字符串<code>\n</code>并作为 regex。但若是要匹配<code>\n</code>这个长度为二的字符串，相应的原生字符串是<code>\\n</code>，为此，相应的 Java 字符串应当转义两个反斜杠，最终得到<code>\\\\n</code>这样的结果。</p><p>如果 Java 提供了 raw 字符串的功能，编写这个将漂亮很多。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\&quot;(\\\\\&quot;|\\\\\\\\|\\\\\n|[^\&quot;\n])*\&quot;&quot;</span>; <span class="hljs-comment">// mdzz</span><br></code></pre></div></td></tr></table></figure><h2 id="词法分析器的设计和实现"><a href="#词法分析器的设计和实现" class="headerlink" title="词法分析器的设计和实现"></a>词法分析器的设计和实现</h2><p>Java 语言能够使用一个正则表达式获取特定字符串中所有匹配字符串，因此这里使用正则表达式来获取 Token，具体来说，可以通过如下正则表达式来对 Token 进行获取——</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">\s*<span class="hljs-comment">((//.*)</span>|<span class="hljs-comment">(pat1)</span>|<span class="hljs-comment">(pat2)</span>|<span class="hljs-comment">(pat3)</span>)?<br></code></pre></div></td></tr></table></figure><blockquote><p>这里的 pat3 的括号加或不加都可，只不过标识符所匹配的括号不一样罢了。</p></blockquote><p>其中，pat1-3 为匹配整型字面量，字符串字面量，标识符的正则表达式。&#x2F;&#x2F;. *用于匹配注释，\s *用于匹配 0 个及以上的空字符，? 代表即使没有任何内容也能够匹配。正则表达式匹配成功时，能通过代码对每个括号所匹配的内容进行获取，这样从四个括号的匹配值是否是 null 就能看出，能获得到被匹配的 Token 的类型。</p><p>词法分析器的工作是简单的——逐行读取源代码，对每行源代码，从开头起检查内容是否匹配，并在检查完成后获取所有匹配的字符串。</p><p>在获取时，使用的正则表达式如下。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">STRING_PATTERN</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\&quot;((\\\\\&quot;|\\\\\\\\|\\\\\n|[^\&quot;\\n])*)\&quot;&quot;</span>; <span class="hljs-comment">// 这里又加了一层括号，使能够直接获取字符串双引号包围的值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NUMBER_PATTERN</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[0-9]+&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">IDENTIFIER_PATTERN</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[A-Z_a-z][A-Z_a-z0-9]*|==|&lt;=|&gt;=|&amp;&amp;|\\|\\||\\p&#123;Punct&#125;&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">FULL_PATTERN</span><br>  <span class="hljs-operator">=</span> Pattern.compile(String.format(<span class="hljs-string">&quot;\\s*((//.*)|(%s)|(%s)|(%s))?&quot;</span>, NUMBER_PATTERN, STRING_PATTERN, IDENTIFIER_PATTERN));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">matcher.group(0) 无意义</span><br><span class="hljs-comment">group(1) 若为 null 说明字符串为空</span><br><span class="hljs-comment">group(2) 为注释</span><br><span class="hljs-comment">group(3) 为数字字面量之字符串表述</span><br><span class="hljs-comment">group(4) 为字符串</span><br><span class="hljs-comment">group(5) 为字符串字面量之实际值，但需要将所有应当转义字符进行转义，比如用户如果在字符串中包括、n，其是以、，n 两个字符保存在文本中的，读取到内存中也是两个字符&#x27;\\&#x27;和&#x27;n&#x27;，需要将其转换成换行符</span><br><span class="hljs-comment">group(6) 无意义</span><br><span class="hljs-comment">group(7) 为标识符</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">像 123abc 这样的是不会出现错误的，它会拆成数字字面量 123 和标识符 abc，这河里吗？还是说这种错误必然会在语法分析阶段被发现？感觉如果要在词法分析阶段解决这个问题，需要增加更多逻辑……得不偿失。</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>根据正则表达式，能够容易写出相应的代码，下面的是获取单行的 Token 的代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对一行字符串进行词法分析</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> lineNumber 字符串所处行数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str 待分析字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> Token 序列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Token&gt; <span class="hljs-title function_">analyzeLine</span><span class="hljs-params">(<span class="hljs-type">int</span> lineNumber, String str)</span> &#123;<br>  List&lt;Token&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> FULL_PATTERN.matcher(str);<br>  <span class="hljs-keyword">while</span>(matcher.find()) &#123;<br>    <span class="hljs-keyword">if</span> (matcher.group(<span class="hljs-number">1</span>) == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (matcher.group(<span class="hljs-number">3</span>) != <span class="hljs-literal">null</span>) &#123;<br>      res.add(TokenFactory.of(lineNumber, TokenType.NUMBER, matcher.group(<span class="hljs-number">3</span>)));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (matcher.group(<span class="hljs-number">5</span>) != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// TODO 需要转义</span><br>      res.add(TokenFactory.of(lineNumber, TokenType.STRING ,matcher.group(<span class="hljs-number">5</span>)));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (matcher.group(<span class="hljs-number">7</span>) != <span class="hljs-literal">null</span>) &#123;<br>      res.add(TokenFactory.of(lineNumber, TokenType.IDENTIFIER, matcher.group(<span class="hljs-number">7</span>)));<br>    &#125;<br>  &#125;<br>  res.add(TokenFactory.EOL(lineNumber));<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str 待分析字符串数组，将根据下标确定行数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> Token 序列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Token&gt; <span class="hljs-title function_">analyze</span><span class="hljs-params">(String[] str)</span> &#123;<br>  <span class="hljs-type">int</span>[] count = &#123;<span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-keyword">return</span> Arrays.stream(str)<br>    .map(line -&gt; analyzeLine(count[<span class="hljs-number">0</span>]++, line)) <span class="hljs-comment">// 在 map 中使用会改变的参数非常不好，但这里写起来简单</span><br>    .flatMap(List::stream)<br>    .collect(Collectors.toList());<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/images/oss/20210814203324.jpg"></p><p>正则表达式用来进行词法分析感觉还是有些不太舒服的，好在实践中已经开发了许多现成的词法分析器可以直接使用，该书似乎之后还会通过有限状态自动机来进行词法分析…再议吧！下一步是学习和编写语法分析器。</p><blockquote><p>  感觉其实可以把 NumToken 和 StringToken 统一起来，变成 LiteralToken</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对 git 的一些使用的笔记</title>
    <link href="/2021/08-02%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8.html"/>
    <url>/2021/08-02%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>对 git 的了解，仅限于对其概念，命令的了解是绝对不够的（实际上我现在也不能算了解），重要的是掌握相应的<strong>最佳实践</strong>。这里进行一些笔记。我对马上掌握 git 不抱任何期望——这玩意显然是应当在实践中掌握的。</p><h1 id="纵览"><a href="#纵览" class="headerlink" title="纵览"></a>纵览</h1><p><img src="/images/oss/20210729163029.png"></p><p>一个 git 项目可以分为三部分——工作目录，暂存区，git 仓库。其中，工作目录代表项目某个版本提取出的内容（就像某时刻的快照——当前的也可以）；git 仓库代表。git 目录下的内容，其是项目中最重要的部分，包括项目原数据以及对象数据库，<strong>从远程克隆仓库时，拷贝的就是 git 仓库的数据</strong>；暂存区是一个文件，保存下次提交时的文件列表信息。</p><p>git 的最简单的工作流程可以归纳如下——</p><ol start="0"><li>克隆远程仓库（将会克隆整个 git 仓库的所有数据——这也就是说其会拉取每一个文件的所有版本到本地，而非仅当前所需要的文件）或初始化新仓库</li><li>修改文件</li><li>将文件的快照加入暂存区（<code>git add</code>命令）</li><li>提交暂存区内容到仓库——这将生成永久性的快照（<code>git commit</code>命令）</li></ol><p>在这个工作流程中，文件在各个阶段将会有不同状态，这取决于文件是否被追踪，修改是否已经暂存。</p><p><img src="/images/oss/20210729165515.png"></p><blockquote><p>关于将修改加入到暂存区这一步，如果在文件 add 后再次编辑文件。文件将同时处于 Modified 和 Staged 状态——Staged 是编辑前被 add 的文件快照，Modified 是编辑后的文件，这时需再次执行 add 命令，但是旧的 add 命令的结果会被覆盖——如果需要保存该结果，应当在此时进行 commit。</p></blockquote><p><code>git status -s</code>命令会紧凑地显示各被修改的文件的情况。其中，?? 代表未追踪，A 表示新添加到暂存区，左边的 M 表示文件修改且存入暂存区，右边的 M 表示文件修改且未存入暂存区。但这个或许没有必要了解——IDE 一般都提供了更丰富的表现方式。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status -s</span><br> M README# 修改但未暂存<br>MM Rakefile# 暂存后被再次修改且未暂存<br>A  lib/git.rb# 新添加到暂存区<br>M  lib/simplegit.rb# 修改且暂存<br>?? LICENSE.txt# 未追踪<br></code></pre></div></td></tr></table></figure><p><code>git diff</code>命令将会显示当前尚未暂存文件和上一次提交&#x2F;暂存文件的差别（<strong>未暂存的改动</strong>），<code>git diff --staged</code>命令显示当前暂存文件和上一次提交文件的差别（<strong>已暂存的改动</strong>）。</p><p><code>git commit</code>命令将会把暂存区的快照进行提交并成为项目的一个快照（这个快照使能够完全回溯到项目的这个状态，快照是相对项目而言的，而非相对某个文件而言的；git 的版本控制指的是<strong>对项目的版本控制</strong>，而不是对各个文件的版本控制），在将来可以回退到该快照，或者进行比较等操作。也可以使用<code>git commit -a</code>来一次提交所有跟踪过的文件，而不需要进行暂存。</p><p><img src="/images/oss/20210730093849.png"></p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>分支——<strong>把工作从开发主线上分离开来，以免影响开发主线</strong>。git <strong>鼓励在工作流程中频繁使用分支和合并</strong>。这是说，最好在每次要进行修改的时候都创建新分支，进行编辑和测试后合并到原分支。也可以说，分支的目的是为了更好的合并。</p><p>这分支图一定是分分合合的。git 的默认分支（同时一般也是“主干”）的名字是 master，<code>git init</code>默认会创建名为 master 的分支。</p><h2 id="创建和切换分支"><a href="#创建和切换分支" class="headerlink" title="创建和切换分支"></a>创建和切换分支</h2><p>分支的实质是一个可以移动的指针，其能够指向任意一个快照。每次提交都会形成项目的一个快照，而创建新分支的操作则是创建一个可移动的指针引用当前快照，而进行提交（commit）时，提交的快照则会从这里进行分支，同时指针也会移动。创建新分支的命令是<code>git branch &lt;name&gt;</code>。</p><p>如，下图使用<code>git branch testing</code>命令创建了一个新分支，这个分支和 master 指向同一个快照（下面称为<strong>操作对象</strong>）。这里的 HEAD 也指向一个分支——当前的本地分支，在这里是 master，创建分支时不会改变当前分支。</p><blockquote><p>HEAD 分支可以直接引用操作对象吗？</p></blockquote><blockquote><p>图片中的箭头代表包含指针指向对象。每一个对象都有一个指针让它能够引用它的父对象。</p></blockquote><p><img src="/images/oss/20210731112956.png"></p><p><code>git checkout &lt;branchname&gt;</code> 命令使能够切换分支（这里的<code>&lt;branchname&gt;</code>也可以为操作对象）。</p><p>切换分支时，HEAD 会指向切换后的分支，同时工作目录的内容变为切换后分支的快照内容。在上面的例子里，如果这时进行编辑和提交，前后的分支就指向不同操作对象了。这时候再对前面的分支进行提交，就产生了<strong>分叉</strong>。</p><p><img src="/images/oss/20210731115150.png"></p><p>分支可以通过<code>git branch -f &lt;branchname&gt; &lt;target&gt;</code>进行强制的移动。target 可以为相对路径，也可以为绝对路径。</p><p>关于对分支的使用，一般来说可以遵循这样的流程（就像 add，commit，push 这样的流程一样）——</p><ol><li>为实现某需求，创建一个分支</li><li>在该分支上进行工作</li><li>完成工作后，合并分支到主分支</li></ol><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>合并操作显然是一个非常重要的部分。合并使用<code>git merge &lt;branchname&gt;</code>命令。合并时会将当前的分支和待合并的分支进行合并——在这里，<strong>当前的分支的指针会移动，而待合并的分支指针不动</strong>。</p><p>下面是一个示例，在 C1 时，项目进行了分支以进行 bug 的修复，现在修复完了，而 main 分支也进行了更新，现在如何将 bugFix 的改动合并到当前的 main 分支上呢？</p><p><img src="/images/oss/20210731181603.png"></p><p>答案是将当前分支设为 main，并进行 merge 操作，具体命令如下——</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout main</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge bugFix</span><br></code></pre></div></td></tr></table></figure><p>最终会达到这样的结果——可以看到 bugFix 指针并未移动，main 则移动了。可见，<strong>main 是这次合并的主体</strong>，它把 bugFix 的内容融合进自己，让自己演进了。在进行合并操作时，应按照这样的语义来选择合并的主体。</p><p><img src="/images/oss/20210731182926.png"></p><p><code>git rebase</code>也能够进行合并操作，它的作用就如其名——转移父对象，就是更改当前指针的父对象。其能造成更加线性的提交历史。</p><p>下面是一个示例，展示了执行下面命令的前后状态。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout bugFix</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git rebase main</span><br></code></pre></div></td></tr></table></figure><p><img src="/images/oss/20210731202320.png"></p><p><img src="/images/oss/20210731202341.png"></p><p>可以看到，bugFix 的父对象成为 main 了。现在只需要移动 main 到新节点即可。</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>对远程仓库进行各种操作是 git 使用中不可或缺的部分。一个 git 仓库可以有多个远程仓库。</p><p><code>git remote [-v | --verbose]</code>命令允许对项目的远程仓库进行查看，其中<code>-v</code>将会显示更详细的信息。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote -v</span><br>bakkdoor  https://github.com/bakkdoor/grit (fetch)<br>bakkdoor  https://github.com/bakkdoor/grit (push)<br>cho45     https://github.com/cho45/grit (fetch)<br>cho45     https://github.com/cho45/grit (push)<br>defunkt   https://github.com/defunkt/grit (fetch)<br>defunkt   https://github.com/defunkt/grit (push)<br>koke      git://github.com/koke/grit.git (fetch)<br>koke      git://github.com/koke/grit.git (push)<br>origin    git@github.com:mojombo/grit.git (fetch)<br>origin    git@github.com:mojombo/grit.git (push)<br></code></pre></div></td></tr></table></figure><p>Continued…</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus 的一些基本使用</title>
    <link href="/2021/08-01MyBatisPlus%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html"/>
    <url>/2021/08-01MyBatisPlus%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><blockquote><p>本是想跟着尚医通这个项目来做个完整的项目，结果视频的结构把我整麻了。进行一个跑路。但拜其所赐，对 MP 进行了一些学习。</p></blockquote><p>MyBatis-Plus（下面简称 MP）是对 MyBatis 的增强和扩展，它<strong>不改变 MyBatis 的 API</strong>，但是提供了更多强大的功能以帮助编码。</p><p>对 MP 最基础的使用非常简单——让 Mapper 接口继承一个所谓的<code>BaseMapper</code>接口即可，这个<code>BaseMapper</code>是泛型接口，其类型为操作的实体（当然，对应数据库的一张表）。</p><blockquote><p>在官方示例中，使用<code>MapperScan</code>注解对 Mapper 进行扫描和注入，但我认为使用<code>Mapper</code>注解语义上更为清晰，且 IDE 支持友好（我这 IDEA 不能识别 MapperScan 所导入的 Bean，不知道为何）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// entity/User.java</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-meta">@TableId</span> <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br><br><span class="hljs-comment">// mapper/UserMapper.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;<br></code></pre></div></td></tr></table></figure><h2 id="简单-CRUD"><a href="#简单-CRUD" class="headerlink" title="简单 CRUD"></a>简单 CRUD</h2><p><code>BaseMapper</code>中定义了许多 CRUD 方法，能够满足大多数业务需求。许多方法可以通过传入所谓的<code>Wrapper</code>对象给定查询&#x2F;更改条件。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">userMapper.selectById(<span class="hljs-number">2</span>); <span class="hljs-comment">// 根据主键进行查询</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">结果：</span><br><span class="hljs-comment">User(id=2, name=Jack, age=20, email=test2@baomidou.com)</span><br><span class="hljs-comment">*/</span><br>userMapper.selectList(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 整表查询</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">结果：</span><br><span class="hljs-comment">User(id=1, name=Jone, age=18, email=test1@baomidou.com)</span><br><span class="hljs-comment">User(id=2, name=Jack, age=20, email=test2@baomidou.com)</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">*/</span><br>userMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>)); <span class="hljs-comment">// 带条件的查询</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">结果：</span><br><span class="hljs-comment">User(id=3, name=Tom, age=28, email=test3@baomidou.com)</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p><code>selectBatchIds</code>方法接受一个主键 Id 列表并返回结果集合，但或许查询多条记录时最实用的方法是<code>selectByMap</code>，其接受一个<code>Map</code>，k 为字段名，v 为值，返回 List，这种形式和 where 后接一连串相等运算符的形式基本等效，更复杂的查询得去使用<code>QueryWrapper</code>了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">userMapper.selectBatchIds(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,));<br><span class="hljs-comment">// [User(id=1, name=Jone, age=18, email=test1@baomidou.com, createTime=null, updateTime=null), User(id=2, name=Jack, age=20, email=test2@baomidou.com, createTime=null, updateTime=null), User(id=3, name=Tom, age=28, email=test3@baomidou.com, createTime=null, updateTime=null)]</span><br><br>Map&lt;String, Object&gt; selecter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>selecter.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">28</span>);<br>userMapper.selectByMap(selecter);<br><span class="hljs-comment">// [User(id=3, name=Tom, age=28, email=test3@baomidou.com, createTime=null, updateTime=null)]</span><br></code></pre></div></td></tr></table></figure><p>关于添加操作，MP 提供了方法，使能够通过实体的实例进行添加。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> User.builder()<br>                .id(<span class="hljs-number">10L</span>)<br>                .age(<span class="hljs-number">20</span>)<br>                .email(<span class="hljs-string">&quot;abcd@163.com&quot;</span>)<br>                .name(<span class="hljs-string">&quot;Ri&quot;</span>)<br>                .build();<br>userMapper.insert(newUser); <span class="hljs-comment">// insert 方法直接接受一个实体（在这里是 User）的实例</span><br></code></pre></div></td></tr></table></figure><p>可以配置如下项让 MP 输出日志到标准输出流——</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="hljs-comment"># 相关输出如下：</span><br><span class="hljs-comment"># ==&gt;  Preparing: SELECT id,name,age,email FROM user WHERE id=?</span><br><span class="hljs-comment"># ==&gt; Parameters: 2(Integer)</span><br><span class="hljs-comment"># &lt;==    Columns: id, name, age, email</span><br><span class="hljs-comment"># &lt;==        Row: 2, Jack, 20, test2@baomidou.com</span><br><span class="hljs-comment"># &lt;==      Total: 1</span><br></code></pre></div></td></tr></table></figure><p>关于 MP 提供的<code>UpdateById</code>方法，该方法接受一个实体——其应当设定 Id 以及将要修改的域（其它的设为空），这个方法将会根据该实体的 ID 和非 null 的属性自动生成对应 SQL 语句，这种方法非常方便，特别是结合建造者模式！比如下面的实例——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> User.builder()<br>                .id(<span class="hljs-number">1L</span>)<br>                .name(<span class="hljs-string">&quot;omgwtf&quot;</span>)<br>                .age(<span class="hljs-number">1020</span>)<br>                .build(); <span class="hljs-comment">// 这里 email 为 null，没有设定</span><br>userMapper.updateById(user);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">相关日志：</span><br><span class="hljs-comment">==&gt; Preparing: UPDATE user SET name=?, age=? WHERE id=?</span><br><span class="hljs-comment">==&gt; Parameters: omgwtf(String), 1020(Integer), 1(Long)</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>关于删除操作，MP 提供了<code>delete</code>，<code>deleteById</code>，<code>deleteBatchIds</code>，<code>deleteByMap</code>方法，其分别接受 Wrapper，主键 Id，Id 集合，哈希表，满足了大多数操作需要。</p><h2 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h2><p>Wrapper 是 MP 提供的用以生成相应 SQL 语句的对象，其对 SQL 的大部分（所有？）运算符进行了抽象和方法化，从而能够让用户能够不写一行 SQL 代码而对数据库进行操作。</p><p>就操作对象来说，Wrapper 分为 QueryWrapper 和 UpdateWrapper，顾名思义，其分别负责查询和更新&#x2F;删除。</p><p>就操作形式来说，Wrapper 分为普通 Wrapper 和 LambdaWrapper，普通 Wrapper 在操作中一般接受 Map，LambdaWrapper 一般接受 Lambda 表达式——这显然是更加方便易读的。</p><p>Wrapper 通过链式调用进行使用。各个表达式默认通过 and 进行连接。但也可以显式指定为 or。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()<br>  .eq(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jone&quot;</span>)<br>  .eq(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// 可以使用 allEq</span><br><span class="hljs-comment">// 使用 selectList 方法，生成 SQL 形如 SELECT ... FROM user WHERE (name = ? AND age = ?)</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()<br>  .eq(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jone&quot;</span>)<br>  .eq(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>)<br>  .or()<br>  .eq(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>)<br>  .eq(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">200</span>);<br><span class="hljs-comment">// SELECT ... FROM user WHERE (name = ? AND age = ? OR name = ? AND age = ?)</span><br><br><span class="hljs-comment">// 嵌套子句。这里的 or 和 and 方法的作用形式就像中缀运算符</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()<br>  .or(i-&gt;&#123; <br>    i.eq(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jone&quot;</span>);<br>    i.eq(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br>  &#125;)<br>  .or(i-&gt;&#123;<br>    i.eq(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>    i.eq(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">200</span>);<br>  &#125;);<br><span class="hljs-comment">// SELECT ... FROM user WHERE ((name = ? AND age = ?) OR (name = ? AND age = ?))</span><br></code></pre></div></td></tr></table></figure><h2 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h2><p>MP 还提供了自动填充的功能——在进行插入的时候，能自定义某些字段的填充。这种填充我在毕设项目时也进行过使用，当时是通过触发器进行实现的。</p><p>自动填充分为<strong>添加时设置值</strong>以及<strong>修改时设置值</strong>，其通过<code>INSERT</code>，<code>DEFAULT</code>（默认不处理），<code>INSERT_UPDATE</code>，<code>UPDATE</code>这四个枚举指定。要使用自动填充需要进行两个操作——在字段上添加相关注解；定义自动填充处理器。下面展示了其定义和应用。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 实体类</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// TableField 注解默认会把实体类的小驼峰命名法转换成下划线命名法并作为数据库表中相应字段，但是也可以直接显式指定相应的表字段名。</span><br>    <span class="hljs-meta">@TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date createTime; <span class="hljs-comment">// 创建时间，在插入时进行赋值</span><br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date updateTime; <span class="hljs-comment">// 更新时间，在更新时进行赋值</span><br>&#125;<br><br><span class="hljs-comment">// 处理器，处理器置于 handler 包下而非 config 包下，因为其并非负责配置，而是负责业务</span><br><span class="hljs-comment">// 为什么处理器不需要与实体类绑定？</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MetaObjectHandler</span> &#123;<br>    <span class="hljs-comment">// 插入操作时执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        <span class="hljs-comment">// 设置实体类实例的 createTime 字段为当前时间</span><br>        <span class="hljs-built_in">this</span>.setFieldValByName(<span class="hljs-string">&quot;createTime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), metaObject);<br>        <span class="hljs-built_in">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), metaObject);<br>    &#125;<br>    <span class="hljs-comment">// 修改操作时执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), metaObject);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">插入时的日志，可以看到插入时 createTime 字段和 updateTime 字段都生成在 SQL 中</span><br><span class="hljs-comment">==&gt;  Preparing: INSERT INTO user ( id, name, age, email, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ? )</span><br><span class="hljs-comment">==&gt; Parameters: 11(Long), Rim(String), 20(Integer), abcdefg@163.com(String), 2021-07-28 18:21:42.919(Timestamp), 2021-07-28 18:21:42.919(Timestamp)</span><br><span class="hljs-comment">&lt;==    Updates: 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">更新时的日志，可以看到插入时 updateTime 字段生成在 SQL 中</span><br><span class="hljs-comment">==&gt;  Preparing: UPDATE user SET name=?, age=?, update_time=? WHERE id=?</span><br><span class="hljs-comment">==&gt; Parameters: omgwtf(String), 1020(Integer), 2021-07-28 18:29:01.452(Timestamp), 1(Long)</span><br><span class="hljs-comment">&lt;==    Updates: 1</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>可以认为自动填充做了这样的工作——进行操作时，检查所有字段，查找所有带 TableField 注解且定义了 fill 属性的字段，并将符合条件的字段<strong>也</strong>插入到 SQL 中（就像非 null 的字段），因此这些字段应当（不是必须）在处理器中进行赋值。</p><blockquote><p>一个有趣的地方是，如果定义了多个处理器，Spring Boot 会提示注入失败——有多个可选 Bean，看来应当在配置文件中进行相关定义，而不是直接给处理器进行 Component 注解。</p></blockquote><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>分页在实践中可能是一个比较重要的话题，虽然我从来没写过，都是一口气全部拿到的 w。</p><p>MP 提供了分页查询的功能，其是以<strong>插件</strong>的形式实现的，具体来说是自定义相应的 bean。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 用的还是上面的 MyBatisPlusConfig</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(&quot;me.ykn.mapper&quot;)</span> <span class="hljs-comment">// 还是使用 Mapper 注解语义更加清晰一些</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisPlusConfig</span> &#123;<br>  <span class="hljs-comment">// 自动分页插件</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PaginationInnerInterceptor <span class="hljs-title function_">paginationInnerInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL);<br>    &#125;<br>    <span class="hljs-comment">// 插件主体</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        interceptor.addInnerInterceptor(paginationInnerInterceptor()); <span class="hljs-comment">// 添加分页插件，其它插件也通过这种形式进行添加</span><br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>分页查询的应用是简单的，许多方法提供了对应返回 Page 的方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Page&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 页数，条数，页数从 1 开始（！）</span><br>Page&lt;User&gt; res = userMapper.selectPage(page, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 第二个参数是 Wrapper</span><br>System.out.println(res.getRecords()); <span class="hljs-comment">// getRecords 方法返回相应 List</span><br><span class="hljs-comment">// Page 类还提供了更多方便的方法，足以支撑日常使用</span><br></code></pre></div></td></tr></table></figure><p>就这些吧。</p><p><img src="/images/oss/20210717235544.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Java 的内部类</title>
    <link href="/2021/07-30%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB.html"/>
    <url>/2021/07-30%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>内部类（Inner Class）为定义在类或方法内部的类，其的特点，用途及使用原因如下——</p><ul><li>内部类中的方法可以访问该类定义所在作用域（也就是它的外部类的作用域）的成员，包括私有成员。</li><li>内部类可以对包内其它类不可见（普通的 class 的修饰符只能是 public 和默认，其在同一个包内都是可见的）。</li><li>内部类可利用于 lambda 表达式，匿名实现类等特性，可以实现闭包等功能。</li></ul><p>内部类还可分为内部类和静态内部类，其在语义上和功能上都是有差异的。</p><blockquote><p>我们接触到的内部类最典型的就是 Map 的 Entry，lombok 的 builder。</p></blockquote><p>一般定义的内部类，其在语义上来说是<strong>和实例对应</strong>的，不过这种对应关系不是 1 对 1，是 n 对 1，因为一个实例可以创建无数个对应其的内部类实例。</p><p>类对内部类的实例化和对普通对象的代码是一样的，但是编译器在背后会做不同的工作——内部类实例化时，当前类实例的指针也会被隐式地赋予给该实例，这就使内部类的实例能够访问外部类的属性。一个示例代码见下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">outerData</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 外部类的成员</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123; <span class="hljs-comment">// 使用 private 定义，保证其在外界不可见</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(++outerData); <span class="hljs-comment">// 引用了外部类的成员！</span><br>          <span class="hljs-comment">// 完全的引用是 ++InnerTest.this.outerData</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(); <span class="hljs-comment">// 初始化内部类实例，当前实例的指针（this）会被隐式赋予其。这个内部类的实例也可以作为 Solution 的成员，其将达到同样效果</span><br>      <span class="hljs-comment">// 同 this.new Inner()</span><br>        inner.getData();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InnerTest</span> <span class="hljs-variable">tst</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerTest</span>();<br>        tst.doSomething(); <span class="hljs-comment">// 101</span><br>        tst.doSomething(); <span class="hljs-comment">// 102</span><br>        tst.doSomething(); <span class="hljs-comment">// 103</span><br>     <span class="hljs-comment">// 可见每次创建新内部类实例时，其绑定的类实例都为当前实例</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一个有趣的事实是，不能在其它类中直接创建 Inner 实例，不能在 static 方法中直接创建 Inner 实例——没有和它绑定的外部类对象，自然不能创建！但是可以先创建外部对象，再创建其内部对象，示例见下。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">outerData</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123; <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(++outerData); <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InnerTest</span> <span class="hljs-variable">tst</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerTest</span>();<br>        InnerTest.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> tst.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(); <span class="hljs-comment">// 这个语法就离谱</span><br>        inner.getData(); <span class="hljs-comment">// 101</span><br>        inner.getData(); <span class="hljs-comment">// 102</span><br>        inner.getData(); <span class="hljs-comment">// 103</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用 static 定义的内部类并非意味着这个类是单例的（Java 没有类似 Kotlin 那样的 object 修饰符）——其在语义上是和类对应的，在使用上的限制仅限于其访问修饰符了。但是也可以采用取巧的方法——在构造器中将它的外部类实例作为自己的一个指针，这样就也能够获取和普通的内部类一样的效果了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">outerData</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123; <span class="hljs-comment">// 使用 private 定义，保证其在外界不可见</span><br>        <span class="hljs-keyword">final</span> InnerTest outer;<br>        Inner(InnerTest outer) &#123;<br>            <span class="hljs-built_in">this</span>.outer = outer;<br>        &#125;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(++outer.outerData); <span class="hljs-comment">// 引用了外部类的成员！</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 初始化内部类实例，这次是显式地把当前实例指针传进去了</span><br>        inner.getData();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InnerTest</span> <span class="hljs-variable">tst</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerTest</span>();<br>        tst.doSomething(); <span class="hljs-comment">// 101</span><br>        tst.doSomething(); <span class="hljs-comment">// 102</span><br>        tst.doSomething(); <span class="hljs-comment">// 103</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>静态内部类（也叫嵌套类）和常规内部类的差别在于——</p><ul><li>常规内部类保存对外围类对象的引用，静态内部类则无。</li><li>静态内部类可以有 static 的成员。</li><li>常规内部类需要先生成外围对象，静态内部类可以直接被生成（实际上这也让静态内部类也被称为<strong>嵌套类</strong>——只是将这个类的定义隐藏在另一个类里罢了）。</li></ul><p>内部类可以定义在方法中，这会导致其作用域仅限于该方法作用域中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tmp</span> &#123; <span class="hljs-comment">// 只在 main 方法内可见</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(a); <span class="hljs-comment">// 可以引用上层作用域的变量，如果在实例方法中，可以引用实例的成员</span><br>      System.out.println(<span class="hljs-string">&quot;fun!&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">Tmp</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tmp</span>();<br>  tmp.fun(); <span class="hljs-comment">// 如果在这里对 a 进行操作，Java 会抱怨其只能引用“实际上 final”的对象，见之前对 Java 闭包的解释</span><br>  <span class="hljs-comment">//引用实例成员的话不受此约束——这两个性质和操作都是完全不同的，可以认为引用实例成员时实际只引用了实例，对其成员的操作不会改变实例的指针</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>至于匿名内部类，lambda 表达式，函数式接口等概念已经无需再提，这里再提一点——关于<code>&#123;&#123;&#125;&#125;</code>语法（DBI），这其实是建立了一个匿名子类，同时通过初始化块来进行操作。如在使用 SpringMVC 构造返回结果时，可以这样写——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>Map&lt;String, Object&gt; <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;()&#123;&#123;<br>      put(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>      put(<span class="hljs-string">&quot;answer&quot;</span>, <span class="hljs-number">42</span>);<br>    &#125;&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这形式其实就是构造了一个 HashMap 的匿名子类，定义一个新的初始化块并进行一些操作（这里的执行顺序是父类初始化块-&gt;父类构造器-&gt;子类初始化块）。这种形式的缺点之一是，最后生成的对象的 class 并非是 HashMap，在某些时候会出现问题，比如在 equals 方法里，比较对象类型是否相同时；<strong>比如使用 gson 进行序列化时，如此构造的对象将返回 null</strong>（这可让我吃了些苦头！）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务是什么</title>
    <link href="/2021/07-25%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88.html"/>
    <url>/2021/07-25%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇笔记记录了对微服务及其相关概念的学习，作为一个所谓的先导。但是我不认为我能在没有足够实践的情况下就直接理解微服务以及其带来的优势，弊端，直接理解微服务的各种模式（pattern）。总之并行进行嘛。</p></blockquote><!--Hello, Happy World--><p>任何架构，即使是一团糟的架构，基本上都能被用来实现各种业务需求（功能性需求），而问题在于<strong>非功能性需求</strong>，如可扩展性，可维护性，生产效率，质量管理等。</p><p><strong>微服务</strong>和与其对应的<strong>单体应用</strong>其实都是所谓的<strong>架构模式</strong>，其中单体应用是作为一个整体进行编写和部署的，即使其逻辑上是划分为一个个模块。单体应用在过去基本上是唯一的解决方案，它的优点在于——</p><ul><li>开发简单：只需要构建一个单独的应用程序。</li><li>测试直观：开发者只需要编写单元测试，端到端测试，界面测试等便可对系统进行相对完善的测试。</li><li>部署容易：单独的应用程序，对 Java 来说是 JAR 或 WAR 包，对 Ruby，Nodejs 等语言来说则是一个目录，对其的部署是非常容易的。</li><li>横向扩展容易：可以运行多个实例，通过一个负载均衡器进行调度。</li></ul><p>然而，随着代码规模的增长，技术的发展（同时也意味着旧技术——或许是该项目所使用的技术——的过时！），业务（和模块）的复杂化，这些优点将消失殆尽！</p><p>其中最主要的问题是，系统将变得<strong>过度复杂</strong>，让维护和扩展变成噩梦；同时，开发速度也会变慢，比如，项目的巨大让 IDE 不堪重负，从而编辑——构建——运行——测试这个周期的花费越来越长；多个开发团队向同一个代码库进行提交会导致其最终合并到主分支的过程极为漫长和痛苦；各个模块对硬件要求有自己的独特需要——如负责缓存的模块需要大量内存，负责运算的模块需要大量算力，对单体应用来说，其要使用的服务器需要满足所有模块的要求，这无疑是不够灵活，在进行横向扩展时会造成许多浪费的……</p><p>这就是所谓的<strong>单体地狱</strong>——任何单体应用在无数次迭代后必然导致的结果。而新的解决方案就在眼前——<strong>微服务架构</strong>。</p><p>微服务架构的一个定义是：<strong>把应用程序功能性分解为一组服务的架构风格</strong>。这里的服务指的并非业务层中的 Service，而是<strong>实现了一组相关功能的应用程序</strong>。<strong>服务是无关规模的</strong>！</p><p>微服务使用服务作为模块化的<strong>单元</strong>（原子的），每个服务**通过它提供的 API **构筑了一道绝对无法去逾越的边界（这实际上比编程语言所提供的约定方法更为强大……）。这种架构的优越性是可以直接看到的——各个模块可以独自进行演化——只要提供的 API 不变即可，且各个服务可以独立开发，测试，部署，扩展，甚至可以使用不同编程语言进行编写。这种自由度是单体应用绝对无法提供的。</p><p>微服务的优点在于——</p><ul><li>服务可独立维护，部署，扩展，且由于服务相对较小，对其的维护和测试是容易的。</li><li>更好的容错性（一个服务实例出现 bug 不会导致整个系统崩溃，<strong>故障隔离</strong>）。</li><li>团队协作更加容易且松耦合。</li><li>让大型复杂应用可以持续交付和持续部署。</li><li>更容易采取新技术到项目中。</li></ul><p>看上去挺香，但是至少在计算机这一行，没有银弹，微服务会造成一些单体应用不会出现的问题和弊端——</p><ul><li>服务的定义和拆分是一个挑战，其没有一个具体标准，需要丰富的实践经验和理论基础，一旦出错，就可能构造出<strong>分布式单体应用</strong>，其将不会有任何优势。</li><li>分布式系统会让整个系统的开发，测试，部署相对困难。具体来说，其会带来更多复杂性——进程间通信而非方法调用、跨服务的事物和查询复杂、需维护数据一致性、IDE 支持问题、运维问题……</li><li>部署跨服务的功能需要对多个开发团队进行协调，发布需按照计划以满足服务的依赖关系。</li><li>需思考在什么时候才有必要切换到微服务架构。一般来说项目会从单体应用开始，从微服务架构开始会导致初期进展困难——这是企业不能容忍的。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再看简单工厂和工厂方法</title>
    <link href="/2021/07-15%E5%86%8D%E7%9C%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html"/>
    <url>/2021/07-15%E5%86%8D%E7%9C%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>几个工厂模式的意义都在于将用户从创建依赖（也就是 new）的过程解脱出来，<strong>让创建对象和使用对象这两个职责进行解耦</strong>。同时能够让用户面向抽象层编程，实现依赖倒置原则。</p><p>产品类如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 在这里是 Fruit，在业务中可能就是 XXService 了</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">whoAmI</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">whoAmI</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Apple!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">whoAmI</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Banana!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Peach</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">whoAmI</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Peach!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面的代码实现了通过字符串匹配和类匹配的<strong>简单工厂</strong>模式。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span> || name.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;需给定有效字符串！&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 可以使用反射，通过输入的字符串获取相应类，这能够不违反开闭原则——添加新的实现类不需要做任何改动，但会导致只能调用统一的构造器，这可能无法抽象多种多样的构造过程</span><br>        <span class="hljs-comment">// 可以发现工厂方法模式相较于简单工厂模式的不同——使用反射构造每个 fruit 的工厂而非 fruit，在工厂中处理特定的初始化过程</span><br>        <span class="hljs-keyword">switch</span> (name) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;apple&quot;</span>:<br>            <span class="hljs-comment">// 一堆个性的初始化过程……</span><br>            fruit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;banana&quot;</span>:<br>            <span class="hljs-comment">// 另一堆个性的初始化过程……</span><br>            fruit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Banana</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;peach&quot;</span>:<br>            <span class="hljs-comment">// 再一堆个性的初始化过程……</span><br>            fruit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Peach</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 添加新的 Fruit 就需要修改源代码，违反开闭原则</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fruit == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;字符串不匹配！&quot;</span>);<br>        <span class="hljs-keyword">return</span> fruit;<br>    &#125;<br>    <span class="hljs-comment">// 按类匹配，优点是能够在编译期能够判断类是否合法，缺点是暴露了底层的具体类用户，且无法自定义初始化过程，其它的和反射法没有区别</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">(Class&lt;? extends Fruit&gt; clazz)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Fruit) clazz.getDeclaredConstructor().newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        FruitFactory.getFruit(<span class="hljs-string">&quot;banana&quot;</span>).whoAmI();  <span class="hljs-comment">// 可以用字符串，也就意味着可以用配置文件</span><br>        FruitFactory.getFruit(Peach.class).whoAmI();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>工厂方法模式和简单工厂模式的形式比较相似，除了有这些不同——</p><ul><li><p>工厂方法模式中一个工厂只负责生产<strong>一种</strong>产品（需要和抽象工厂模式中的<strong>一族</strong>进行区分，一族指代一系列类似的多种产品，如某 ui 框架针对各个系统编写了窗口，按钮，文字等控件，Linux 中的窗口，按钮，文字等就是一族控件（产品），windows 中的这些则属于另一族控件……），简单工厂模式的工厂负责生成所有产品。</p></li><li><p>工厂方法模式的静态方法获取生成产品的工厂，简单工厂模式的静态方法直接获取产品。</p></li></ul><p>可以认为，工厂方法模式就是将简单工厂中各个产品的初始化（生产）过程划分开来。生成工厂的工厂仍旧是类似简单工厂的模式，这是没有问题的——工厂的初始化应当是简单且一致的，可以进行抽象。提供给外部的接口也可以与简单工厂一致。其中一个实现如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FruitFactory</span> &#123;<br>    <span class="hljs-comment">// 工厂中获取水果实例的方法</span><br>    Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 这两个静态方法将获取对应工厂并通过其来获取 Fruit，这里使用了模板模式</span><br>    <span class="hljs-comment">// 实际使用中不应当让用户输入全类名，可以像 spring 中的 xml 配置那样给类名绑定一个 id</span><br>    <span class="hljs-keyword">static</span> Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">(String factoryName)</span> &#123;<br>        <span class="hljs-keyword">if</span> (factoryName == <span class="hljs-literal">null</span> || factoryName.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;需给定有效字符串！&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; factoryClass = Class.forName(factoryName);<br>            <span class="hljs-comment">// 获取工厂时可以使用单例模式！</span><br>            <span class="hljs-comment">// 这里没有加入错误检查</span><br>            <span class="hljs-keyword">return</span> getFruit((Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FruitFactory</span>&gt;) factoryClass);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">(Class&lt;? extends FruitFactory&gt; factoryClass)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> factoryClass.getDeclaredConstructor().newInstance().getFruit();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FruitFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 一些处理。..</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    &#125;    <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BananaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FruitFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 一些处理。..</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Banana</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// . . . </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ClassNotFoundException &#123;<br>        FruitFactory.getFruit(AppleFactory.class).whoAmI();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>工厂方法模式可以与各种设计模式组合使用，最有价值的几个组合是和<strong>单例模式，原型模式，代理模式</strong>……技术上对工厂方法模式的发展和改进是持续进行的，目前最经典和最有实践价值的实现是 Spring 的核心容器，它不仅负责管理各个产品（称为 bean），也能管理各个产品之间的相互依赖，用户能够完全不用关心代码的具体实现。这种抽象性虽然让系统更加难以理解，但对工程实践是极为方便的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Java 的闭包</title>
    <link href="/2021/07-14%E5%85%B3%E4%BA%8EJava%E7%9A%84%E9%97%AD%E5%8C%85.html"/>
    <url>/2021/07-14%E5%85%B3%E4%BA%8EJava%E7%9A%84%E9%97%AD%E5%8C%85.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>之前未能理解 Java 对闭包的说明中“effective final”的意思，现在对其进行了一番针对性学习。</p><p>这个词（实际上的 final）应当这样理解——在闭包中不能改变外界变量的“值”，这个“值”对基本类型来说是值，对引用类型来说是引用。这个问题的影响其实并不大——如果需要对变量的值进行改变，将其传入一个数组即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Supplier&lt;Integer&gt; <span class="hljs-title function_">Counter</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 也可使用 IntSupplier</span><br>  <span class="hljs-type">int</span>[] count = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">return</span> () -&gt; &#123;<br>    count[<span class="hljs-number">0</span>]++; <span class="hljs-comment">// 捕获</span><br>    <span class="hljs-keyword">return</span> count[<span class="hljs-number">0</span>];<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  Supplier&lt;Integer&gt; counter = Counter();<br>  System.out.println(counter.getAsInt());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>为什么不能改变外界变量的值？这里可以这样解释（事实上也大概就是如此）——Java 的闭包并非真正捕获外界变量（这种捕获是捕获了 C++风格的真正的<strong>引用</strong>，js，scheme 等语言的闭包都是如此，对这些语言来说，它们所定义的函数看待上层作用域中的变量，就像 if，for 块看待外层块作用域的时候一样），而是把对象的值<strong>复制</strong>（对基本类型是值，对对象来说是指针）并保存为自身的一个属性，所以如果原值改变，捕获值和原值就不同了，这就和闭包性质所要求的不一致了（这时候的性质类似函数调用，作为函数参数传入），因此禁止了被捕获对象的重新赋值。</p><blockquote><p>Java 中的 lambda 表达式是残废的——要使用它必须先定义相应函数式接口，而不能像 kotlin，ts 等语言有所谓函数类型，可以直接应用，且对其的应用（apply）必须要通过其方法，这是比较麻烦的。</p><p>但是这些限制实际上影响不大——需要自定义接口的情况是较少的，Java 本身提供了比较丰富的接口定义可以直接使用，但是代价是增加理解成本；客户代码一般不会预先定义相关类型的变量并自己使用，而是直接通过 lambda 表达式构造相应实例并直接传递给相关方法中，将其的调用交由相关方法进行实现。</p><p>而 Java 的 lambda 的最大缺陷在于——其只能抛出在签名中指明能够抛出的异常！也就是说，如果用户自定义的 lambda 表达式可能出现异常，他必须进行 try-catch！这是极为不便的，目前的解决方案唯有定义自己的函数式接口用于抛出异常！这可不是我们想要的答案——对集合类型的 map-filter-reduce 操作中如果有异常，就必须要 try-catch，无法改变！这是无法理喻的，特别是当我们在 Spring 环境下工作，依赖全局异常处理来进行异常的时候，或者说将异常当作一种别样的控制流来处理的时候。</p></blockquote><p>Java8 提供的<code>java.util.function</code>包包含了许多可以直接应用的函数式接口，可以应付绝大部分简单业务情况——（下表引用于网络）</p><table><thead><tr><th>1</th><th><strong>BiConsumer&lt;T,U&gt;</strong> 代表了一个接受两个输入参数的操作，并且不返回任何结果</th></tr></thead><tbody><tr><td>2</td><td><strong>BiFunction&lt;T,U,R&gt;</strong> 代表了一个接受两个输入参数的方法，并且返回一个结果</td></tr><tr><td>3</td><td><strong>BinaryOperator<T></strong> 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果</td></tr><tr><td>4</td><td><strong>BiPredicate&lt;T,U&gt;</strong> 代表了一个两个参数的 boolean 值方法</td></tr><tr><td>5</td><td><strong>BooleanSupplier</strong> 代表了 boolean 值结果的提供方</td></tr><tr><td>6</td><td><strong>Consumer<T></strong> 代表了接受一个输入参数并且无返回的操作</td></tr><tr><td>7</td><td><strong>DoubleBinaryOperator</strong> 代表了作用于两个 double 值操作符的操作，并且返回了一个 double 值的结果。</td></tr><tr><td>8</td><td><strong>DoubleConsumer</strong> 代表一个接受 double 值参数的操作，并且不返回结果。</td></tr><tr><td>9</td><td><strong>DoubleFunction<R></strong> 代表接受一个 double 值参数的方法，并且返回结果</td></tr><tr><td>10</td><td><strong>DoublePredicate</strong> 代表一个拥有 double 值参数的 boolean 值方法</td></tr><tr><td>11</td><td><strong>DoubleSupplier</strong> 代表一个 double 值结构的提供方</td></tr><tr><td>12</td><td><strong>DoubleToIntFunction</strong> 接受一个 double 类型输入，返回一个 int 类型结果。</td></tr><tr><td>13</td><td><strong>DoubleToLongFunction</strong> 接受一个 double 类型输入，返回一个 long 类型结果</td></tr><tr><td>14</td><td><strong>DoubleUnaryOperator</strong> 接受一个参数同为类型 double, 返回值类型也为 double 。</td></tr><tr><td>15</td><td><strong>Function&lt;T,R&gt;</strong> 接受一个输入参数，返回一个结果。</td></tr><tr><td>16</td><td><strong>IntBinaryOperator</strong> 接受两个参数同为类型 int, 返回值类型也为 int 。</td></tr><tr><td>17</td><td><strong>IntConsumer</strong> 接受一个 int 类型的输入参数，无返回值 。</td></tr><tr><td>18</td><td><strong>IntFunction<R></strong> 接受一个 int 类型输入参数，返回一个结果 。</td></tr><tr><td>19</td><td><strong>IntPredicate</strong> ：接受一个 int 输入参数，返回一个布尔值的结果。</td></tr><tr><td>20</td><td><strong>IntSupplier</strong> 无参数，返回一个 int 类型结果。</td></tr><tr><td>21</td><td><strong>IntToDoubleFunction</strong> 接受一个 int 类型输入，返回一个 double 类型结果 。</td></tr><tr><td>22</td><td><strong>IntToLongFunction</strong> 接受一个 int 类型输入，返回一个 long 类型结果。</td></tr><tr><td>23</td><td><strong>IntUnaryOperator</strong> 接受一个参数同为类型 int, 返回值类型也为 int 。</td></tr><tr><td>24</td><td><strong>LongBinaryOperator</strong> 接受两个参数同为类型 long, 返回值类型也为 long。</td></tr><tr><td>25</td><td><strong>LongConsumer</strong> 接受一个 long 类型的输入参数，无返回值。</td></tr><tr><td>26</td><td><strong>LongFunction<R></strong> 接受一个 long 类型输入参数，返回一个结果。</td></tr><tr><td>27</td><td><strong>LongPredicate</strong> R 接受一个 long 输入参数，返回一个布尔值类型结果。</td></tr><tr><td>28</td><td><strong>LongSupplier</strong> 无参数，返回一个结果 long 类型的值。</td></tr><tr><td>29</td><td><strong>LongToDoubleFunction</strong> 接受一个 long 类型输入，返回一个 double 类型结果。</td></tr><tr><td>30</td><td><strong>LongToIntFunction</strong> 接受一个 long 类型输入，返回一个 int 类型结果。</td></tr><tr><td>31</td><td><strong>LongUnaryOperator</strong> 接受一个参数同为类型 long, 返回值类型也为 long。</td></tr><tr><td>32</td><td><strong>ObjDoubleConsumer<T></strong> 接受一个 object 类型和一个 double 类型的输入参数，无返回值。</td></tr><tr><td>33</td><td><strong>ObjIntConsumer<T></strong> 接受一个 object 类型和一个 int 类型的输入参数，无返回值。</td></tr><tr><td>34</td><td><strong>ObjLongConsumer<T></strong> 接受一个 object 类型和一个 long 类型的输入参数，无返回值。</td></tr><tr><td>35</td><td><strong>Predicate<T></strong> 接受一个输入参数，返回一个布尔值结果。</td></tr><tr><td>36</td><td><strong>Supplier<T></strong> 无参数，返回一个结果。</td></tr><tr><td>37</td><td><strong>ToDoubleBiFunction&lt;T,U&gt;</strong> 接受两个输入参数，返回一个 double 类型结果</td></tr><tr><td>38</td><td><strong>ToDoubleFunction<T></strong> 接受一个输入参数，返回一个 double 类型结果</td></tr><tr><td>39</td><td><strong>ToIntBiFunction&lt;T,U&gt;</strong> 接受两个输入参数，返回一个 int 类型结果。</td></tr><tr><td>40</td><td><strong>ToIntFunction<T></strong> 接受一个输入参数，返回一个 int 类型结果。</td></tr><tr><td>41</td><td><strong>ToLongBiFunction&lt;T,U&gt;</strong> 接受两个输入参数，返回一个 long 类型结果。</td></tr><tr><td>42</td><td><strong>ToLongFunction<T></strong> 接受一个输入参数，返回一个 long 类型结果。</td></tr><tr><td>43</td><td><strong>UnaryOperator<T></strong> 接受一个参数为类型 T, 返回值类型也为 T。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 js 的 promise</title>
    <link href="/2021/07-07%E5%85%B3%E4%BA%8Ejs%E7%9A%84promise.html"/>
    <url>/2021/07-07%E5%85%B3%E4%BA%8Ejs%E7%9A%84promise.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>  2021 年 11 月 23 日更新。最近突然意识到，Promise 是一个 Monad，其 then 方法兼具 fmap 和 bind 的功能——返回值为新的 Promise 对象，或是为普通的值，都能正确处理，所谓的 await，async 语法很像 Haskell 中的 do。比如下面两个 asyncFunc 就是等价的。</p>  <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)&#125;, <span class="hljs-number">1000</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)&#125;, <span class="hljs-number">1000</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunc1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> numA = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fun1</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;numA:&quot;</span> + numA)<br>    <span class="hljs-keyword">const</span> numB = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fun2</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;numB:&quot;</span> + numA)<br><span class="hljs-keyword">return</span> numA + numB;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunc2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fun1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">numA</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;numA:&quot;</span> + numA)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fun2</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">numB</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;numB:&quot;</span> + numA)<br>            <span class="hljs-keyword">return</span> numA + numB;<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p>promise 是 ES6 为解决异步编程过于复杂的问题所提出的一种技术&#x2F;异步模式。对其的学习是必要的。</p><h1 id="什么是-promise"><a href="#什么是-promise" class="headerlink" title="什么是 promise"></a>什么是 promise</h1><p>promise，意为“承诺”，它归根结底是一个类，其将异步操作（或同步操作）封装在自己的构造器中并获取结果或错误。其后其允许使用异步方法取出结果。</p><p>promise 的优点在于其能避免回调地狱——多层的嵌套，将嵌套调用变成链式调用，且其保存的结果将被缓存以备无数次的监听。其也提供了合适的方式以方便错误和异常的处理。promise 当然也有缺点——不然也不会有像 RxJS 这样其它的异步解决方案了，但是这是我当前感觉不到的。</p><h1 id="Promise-构造器和-then，catch"><a href="#Promise-构造器和-then，catch" class="headerlink" title="Promise 构造器和 then，catch"></a>Promise 构造器和 then，catch</h1><p>使用 Promise 的一个比较典型的方式是使用其构造函数，其构造函数接受一个参数——它称为执行器，executor，该执行器有两个参数——resolve 和 reject，其都是函数，其作用为收集结果或错误，用户将异步操作置于其函数体中，并通过 resolve 收集结果，或通过 reject 收集错误，如果遇到异常，则效果同 reject 方法相同。整个函数体将会<strong>同步执行</strong>。</p><p>Promise 对象维护两个属性——其一是其状态（state），状态分为三种——pending，resolve（fulfilled），reject。pending 是默认状态，标识还未获得结果。在调用 resolve 或 reject 时，状态将发生转移——从 pending 到 resolve，从 pending 到 reject，这种状态转移只会执行一次，也就是说它只会收集第一次调用 resolve 或 reject 的结果，其后的调用将被忽视（但是函数的执行不会被中断）；另一个属性则是结果。</p><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p>用户可以使用 then 方法，通过其回调接受 promise 的结果，then 方法是可以无数次执行的，其回调是异步的。下面是一个示例。then 也可以接受第二个函数参数——代表 reject 时的回调。可以认为 then 是在这里注册了一个临时的监听器，在状态为 fulfilled 时执行函数体，因此它是异步的，即使状态早在 then 方法执行前改变也是如此。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><br><span class="hljs-comment">// ts 能够通过泛型指定 resolve 函数接受的类型</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <span class="hljs-comment">// 同步</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入执行器函数体了&quot;</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello, happy world!&quot;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve 了&quot;</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;退出执行器函数体了&quot;</span>)<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>)=&gt;</span>&#123; <span class="hljs-comment">// 异步</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取到了&quot;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then 方法之后&quot;</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123; <span class="hljs-comment">// 多次接受</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;能够多次获取，结束后能继续获取&quot;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// 通过链式调用 catch 方法能够获取执行过程中抛出的异常</span><br>    <br>&#125;, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">进入执行器函数体了</span><br><span class="hljs-comment">退出执行器函数体了</span><br><span class="hljs-comment">then 方法之后</span><br><span class="hljs-comment">resolve 了</span><br><span class="hljs-comment">获取到了</span><br><span class="hljs-comment">hello, happy world!</span><br><span class="hljs-comment">能够多次获取，结束后能继续获取</span><br><span class="hljs-comment">hello, happy world!</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p><strong>then 方法的返回值也是 promise 对象</strong>（这或许是 promise 相比与原先的以回调为基础的异步编程的最大的差别吧？通过这种性质，then 方法能够对多个同步&#x2F;异步任务进行串联，链式调用），其结果取决于 then 方法中函数的返回值（如果成功，调用 onfulfilled，如果失败，调用 onrejected）。函数正常返回时，返回一个结果为返回值的 resolved 的 promise 对象；函数抛出异常时，返回一个结果为异常的 rejected 的 promise 对象；函数返回新的 promise，则返回值就为该 promise。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 测试 then 方法的返回值</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">let</span> res = p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;<br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;  <br>    <span class="hljs-comment">// Promise &#123; 1000 &#125;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// 必须使用 setTimeout 或者 res.then，否则状态一定是 pending，这是因为其是异步的</span><br>&#125;, <span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p>利用 then 的这种特性，可以进行链式调用。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    &#125;)<br></code></pre></div></td></tr></table></figure><p>可以通过返回一个永远在 pending 状态的 promise 来中断调用链，这是中断的唯一办法（异常不能算中断，它进入了错误处理逻辑中）。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 不会再执行下去了，实践上来说这个应该放在条件语句中</span><br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    &#125;)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>进行链式调用时，必须要遵循这样的规范——同步调用直接写在方法的参数的函数体中，异步调用写在新的 promise 对象的执行器中。</p><h2 id="catch-和异常穿透"><a href="#catch-和异常穿透" class="headerlink" title="catch 和异常穿透"></a>catch 和异常穿透</h2><p>catch 方法接受这样一个函数参数——它在 reject 时执行。乍得一看 catch 好似是 then 的子集，没有意义，但是 catch 有这样一个特性——<strong>异常穿透</strong>，当进行 then 的链式调用时，链条上抛出的异常&#x2F;错误会直接到达 catch，并且错误提示中能够指出错误发生的具体位置！</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;err!&quot;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(err)&#125;)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">Error: err!</span><br><span class="hljs-comment">    at path/to/the/file.ts:19:15   居然能够给定发生异常的位置！nba</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h2 id="一个简单的实现"><a href="#一个简单的实现" class="headerlink" title="一个简单的实现"></a>一个简单的实现</h2><p>下面展示了对 Promise 的一个简单的实现。其中 then 的实现是比较重要的——它将返回一个新的 Promise，在执行器中，它将等待直到当前 Promise 实例的状态不为 pending，然后修改自身的状态。这里可以有其它的实现方法——比如在 Promise 中维护一个保存 then 中回调的数组作为属性，调用 then 方法时，如果 Promise 仍旧是 pending 状态，则将这时的上下文添加到数组中，在状态改变时，即调用 resolved，reject 方法时，对数组进行遍历执行。如果不是 pending，则直接执行（但应当通过 setTimeout 将其变为异步）。同时关于 result 是 promise 时进行处理的逻辑也转移到 then 方法中执行。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 不会用 ts 的泛型，随便写写</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PromiseState</span> &#123;<br>    <span class="hljs-variable constant_">PENDING</span>, <span class="hljs-variable constant_">FULFILLED</span>, <span class="hljs-variable constant_">REJECTED</span><br>&#125;<br><br><span class="hljs-comment">// 工具函数，在 signal 函数返回真时执行回调，否则持续执行</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">waitUntil</span>(<span class="hljs-params">doSomething:()=&gt;<span class="hljs-built_in">void</span>,signal:()=&gt;<span class="hljs-built_in">boolean</span></span>) &#123;<br>    <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-comment">// setInterval 的性能可能是不好的</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">signal</span>()) &#123;<br>            <span class="hljs-title function_">doSomething</span>();<br>            <span class="hljs-built_in">clearInterval</span>(interval)<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 状态</span><br>    <span class="hljs-keyword">private</span> state : <span class="hljs-title class_">PromiseState</span> = <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">PENDING</span><br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-keyword">private</span> value : <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">setToPromise</span>(<span class="hljs-params">anotherMyPromise : MyPromise&lt;T&gt;</span>) &#123;<br>        <span class="hljs-title function_">waitUntil</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = anotherMyPromise.<span class="hljs-property">value</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = anotherMyPromise.<span class="hljs-property">state</span><br>        &#125;, <span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-keyword">return</span> anotherMyPromise.<span class="hljs-property">state</span> !== <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">PENDING</span>;<br>        &#125;)<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor : (resolve : (arg0: T)=&gt;<span class="hljs-built_in">void</span>, reject : (arg0: <span class="hljs-built_in">any</span>)=&gt;<span class="hljs-built_in">void</span>)=&gt;<span class="hljs-built_in">void</span></span>)&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">arg : T</span>) =&gt; &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">PENDING</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 状态只改变一次</span><br>                <span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123; <span class="hljs-comment">// 如果参数就是 Promise</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setToPromise</span>(arg)<br>                &#125;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = arg;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">FULFILLED</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">arg : <span class="hljs-built_in">unknown</span></span>) =&gt; &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">PENDING</span>) <span class="hljs-keyword">return</span>; <br>                <span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123; <span class="hljs-comment">// 如果参数就是 Promise</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setToPromise</span>(arg)<br>                &#125;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = arg;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">REJECTED</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-title function_">executor</span>(resolve, reject)<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(err) &#123;<br>            <span class="hljs-title function_">reject</span>(err);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> then&lt;V&gt;(onfulfilled : <span class="hljs-function">(<span class="hljs-params">v : T</span>) =&gt;</span> V, onrejected? : <span class="hljs-function">(<span class="hljs-params">v : <span class="hljs-built_in">unknown</span></span>) =&gt;</span> <span class="hljs-built_in">unknown</span>) : <span class="hljs-title class_">MyPromise</span>&lt;<span class="hljs-built_in">unknown</span>&gt; &#123;<br>        <span class="hljs-comment">// 调用 then 时，相当于设置了一个临时的监听器。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">waitUntil</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">REJECTED</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (!onrejected) &#123;<br>                        reject (<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>                        <span class="hljs-keyword">return</span><br>                    &#125;<br>                    <span class="hljs-title function_">reject</span>(<span class="hljs-title function_">onrejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>))<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">FULFILLED</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">onfulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>                        <span class="hljs-title function_">resolve</span>(res)<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (err) &#123; <span class="hljs-comment">// 调用 onfulfiled 时发生异常</span><br>                        <span class="hljs-title function_">reject</span>(err)<br>                    &#125;<br>                &#125;<br>            &#125;, <span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">PENDING</span><br>            &#125;)<br>        &#125;)<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">catch</span>(onrejected : <span class="hljs-function">(<span class="hljs-params">v : <span class="hljs-built_in">unknown</span></span>) =&gt;</span> <span class="hljs-built_in">unknown</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">waitUntil</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">REJECTED</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (!onrejected) &#123;<br>                        reject (<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>                        <span class="hljs-keyword">return</span><br>                    &#125;<br>                    <span class="hljs-title function_">reject</span>(<span class="hljs-title function_">onrejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>))<br>                &#125;<br>            &#125;, <span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-title class_">PromiseState</span>.<span class="hljs-property">PENDING</span><br>            &#125;)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> resolve&lt;V&gt;(arg : V) : <span class="hljs-title class_">MyPromise</span>&lt;V&gt; &#123;<br>        <span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) <span class="hljs-keyword">return</span> arg;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-title function_">resolve</span>(arg)&#125;)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="all，-race"><a href="#all，-race" class="headerlink" title="#all，#race"></a>#all，#race</h1><p>all 和 race 是 Promise 提供的两个比较重要的静态方法。前者接受一个 promise 的数组并返回一个 promise 对象，其将等待所有 promise 都执行完毕且全为 resolved 时收集所有结果。race 方法也接受一个 promise 数组并返回一个 promise 对象，其将等待某 promise 最先执行完成并收集其结果，无论是 resolved 还是 reject。</p><h1 id="async，await"><a href="#async，await" class="headerlink" title="async，await"></a>async，await</h1><p>async 和 await 是两个非常方便的操作符。async 将函数转换成返回 promise 的<strong>异步函数</strong>，结果的类型取决于 return 的结果，如果 return 一个非 promise 的值，其将被包装，如果 return 一个 promise，那就是 return 该 promise。抛出异常则返回一个 rejected 的 promise。</p><p>await 对 promise 进行操作，其将等待直到 promise 返回结果。await 的返回值为 promise 的结果。<strong>await 必须在 async 函数内部使用</strong>。通过 async 和 await，可以轻易将异步操作转换成同步操作流，对编写非常方便。</p><p>await 所接受的 promise 如果失败，则这个表达式将抛出异常——值为失败的结果，需要在外层进行捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 其实就这里来说，这里的 async 是无关紧要的，可以去掉</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn1</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步过程 1&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-number">123</span>)<br>        &#125;, <span class="hljs-number">2000</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn2</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步过程 2&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;number&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-number">456</span>)<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;dsdsdssd&quot;</span>)<br>        &#125;, <span class="hljs-number">1000</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mainFn</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn1</span>();<br>    <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res1, res2, <span class="hljs-string">&quot;wow&quot;</span>)<br>&#125;<br><span class="hljs-title function_">mainFn</span>().<span class="hljs-title function_">then</span>() <span class="hljs-comment">// 经过一定的配置可以在顶层使用 await</span><br></code></pre></div></td></tr></table></figure><p><img src="/images/oss/2021/07/142021-07-14.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再看面向对象的六原则</title>
    <link href="/2021/07-04%E5%86%8D%E7%9C%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%8E%9F%E5%88%99.html"/>
    <url>/2021/07-04%E5%86%8D%E7%9C%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%8E%9F%E5%88%99.html</url>
    
    <content type="html"><![CDATA[<p>在学习 spring 的时候看到它利用了许多设计模式，如代理，单例，策略，原型等，感到有继续学习设计模式，并且联系实践的必要了。</p><p>目前看《设计模式之禅》，这本书关于面向对象的六个原则提出了更加深刻和具有实践性的见解，颠覆了我以往的看法，这次跟着详细学习一次。目标不是学究似的抓准确定义，而是看对实践有无新的启迪。认识世界的目的终究是改造世界。</p><h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>单一职责原则（Single Responsibility Principle），表面上看起来内涵并不多——好好分工，各司其职，从而保证维护性，扩展性，解耦嘛。但是这里有两个问题——它的主体是谁？也就是说，是谁要承担这里所谓的单一职责？是类，接口还是方法？另一个问题是，职责该如何划分？比如打电话是一个职责，它继续细分不是还能够分成电话的接通，通信，挂断吗？这些过程不是还能够分成更多部分吗？</p><p>关于单一职责的主体问题，答案是均有，但是主要是接口和方法，在生产实践中，对类的设计<strong>通常</strong>是不强求满足单一职责原则的——如果每个类都只负责一个职责，那类的数量以及关系的复杂度将会严重上升，因此一般是让接口满足单一职责，面向接口（抽象层）编程嘛！至于方法的单一职责，这应当是无需强调的——对方法&#x2F;函数的使用，要么是利用其返回值，要么利用其副作用，如若均有则会让代码不清晰，阅读困难，难以通过方法&#x2F;函数名直接获取其作用等。</p><p>职责的划分则是一个更重要的问题，我认为真正的单一“职责”只存在于编程语言的“原子”，即我们一般能接触到的最底层的形式——单行表达式（就本质来说，这职责还能够继续细分，划分成机器语言，微代码的执行等，乃至更加底层的物理领域，层层的抽象）。单一职责原则中所说的职责和前面所述的“职责”，显然是更加接近自然语言中所提到的“职责”的。</p><p>因此，我认为对职责的划分是一个广泛和复杂的问题，问题领域（即代码所面临的场景），划分的根据，代码编写者的实践经验，语言限制，甚至硬件限制等都可能对职责的划分做出影响。并且任一职责一般来说都是非“单一”的，其应当能够继续细分，形成一个树状结构。比如上面所说的打电话，可分为接通，通信，挂断三个步骤，这是按次序或步骤进行职责划分，但是这里又可以看到，接通和挂断是和协议相关的，而通信则是和接通、挂断完全无关的——我说什么话和用电信还是联通没有任何关系，因此这里又可以将接通和挂断综合为一个职责……最终究竟采用何种抽象可能都能完成任务，只不过其的维护性，扩展性，抽象性等需要在实践中才能认知到了。但是一定的场景下一定有一个相应的最佳实践（当然，绝对和相对的关系），只不过归纳出一般论是困难的。</p><p>单一职责原则原话的解释是<code>There should never be more than one reason for a class to change</code>。老实说难以理解，change 是什么意思？改变状态？副作用？？do something？但是这里也可以看到，其主体是类，这在生产实践中通常是难以遵守的。</p><p>对单一职责原则，我认为这里仅需要认知的是，其一般适用于接口，设计接口时一定要满足单一职责原则，类则尽量进行满足。更加丰富的结论要在积累足够感性经验后才能获得。</p><h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><blockquote><p>下面所说的父类既可以是类，也可以是抽象类，接口，子类也同样如此。</p></blockquote><p>这个原则表面上仍然是容易理解的——能用父类的地方，其子类一定要能够<strong>透明地</strong>（对程序员不可见）使用且不产生问题。这仍旧是对现实关系的抽象——兔子是动物，要动物的地方可以给一个兔子，但是要兔子的地方就不能给一个动物——除非它就是兔子。子类一定<strong>是</strong>父类，父类不一定<strong>是</strong>子类。这里的“是”指逻辑上的属种关系。</p><p>子类在拥有父类的特性的基础上，要能够有自己特定的特性。但这种特性是不违反父类特性的基础上的。在实践中这既是优点也是缺点，优点在于能够重用，容易对父类进行扩展；缺点在于，子类必须继承父类所有方法和域（当然，只有 public 和 protected 的方法和域对子类可见），实现父类中所有方法，代码灵活性降低，且耦合性增强了——一旦父类要进行更改，所有子类都要进行更改。</p><p>在进行编程时，应当使用父类或接口作为声明类型，这时候父类或接口就像一个<strong>契约</strong>（依赖倒置原则也对其起作用），如若发现某种情况下无法进行这样的使用，则说明里氏替换原则被违反了，应当进行重构。</p><p>要满足里氏替换原则，子类对父类的方法进行覆盖或重载时，只能够将参数进行扩大而不能缩小，只能将输出结果进行缩小而不能扩大。这里的扩大是指从子类到父类，比如从 HashMap 到 Map，缩小指从父类到子类，如从 Map 到 HashMap。前者设计是为了子类对覆盖的方法进行重载时能够不覆盖父类的实现，否则里氏替换原则就要被破坏了——子类分明没有重写父类的方法，调用的时候却跑了子类的逻辑而非父类的逻辑！一个代码示例见下。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这个示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-comment">// 父类返回较大</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类被调用&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-comment">// 子类返回较小，不满足上面的要求</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类被调用&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">Father</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>        obj.doSomething(tmp);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 这里的输出是有趣的——当数组使用 List 声明类型，无论何时都是父类被调用；数组使用 ArrayList 声明类型时，obj 的声明类型是 Father 时父类被调用，是 Son 时子类被调用，里氏替换原则不满足了——能用父类的地方用子类，结果和预想的不同了（预想的是应当进入父类的方法，或者是子类所重写的父类的方法）。这是令人迷惑的。</span><br></code></pre></div></td></tr></table></figure><p>后者设计则是协变机制。这里不多做介绍。</p><blockquote><p>这个原则是非常迷惑的，但若是遵循面向抽象层编程的规范，一般来说不会出现这个问题。</p></blockquote><p>保证里氏替换原则能够达到这样的效果——即使新增加子类，原有的使用该类父类的代码都可以继续运行而不会出现问题。这保证了可维护性和扩展性。</p><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>依赖倒置原则包括三层含义——</p><ul><li>高层模块（的实现）不应当依赖底层模块（的实现），两者都应当依赖抽象。</li><li>抽象不应当依赖于细节。</li><li>细节应当依赖于抽象。</li></ul><p>这个原则实际上就是要求我们<strong>面向接口编程</strong>。第一层含义表示，高层模块对底层模块进行使用时，不应当依赖底层模块的具体实现，而是依赖底层模块所做的抽象，在 Java 中，这种抽象是接口或抽象类。至于后两个含义，细节和抽象的实质和关系，我认为之前理解的已经很清楚了。</p><p>依赖倒置原则反映到使用 Java 语言中，表现为如下几点——</p><ul><li>模块间通过抽象（接口，抽象类）进行依赖，而非是实现类之间进行直接依赖。</li><li>接口和抽象类的实现不依赖于实现类。</li><li>实现类的实现依赖于接口或抽象类。</li></ul><p>就如上面的里氏替换原则所提到的，这里的抽象就像<strong>契约</strong>，其进行的约束不仅是对代码，更是对程序员。通过接口或抽象类进行规范能够极大地提升可维护性，扩展性等。但是现实世界终究是抽象依赖于细节的，很多时候我们得先把正着把路走一遍，吸收够足够感性经验了，才能化为理性认识，把抽象抽取出来，用在之后的实践中。从感性认识到理性认识，再反作用于感性认识，由此螺旋上升，认识是这样的规律，这个原则也是这样的规律。</p><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><ul><li>客户端不应当依赖它不需要的接口。</li><li>类间的依赖关系应当建立在最小的接口上。</li></ul><p>该原则中所谓的“接口”并非指的是语言中的 interface，而是某种更为抽象的东西。接口分为类接口和实例接口，前者为 interface，后者为实例对象。</p><p>接口隔离原则也是容易理解的——只取所需要的依赖，不要任何多余的东西。在 Java 中，对这个原则的实践就和它的描述一样一致。接口隔离原则应当和单一职责原则结合使用——实现类只拿自己所需的依赖，每个接口在保持单一职责的前提下最小化。</p><p>存在这样的情况，即一个接口的设计满足单一职责原则，但是不满足接口隔离原则——很多模块对于这个接口的使用只是使用其的一部分，然后被迫使用文档而非语言特性进行约束，要求不使用某些方法。这种情况下就可以按照隔离原则将这个接口拆分成多个相互独立的接口。但是这种拆分仍旧应当满足单一职责原则。</p><p>要满足接口隔离原则，一个好的实践是尽量减少 public 的方法&#x2F;域成员，也就是说做尽量少的“承诺”，减少与外界的交互。同时也应当认识到，接口的拆分很大程度上是取决于具体业务的。</p><h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p>迪米特法则是关于类之间的耦合的——一个类对于自己相耦合的类应当知道的最少。具体来说，类只和自己的<strong>直接朋友</strong>交流。这同样要求——尽量减少耦合的类的数量；尽量削弱耦合关系——对该类进行改变时，其它相耦合的类的改变最小化。</p><p>朋友就是与该类相互有耦合关系的类，组合，聚合，依赖等关系都属于在内。方法中的输入输出参数中的类为成员朋友类，但是<strong>出现在方法体中的类不属于朋友</strong>。</p><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>对扩展开放，对修改封闭，一切设计模式归根结蒂都是要满足这个原则，只因它是最基础的原则。可以认为前五个原则都是开闭原则在某个具体方面上的表现，或者说是具体与抽象的关系。</p><p>软件产品在它的生命周期内是时时刻刻在变化的，如何保证进行变化时能对原有代码不做大的改动是一个至关重要的问题，这个原则就要求我们尽量通过扩展而非修改的方式实现变化。</p><p>修改分为三类——</p><ul><li>逻辑变化</li></ul><p>单纯一个逻辑的变化，不涉及其它模块，这一般能通过修改原有类的方法来解决。</p><ul><li>模块变化</li></ul><p>模块变化可以认为是模块提供的接口发生的变化，低层次的模块的变化必定会影响高层次模块。</p><ul><li>视图变化</li></ul><p>视图层的变化可能会引起严重的连锁反应，暂且不表。（前后端分离好哇！）</p><p>对这个原则的实现，在 Java 编程中的一个基本要求是，<strong>接口应当稳定可靠，不经常发生变化</strong>。如果必须要进行修改，对接口的修改是最后选择。</p><p>满足开闭原则要求尽量少修改历史代码——所有已经投产的代码都是有意义的（当然，总有特例存在），对历史代码的修改可能会让测试人员重新编写测试，原有的代码的经过实践保证的健壮性需要被重新验证了。这可能会产生很坏的后果。且能够通过扩展来实现变化，能够减轻编码人员的压力——不用在旧代码的海洋（或者是、**）里四处游弋，寻找需要修改的地方了。</p><p>OOP 的六大原则，归根结底就是要求系统能够<strong>拥抱变化</strong>，而实现其的方法并不局限于这六大原则。二十三种设计模式是对这六个原则进行应用，针对特定场景的“样板戏”，对其的学懂弄通是大有益处的——模仿样板戏来进行自己的创造，甚至开发出新的样板戏，对设计模式的学习也能够使对这六大原则认识更清楚…这就是接下来的任务了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Spring 的 IoC 和 AOP</title>
    <link href="/2021/06-29%E5%85%B3%E4%BA%8ESpring%E7%9A%84IoC%E5%92%8CAOP.html"/>
    <url>/2021/06-29%E5%85%B3%E4%BA%8ESpring%E7%9A%84IoC%E5%92%8CAOP.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p><img src="/images/oss/20210811223632.png"></p><blockquote><p>这张图片非常生动形象地描述了 IoC 的性质，它还能进行更多扩展——比如图上的女孩拿到衣服后，可以烫衣服，缝补……以此说明 IoC 容器可以对 Bean 进行非常多的操作，AOP 离开了 IoC，实现也是比较麻烦的。</p></blockquote><p>虽然毕设后端使用的是 Spring Boot，但我实际上对 Spring 斌没有真正的了解过，也就能敲一些业务代码罢了（比较重要的测试也不会用）。现在为准备工作，学一些 Spring 基础，顺便做一些笔记。这里只是粗糙地了解一下，等真正熟练使用了再去了解更深层的东西。</p><h1 id="Spring-是什么"><a href="#Spring-是什么" class="headerlink" title="Spring 是什么"></a>Spring 是什么</h1><p>Spring 是什么？它是什么条件下产生的，基于怎样的理念，提供了什么功能，解决了什么问题？这几个问题是重要的，但是我目前可没法全部回答。</p><p>广义上来说，我们常说的 Spring 实际上指的是 Spring <strong>生态圈</strong>，它包括核心的 Spring 框架，方便配置的 Spring Boot 框架，提供分布式和微服务的 Spring Cloud，负责数据持久化的 Spring Data，负责安全的 Spring Security……其中 Spring 框架是其的核心。</p><p>Spring 是一个<strong>后端框架</strong>，可用于编写服务端应用，桌面端应用（哪有人这么用！），同分布式，微服务等进行结合也是容易的。Spring 是非侵入式的（但 Spring Boot 不是，作为一个脚手架，它要求项目完全在它的框架里演化）。Spring 也提供了各种功能丰富的框架——Web，响应式 Web，安全，模板，持久化，运行时监控等，其也容易和很多其它 java 库结合使用。</p><p>应用程序是由许多组件构成的，每个组件都负责一部分功能，一般来说其会通过和其他组件进行协调和交互来完成自己的任务（和 OOP 很相似）。Spring 的核心是提供了一个<strong>容器</strong>——<strong>Spring 应用上下文（Spring Application Context）</strong>，其将对应用程序中各组件进行创建和管理，最终<strong>装配</strong>到一起。被管理的组件称为** bean**。</p><p>为什么要将组件的生命周期交给 Spring 容器进行管理？为了实现所谓的<strong>控制反转（IoC，Inversion of Control）</strong>，对程序进行解耦，同时让组件更加专注于业务——不需要负责依赖对象的创建和管理了。</p><p>这种装配的过程是通过<strong>依赖注入（DI，Dependency Injection）</strong>实现的，对每个 bean，容器将对其的所有依赖（即其持有的其它 bean）进行注入。可以认为 Spring 应用上下文所维护的就是各个 bean（或者说各个组件）的生命周期及其相互关系。</p><p>装配的配置可以使用 xml 或 java 类，但最常用的仍旧是自动装配——Spring 自动发现包中的组件并进行装配。</p><h1 id="IoC-是什么以及其的意义"><a href="#IoC-是什么以及其的意义" class="headerlink" title="IoC 是什么以及其的意义"></a>IoC 是什么以及其的意义</h1><blockquote><p>我们自己每次用到什么依赖对象都要主动地去获取，这是否真的必要？我们最终所要做的，其实就是直接调用依赖对象所提供的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，<strong>我们完全可以不管这个对象是自己找来的还是别人送过来的</strong>……</p><p>—— 《Spring 揭秘》</p></blockquote><p>IoC（控制反转）即对所需对象的创建不由程序进行，而是由用户进行，将控制权交由用户，Spring 中的 IoC 即是将对象的创建，管理交由 Spring 提供的 IoC 容器进行，其实现的方式是 DI（依赖注入）。IoC 可以认为是工厂方法模式的一种应用。</p><p>就如大多数特定的技术一样，IoC 的意义也在于对程序解耦合，提高程序的可维护性。</p><p>考虑这样一个场景，在某个 Service 里通过 DAO 层获取用户信息。这里系统使用了 MySQl 作为数据库。于是得到了这样的代码——</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>: User;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>: User;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoMySQLImpl</span> : <span class="hljs-type">UserDao</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>: User &#123;<br>        println(<span class="hljs-string">&quot;查询了 MySQL&quot;</span>)<br>        <span class="hljs-keyword">return</span> User()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> : <span class="hljs-type">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userDao : UserDao = UserDaoMySQLImpl()<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>: User &#123;<br>        <span class="hljs-keyword">return</span> userDao.getUser()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后，出于某种奇怪的业务需要，系统又换成了 SQL Server 数据库，然后下面的程序员就编写了 UserDaoSQLServerImpl，并把各种 Service 里的所有的 UserDaoMySQLImpl 改成 UserDaoSQLServerImpl。</p><p>再然后，需求又改了，要用 sqlite 数据库了，于是程序员们又重复了上面的步骤，周而复始……</p><p>这里就可以看到问题，每次需求一改变，都要改源代码，这里的问题在于，各种 serviceImpl 实际上和各种 daoImpl 是<strong>紧耦合</strong>的，要更换使用的 dao 就必须侵入式地修改代码，显然这里可以使用工厂方法模式，通过反射和配置文件生成相应的类。</p><p>但是这里先不提工厂方法模式，一个比较简单的修改方式是，将使用哪个 daoImpl 的权力交给“用户”（使用相关类的代码），让用户通过构造器或 set 方法，对想要使用的 dao 进行设定。如下面的形式——</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> : <span class="hljs-type">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> userDao : UserDao? = <span class="hljs-literal">null</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUserDao</span><span class="hljs-params">(userDao : <span class="hljs-type">UserDao</span>)</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.userDao = userDao;<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>: User &#123;<br>        <span class="hljs-keyword">return</span> userDao?.getUser()!! <span class="hljs-comment">// 这里写的非常不优雅</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 假设这是用户代码</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">userCode</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> userService : UserService = UserServiceImpl()<br>    (userService <span class="hljs-keyword">as</span> UserServiceImpl).setUserDao(UserDaoMySQLImpl()) <span class="hljs-comment">// 在这里注入</span><br>    userService.getUser()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>用户想用 mySQL？想用 SQL Server？自己选择相应的实现就是了！这就是所谓的控制权交给用户，即控制反转的一个示例。更换实现也不需要改变源代码了。但是显然，这也是比较复杂和麻烦的——用户需要手动注入所需依赖，且需要自己创建所需的实际对象，引入了本不必要的复杂性，抽象程度降低了。“如果有人能够在我们需要时将某个依赖对象送过来，为什么还要大费周折地自己去折腾？”</p><h1 id="IoC-的使用"><a href="#IoC-的使用" class="headerlink" title="IoC 的使用"></a>IoC 的使用</h1><p>在 Spring 中，对象创建的控制权交给了 IoC 容器，被接管的对象称为** Bean**。用户需要通过 xml，Java 代码或注解对 Bean 进行配置。使用时，根据 xml 或其它形式获取相关配置的上下文，并手动或自动对 Bean 进行获取，下面是一个手动获取 Bean 的示例。</p><p>IoC 容器接管的类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// DAO 层</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HelloDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getHappyEnergy</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getHappyEnergy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Happy, Lucky, Smile, Yeah!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Service 层</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HelloService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getHappyEnergy</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloService</span> &#123;<br>    <span class="hljs-keyword">private</span> HelloDao helloDao;<br>    <span class="hljs-comment">// 用于注入的 setter，必须要有此方法，Spring 才能进行依赖注入，或者使用 Autowired 注解域也可，Spring 将通过反射设置属性。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHelloDao</span><span class="hljs-params">(HelloDao helloDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.helloDao = helloDao;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getHappyEnergy</span><span class="hljs-params">()</span> &#123;<br>        helloDao.getHappyEnergy();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>xml 文件：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- ApplicationContext.xml --&gt;</span><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- bean 在这里定义，要修改使用的实现？修改 class 即可！</span><br><span class="hljs-comment">    这里还能够进行更加精细的配置，如通过构造器参数配置，</span><br><span class="hljs-comment">    对每个成员进行配置（各种容器类也提供了相应的配置标签），</span><br><span class="hljs-comment">    其成员也可以引用其它 Bean，从而让各实现类能够相互引用，</span><br><span class="hljs-comment">    也可在此配置 autowire，令 IoC 进行自动注入 --&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 也可通过注解和 component-scan，annotation-config 这两个注解进行自动注入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xyz.yukina.dao.HelloDaoImpl&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xyz.yukina.service.HelloServiceImpl&quot;</span> <span class="hljs-attr">p:helloDao-ref</span>=<span class="hljs-string">&quot;helloDao&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>用户代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// ClassPathXmlApplicationContext——通过 xml 获取配置，简写 CPX</span><br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;ApplicationContext.xml&quot;</span>);<br>    <span class="hljs-type">HelloService</span> <span class="hljs-variable">helloService</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;helloService&quot;</span>, HelloService.class);<br>    helloService.getHappyEnergy();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可见，现在用户要获取的实例是通过配置文件给定的，而对配置文件的修改是不需要修改源代码的，这就让各个模块解耦了——在使用 IoC 之前，各个模块是紧密相连，需要手动处理（new）相互的依赖关系，使用 IoC 容器后，它们<strong>实际上只需要与 IoC 容器交互</strong>即可，这样互相的耦合性就降低了，且用户也可以不必关心自己究竟用的是哪个具体类，提高了系统的抽象性。且将对象的创建和管理交管给 IoC 容器，这也让容器对对象进行特定的处理也成为可能，或许 AOP 就是在此条件下实现的吧！</p><p>需要注意的是，Bean 默认是<strong>单例</strong>的，<strong>非惰性</strong>的——在执行<code>new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;)</code>时，所有 bean 默认将被初始化而无论是否使用。</p><h1 id="关于注入的方式"><a href="#关于注入的方式" class="headerlink" title="关于注入的方式"></a>关于注入的方式</h1><p>Spring 提供的注入方式有三种——域注入，set 注入，构造器注入。默认在 xml 中进行配置的话使用的是 set 注入和构造器注入，将 Autowired 注解作用到域中则是域注入。Spring 不推荐使用域注入。</p><p>Spring 推荐使用构造器注入，其次是 set 注入，其中构造器注入用于注入必需的（不为 null）依赖，set 注入用于注入可选的，或者给定默认值的依赖。kotlin 推荐的方式也是构造器注入。构造器注入的优势在于其能够定义注入对象为 final（或者 kotlin 的 val），语义更加明确。</p><p>其中，对于构造器注入，Spring 推荐使用断言来保证为非 null（这里姑且使用 lombok 提供的 NonNull 注解）。一个示例如下。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 域注入</span><br>    <span class="hljs-keyword">private</span> AbcDao abcDao;<br><br>    <span class="hljs-keyword">private</span> AnotherDao anotherDao;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// set 注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAnotherDao</span><span class="hljs-params">(AnotherDao anotherDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.anotherDao = anotherDao;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> HelloDao helloDao;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 构造器注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloServiceImpl</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@Qualifier(&quot;HelloDaoImpl&quot;)</span> <span class="hljs-meta">@NonNull</span> HelloDao helloDao // 如果有歧义，可以在这里用 Qualifier 注解</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-built_in">this</span>.HelloDao = helloDao;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getHappyEnergy</span><span class="hljs-params">()</span> &#123;<br>        helloDao.getHappyEnergy();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意的是，构造器注入法可能导致循环依赖问题！</p><p><img src="/images/oss/20210811225149.jpg"></p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><blockquote><p>关于 AOP，我曾经以为它意义并不重大，直到最近我发现，很多地方如 Spring MVC 中都使用了 AOP，且一些可能对业务很重要的地方也是通过 AOP 实现的。比如控制器中方法的返回值将会经由切面转换成相应视图，JSON 或其它对象，这个转换是可以通过自定义切面进行自定义的，可见学习 AOP 是比较有意义的。</p></blockquote><p>Spring 的 AOP 的实现利用了<strong>代理模式</strong>。实际上我在编写毕设时已经接触过了代理模式——vue 的 ref 对象将原对象的 get 和 set 方法进行<strong>劫持</strong>（我觉得这个词更加形象）以保证监听数据改变，这样，在操作 ref 对象的时候，我们采用和普通对象一样的方式，而 vue 则在后台做更多的操作，如更新视图，维护相关计算属性，方法，监听器等。</p><p>在这里，代理模式的作用在于，真实角色（即原对象）的操作完全不需要关心任何视图层的事情，简单纯粹，而相应的业务交由代理角色（ref 对象）执行，容易进行维护和扩展。代码的编写者只需要对代理角色像真实角色一样进行操作即可，摆脱了手动管理 DOM 的麻烦。我认为<strong>代理模式最大的意义在于，通过特定的抽象，客户端可以完全不用关注自己所使用的是真实角色还是代理角色，从而提高了系统的抽象程度</strong>。</p><p>代理模式有四个角色：</p><ol><li><strong>接口</strong></li></ol><p>接口代表真实角色需要进行代理的方法。在 vue 中，这些方法是对象的各个属性的 get 和 set，因此这里的接口角色是隐含的。</p><ol start="2"><li><strong>真实角色</strong></li></ol><p>真实角色即为被代理的角色，它应当实现接口。</p><ol start="3"><li><strong>代理角色</strong></li></ol><p>代理角色应当持有真实角色（通过<strong>组合</strong>和继承均可，组合最优，这时就通过<strong>委托</strong>进行代理；这里我认为使用继承在语义上更加符合）并实现接口，在接口中，除调用真实角色的相应方法，也应加入自身的处理。代理角色和真实角色都实现接口，以保证其提供的 API 一致。</p><ol start="4"><li><strong>客户端</strong></li></ol><p>客户端为调用接口的角色，在这里，客户端应当使用代理角色，并期待它通过真实角色进行操作时同时执行自己的业务。</p><p>AOP 其实就是这样的东西——它对特定对象进行<strong>切入</strong>，在这些对象执行特定方法时能够进行“劫持”，添加进自己的操作，比如输出，计数，监控 <del>，发给某些企业</del> ，异常处理（！）等，甚至可修改传递给原对象的方法的参数。将方法标识为事务也是利用了 AOP。下面编写了一个实例——通过代理对原有操作进行计数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;做点什么事&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyService myService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceProxy</span><span class="hljs-params">(MyService myService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myService = myService;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;第&quot;</span>+(++counter)+<span class="hljs-string">&quot;次执行&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;执行前&quot;</span>);<br>        myService.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;执行后&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">myService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceImpl</span>(); <span class="hljs-comment">// 也可以不暴露原对象给客户端</span><br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">myServiceProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceProxy</span>(myService);<br>        myServiceProxy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>上面所说的是静态代理模式——代理角色是写死的，而还存在动态代理模式——动态生成代理角色（vue 的例子应当也是动态代理）。动态代理分为<strong>基于接口的动态代理</strong>和<strong>基于类的动态代理</strong>。</p><p>动态代理其实就是利用反射对方法调用进行劫持。这里展示了一个代理 handler 的例子，它劫持所有方法调用，在方法执行前和执行后都进行输出。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 代理 handler，每个 handler 都应当有自己的业务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">// 获取代理实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyInvocationHandler</span>(obj));<br>    &#125;<br><br>    <span class="hljs-comment">// handler 是和被代理对象一一对应的，这非常让人误解</span><br>    <span class="hljs-keyword">private</span> Object t;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyInvocationHandler</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 对象进行方法调用时，实际调用的是这个方法</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行前&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> method.invoke(t, args);<br>        System.out.println(<span class="hljs-string">&quot;执行后&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 业务代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 也可通过给定 Class 的方法避免强转，但是这语法我不会</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">serviceProxy</span> <span class="hljs-operator">=</span> (UserService) ProxyInvocationHandler.getProxyInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>());<br>        serviceProxy.add();<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>代理类的接口为什么要这么设计？看上去简直就是在说，代理处理器是和特定方法（接口）绑定的，而非是和实例绑定的，但在实践中却是和实例进行绑定的。</p></blockquote><p>这个代理 handler 可以进一步抽象成更加一般的形式——要求用户给定方法执行前，执行后将要执行的代码，给定对 args 的处理，给定对输出结果的处理……这里按本人想法进行了一些编码，可以意识到，invoke 方法采用了模板方法模式。相信 Spring 的 AOP 对此有更加具有实践性和更优雅的实现。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 考虑到要持有对象，使用抽象类而非接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object obj;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyHandler</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-built_in">this</span>.obj = obj;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;&#125;;<br>    <span class="hljs-keyword">public</span> Object[] parseArg(Method method, Object[] args) &#123;<span class="hljs-keyword">return</span> args;&#125;;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">parseRes</span><span class="hljs-params">(Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;<span class="hljs-keyword">return</span> method.invoke(obj, args);&#125;;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 这里可以根据 method.getName 对代理的方法做限定</span><br>        before();<br>        <span class="hljs-comment">// 在某些情形，比如缓存时，甚至可以不调用原方法！</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> parseRes(method, parseArg(method, args));<br>        after();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 考虑到如果使用 static，则无法直接引用到类的 class，这里被迫使用抽象程度比较低的写法，同样的，这里可以整个 class 作为参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 一个代理的定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ProxyHandler</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CounterProxy</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-built_in">super</span>(obj);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> startTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> endTime;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行前&quot;</span>);<br>        startTime = System.currentTimeMillis();    <span class="hljs-comment">//获取开始时间</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>        endTime = System.currentTimeMillis();    <span class="hljs-comment">//获取开始时间</span><br>        System.out.println(<span class="hljs-string">&quot;执行后&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;程序运行时间： &quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ns&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 业务代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 考虑到能够让用户不了解 ProxyHandler 便可编写新的代理，我觉得这种抽象程度已经足够</span><br>    <span class="hljs-comment">// 但若是容忍每次编写新的代理类时都把 getProxyInstance 静态方法重写一次，则可使用更加优雅的写法（伴生对象能不能解决这一问题？）</span><br>    <span class="hljs-comment">// 当然，或许更优的方式则是通过工厂方法模式获取相应 Class 并进行操作，这理论上可以通过注解或配置文件进行，应该是非常好的一个解决方案。</span><br>    <span class="hljs-type">UserService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> (UserService) <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>()).getProxyInstance();<br>    service.add();<br>    service.delete();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>AOP 的具体使用方法不再研究了，先研究其他更重要的东西去。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习乐理笔记——音程，转位，调式……</title>
    <link href="/2021/06-05%E5%AD%A6%E4%B9%A0%E4%B9%90%E7%90%86%E2%80%94%E2%80%94%E9%9F%B3%E7%A8%8B%EF%BC%8C%E8%BD%AC%E4%BD%8D%EF%BC%8C%E8%B0%83%E5%BC%8F%EF%BC%8C%E5%92%8C%E5%BC%A6.html"/>
    <url>/2021/06-05%E5%AD%A6%E4%B9%A0%E4%B9%90%E7%90%86%E2%80%94%E2%80%94%E9%9F%B3%E7%A8%8B%EF%BC%8C%E8%BD%AC%E4%BD%8D%EF%BC%8C%E8%B0%83%E5%BC%8F%EF%BC%8C%E5%92%8C%E5%BC%A6.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><h1 id="音程"><a href="#音程" class="headerlink" title="音程"></a>音程</h1><p>音程为两个音之间的“距离”，以半音数为单位。一个八度中，音程可以为：纯一度，小二度，大二度，小三度，大三度，纯四度，增四度，减五度，纯五度，小六度，大六度，小七度，大七度，纯八度。其和半音数的对应关系如表。</p><table><thead><tr><th align="center">纯一度</th><th align="center">小二度</th><th align="center">大二度</th><th align="center">小三度</th><th align="center">大三度</th><th align="center">纯四度</th><th align="center">增四度</th><th align="center">减五度</th><th align="center">纯五度</th><th align="center">小六度</th><th align="center">大六度</th><th align="center">小七度</th><th align="center">大七度</th><th align="center">纯八度</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">10</td><td align="center">11</td><td align="center">12</td></tr></tbody></table><p>纯一度即为自身与自身，间隔 0 个半音，比如 C-C，D-D。</p><p>小二度为间隔 1 个半音，C 大调上有 B-C，E-F。</p><p>大二度为间隔 2 个半音，C 大调上有 C-D，D-E，F-G，G-A，A-B。</p><p>小三度为间隔 3 个半音，C 大调上有 D-F，E-G，A-C。</p><p>大三度为间隔 4 个半音，C 大调上有 C-E,F-A，G-B。</p><p>增四度、减五度间隔 6 个半音，为 F-B，B-F（下一个八度的 F）。</p><p>纯四度间隔 5 个半音，为除 F-B 之外的所有四度。</p><p>纯五度间隔 7 个半音，为除 B-F 之外的所有五度。</p><p>小六度间隔 8 个半音，C 大调上有 E-C，A-F，B-G。</p><p>……</p><h1 id="转位"><a href="#转位" class="headerlink" title="转位"></a>转位</h1><p>根据上面的音程，可以发现各音程间存在一定的规律——将半音数为 n 的音程反转即可得到半音数为 12-n 的音程，比如 C-E 为大三度，E-C 就为小六度（这里的 C 为下一个八度里的 C）。F-B 为增四度，B-F 为减五度。这称为音程的转位。</p><p>总结来说互为转位的音程有如下规律：</p><ul><li>相加为九度。<br>比如大三度转位得到小六度，纯四度转位得到纯五度，相加为九度。</li><li>大小互换，增减互换，纯则不变。<br>例子同上。</li></ul><p>根据这个规律，实际上只需要记忆从纯一度到增四度&#x2F;减五度的音程即可，其后的通过转位进行计算。</p><h1 id="调式"><a href="#调式" class="headerlink" title="调式"></a>调式</h1><p>可以认为调式是一组音阶，其中各个音之间的音程是确定的。调式和主音确定所谓的<strong>调性</strong>。</p><p>现在主要学习了大调和自然小调，大调为分别相隔全全半全全全半（全指一个全音即两个半音，半指一个半音）组成的音阶，小调则相隔全半全全半全全，可以发现大调和小调有“全全半全全”这公共的部分，也就是说将大调最后的“全半”移到前面就能够变成小调，小调最前的全半移到后面就能变成大调。这里就能够获得所谓的关系调（也叫平行调）和同主调的计算方法。</p><p>所谓关系调就是组成的音完全相同的大小调，如 C 大调和 a 小调，同主调就是主音相同的大小调，如 C 大调和 c 小调。</p><p>获取一个大调的关系小调，只需对该大调向左循环移位，直到六级音（下属音）到达第一位为止，比如 C 大调为 CDEFGAB，其六级音为 A，得出的关系小调为 ABCDEFG，为 a 小调（其实实质就是获取主音向下小三度的音——大调的六级音和主音音程一定是大六度，转位后为小三度）。获取小调的关系大调，也只需向左循环移位，直到三级音（属音）到达第一位（主音向上小三度）。</p><p>获取一个大调的同主小调，只需将 3，6，7 级音下降半音即可。可以这样理解：</p><p>大调：n +2 +2 +1 +2 +2 +2 +1<br>小调：n +2 +1 +2 +2 +1 +2 +2</p><p>假设主音是 n，大调的一级音就为 n+2，二级音为 n+2+2……以此类推，最后一个音一定是 n+12（下一个八度的 n）。将大调转成小调，就得调整各级音相对于前一个音的升高（即这里的+i）和小调的一致。</p><p>对第二级音，大小调是一致的，不需要修改。</p><p>对第三级音，大调比小调高 1，因此<strong>减去 1</strong>，把这个 1 当做类似加法的进位看待。</p><p>对第四级音，大调的+1 进 1 得到+2，和小调一致，不变。第五级音也不变。</p><p>对第六级音，大调比小调高 1，**减去 1 **作进位。</p><p>对第七级音，大调加上进位得到+3，**减去 1 **作进位。</p><p>对第八级音，大调比小调高 1，进 1 得到+2，和小调一致。</p><p>总之，为了让大调的音阶能够变化成小调的音阶，需要对 3，6，7 级音降一个半音，并填补在后面的音上。</p><p>小调转大调则正相反，将 3，6，7 级音加上一个半音即可。</p><h1 id="和弦"><a href="#和弦" class="headerlink" title="和弦"></a>和弦</h1><p>和弦即同时奏响多个音，按音的数量有三和弦，七和弦等，按音程的组合有大&#x2F;小和弦，增&#x2F;减和弦等。</p><p>所谓三和弦，就是由三个音组成的和弦，第二个音和第三个音和第一个音分别是三度，五度，因此分别称为三度音，五度音，第一个音称为根音。三和弦中由大三度，小三度组成的和弦称为大三和弦，如 C-E-G，写作 C，由小三度，大三度组成的和弦称为小三和弦，如 D-F-A，写作 Dm，由小三度和小三度组成的和弦称为减三和弦，如 B-D-F，写作 Bdim。</p><p>按照某个调的音阶排列的和弦称为顺阶和弦或调内和弦，其性质是所有组成和弦的音都在调内。如 C 大调的顺阶和弦为 C，Dm，Em，F，G，Am，Bdim。</p><p>七和弦为四个音组成的和弦，因根音和第四个音（七度音）相差七度得名。</p><p>continued…. 这玩意不是一蹴而就的东西，要多次反哺才行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>乐理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些 haskell 的列表操作的实现</title>
    <link href="/2021/05-27%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9Bhaskell%E7%9A%84%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C.html"/>
    <url>/2021/05-27%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9Bhaskell%E7%9A%84%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C.html</url>
    
    <content type="html"><![CDATA[<p>最近专注毕设，太久没写新东西了，该整点活了。</p><p>最近又开始去了解 haskell，之前学这语言觉得语法和之前学的差距太大因此弃坑（也或许是看得太快了），现在回过头来才发现，还挺有趣的。haskell 很有魔力，和之前学的语言又有很大差别，感觉又太过学术性……学起来确实是挺难的。</p><p>还是根据之前看的《Haskell 趣学指南》来学。这篇文章实现一下 haskell 的几个已有的函数。</p><h1 id="replicate-repeat"><a href="#replicate-repeat" class="headerlink" title="replicate, repeat"></a>replicate, repeat</h1><p>replicate 接受一个整数 n 和一个元素，返回包含 n 个该元素的列表。</p><p>显然当 n 为 0 的时候返回空列表，这里约定 n 小于 0 的时候也返回空列表，明显地，这里已经获得递归的基线条件了。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">replicate&#x27;</span> :: (<span class="hljs-type">Ord</span> t, <span class="hljs-type">Num</span> t) =&gt; t -&gt; a -&gt; [a]<br><span class="hljs-title">replicate&#x27;</span> n elem<br>    | n &lt;= <span class="hljs-number">0</span> = []<br>    | otherwise = elem : replicate&#x27; (n - <span class="hljs-number">1</span>) elem<br></code></pre></div></td></tr></table></figure><p>repeat 生成某元素的无限列表（牛逼啊……），实现非常容易。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">repeat&#x27;</span> :: a -&gt; [a]<br><span class="hljs-title">repeat&#x27;</span> elem = elem:repeat&#x27; elem<br></code></pre></div></td></tr></table></figure><h1 id="take-reverse-elem"><a href="#take-reverse-elem" class="headerlink" title="take, reverse, elem"></a>take, reverse, elem</h1><p>take 函数从列表中取出前 n 个元素。约定 n 小于等于 0 时取得空列表，列表为空的时候取得空列表。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">take&#x27;</span> :: (<span class="hljs-type">Ord</span> t, <span class="hljs-type">Num</span> t) =&gt; t -&gt; [a] -&gt; [a]<br><span class="hljs-title">take&#x27;</span> n _ <br>    | n &lt;= <span class="hljs-number">0</span> = []<br><span class="hljs-title">take&#x27;</span> _ [] = []<br><span class="hljs-title">take&#x27;</span> n (x:xs) = x : take&#x27; (n - <span class="hljs-number">1</span>) xs<br></code></pre></div></td></tr></table></figure><p>一个非常鬼畜的地方是，像<code>take 3 []</code>这样的函数调用时会报错的，haskell 抱怨到，它不知道这个列表里的元素究竟是什么类型（即使这是一个空列表！）。同理，<code>[]</code>在任何地方直接使用（不使用++和：，否则 haskell 能推断出类型，也不指定类型，如<code>[] :: [Integer]</code>，这是不会报错的）都会报这个错误，而且那错误提示还挺晦涩，挺迷惑人的。</p><p>elem 检测元素是否在列表中。遍历一遍，每次查头部即可，和 lisp 版的一样。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">elem&#x27;</span> :: <span class="hljs-type">Eq</span> t =&gt; t -&gt; [t] -&gt; <span class="hljs-type">Bool</span><br><span class="hljs-title">elem&#x27;</span> a [] = <span class="hljs-type">False</span><br><span class="hljs-title">elem&#x27;</span> a (x:xs) = a == x || elem&#x27; a xs<br><br><span class="hljs-comment">-- 简化版</span><br><span class="hljs-title">elem&#x27;</span> :: <span class="hljs-type">Eq</span> t =&gt; t -&gt; [t] -&gt; <span class="hljs-type">Bool</span><br><span class="hljs-title">elem&#x27;</span> a = foldr (\ x -&gt; (||) (a == x)) <span class="hljs-type">False</span><br></code></pre></div></td></tr></table></figure><p>reverse 的实现就不用多说了 8。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">reverse&#x27;</span> :: [a] -&gt; [a]<br><span class="hljs-title">reverse&#x27;</span> [] = []<br><span class="hljs-title">reverse&#x27;</span> (x:xs) = reverse&#x27; xs ++ [x]<br><br><span class="hljs-comment">-- 使用折叠和 flip 的更加酷炫的实现</span><br><span class="hljs-title">reverse&#x27;</span> :: [a] -&gt; [a]<br><span class="hljs-title">reverse&#x27;</span> [] = []<br><span class="hljs-title">reverse&#x27;</span> xs = <br>    foldl (flip (:)) [] xs<br></code></pre></div></td></tr></table></figure><h1 id="zip-zipWith"><a href="#zip-zipWith" class="headerlink" title="zip, zipWith"></a>zip, zipWith</h1><p>zip 将两列表中对应位置元素一一组成元组列表，其长度为两列表中较小的一个。zipWith 方法接受一个函数和两个列表，将两列表中对应元素一一应用到函数并返回结果的列表。写起来其实和 zip 一样。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">zip&#x27;</span> :: [a] -&gt; [b] -&gt; [(a, b)]<br><span class="hljs-title">zip&#x27;</span> [] _ = []<br><span class="hljs-title">zip&#x27;</span> _ [] = []<br><span class="hljs-title">zip&#x27;</span> (x:xs) (y:ys) = (x,y):zip&#x27; xs ys<br><br><span class="hljs-title">zipWith&#x27;</span> :: (t1 -&gt; t2 -&gt; a) -&gt; [t1] -&gt; [t2] -&gt; [a]<br><span class="hljs-title">zipWith&#x27;</span> _ [] _ = []<br><span class="hljs-title">zipWith&#x27;</span> _ _ [] = []<br><span class="hljs-title">zipWith&#x27;</span> f (x:xs) (y:ys) = f x y:zipWith&#x27; f xs ys<br></code></pre></div></td></tr></table></figure><p>感叹，haskell 写起这个来比其他语言优雅多了。</p><h1 id="fold-map-filter"><a href="#fold-map-filter" class="headerlink" title="fold, map, filter"></a>fold, map, filter</h1><p>折叠操作：一个列表生成一个值。</p><p>折叠操作能用来编写 map 和 filter，毕竟列表也是值嘛。就这方面来说，可以认为折叠操作是对列表的最广泛的操作：以源列表为输入，输出一个值。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">foldl&#x27;</span> :: (t1 -&gt; t2 -&gt; t1) -&gt; t1 -&gt; [t2] -&gt; t1<br><span class="hljs-title">foldl&#x27;</span> _ a [] = a<br><span class="hljs-title">foldl&#x27;</span> f a (x:xs) = foldl&#x27; f (f a x) xs<br><br><span class="hljs-title">foldl1&#x27;</span> :: (p -&gt; p -&gt; p) -&gt; [p] -&gt; p<br><span class="hljs-title">foldl1&#x27;</span> _ [] = error <span class="hljs-string">&quot;empty list&quot;</span><br><span class="hljs-title">foldl1&#x27;</span> f (x:xs) = foldl&#x27; f x xs<br><br><span class="hljs-title">map&#x27;</span> :: (t -&gt; a) -&gt; [t] -&gt; [a]<br><span class="hljs-title">map&#x27;</span> _ [] = []<br><span class="hljs-title">map&#x27;</span> f xs =<br>    foldl&#x27; (\ x y -&gt; x ++ [f y]) [] xs<br><br><span class="hljs-title">filter&#x27;</span> :: (a -&gt; <span class="hljs-type">Bool</span>) -&gt; [a] -&gt; [a]<br><span class="hljs-title">filter&#x27;</span> _ [] = []<br><span class="hljs-title">filter&#x27;</span> f xs =<br>    foldl&#x27; (\ x y -&gt; x ++ [y | f y]) [] xs<br><br><span class="hljs-comment">-- 不利用各种语法糖的写法</span><br><span class="hljs-title">filter&#x27;</span> :: (a -&gt; <span class="hljs-type">Bool</span>) -&gt; [a] -&gt; [a]<br><span class="hljs-title">filter&#x27;</span> _ [] = []<br><span class="hljs-title">filter&#x27;</span> fn (x:xs) = <br>    <span class="hljs-keyword">if</span> fn x <span class="hljs-keyword">then</span> x : last <span class="hljs-keyword">else</span> last<br>    <span class="hljs-keyword">where</span> last = filter&#x27; fn xs<br></code></pre></div></td></tr></table></figure><p>就写这些。haskell 虽然漂亮且优雅（以后要写伪代码的时候干脆就写 haskell 吧！），但是着实有点得劲。我还是先去学学 scala 吧……</p>]]></content>
    
    
    
    <tags>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue.js+Typescript 学习环境搭建</title>
    <link href="/2021/04-04vue.js+Typescript%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <url>/2021/04-04vue.js+Typescript%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>最简单的解决方案其实是使用 vite 和 vue3.x，零配置！我现在毕设前端项目使用该解决方案，非常方便。</p></blockquote><!--Hello, Happy World--><p>毕设的前端项目打算使用 vue.js+typescript+vue-baidu-map+<del>layUI</del>搭建。不过现在面临的一个主要问题是我对 vue 完全不懂，而它又是我的项目不可或缺的……vue 那超级强大的数据绑定功能对这个项目实在太重要了，可以说离开 vue 我根本找不到切入点，所以必须硬着头皮上。</p><p>现阶段我并不打算直接开始做前端项目，而是先写一些小项目练习 typescript 和 vue.js。而这篇文章的目的则是搭建一个适合学习的环境。我当前所阅读的书籍是《Vue.js 项目实战》，它完全没有使用 vue-cli，全是在浏览器中进行的，因此我也选择不使用 vue-cli（但是毕设我肯定是要用 vue-cli 来生成项目的），不使用 webpack 中除 ts-loader 以外的其他 loader。具体说来有这样的目标——</p><ul><li>以<code>./src/index.js</code>为 entry，生成<code>./dist/index.js</code>（这里限定文件名为 index.js，是因为默认的名称 main.js 在我的电脑上总会有一些奇怪的 bug）</li><li>只使用 ts-loader，也就是说不能在 ts 文件里 import 除 js&#x2F;ts 以外的其他文件</li><li>html 硬编码手动引入 js 以及其他资源（如 css），不使用 webpack 所提供的插件</li><li>使用 http-server 作为服务器，使用<code>webpack --watch</code>命令来自动编译</li><li>不使用 vue-cli</li><li>正确引入 vue</li></ul><p>那么，开始吧。</p><h1 id="初始化-webpack-项目"><a href="#初始化-webpack-项目" class="headerlink" title="初始化 webpack 项目"></a>初始化 webpack 项目</h1><p>总之首先创建一个空目录，cd 进去，输入命令<code>webpack init</code>（当然，在此之前需要安装 webpack）——</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">$ webpack init<br># 下面是对各种选项的选择<br>? Will your application have multiple bundles? <span class="hljs-keyword">No</span><br>? Which will be your application entry <span class="hljs-type">point</span>? src/<span class="hljs-keyword">index</span><br>? <span class="hljs-keyword">In</span> which folder <span class="hljs-keyword">do</span> you want <span class="hljs-keyword">to</span> store your <span class="hljs-keyword">generated</span> bundles? dist<br>? Will you use one <span class="hljs-keyword">of</span> the below JS solutions? Typescript<br>? Will you use one <span class="hljs-keyword">of</span> the below CSS solutions? <span class="hljs-keyword">No</span><br>? <span class="hljs-keyword">Do</span> you want <span class="hljs-keyword">to</span> use webpack-dev-<span class="hljs-keyword">server</span>? <span class="hljs-keyword">No</span><br>? <span class="hljs-keyword">Do</span> you want <span class="hljs-keyword">to</span> simplify the creation <span class="hljs-keyword">of</span> HTML files <span class="hljs-keyword">for</span> your bundle? <span class="hljs-keyword">No</span><br>? <span class="hljs-keyword">Do</span> you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">add</span> PWA support? <span class="hljs-keyword">No</span><br></code></pre></div></td></tr></table></figure><p>这已经初始化完成项目了，先运行一次<code>npm run build</code>进行一次编译以创建 dist 文件夹（或者手动创建，没什么区别），并将项目根目录下 index.html 文件移入 dist 文件夹中并编辑，在 body 尾部引入 index.js。</p><h1 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h1><p>接下来需要编辑 webpack.config.js，和 package.json。</p><h2 id="编辑-package-json"><a href="#编辑-package-json" class="headerlink" title="编辑 package.json"></a>编辑 package.json</h2><p>对 package.json 的编辑实际上只需要在 scripts 中插入一个命令——</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">...<br><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span>,<br>    <span class="hljs-string">&quot;watch&quot;</span>: <span class="hljs-string">&quot;webpack --watch &amp; http-server -p 8080 -s ./dist/&quot;</span><br>  &#125;,<br>...<br></code></pre></div></td></tr></table></figure><p>这样，只需输入<code>npm run watch</code>便可启动一个服务器并自动进行编译了。这里的 http-server 加入-s 命令以不进行输出（它的输出信息一般来说没啥意义）。</p><p>这种方式好像关闭比较麻烦……得手动 kill 才行，我对 bash 理解不多，不知道如何解决。</p><h2 id="编辑-webpack-config-js"><a href="#编辑-webpack-config-js" class="headerlink" title="编辑 webpack.config.js"></a>编辑 webpack.config.js</h2><p>对 webpack.config.js 文件的编辑也只需要更改一处地方——给 entry 定义名称为 index 以正确生成文件。&#x2F;dist&#x2F;index.js，否则默认的名称是 main.js。</p><figure class="highlight node-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">...</span><br>entry: &#123;index : &#x27;./src/index.ts&#x27;&#125;,<br><span class="hljs-meta prompt_">...</span><br></code></pre></div></td></tr></table></figure><h2 id="测试是否搭建成功"><a href="#测试是否搭建成功" class="headerlink" title="测试是否搭建成功"></a>测试是否搭建成功</h2><p>在 src 文件夹中中创建（编辑）两个文件——</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// util.ts</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello, happy world!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">export</span> &#123;<br>    hello<br>&#125;<br><br><span class="hljs-comment">// index.ts，入口文件</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> util <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./util&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello World from your main file!&#x27;</span>);<br>util.<span class="hljs-title function_">hello</span>();<br></code></pre></div></td></tr></table></figure><p>输入<code>npm run watch</code>并进入 localhost:8080，检查 console 是否有正确输出。</p><h1 id="引入-vue-js"><a href="#引入-vue-js" class="headerlink" title="引入 vue.js"></a>引入 vue.js</h1><p>输入<code>npm i vue</code>安装 vue 模块，然后编辑。&#x2F;node_module&#x2F;vue&#x2F;package.json，删除 main 项和 module 项的值中的 runtime——</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">...<br><span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;dist/vue.common.js&quot;</span>,<br><span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;dist/vue.esm.js&quot;</span>,<br>...<br></code></pre></div></td></tr></table></figure><p>这一步（似乎）是因为这个模块默认导入的是运行时的模块，模板功能无法使用。网络上建议通过编辑 vue.config.js 来调整，但这里的项目并非使用 vue-cli 搭建，即使配置也无效果，所以就先暂且这样。</p><h2 id="编辑-tsconfig-json"><a href="#编辑-tsconfig-json" class="headerlink" title="编辑 tsconfig.json"></a>编辑 tsconfig.json</h2><p>在 compilerOptions 中插入——</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;moduleResolution&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Node&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br></code></pre></div></td></tr></table></figure><p>需要注意的是，使用了 strict 选项后需要自己声明一些玩意，参见 <a href="https://cn.vuejs.org/v2/guide/typescript.html">这里</a>。</p><h2 id="测试-vue-是否成功引入"><a href="#测试-vue-是否成功引入" class="headerlink" title="测试 vue 是否成功引入"></a>测试 vue 是否成功引入</h2><p>编辑 index.html，在 body 中插入一个 div 作为 Vue 的 el。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>编辑 index.ts 文件，初始化 Vue 对象。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Data</span> = &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">const</span> vue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#root&quot;</span>,<br>    <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) : <span class="hljs-title class_">Data</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello, happy world!&quot;</span><br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>输入<code>npm run watch</code>，进入 localhost:8080，随意向文本框中输入内容，观察 p 标签中内容是否改变。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>仍旧是关于毕设</title>
    <link href="/2021/03-25%E4%BB%8D%E6%97%A7%E6%98%AF%E5%85%B3%E4%BA%8E%E6%AF%95%E8%AE%BE.html"/>
    <url>/2021/03-25%E4%BB%8D%E6%97%A7%E6%98%AF%E5%85%B3%E4%BA%8E%E6%AF%95%E8%AE%BE.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>到实际开始做的时候才发现要做的东西多麻烦……既需要了解 Spring 的使用，也需要了解前端页面各种库和 webpack 的使用……</p><p>后端使用 Soring Boot+Mybatis，因为系统比较复杂，所以分离 entity 层和 domain 层，其中 entity 层代表表中实体，其中包括 bus，place，busline，driver，station，pos，administrator。domain 层则是借助 entity 层，同时利用 bus_line，line_place 和 driver_bus 三个表达前述实体表关系的表以给出前端（实际上是 service 层）所需要的数据实体。dao 层则利用 entity 和 domain 层提供给 service 层操作数据的接口。（这时，entity 层和 domain 层实际上是属于同一层的……需不需要将它们结合呢……）</p><p>domain 层也可以去利用 SQL 的视图功能，优点在于只需要对视图进行操作。但是我不知道这实现难度如何，符不符合业务需要……只能说自己菜，还没接触到这些（不如说也不想去了解这些啊……）</p><p>现在，至关重要的是去开一个头！使用所谓的“敏捷开发”的方式吧，先整出东西来，再不断迭代——</p><h1 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h1><p>第一步是完成公交车信息的展示，具体来说有以下需求（使用！标记难度，从低到高分为 1 到 5 个！）——</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li>数据库中实体的设计（出于使用的需要，这一步就需要数据库的设计满足所有功能）（！）</li><li>entity 层及与当前步骤相关的 mapper 的实现（对应数据库中实体）（！）</li><li>数据库中<strong>视图</strong>的实现（！！）（或许可以不实现）</li><li>domain 层中与当前步骤相关的实现及其 mapper（对应数据库中视图）（！！）</li><li>dao 层中相关功能的实现（！！）</li><li>支持返回某市区县的公交车之前一段时间的速度和位置功能和不断更新该信息的功能的 websocket 的实现（！！！）</li><li>实时接受公交车所发送的信息的 websocket 的实现（！）</li><li>公交车模拟模块的实现（！）</li></ul><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li>展示某市区县的所有公交车实时信息功能的实现（只需实现最基本的展示轨迹。站点，轨迹等功能随后实现）（！！！）</li></ul><h1 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h1><p>这一步需要完成前端对数据（站点，节点……）的增删改查，同时完全完成上一步的展示实时信息功能。</p><h2 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h2><ul><li>完成所有查询功能（！！！）</li><li>完成登录的需求（！）</li><li>完成增删改的需求（！！！）</li></ul><h2 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h2><ul><li>完成登录功能（！）</li><li>完成查询功能（！！！）</li><li>完成增删改功能（非常困难！整个项目最困难的地方！同时也应当是项目的亮点所在）（！！！！！）</li></ul><h1 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h1><p>然后是查询某日历史信息的实现。</p><h2 id="后端-2"><a href="#后端-2" class="headerlink" title="后端"></a>后端</h2><ul><li>展示某市区县公交车某日所有信息功能的实现（！！！）</li></ul><h2 id="前端-2"><a href="#前端-2" class="headerlink" title="前端"></a>前端</h2><ul><li>展示某市区县公交车某日所有信息功能的实现（！！！）</li></ul><h1 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h1><p>进一步增强前端数据可视化的功能，提供热力图等玩意，以追踪特定时间或特定位置超速情况。</p><h2 id="后端-3"><a href="#后端-3" class="headerlink" title="后端"></a>后端</h2><ul><li>完成所有设计（！！！）</li></ul><h2 id="前端-3"><a href="#前端-3" class="headerlink" title="前端"></a>前端</h2><ul><li>完善数据可视化功能（！！）</li><li>完成生成 CSV 文件功能（！）</li></ul><hr><p>现在只能给出粗略的要求，每一个步骤需要在前一个步骤的基础上进行研究实现。</p><p>首先是建表，考虑到查询之前数据的需要，表中数据必须存储一个时间戳，即使第一步并不提供管理的功能。</p><p>思考和多次更改后得出这样的表结构（仍旧可能更改）——</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 对应公交车的表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> bus (<br>    bus_id <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>    bus_number <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">7</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-comment">-- 车牌号，长度为 7 位，形如豫 A99999</span><br>    bus_type <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-comment">-- 车型</span><br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (bus_id, update_time)<br>);<br><br><span class="hljs-comment">-- 对应各个区域的表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> place (<br>    place_id <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>    place_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    lat <span class="hljs-type">DECIMAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    lont <span class="hljs-type">DECIMAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (place_id, update_time)<br>);<br><br><span class="hljs-comment">-- 对应公交车线路的表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> busline (<br>    line_id <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        data_map 是一个相当复杂的数据。它是 json 格式的。</span><br><span class="hljs-comment">        它应当保存途径的路段 id，站点 id，以这样的格式存储——</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            data:[</span><br><span class="hljs-comment">                [&quot;nodepath&quot;, nodepath_id],</span><br><span class="hljs-comment">                [&quot;station&quot;, station_id],</span><br><span class="hljs-comment">                [&quot;nodepath&quot;, nodepath_id],</span><br><span class="hljs-comment">                ...</span><br><span class="hljs-comment">            ]</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    */</span><br>    data_json TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (line_id, update_time)<br>);<br><br><span class="hljs-comment">-- 对应驾驶员的表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> driver (<br>    driver_id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(), <span class="hljs-comment">-- 实为上传 (upload) 时间。driver 的信息显然是即使更改也不随时间变化的</span><br>    driver_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    driver_sex BIT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    driver_birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br><br><span class="hljs-comment">-- 对应公交车站点的表</span><br><span class="hljs-comment">-- 创建站点时，同时创建一个位于此位置的 node！</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> station (<br>    station_id <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(),<br>    lat <span class="hljs-type">DECIMAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    lont <span class="hljs-type">DECIMAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (station_id, update_time)<br>);<br><br><span class="hljs-comment">-- 对应公交车发送信息（当前位置，车辆 ID）的表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> pos(<br>    bus_id <span class="hljs-type">INT</span>,<br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(),<br>    speed TINYINT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-comment">-- 速度——公里每小时（迈），tinyint 存储 0~255 的数字</span><br>    lat <span class="hljs-type">DECIMAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    lont <span class="hljs-type">DECIMAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (bus_id, update_time),<br>    <span class="hljs-keyword">FOREIGN</span> KEY (bus_id) <span class="hljs-keyword">REFERENCES</span> bus(bus_id)<br>);<br><br><span class="hljs-comment">-- 管理员的表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> administrator(<br>    admin_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">PRIMARY</span> KEY, <span class="hljs-comment">-- 用作登录</span><br>    admin_passwd <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-comment">-- 可以不存储明文</span><br>    admin_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br><br><span class="hljs-comment">-- 对应路段节点的表（将被路段表使用）</span><br><span class="hljs-comment">-- 节点和路段表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> node(<br>    node_id <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(),<br>    lat <span class="hljs-type">DECIMAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    lont <span class="hljs-type">DECIMAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (node_id, update_time)<br>);<br><br><span class="hljs-comment">-- 对应路段的表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> nodepath(<br>    nodepath_id <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(),<br>    node1_id <span class="hljs-type">INT</span>,<br>    node2_id <span class="hljs-type">INT</span>,<br>    speed_limit TINYINT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br>    direction TINYINT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-comment">-- 方向，由南向北逆时针方向为顺向，0 为顺向，1 为逆向，2 为双向</span><br>    street_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY(nodepath_id, update_time),<br>    <span class="hljs-keyword">FOREIGN</span> KEY (node1_id) <span class="hljs-keyword">REFERENCES</span> node(node_id),<br>    <span class="hljs-keyword">FOREIGN</span> KEY (node2_id) <span class="hljs-keyword">REFERENCES</span> node(node_id)<br>);<br><br><span class="hljs-comment">-- 分割线分割线分割线</span><br><br><span class="hljs-comment">-- 公交车线路同公交车的对应的表</span><br><span class="hljs-comment">-- 一条公交车线路上有多个公交车，一个公交车可能跑多个线路（虽然稀有，但不能说没有）</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> bus_line (<br>    line_id <span class="hljs-type">INT</span>,<br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(),<br>    bus_id <span class="hljs-type">INT</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (line_id, update_time, bus_id),<br>    <span class="hljs-keyword">FOREIGN</span> KEY(bus_id) <span class="hljs-keyword">REFERENCES</span> bus(bus_id),<br>    <span class="hljs-keyword">FOREIGN</span> KEY(line_id) <span class="hljs-keyword">REFERENCES</span> busline(line_id)<br>);<br><br><span class="hljs-comment">-- 公交车线路所处于的位置（一般来说只为同一个位置，但跨区的线路有多个）</span><br><span class="hljs-comment">-- 与之前的想法不同（通过位置确定所需站点，再通过站点确定线路），选择直接通过位置确定线路。</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> line_place (<br>    line_id <span class="hljs-type">INT</span>,<br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(),<br>    place_id <span class="hljs-type">INT</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (line_id, update_time, place_id),<br>    <span class="hljs-keyword">FOREIGN</span> KEY (place_id) <span class="hljs-keyword">REFERENCES</span> place(place_id)<br>);<br><br><span class="hljs-comment">-- 公交车的驾驶员，一个驾驶员可能可以驾驶多个公交车，一个公交车可能可以由多个驾驶员驾驶</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> driver_bus (<br>    driver_id <span class="hljs-type">INT</span>,<br>    update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> NOW(),<br>    bus_id <span class="hljs-type">INT</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (driver_id, update_time, bus_id),<br>    <span class="hljs-keyword">FOREIGN</span> KEY (driver_id) <span class="hljs-keyword">REFERENCES</span> driver(driver_id),<br>    <span class="hljs-keyword">FOREIGN</span> KEY (bus_id) <span class="hljs-keyword">REFERENCES</span> bus(bus_id)<br>);<br></code></pre></div></td></tr></table></figure><p>下一步是完成对应的 dao 和 domain……</p><hr><p>当前完成了 websocket，service，servlet 的框架，直接更改其内容为业务代码即可。（需要学习一下 spring 的注入……不过对于这个项目或需不需要）</p><p>当前任务是——编写测试模块（websocket 客户端，或许使用 python 实现。公交车应当发送当前位置的速度，这是应该的，正常的，容易实现的（对公交车上的硬件来说）），编写实时展示当前信息的前端页面。这一步并不需要完成节点，站点，道路显示等功能（之后再实现）</p><hr><p>忙活了好久……终于把 webpack 前端弄完了，感觉还是……挺麻烦的。但是似乎也有所感悟，总之将来再配置的时候就不会这么尴尬了（不过我不想干前端，所以还是希望不要再去搞这个了）。</p><p>这篇文章不再更新了，另起炉灶。</p>]]></content>
    
    
    
    <tags>
      
      <tag>毕业设计</tag>
      
      <tag>饼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对创建型模式的总结</title>
    <link href="/2021/02-20%E5%AF%B9%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html"/>
    <url>/2021/02-20%E5%AF%B9%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>创建型模式关注类的创建过程。它专注分离对象的创建和使用（非常粗略地来说，就是不使用 new 来创建对象 w），在使用对象时无需在乎其创建过程，创建对象时无需在乎其使用，从而降低系统耦合性，使其更容易扩展。创建型模式中有如下模式——单例模式，2（+1）个工厂模式，原型模式，建造者模式，现在挨个过堂。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式是名副其实的——确保类只能生成单个实例。它的适用范围也是和其性质直接对应的——只需要一个实例的场合。单例模式有三种实现——饿汉式（EagleSingleton）：类加载时即生成所需单例，请求时直接返回该单例；懒汉式（LazySingleton）：每次请求时都检查是否已经初始化，从而在第一次请求的时候进行创建，之后则直接返回；IoDH：利用 Java 的类加载机制，用一个静态内部类（称为持有类）持有所需对象，使其在第一次请求时加载该持有类。</p><p>三种实现各有优劣——饿汉式可能造成资源的浪费，因为其可能在未被使用时就初始化了；懒汉式是线程不安全的，需要所谓的“双重检查锁定”来保证线程安全，使代码比较复杂，性能也会有损失；IoDH 让 JVM 来保证线程安全性（这一点是很好的，额外的细节什么的，交给编程语言去处理便好，程序员应该专注更加抽象，更加偏向业务的层面），但是它是局限于编程语言的。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式的实质是使用一个所谓的<strong>工厂类</strong>来接管一类对象的创建。其一般形式是——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-comment">// 注意，Product 是一个抽象基类或接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Product <span class="hljs-title function_">getProduct</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;ProductA&quot;</span>)) &#123;<br>            res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>();<br>            <span class="hljs-comment">// 各种其他处理……</span><br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;ProductB&quot;</span>)) &#123;<br>            res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductB</span>();<br>            <span class="hljs-comment">// 各种其他处理……</span><br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;ProductC&quot;</span>)) &#123;<br>            res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductC</span>();<br>            <span class="hljs-comment">// 各种其他处理……</span><br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 或者抛个异常之类的</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>它的目的是将创建所需对象（也就是产品）的职责从客户端转交给工厂类，从而将类的创建和使用的职责相分离。客户端将不再自己手动 new 产品，而是使用<code>Product product = Factory.getProduct(&quot;ProductA&quot;);</code>这样的形式。参数字符串还可写入配置文件中，从而使其更加灵活，更改产品也不需要重新编译。</p><p>简单工厂模式的缺点在于，其中有大量 if-else 逻辑，导致可能的性能问题；且<strong>增加，修改和删除产品都需要修改工厂类</strong>，违反开闭原则。</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式为简单工厂模式增加了一个抽象层并解决了简单工厂模式的问题。对于工厂方法模式，每一个工厂都为一个所谓的抽象工厂的子类（或实现，取决于这个抽象工厂是抽象类还是接口），这个抽象工厂中将定义生成抽象产品的方法的接口。每一个具体工厂只负责生产一种具体产品。</p><p><img src="https://i.loli.net/2021/02/08/zBmUGiTKaI3gJ2O.png"></p><p>其一般形式如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 抽象层</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title function_">getProduct</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Factory <span class="hljs-title function_">getFactory</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-comment">// 通过反射等手段获取一个具体工厂</span><br>    &#125; <br>&#125; <br><span class="hljs-comment">// 一个具体工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getProduct</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product1</span>();<br>        <span class="hljs-comment">// . . .</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// . . .</span><br><span class="hljs-comment">// 客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// いつもどおり，这里获取具体工厂的参数也是能够写在配置文件里的</span><br>        <span class="hljs-comment">// 其实也可以直接在抽象工厂中定义一个取得具体产品的 static 方法以隐藏具体工厂，降低系统的复杂性</span><br>        <span class="hljs-type">Product</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Factory.getFactory(<span class="hljs-string">&quot;Product1&quot;</span>).getProduct(); <br>        <span class="hljs-comment">// . . .</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>为什么简单工厂模式里不使用反射生成产品，而工厂方法模式里使用反射生成具体工厂？因为具体工厂的初始化过程是极易抽象出来的——new 就完事了（或者使用单例模式之类的？），而具体产品的初始化并不能这么简单地抽象。</p></blockquote><blockquote><p>一个有趣的事实是，在简单工厂模式中，参数用于生成特定产品；在工厂方法模式和抽象工厂模式中，参数用于生成特定的工厂。</p></blockquote><p>工厂方法模式相较于简单工厂模式的优点在于，它去掉了繁复的 if-else 循环，每个具体产品的初始化过程交由各个具体工厂来执行，保证了单一职责原则；添加新的具体产品的时候，只需要添加成对工厂及其产品即可，不需要修改源代码，保证了开闭原则。缺点是类的数量会成对增加，且使用了反射等技术，使系统复杂性更高，更难以理解。</p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式相较于工厂方法模式的区别在于，工厂方法模式中的一系列工厂负责一个<strong>产品等级结构</strong>（也就是一个继承结构，如按钮，白色按钮，蓝色按钮等这样的一个继承体系）的生产，而抽象工厂模式负责一个<strong>产品族</strong>的生产。也可以说，<strong>在工厂方法模式中，一个具体工厂对应一个具体产品；在抽象工厂模式中，一个具体工厂对应一族产品</strong>。所谓产品族，就是一系列本质不同但具有相近性质，且应当一起生产的产品，比如 win 系统的各种 UI 组件，Android 系统中各种 UI 组件，就各是一个产品族。</p><p><img src="https://i.loli.net/2021/02/11/icOJlbfS5TkphdG.png"></p><p>其一般形式是——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-comment">// 当然，这里的 ProductABC 全是抽象的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ProductA <span class="hljs-title function_">getProductA</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ProductB <span class="hljs-title function_">getProductB</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ProductC <span class="hljs-title function_">getProductC</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Factory <span class="hljs-title function_">getFactory</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-comment">// 通过反射等手段获取一个具体工厂</span><br>    &#125; <br>&#125;<br><span class="hljs-comment">// 一个具体工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> ProductA <span class="hljs-title function_">getProductA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ProductA</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProductA1</span>(); <br>        <span class="hljs-comment">// . . .</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// . . .</span><br>&#125;<br><span class="hljs-comment">// 客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 同上，也可以使用配置文件</span><br>        <span class="hljs-type">ProductA</span> <span class="hljs-variable">productA</span> <span class="hljs-operator">=</span> Factory.getFactory(<span class="hljs-string">&quot;Product1&quot;</span>).getProductA(); <br>        <span class="hljs-type">ProductB</span> <span class="hljs-variable">productB</span> <span class="hljs-operator">=</span> Factory.getFactory(<span class="hljs-string">&quot;Product1&quot;</span>).getProductB(); <br>        <span class="hljs-comment">// . . .</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当用户需求一族产品时，使用抽象工厂方法模式是比较适合的，比如一个游戏的各个不同平台上的 UI。这时候如果使用工厂方法模式会导致类的数量很多，且需要配置好每个工厂的生产，配置文件也会变得复杂且容易出错。需要增加新的产品族（比如这游戏又移植到新的平台上去了）时，需要添加许多具体工厂和产品，比较麻烦。</p><p>抽象工厂方法的问题在于，当需要在产品族中增加新的产品时，需要大刀阔斧地改抽象工厂类和所有具体工厂类的源代码，而增加新的产品族则是保持开闭原则的，这里就提到了“<strong>开闭原则的倾斜性</strong>”。且一个工厂要负责许多不同产品的构建，虽然这些构建分散到不同方法中，但归根结底还是比较麻烦，职责过重的。</p><h1 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式没啥好说的……我觉得我现在的认识或许也不太充分。</p><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式就是一步一步构建复杂对象的一种设计模式。其要点在于将复杂对象切分成一个个部分（比如游戏的捏人系统之类的），逐个击破。同时使用诸如钩子函数等手段更精确地控制对象的构建。</p><blockquote><p>也没啥好说的……没看到它的特别之处（悲</p></blockquote><p>无论如何，创建型模式已经告一段落，等将来实践或复习的时候再来讨教吧。现在开始下一部分：结构型模式——它关注将现有的类或对象<strong>组织在一起</strong>以形成更加……符合要求的结构。也就是关注类之间的<strong>组合</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式和建造者模式</title>
    <link href="/2021/02-19%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <url>/2021/02-19%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式就是<strong>从一个原型克隆出多个一模一样的对象</strong>的模式。原型模式对于这样的情形适用——需要一个和已有的对象大体相同的对象，但无法接受从零开始创建该对象。举例来说，当编写 PPT 时，当上一页和当前页面元素基本一致的时候，就将上一页复制，进行一些编辑即可，从而免去再次的排版等工序。</p><p>原型模式的角色有抽象原型，具体原型和客户端。其中抽象原型类是一个提供 clone 方法的接口（Java 本身有一个这样作用的接口 Cloneable，但它仅仅起标记作用）。具体原型类是实现了该接口的类。客户端使用时调用原型类的 clone 方法。</p><p>对于 Java，clone 方法的实现，应当通过构造函数定义一个 Object 对象（在这里，Object 负责抽象原型类的角色，它就是 Prototype），其值为 super.clone()，并设定其各个域成员与被克隆的对象一致（需注意浅拷贝和深拷贝，深拷贝可以简单使用序列化接口来实现），最后强制类型转换并返回该对象。其代码形式如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这个类应当实现 Cloneable 接口</span><br><span class="hljs-keyword">public</span> Prototype <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        obj = <span class="hljs-built_in">super</span>.clone(); <span class="hljs-comment">// Object 所定义的方法，其是 native 的。</span><br>        <span class="hljs-comment">// 设定各种属性与该对象一致</span><br>        <span class="hljs-comment">// . . .</span><br>        <span class="hljs-keyword">return</span> (Prototype) obj;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>还可使用所谓的原型管理器——其实质是一个、&lt;String, Prototype&gt;的 HashMap，其通过单例模式创建，维护着所需的原型对象，并应客户端的要求返回特定的对象。</p><p>原型模式的优点在于能够节约初始化的成本（特别是需要调用硬盘甚至网络资源的时候），简化复杂实例的创建，且其扩展性高，可以针对抽象原型类进行编程，而<strong>具体原型类编写在配置文件中</strong>，增加，减少具体原型类都不需要修改源代码（甚至修改也可能可以不需要，不过可能会造成配置文件繁琐？）。</p><p>缺点在于深拷贝时代码可能比较复杂，且克隆方法必须位于类的内部，修改时需要修改源代码，违反开闭原则。</p><p>Spring 的 IoC 容器对 Bean 的创建可以选择使用单例模式或原型模式。</p><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式就像游戏中的捏人系统，人的外观分为几个特定的部分，如发型，脸型，五官，躯干……一次捏人的完成，是对各个部分都进行“建造”，最后将其组合出结果（当然，这里没有组合，或许也可以联想飞船的各模块的建造……就像 Space Engineer 里那样的？）。</p><p>建造者模式的实质就是将<strong>复杂对象</strong>（具有多个实例域的对象）的构建和对象的表示（其属性）相分离，建造者<strong>将对象所属的类中各个共通的部分抽象成一个个模块</strong>，按模块地进行建设（比如划分为登陆模块，控制模块，推进模块，战斗模块……），最后将各个模块进行组合，得出最终的舰船。而非是直接上手创建这样一个复杂的对象——抽象啊抽象！这就和用汇编写 http 服务器一样离谱。</p><p>建造者模式有如下角色：<strong>抽象建造者</strong>——提供各部分的构造方法的接口，以及返回最终对象的方法的接口。这里的抽象建造者可以是抽象类（它可以维护一个最终产品并直接实现返回最终对象的方法），也可以是接口；<strong>产品</strong>——建造的对象；<strong>建造者</strong>——对抽象建造者的实现；<strong>导演</strong>——指挥建造者进行建造并返回结果（也就是调用建造者提供的方法返回最终对象）（这个导演倒是可以直接设定成抽象建造者的一个方法…这便使用了类似模板方法的一种设计…这样简化了系统的结构，但可能会让抽象建造者类职责过重）；<strong>客户端</strong>——与导演交互，获取最终对象。</p><p>类图如下——</p><p><img src="https://i.loli.net/2021/02/19/LPcNWHBatRJUjOo.png"></p><p>然后是各个角色的一般形式——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 复杂对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> dataA partA;<br>    <span class="hljs-keyword">private</span> dataB partB;<br>    <span class="hljs-keyword">private</span> dataC partC;<br>    <span class="hljs-comment">// 和其 getter 和 setter</span><br>&#125;<br><br><span class="hljs-comment">// 抽象建造者类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartA</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartB</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartC</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 导演类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> &#123; <span class="hljs-comment">// 导演类大可直接作为 Builder 类的一个方法</span><br>    <span class="hljs-keyword">private</span> Builder builder;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Director</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.builder = builder;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">construct</span><span class="hljs-params">()</span> &#123;<br>        builder.buildPartA();<br>        builder.buildPartB();<br>        builder.buildPartC();<br>        <span class="hljs-keyword">return</span> builder.getResult();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体建造者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// blablabla</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// blablabla</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartC</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// blablabla</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>客户端形式如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteBuilder</span>(); <span class="hljs-comment">// 显然，这里的 new 可以使用工厂模式干掉以（无论是简单工厂还是工厂方法模式）</span><br>        <span class="hljs-type">Director</span> <span class="hljs-variable">director</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>(builder);<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> director.construct();<br>        <span class="hljs-comment">// ... 如此复杂，果然 construct 方法应该直接放到建造者类中，</span><br>        <span class="hljs-comment">//无论是抽象建造者类中还是具体建造者类中（取决于有无必要对 construct 方法进行重载）</span><br>        <span class="hljs-comment">//然后使用工厂方法进行进一步抽象，让其能够这样调用——</span><br>        <span class="hljs-comment">// Product product = BuilderFactory.createBuilder(&quot;angel&quot;).construct(); // 这里的 createBuilder 方法既可以返回具体建造者，也可以返回一个导演类……</span><br>        <span class="hljs-comment">// . . .</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可见还是简化后的形式更加舒服。</p><p>关于建造过程，其实能够给其添加更多程序结构来更加精细地控制建造过程。比如添加所谓的钩子方法（Hook Method），它控制是否需要调用某个 buildPartX() 方法。</p><p>钩子方法的形式是置于抽象建造者类中的一个返回布尔值的方法，来决定某个部分的是否构建。比如对于一个建造船舰的抽象建造者类 ShipBuilder，给定一个名为 isArmed 的方法，对于运输船，它不需要火力模块，因此对于这个方法它就返回 false。导演类就可以这样 construct——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Product <span class="hljs-title function_">construct</span><span class="hljs-params">()</span> &#123;<br>    shipBuilder.buildPowerModule(); <span class="hljs-comment">// 无论什么船，都需要能源，对吧？</span><br>    <span class="hljs-keyword">if</span> (shipBuilder.isArmed())<br>        shipBuilder.buildFireModule();<br>    <span class="hljs-comment">// . . .</span><br>    <span class="hljs-keyword">return</span> builder.getResult();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一个练习——某视频播放软件有多种界面显示模式——标准模式，精简模式，编辑模式等等。不同界面显示模式中组成元素有差异。其中，各界面现实如下元素——</p><ul><li>标准模式：播放窗口，控制条，显示菜单，播放列表</li><li>编辑模式：播放窗口，控制条，显示菜单，编辑栏</li><li>精简模式：播放窗口，控制条</li></ul><p>可以使用一些钩子函数对窗口的构建进行精细控制。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  - 完整模式：播放窗口，控制条，显示菜单，播放列表</span><br><span class="hljs-comment">    - 编辑模式：播放窗口，控制条，显示菜单，编辑条</span><br><span class="hljs-comment">    - 精简模式：播放窗口，控制条</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 产品，这里为简洁需要。.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br>    <span class="hljs-comment">// . . .</span><br>&#125;<br><span class="hljs-comment">// 抽象建造类，导演类包含在其中</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UIBuilder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Window</span> <span class="hljs-variable">window</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Window</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPlayWindow</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildCtrlBar</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDisplayMenu</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPlayList</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildEditBar</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needDisplayMenu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needPlayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needEditBar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Window <span class="hljs-title function_">createWindow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> window;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Window <span class="hljs-title function_">construct</span><span class="hljs-params">(UIBuilder builder)</span> &#123;<br>        builder.buildPlayWindow();<br>        builder.buildCtrlBar();<br>        <span class="hljs-keyword">if</span> (builder.needDisplayMenu())<br>            builder.buildDisplayMenu();<br>        <span class="hljs-keyword">if</span> (builder.needPlayList())<br>            builder.buildPlayList();<br>        <span class="hljs-keyword">if</span> (builder.needEditBar())<br>            builder.buildEditBar();<br>        <span class="hljs-keyword">return</span> builder.createWindow();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 三个具体建造类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StandardWindowBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UIBuilder</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPlayWindow</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;标准模式：播放窗口&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildCtrlBar</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;标准模式：控制条&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDisplayMenu</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;标准模式：显示菜单&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPlayList</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;标准模式：播放列表&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildEditBar</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不应该被执行&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needDisplayMenu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needEditBar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needPlayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EditWindowBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UIBuilder</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPlayWindow</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;编辑模式：播放窗口&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildCtrlBar</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;编辑模式：控制条&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDisplayMenu</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;编辑模式：显示菜单&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPlayList</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不应该被执行&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildEditBar</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;编辑模式：编辑条&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needDisplayMenu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needEditBar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needPlayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinusWindowBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UIBuilder</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPlayWindow</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;精简模式：播放窗口&quot;</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildCtrlBar</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;精简模式：控制条&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDisplayMenu</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不应该被执行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPlayList</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不应该被执行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildEditBar</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不应该被执行&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needDisplayMenu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needEditBar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needPlayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 可以使用反射或者工厂模式干掉这个 new</span><br>        <span class="hljs-type">Window</span> <span class="hljs-variable">window</span> <span class="hljs-operator">=</span> UIBuilder.construct(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EditWindowBuilder</span>());<br>        <span class="hljs-comment">// . . .</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>天啊……这代码长的离谱。</p><p>建造者模式的优点在于，客户端不需要知道产品内部的细节（这同工厂模式是一样的），产品本身同产品的构建分离（客户端不需要自己 new 和其他初始化操作）；每一个具体建造者是相对独立的，系统扩展方便，符合开闭原则；产品的创建过程能够分散在不同的方法中，从而更加清晰，易维护。</p><p>缺点在于，其只能创建有较多共同点的产品（如人的外观，船舰等），如果差异性很大（比如人类和外星人的船舰，人和动物），很多部分都不相同（从而不能抽象出一般的创建过程），就无法使用建造者模式。</p><h2 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h2><p>下面在公众号上看到的对建造者模式的另一种实现。客户端使用<code>new Ship.Builder(&quot;powerModule&quot;).setFireModule(&quot;fireModule&quot;).setTransportModule(&quot;transportModule&quot;).build();</code>这样的形式进行调用。这也可以通过另一个类（那么其实它才是真正的“建造者”）来实现。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span> &#123; <br>    <span class="hljs-comment">// 当然，这些模块不可能是字符串…火力模块也不可能单独来一个</span><br>    <span class="hljs-keyword">private</span> String powerModule;<br>    <span class="hljs-keyword">private</span> String fireModule;<br>    <span class="hljs-keyword">private</span> String transportModule; <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Ship</span><span class="hljs-params">(Builder builder)</span> &#123; <span class="hljs-comment">// 包访问限定</span><br>        <span class="hljs-built_in">this</span>.powerModule = builder.powerModule;<br>        <span class="hljs-built_in">this</span>.fireModule = builder.fireModule;<br>        <span class="hljs-built_in">this</span>.transportModule = builder.transportModule;<br>    &#125;  <br>    <br>    <span class="hljs-comment">// 这个建造者大可以放到外面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-comment">// 每一个属性都要定义一个相同的……老实说有点蛋疼</span><br>        <span class="hljs-keyword">private</span> String powerModule;<br>        <span class="hljs-keyword">private</span> String fireModule;<br>        <span class="hljs-keyword">private</span> String transportModule; <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(String powerModule)</span> &#123;<br>            <span class="hljs-built_in">this</span>.powerModule = powerModule;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setFireModule</span><span class="hljs-params">(String fireModule)</span> &#123;<br>            <span class="hljs-built_in">this</span>.fireModule = fireModule;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setTransportModule</span><span class="hljs-params">(String transportModule)</span> &#123;<br>            <span class="hljs-built_in">this</span>.transportModule = transportModule;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Ship <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ship</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 众所周知，客户端不应该自己 new 东西～</span><br>        <span class="hljs-type">Ship</span> <span class="hljs-variable">ship</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ship</span>.Builder(<span class="hljs-string">&quot;powerModule&quot;</span>)<br>                            .setFireModule(<span class="hljs-string">&quot;fireModule&quot;</span>)<br>                            .setTransportModule(<span class="hljs-string">&quot;transportModule&quot;</span>)<br>                            .build();<br>        <span class="hljs-comment">// . . .</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日语中数词和量词的读法</title>
    <link href="/2021/02-16%E6%97%A5%E8%AF%AD%E4%B8%AD%E6%95%B0%E8%AF%8D%E5%92%8C%E9%87%8F%E8%AF%8D%E7%9A%84%E8%AF%BB%E6%B3%95.html"/>
    <url>/2021/02-16%E6%97%A5%E8%AF%AD%E4%B8%AD%E6%95%B0%E8%AF%8D%E5%92%8C%E9%87%8F%E8%AF%8D%E7%9A%84%E8%AF%BB%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>日语中日期，时间（乃至数字）等的读法，要比英语和中文麻烦得多，这里特别记录一下……不过不代表死记硬背，老实说我没打算好好背，在实践中多多掌握，时不时翻来看看就好。</p><h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><p>这个表表示了从个位数到亿的读法。0 读作まる或ゼロ。</p><table><thead><tr><th align="center"></th><th align="center">个</th><th align="center">十</th><th align="center">百</th><th align="center">千</th><th align="center">万</th><th align="center">亿</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">いち</td><td align="center">じゅう</td><td align="center">ひゃく</td><td align="center">せん</td><td align="center">いち まん</td><td align="center">いち おく</td></tr><tr><td align="center">2</td><td align="center">に</td><td align="center">に じゅう</td><td align="center">に ひゃく</td><td align="center">に せん</td><td align="center">に まん</td><td align="center">に おく</td></tr><tr><td align="center">3</td><td align="center">さん</td><td align="center">さん じゅう</td><td align="center">さん ぴゃく</td><td align="center">さん ぜん</td><td align="center">さん まん</td><td align="center">さん おく</td></tr><tr><td align="center">4</td><td align="center">よん、し</td><td align="center">よん じゅう</td><td align="center">よん ひゃく</td><td align="center">よん せん</td><td align="center">よん まん</td><td align="center">よん おく</td></tr><tr><td align="center">5</td><td align="center">ご</td><td align="center">ご じゅう</td><td align="center">ご ひゃく</td><td align="center">ご せん</td><td align="center">ご まん</td><td align="center">ご おく</td></tr><tr><td align="center">6</td><td align="center">ろく</td><td align="center">ろく じゅう</td><td align="center">ろっ ぴゃく</td><td align="center">ろく せん</td><td align="center">ろく まん</td><td align="center">ろく おく</td></tr><tr><td align="center">7</td><td align="center">なな、しち</td><td align="center">なな じゅう</td><td align="center">なな ぴゃく</td><td align="center">なな せん</td><td align="center">なな まん</td><td align="center">なな おく</td></tr><tr><td align="center">8</td><td align="center">はち</td><td align="center">はち じゅう</td><td align="center">はっ ぴゃく</td><td align="center">はっ せん</td><td align="center">はち まん</td><td align="center">はち おく</td></tr><tr><td align="center">9</td><td align="center">きゅう、く</td><td align="center">きゅう じゅう</td><td align="center">きゅう ひゃく</td><td align="center">きゅう せん</td><td align="center">きゅう まん</td><td align="center">きゅう おく</td></tr></tbody></table><p>数字的读法直接将各位从大到小连起来读即可，和中文是一致的，比如 23 读作にじゅうさん。</p><p>十万，百万读作じゅうまん、ひゃくまん，而一千万应特别记忆——<strong>いっせんまん</strong>。</p><h2 id="个十"><a href="#个十" class="headerlink" title="个十"></a>个十</h2><p>一到十是容易掌握的。</p><ol start="0"><li>まる、ゼロ</li><li>いち</li><li>に</li><li>さん</li><li>よん、し</li><li>ご</li><li>ろく</li><li>なな、しち</li><li>はち</li><li>きゅう、く</li><li>じゅう</li></ol><p>十位数也是容易的。需要注意的是 40 使用よんじゅう，70 使用ななじゅう，90 使用きゅうじゅう</p><ol><li>じゅう</li><li>に じゅう</li><li>さん じゅう</li><li>よん じゅう</li><li>ご じゅう</li><li>ろく じゅう</li><li>なな じゅう</li><li>はち じゅう</li><li>きゅう じゅう</li></ol><p>数字的读法直接将各位从大到小连起来读即可，和中文是一致的，比如 23 读作にじゅうさん。</p><h2 id="百"><a href="#百" class="headerlink" title="百"></a>百</h2><p>需要注意的是，300，600，700，800 后是ぴゃく，其它的是ひゃく。</p><p>同时，百，千是不加いち的，直接读作ひゃく、せん。但是万，亿是需要加いち的。</p><ol><li>ひゃく</li><li>に ひゃく</li><li>さん ぴゃく</li><li>よん ひゃく</li><li>ご ひゃく</li><li>ろっ ぴゃく</li><li>なな ぴゃく</li><li>はっ ぴゃく</li><li>きゅう ひゃく</li></ol><p>形如 405 这样的数字，中间的零是不读的（和中文不一样），よんひゃくご。</p><h2 id="千"><a href="#千" class="headerlink" title="千"></a>千</h2><ol><li>せん</li><li>に せん</li><li>さん ぜん （！）</li><li>よん せん</li><li>ご せん</li><li>ろく せん</li><li>なな せん</li><li>はっ せん</li><li>きゅう せん</li></ol><h2 id="万"><a href="#万" class="headerlink" title="万"></a>万</h2><p>1 万到 10 万的读音没有变化，为数字+万（まん）</p><ol><li>いち まん</li><li>に まん</li><li>さん まん</li><li>よん まん</li><li>ご まん</li><li>ろく まん</li><li>なな まん</li><li>はち まん</li><li>きゅう まん</li></ol><p>十万，百万读作じゅうまん、ひゃくまん，而一千万应特别记忆——<strong>いっせんまん</strong>。</p><h1 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h1><h2 id="年"><a href="#年" class="headerlink" title="年"></a>年</h2><p>年的读音是和数字一样读法的。</p><p>例：<br>１９７５年 读作 せんきゅひゃくななじゅうご ねん　（直接读せん，没有一）<br>２００６年 读作 にせんろく ねん  （零不用读）<br>昭和６４年 读作 しょうわ ろくじゅうよ ねん</p><h2 id="月"><a href="#月" class="headerlink" title="月"></a>月</h2><p>月份的读法全为数字的音读+がつ，但是 4，7，9 月的读法是固定的——</p><ol><li>いちがつ</li><li>にがつ</li><li>さんがつ</li><li>しがつ （よんがつは NG！）</li><li>ごがつ</li><li>ろくがつ</li><li>しちがつ （不能是なながつ）</li><li>はちがつ</li><li>くがつ （不能是きゅうがつ）</li><li>じゅうがつ</li><li>じゅういちがつ</li><li>じゅうにがつ</li></ol><blockquote><p><del>月（がつ）和月（げつ）有什么区别呢？我认为后者是“几个月”中的月，前者是“几月”中的月。how long 和 when 的区别。</del></p></blockquote><p><del>比如，三个月写作三ヶ月（さん<strong>かげつ</strong>)，僕は三ヶ月間勉強しました……つまり、そういうことさ。</del></p><p>还有正月（しょうがつ）。</p><h2 id="日"><a href="#日" class="headerlink" title="日"></a>日</h2><p>日期的读音中，1-10 日为<strong>训读</strong>，11-31 日中，除特殊的 14,20,24 日外都为音读。</p><ol><li>ついたち （而不是いちにち——它指代作为时长的一天）</li><li>ふつか</li><li>みっか</li><li>よっか</li><li>いつか</li><li>むいか</li><li>なのか</li><li>ようか</li><li>ここのか</li><li>とおか</li><li>じゅういちにち</li><li>じゅうににち</li><li>じゅうさんにち</li><li>じゅうよっか （！）</li><li>じゅうごにち</li><li>じゅうろくにち</li><li>じゅうしちにち</li><li>じゅうはちにち</li><li>じゅうくにち</li><li>はつか （！）</li><li>にじゅういちにち</li><li>にじゅうににち</li><li>にじゅうさんにち</li><li>にじゅうよっか （！）</li><li>にじゅうごにち</li><li>にじゅうろくにち</li><li>にじゅうしちにち</li><li>にじゅうはちにち</li><li>にじゅうくにち</li><li>さんじゅうにち</li><li>さんじゅういちにち</li></ol><p><del>表达多少天该如何说呢？可以在日期后直接加間（かん）。但是一天则是一日間（いちにちかん）。</del></p><p><del>表达区间的时候，在年&#x2F;月&#x2F;日后加間即可，比如彼は<strong>何時間</strong>勉強しましたか？（好像不加に）</del></p><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><h2 id="小时"><a href="#小时" class="headerlink" title="小时"></a>小时</h2><p>小时的读音中，4，7，9 时需要注意。</p><ol><li>いちじ</li><li>にじ</li><li>さんじ</li><li>よじ （没有ん！）</li><li>ごじ</li><li>ろくじ</li><li>しちじ</li><li>はちじ</li><li>くじ</li><li>じゅうじ</li><li>じゅういちじ</li><li>じゅうにじ</li><li>じゅうさんじ</li><li>じゅうよじ</li><li>. . .</li></ol><h2 id="分"><a href="#分" class="headerlink" title="分"></a>分</h2><p>分钟需要注意ふん和ぶん。</p><ol><li>いっぷん</li><li>にふん</li><li>さんぷん</li><li>よんぷん</li><li>ごふん</li><li>ろっぷん</li><li>ななふん</li><li>はちふん</li><li>きゅうふん</li><li>じっぷん（じゅっぷん）</li><li>じゅういっぷん</li><li>. . .</li></ol><h2 id="秒"><a href="#秒" class="headerlink" title="秒"></a>秒</h2><p>秒全部都是音读的数字加上秒（びょう）。需要注意的是，四秒（よんびょう），七秒（ななびょう），九秒（きゅうびょう）。</p><blockquote><p>好像 4 只有在月份里读作し；只有在月份，小时里 7 读作しち，9 读作く。</p></blockquote><h1 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h1><p>数东西（比如清点桌子上的各种物品，清点人数）时，1-10 使用特殊的说法，其余的使用和数字一样的读法。</p><ol><li>ひとつ</li><li>ふたつ</li><li>みっつ</li><li>よっつ</li><li>いつつ</li><li>むっつ</li><li>ななつ</li><li>やっつ</li><li>ここのつ</li><li>とお</li></ol><p>对于数量，询问时使用いくつ。比如 りんごをいくつ買いましたか。４つ（よっつ）買いました。</p><hr><p>对于属于特定范围的东西，使用特定的量词。其形式为数字加量词。</p><p>关于一般的量词——</p><ul><li>〜人　〜にん　人，需要注意一人，二人和四人是特殊的——ひとり、ふたり、よにん</li><li>〜台　〜だい　机械，载具</li><li>〜枚　〜まい　薄的，扁平的东西，比如纸张，CD，盘子</li><li>〜回　〜かい　次数</li></ul><p>对一般的量词，询问的形式是何+量词，如 姉妹は何人ですか、車が何台ありますか。</p><p>关于时间的量词——</p><ul><li>〜年　〜ねん　年</li><li>〜ヶ月　〜かげつ （个）月</li><li>〜週間　〜しゅうかん　周　（！）</li><li>〜日　〜にち　天，其和日期中的天读法相同，但是 1 天读作いちにち而非ついたち</li><li>〜時間　〜じかん　小时　（！）</li><li>〜分　〜ふん　分钟</li></ul><p>询问时长的形式可与一般的形式相同，如 平沢さんは 毎晩 何時間 ギターを 練習しますか；也可为どのくらい，如 ありさちゃんは どのくらい ピアノを 習いましたか。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂方法模式和抽象工厂模式</title>
    <link href="/2021/02-12%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html"/>
    <url>/2021/02-12%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><h1 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h1><blockquote><p>这个模式在之前看《图解设计模式》已经有部分了解，那本书并没有解释为何工厂方法模式要求一个抽象工厂的角色……这里讲的比较清楚。</p></blockquote><p>简单工厂的主要一个缺点是，工厂类的职责过重，存在大量 if-else 逻辑，且如果添加新产品时<strong>必须要修改工厂类</strong>，这违反了开闭原则和单一职责原则（而且，添加子类需要修改基类，这个怎么说也感觉有点怪吧？）。而工厂方法模式则消除了这一缺点——它给所有工厂一个抽象的基类（或接口），给每个产品提供它对应的工厂。如果添加新产品，只需要定义新的工厂类和产品即可。客户端可以通过反射等手段进行调用。</p><h2 id="从简单工厂到工厂方法"><a href="#从简单工厂到工厂方法" class="headerlink" title="从简单工厂到工厂方法"></a>从简单工厂到工厂方法</h2><p>书中举了个十分容易理解的例子（不过我认为有改进的空间）——</p><p>客户需要一个日志记录器，且需要能不更改源代码（即不需要重新编译）灵活选择不同的记录器。需求分析发现，<strong>日志记录器的初始化比较复杂</strong>，可能需要初始化其他相关的类，可能需要配置工作环境等，如果都写在构造函数里会<strong>导致构造函数庞大，不利于维护</strong>。因此，使用简单工厂方法进行系统设计，其中 LoggerFactory 为工厂角色，FileLogger，DatabaseLogger 为具体产品，Logger 为抽象产品——</p><p><img src="https://i.loli.net/2021/02/08/5AMIoksLVbWHmrq.png"></p><p>代码如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Logger.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeLog</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Logger</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeLog</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一个 fileLogger&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Logger</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeLog</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一个 DatabaseLogger&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// LoggerFactory.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LoggerFactory</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title function_">getLogger</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;FileLogger&quot;</span>)) &#123;<br>            res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileLogger</span>();<br>            <span class="hljs-comment">// 做一些处理</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;DatabaseLogger&quot;</span>)) &#123;<br>            res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatabaseLogger</span>();<br>            <span class="hljs-comment">// 做另一些处理</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Main.java 客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;FileLogger&quot;</span>); <span class="hljs-comment">// 可以写在配置文件里</span><br>        logger.writeLog();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在，缺点来了，一旦需要增加新的 logger，必须更改工厂类，并且工厂类包含所有 logger 的初始化代码，职责过重。现在，通过使用工厂方法模式来解决这个问题。</p><p>工厂方法的要点在于，给定一个抽象工厂类，任何具体工厂作为它的子类，对每一个工厂，都有一定的产品与之适配。用户构造工厂时以抽象工厂为类型。形如下面的代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">LoggerFactory</span> <span class="hljs-variable">loggerFactory</span> <span class="hljs-operator">=</span> LoggerFactory.getFactory(<span class="hljs-string">&quot;Logger&quot;</span>); <span class="hljs-comment">// 也可以写在配置文件里</span><br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> loggerFactory.getLogger();<br>    logger.writeLog();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的 getFactory 是个 static 方法，它应当根据字符串返回对应的工厂。书中的示例将这相关的代码放到外面，而我觉得这个方法其实很适合作为抽象工厂的一个静态方法。这里也可以将要生成的工厂写在配置文件里以保证开闭原则。</p><p>这个方法中可以仍旧使用 if-else 来返回工厂（这陷入了一个循环吗？并非如此，因为工厂的初始化是简单的，不需要抽象工厂关心的，它只需返回一个 new 的对象即可。但是这仍旧违反了开闭原则——添加新工厂还是要修改抽象工厂的源代码），也可以使用反射机制。</p><p>简单工厂模式可以使用反射来去掉 if-else 循环吗？不可以！每个具体产品的初始化过程是不同的，因此不同产品的初始化代码不能被抽象到一致。而工厂方法模式将产品的初始化下放到具体工厂中，其<strong>只负责具体工厂的初始化</strong>——只需要调用其构造函数即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// LoggerFactory.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Logger <span class="hljs-title function_">createLogger</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LoggerFactory <span class="hljs-title function_">getFactory</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (LoggerFactory) Class.forName(type).newInstance();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">// 应该进一步处理</span><br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LoggerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> LoggerFactory.getFactory(<span class="hljs-string">&quot;FileLoggerFactory&quot;</span>); <span class="hljs-comment">// 可以写在配置文件里</span><br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> factory.createLogger();<br>        logger.writeLog();<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>要添加新的实例？没问题，创建两个新文件，比如 ImageLogger.java 和 ImageLoggerFactory.java，其中 ImageLogger 要继承 Logger 类，ImageLoggerFactory 要继承 LoggerFactory 类，然后在配置文件里修改要生成的工厂即可。这里完全不需要更改任何源代码，只需要增加文件即可！这保证了开闭原则——对扩展开放，对修改封闭。</p><p>这里也可以进行一些优化，比如重载 createLogger 方法以适应更多情况，比如可以直接在抽象工厂中定义 writeLog 方法，使客户端可以使用抽象工厂直接进行操作（这里使用了模板方法）——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Logger <span class="hljs-title function_">createLogger</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LoggerFactory <span class="hljs-title function_">getFactory</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (LoggerFactory) Class.forName(type).newInstance();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">// 应该进一步处理</span><br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeLog</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.createLogger(); <span class="hljs-comment">// 模板方法模式——定义一个处理流程，让子类实现其中的具体步骤。</span><br>        logger.writeLog();<br>    &#125;<br>    <span class="hljs-comment">// 客户端</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LoggerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> LoggerFactory.getFactory(<span class="hljs-string">&quot;FileLoggerFactory&quot;</span>); <span class="hljs-comment">// 可以写在配置文件里</span><br>        factory.writeLog();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工厂方法模式的优点是显而易见的，保证开闭原则，且消除了简单工厂中工厂类负担过重的问题，且用户不需知道自己究竟使用的是什么类即可完成任务（从直接使用变成间接使用……感觉这是保持开闭原则不可或缺的。..）。而它的缺点是会让系统中的类的数量<strong>成对增加</strong>，且要使用反射等手段，影响了系统的理解难度。</p><p>工厂方法模式的类图如下——</p><p><img src="https://i.loli.net/2021/02/08/zBmUGiTKaI3gJ2O.png"></p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>工厂方法的缺点在于，它一个工厂只负责一类产品，因此会导致类的数量增加，增加维护难度。抽象工厂模式要求它的<strong>具体工厂</strong>并非只生成一类产品，而是一“族”产品。这对要求所有产品都符合一定规范是必要的，比如不同操作系统的各种 UI 控件，比如软件的皮肤……</p><p>一族所指的并非是相似的关系，或者父类相同的关系，如白色按钮和蓝色按钮，而是具有相互约束关系的东西，即使它们没有直接关系，比如某个操作系统下的文本框和按钮（它们都是属于这个操作系统的）。</p><p>工厂方法模式和抽象工厂模式的差别在于，工厂方法模式中每个具体工厂生产一类产品，比如白色按钮，红色按钮，蓝色按钮…抽象工厂模式中每个具体工厂生产一族产品，比如白色按钮，白色弹窗……可以说，<strong>工厂方法模式（中的每一系列工厂）针对的是一个产品等级结构（一系列继承结构），抽象工厂模式则需要面对多个产品等级结构。每一个工厂等级结构都需要负责多个不同产品等级结构中工厂的创建</strong>。</p><p>显然，抽象工厂模式中，抽象工厂应当定义生成所有产品的接口，当为抽象工厂模式中这一族产品添加新成员的时候，需要修改所有具体工厂和抽象工厂的源代码。抽象工厂模式对添加产品族是符合开闭原则的，但是对修改产品等级结构（也就是说修改，添加新的产品到产品族中）是不符合开闭原则的。<strong>开闭原则的倾斜性</strong>。</p><p><img src="https://i.loli.net/2021/02/11/V3FXR61CPSQIY8h.png"></p><p>工厂方法模式没有所谓产品族的实现，如果要添加新的产品族，需要添加一系列的工厂和产品，且这些工厂和产品间在代码上是没有直接关系的，需要提供额外约束（要求用户只使用同一个产品族的产品），增加维护成本。但是工厂方法模式对于修改产品等级结构是符合开闭原则的——只需要创建新的产品和工厂类即可。</p><blockquote><p>这个设计模式是最具抽象性和一般性的，我觉得我的描述也挺抽象的。</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>书中的例子还满贴切的，可以直接用——</p><p>考虑这样的情景——要给软件添加“皮肤”的功能，现在假设有 Spring 皮肤和 Summer 皮肤，设计者先使用工厂方法进行系统设计——</p><p><img src="https://i.loli.net/2021/02/11/t69KeXsqVWA4wYg.png"></p><p>用户应当一次选择一种皮肤——也就是说使用同一族的产品（SummerTextField，SummerButton……），而使用工厂方法，用户要选择逐个配置选择哪个具体工厂，当然也可以使用字符串拼接+反射等方式来进行约束，但是仍旧是比较复杂的（而且抽象，难以调试，维护）。且每次添加新的皮肤（产品族），需要对每一个产品都新增一个具体工厂，增加了类的数量。</p><blockquote><p>这里其实拿不同操作系统的 UI 为例更好，这年代，谁拿 Java 写 UI 啊（</p></blockquote><p>考虑到有添加新皮肤（新的产品族）的需求，没有添加新的组件（新的产品等级结构）的需求，使用抽象工厂模式进行重构——</p><p><img src="https://i.loli.net/2021/02/11/2YaRnI9xEwMzKLO.png"></p><p>其代码如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 抽象工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkinFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Button <span class="hljs-title function_">createButton</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> TextField <span class="hljs-title function_">createTextField</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ComboBox <span class="hljs-title function_">createComboBox</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SkinFactory <span class="hljs-title function_">getSkinFactory</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (SkinFactory) Class.forName(type).newInstance();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">// 应该进一步处理</span><br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 各个组件的接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayButton</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextField</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayTextField</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComboBox</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayComboBox</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// ---------具体工厂和具体组件----------</span><br><span class="hljs-comment">//SummerSkinFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SummerSkinFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SkinFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Button <span class="hljs-title function_">createButton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SummerButton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TextField <span class="hljs-title function_">createTextField</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SummerTextField</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ComboBox <span class="hljs-title function_">createComboBox</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SummerComboBox</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SummerTextField</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TextField</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayTextField</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;一个 Summer 皮肤的文本框&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SummerButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayButton</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;一个 Summer 皮肤的按钮&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SummerComboBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ComboBox</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayComboBox</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;一个 Summer 皮肤的复选框&quot;</span>);<br>&#125; <br>&#125;<br><br><span class="hljs-comment">//SpringSkinFactory 和 Summer 的基本一致，不复制了</span><br><br><span class="hljs-comment">// 客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SkinFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> SkinFactory.getSkinFactory(<span class="hljs-string">&quot;SpringSkinFactory&quot;</span>);<br>        factory.createButton().displayButton();<br>        factory.createComboBox().displayComboBox();<br>        factory.createTextField().displayTextField();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>要添加和使用新皮肤？没问题，添加新的具体的皮肤工厂和相应的组件即可。添加新组件？emmmm，大刀阔斧地改吧。优缺点我觉得已经说够了。</p><p>抽象工厂模式的一般形式如图——</p><p><img src="https://i.loli.net/2021/02/11/icOJlbfS5TkphdG.png"></p><h1 id="做一做题目"><a href="#做一做题目" class="headerlink" title="做一做题目"></a>做一做题目</h1><p>两个题目——提供一个程序，它能读取不同编码的图像文件，需保证扩展性和灵活性；针对不同操作系统平台，提供一套游戏操作控制类（OperatonController）和游戏界面控制类（InterfaceController），需封装这些类的初始化过程。</p><p>第一个题目显然适合用工厂方法模式，假设图像的编码总是符合它的后缀，对所有有多后缀的编码格式，都假设它是其中一个编码——比如对 jpeg 和 jpg，假设只有 jpg。</p><p>代码如下，这里 ImageReader 是抽象工厂，JPGReader 和 PNGReader 则是具体工厂，Image 是抽象产品，JPG，PNG 是具体产品，它们理应返回 Image 作为产品，考虑到要根据后缀选择工厂，所以后缀应当作为工厂的一个域（这恐怕在实际生产中是不合理的，应当掩盖掉具体工厂的构造，直接返回 Image）——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageReader</span> &#123;<br>    String path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ImageReader</span><span class="hljs-params">(String path)</span>&#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Image <span class="hljs-title function_">readImage</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ImageReader <span class="hljs-title function_">getReader</span><span class="hljs-params">(String path)</span> &#123;<br>        String[] split = path.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">postfix</span> <span class="hljs-operator">=</span> split[split.length-<span class="hljs-number">1</span>].toUpperCase();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (ImageReader) Class.forName(postfix + <span class="hljs-string">&quot;Reader&quot;</span>).getConstructor(String.class).newInstance(path);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">// 应该进一步处理</span><br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Image</span> &#123;<br>    String path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Image</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JPGReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ImageReader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JPGReader</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Image <span class="hljs-title function_">readImage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;读取 JPG 文件：&quot;</span> + path);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPG</span>(path);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JPG</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Image</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JPG</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;展示这个 JPG 的信息&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PNGReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ImageReader</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PNGReader</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PNG <span class="hljs-title function_">readImage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;读取 PNG 文件：&quot;</span> + path);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PNG</span>(path);<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PNG</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Image</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PNG</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;展示这个 PNG 的信息&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/home/abc/hello.jpg&quot;</span>;<br>        <span class="hljs-type">ImageReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> ImageReader.getReader(path); <span class="hljs-comment">// 使用 ImageReader 直接返回图像在这里更合理些</span><br>        <span class="hljs-type">Image</span> <span class="hljs-variable">Image</span> <span class="hljs-operator">=</span> reader.readImage();<br>        Image.show();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/11/xZuFakIJcoBAj9i.png"></p><p>更加合适的解决方案是这样——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageReader</span> &#123;<br>    String path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ImageReader</span><span class="hljs-params">(String path)</span>&#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Image <span class="hljs-title function_">readImage</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Image <span class="hljs-title function_">getImage</span><span class="hljs-params">(String path)</span> &#123;<br>        String[] split = path.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">postfix</span> <span class="hljs-operator">=</span> split[split.length-<span class="hljs-number">1</span>].toUpperCase();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> ((ImageReader) Class.forName(postfix + <span class="hljs-string">&quot;Reader&quot;</span>).getConstructor(String.class).newInstance(path)).readImage();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">// 应该进一步处理</span><br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/home/abc/hello.jpg&quot;</span>;<br>        <span class="hljs-type">Image</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> ImageReader.getImage(path);<br>        image.show();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第二个题目，每个操作系统下的各种组件显然是属于一个产品族的，这里显然要使用抽象工厂模式。角色分类如下——ControllerFactory 为抽象工厂类，定义 createOperatonController 和 createInterfaceController 抽象方法。它们返回 OperatonController 和 InterfaceController，这是两个抽象产品，它们属于一个产品族。AndroidControllerFactory 和 IOSControllerFactory 为两个具体工厂，它们生产 AndroidOperatonController，AndroidInterfaceController 和 IOSOperatonController，IOSInterfaceController 这四个具体产品。</p><p><img src="https://i.loli.net/2021/02/12/Mhk6Xzbqm4Y15DG.png"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 抽象层</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ControllerFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> OperationController <span class="hljs-title function_">createOperationController</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> InterfaceController <span class="hljs-title function_">createInterfaceController</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ControllerFactory <span class="hljs-title function_">getControllerFactory</span><span class="hljs-params">(String systemType)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (ControllerFactory) Class.forName(systemType + <span class="hljs-string">&quot;ControllerFactory&quot;</span>).newInstance();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">// 应该进一步处理</span><br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// Android 的具体工厂和产品族</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidControllerFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ControllerFactory</span>&#123;<br><br>    <span class="hljs-keyword">public</span> OperationController <span class="hljs-title function_">createOperationController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndroidOperationController</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> InterfaceController <span class="hljs-title function_">createInterfaceController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndroidInterfaceController</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidOperationController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OperationController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化 Android 的操作控制类&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidInterfaceController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InterfaceController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化 Android 的界面控制类&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// IOS 的具体工厂和产品族</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IOSControllerFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ControllerFactory</span>&#123;<br><br>    <span class="hljs-keyword">public</span> OperationController <span class="hljs-title function_">createOperationController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOSOperationController</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> InterfaceController <span class="hljs-title function_">createInterfaceController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOSInterfaceController</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IOSOperationController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OperationController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化 IOS 的操作控制类&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IOSInterfaceController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InterfaceController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化 IOS 的界面控制类&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ControllerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> ControllerFactory.getControllerFactory(<span class="hljs-string">&quot;IOS&quot;</span>);<br>        factory.createInterfaceController().doSomething();<br>        factory.createOperationController().doSomething();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>挺复杂，但其实也不太复杂，重要的是如何将其运用到具体开发中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS 从入门到入坟——全排列和八皇后问题</title>
    <link href="/2021/02-10DFS%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97%E5%92%8C%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.html"/>
    <url>/2021/02-10DFS%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97%E5%92%8C%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>2022 年 1 月 31 日更新，添加 Haskell 的解决方案，和 Racket 的实现一致（即“不断维护所有当前路径的列表”），但更容易看些。</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">permutationFrom1toN</span> :: <span class="hljs-type">Int</span> -&gt; [[<span class="hljs-type">Int</span>]]<br><span class="hljs-title">permutationFrom1toN</span> n | n &lt;= <span class="hljs-number">0</span> = error <span class="hljs-string">&quot;!&quot;</span><br><span class="hljs-title">permutationFrom1toN</span> n = helper (map pure [<span class="hljs-number">1</span> .. n]) <span class="hljs-number">1</span><br>  <span class="hljs-keyword">where</span> <br>    helper :: [[<span class="hljs-type">Int</span>]] -&gt; <span class="hljs-type">Int</span> -&gt; [[<span class="hljs-type">Int</span>]]<br>    helper lst step | step == n = lst<br>    helper lst step = lst &gt;&gt;= \ path -&gt; <br>      <span class="hljs-keyword">let</span> validNextElem = filter (`notElem` path) [<span class="hljs-number">1</span> .. n] <br>          nextPaths = map ((path ++ ). pure) validNextElem <span class="hljs-comment">-- 不使用：是为了保证可读性</span><br>      <span class="hljs-keyword">in</span> helper nextPaths $ step + <span class="hljs-number">1</span><br><br><span class="hljs-title">nQueens</span> :: <span class="hljs-type">Int</span> -&gt; [[<span class="hljs-type">Int</span>]]<br><span class="hljs-title">nQueens</span> n | n &lt;= <span class="hljs-number">0</span> = error <span class="hljs-string">&quot;illegal argument&quot;</span><br><span class="hljs-title">nQueens</span> n = helper (map pure [<span class="hljs-number">1</span> .. n]) <span class="hljs-number">1</span><br>  <span class="hljs-keyword">where</span> <br>    helper :: [[<span class="hljs-type">Int</span>]] -&gt; <span class="hljs-type">Int</span> -&gt; [[<span class="hljs-type">Int</span>]]<br>    helper pathList step | step == n = pathList<br>    helper pathList step = pathList &gt;&gt;= \ path -&gt;<br>      <span class="hljs-keyword">let</span> nextPaths = map ((path ++ ). pure) $ validNextPos path<br>      <span class="hljs-keyword">in</span> helper nextPaths $ step + <span class="hljs-number">1</span><br><br>    validNextPos :: [<span class="hljs-type">Int</span>] -&gt; [<span class="hljs-type">Int</span>]<br>    validNextPos path = <br>      filter (\currentX -&gt; all (\(x, y) -&gt; <br>        currentX /= x &amp;&amp; <br>        abs (currentY - y) /= abs (currentX - x) <br>      ) zippedWithY) [<span class="hljs-number">1</span> .. n]<br>      <span class="hljs-keyword">where</span> zippedWithY = zip path $ iterate (+<span class="hljs-number">1</span>) <span class="hljs-number">1</span><br>            currentY = length path + <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><hr><p>太久没有好好敲代码了……最近整一堆花里胡哨的，学 racket，haskell，scala（当然，日语也包含在内）之类的，但是一个都没深入。这里 racket 是我最感兴趣的，它的 LOP（面向语言编程）我非常想去了解和学习，scala 则是看重它运行在 JVM 上且有充足的函数式编程特性（函数式编程也是我想去了解的），在将来的项目中或许可以用到，haskell……新语法太多（但是它的函数的表现形式，对柯里化的支持等都是非常酷的…但是我苯，不想学：），还是纯函数式的，一时难以接受。</p><p>于是现在重拾算法，发现之前学的都不知道忘到哪里去了……是时候该进行一波复习了。首先拿 DFS 开刀，这算法是能归纳出一个“范式”的。</p><p>其实，无论 DFS 还是 BFS，其实都是以不同的方式遍历一棵树（也就是搜索的路径，其实也是在动态构造这棵树），那些没有叶子节点的节点即为搜索成功或再没有路径可选。区别在于，如果要留下搜索路径，BFS 需要保存所有的路径，而 DFS 则无此需要（可以说应该选择的路径被保存在函数调用栈中了）。从实例能看出这一点。</p><h1 id="数的全排列"><a href="#数的全排列" class="headerlink" title="数的全排列"></a>数的全排列</h1><p>首先考虑数的全排列问题。这个问题要求给定一个数字 n，输出从 1 到 n 的全排列。</p><p>这里先按 BFS 来思考一下。假设 n 等于 3，能得到这样的一棵树——</p><p><img src="https://i.loli.net/2021/02/09/nFOuLSN94vhB3Gl.jpg"></p><p>任何一个排列都是从根结点到子节点的一条<strong>路径</strong>。BFS 的方法就是不断维护所有路径，直到所有路径（或某个路径）成功（或失败）。</p><blockquote><p>这个树叫<strong>解空间树</strong>，其实对树中每个节点（目前的路径），都需要遍历所有的可能（当然，也可以根据一定问题使用一定手段，以保证能在 O(n) 复杂度以下获取到有效可能），比如对路径 (1 2)，要遍历 1，2，3，然后发现 1 和 2 是不合法的，因此其子节点只有 (1 2 3) 了。</p></blockquote><p>比如下面的 BFS 的 racket 实现就是不断维护所有当前路径的列表，假设 n 为 3，经历多次（n-1 次）迭代后，所有路径都到达终点，每次迭代的结果如下，其中 0 为初始值——</p><ol start="0"><li>‘((1) (2) (3))</li><li>‘((1 2) (1 3) (2 1) (2 3) (3 1) (3 2))</li><li>‘((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))</li></ol><blockquote><p>其实写完迭代的结果后我才突然意识到好像递归法满好写的…使用 map 和 flatten 就可以了，我用了非常丑陋的命令式的写法…</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs racket">;; 写的累死人……我为啥不干脆用 Java 写？<br>;; BFS 的方法……由于我完全不熟悉 racket，所以写的及其丑陋（而且用了非常命令式的写法…由于 racket 并没有提供太多有副作用的函数，所以写的还是蛮痛苦的……这时候或许应该用 mutable list？）<br>;; 顺便，羡慕 haskell 的偏函数调用<br>(require control)<br>;; 以二维 list 的形式返回从 1 到 n 的全排列<br>(define (permutation-from-1-to-n n)<br>  ;; 从 (1) 到 (n) 的 list，它储存所有路径<br>  (define paths (build-list n (lambda (x) (list (add1 x)))))<br>  <br>  ;; 循环 n-1 次维护 paths，增长（和分支）其中每条 path 并将其“打散”到 paths 中<br>  (dotimes (__ (sub1 n))<br>    (set! paths (foldl append empty (map (generate-paths n) paths))))<br>  paths)<br><br>;; 一个柯里化函数，它维护和分支一条 path。比如对于 n=5，path=(1 3) 的情况，它返回 ((1 3 2) (1 3 4) (1 3 5))<br>(define generate-paths<br>  (lambda (n)<br>    (lambda (path)<br>      (for/list ([i (in-range 1 (add1 n))]<br>             #:when (not (member i path)))<br>    (append path (list i))))))<br></code></pre></div></td></tr></table></figure><p>也可以使用队列来实现，其实质仍旧是不断维护所有当前路径，只不过将每次延伸队列头部的路径，并将其出队，将延伸后的路径加入到队列尾，容易知道当队列头部的路径长度为 n 时已获取到所有路径——</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs racket">(require data/queue control)<br><br>;; 循环维护队列首，将其生成的路径入队，直到队首长度为 n，此时已生成所有全排列<br>(define (permutation-from-1-to-n n)<br>  (define res (make-queue))<br>  (for ([i (build-list n (lambda (x) (list (add1 x))))])<br>    (enqueue! res i))<br>  (while (not (= (length (queue-head res)) n))<br>    (for ([i ((generate-paths n) (dequeue! res))]) ; define 不能在循环体内使用<br>      (enqueue! res i)))<br>  (queue-&gt;list res))<br><br>;; racket 的 queue 居然没有提供直接获取队列头部的过程，设计者究竟是什么意思……<br>(define (queue-head queue)<br>  (let ([head (dequeue! queue)])<br>    (enqueue-front! queue head)<br>    head))<br><br>;; 同上面的定义<br>(define generate-paths<br>  (lambda (n)<br>    (lambda (path)<br>      (for/list ([i (in-range 1 (add1 n))]<br>             #:when (not (member i path)))<br>    (append path (list i))))))<br></code></pre></div></td></tr></table></figure><p>DFS 相当与对每一条 path，对它的所有子节点进行“尝试”，DFS 解法的 racket 代码如下（这个比 Java 版好理解多了）——</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs racket">(define (permutation-from-1-to-n n)<br>  (define (DFS path)<br>    (if (= (length path) n) ; 如果 path 长度已经为 n，说明必定已经完成一个排列。<br>        (println path) ; 基线条件，此时的 path 即为一条路经<br>        (for ([i (in-range 1 (add1 n))]) ; 从 1 到 n<br>          (unless (member i path)<br>            (DFS (append path (list i)))))))<br>  (DFS empty))<br></code></pre></div></td></tr></table></figure><p>可以形象地将 DFS 解法的函数调用栈这样表示——</p><p><img src="https://i.loli.net/2021/02/09/FyI6SwducPlYVbi.jpg"></p><p>在每一次函数调用里，它都会对每一个可能进行递归，比如对路径’(1)，它会递归’(1 2)，’(1 3)……</p><p>Java 版的写法较此要麻烦一些（出于 Java 并不方便像 racket 这样的函数式语言一样使用不可变的数据结构），需要使用一个数组来维护当前路径，需要维护当前的“步长”。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">permutationFrom1ToN</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        DFS(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>], <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] path, <span class="hljs-type">int</span> step)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> path.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (step == N + <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 基线条件</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= N; i++)<br>                System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>            System.out.println();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>            <span class="hljs-comment">// 传统手段是使用一个 bool 数组来维护元素是否已经保存在 path 中。如果使用那种方式，</span><br>            <span class="hljs-comment">// 需要在将元素置入 path 前将该位置置为 true，在递归下一个位置后将该位置置为 false。</span><br>            <span class="hljs-comment">// 这里直接通过一次遍历来检查元素是否存在于 path 中</span><br>            <span class="hljs-keyword">if</span> (numInPath(path, step, i)) <br>                <span class="hljs-keyword">continue</span>;<br>            path[step] = i;<br>            DFS(path, step + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">numInPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[]path, <span class="hljs-type">int</span> step, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; step; i++)<br>            <span class="hljs-keyword">if</span> (path[i] == num) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总之，DFS 可以归纳出一个“范式”——</p><figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit">def DFS(<span class="hljs-keyword">step</span>):<br>    <span class="hljs-keyword">if</span> （达到基线条件）:<br>        进行一些处理，比如打印，保存当前 path 等<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 所有元素 where i 未被取出且合法：<span class="hljs-meta"># 遍历该 path 的下一步所有的可能</span><br>        books[i] = <span class="hljs-literal">true</span> <span class="hljs-meta"># 取该元素</span><br>        path[<span class="hljs-keyword">step</span>] = i<br>        DFS(<span class="hljs-keyword">step</span> + <span class="hljs-number">1</span>) <span class="hljs-meta"># 递归其子节点</span><br>        books[i] = <span class="hljs-literal">false</span> <span class="hljs-meta"># 放回该元素</span><br><br></code></pre></div></td></tr></table></figure><p>八皇后问题也是遵循这样的范式的。</p><h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><p>八皇后是这样一个问题——在一个 8X8 的棋盘上安排 8 个皇后，各个皇后两两之间要遵循这样的要求——每两个皇后不能在同一行，同一列，或相对棋盘边相互呈 45 度（即行距离和列距离相等）。</p><p>一个问题是，如何定义“步长”？这里考虑到各个皇后两两不能在同一行同一列，但每一行，每一列又必须存在一个皇后，所以可以以行数或列数作为步长。比如对一个 5X5 的棋盘，可以有这样的树，其中 (1 . 1) 这样的值代表在位置 (1, 1) 安放皇后——</p><p><img src="https://i.loli.net/2021/02/09/pZukVxjRL3TYoIb.jpg"></p><blockquote><p>其实就根本上来说，步长是每一个皇后的安置，也就是说每一步都可以遍历整个棋盘，检查该位置是否可以安置皇后，但是这样是不划算的——已经安置过皇后的行或列是不必要再遍历的，并且会造成有重复的情况。比如对路径’((1 . 1) (2 . 3) …)，还可以有路径’((2 . 3) (1 . 1) …)……</p></blockquote><p>因此，可以很容易得到 DFS 的代码，这里以行作为 step——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 一年后再看这代码，只能说很面向过程😂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queen</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> step;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> y;<br><br>    Queen(<span class="hljs-type">int</span> step, <span class="hljs-type">int</span> y) &#123;<br>        <span class="hljs-built_in">this</span>.step = step;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">n_queensCount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        counter = <span class="hljs-number">0</span>;<br>        DFS(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queen</span>[n + <span class="hljs-number">1</span>], n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(Queen[] queens, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> step)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> queens.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (step == N + <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 基线条件</span><br>            counter++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 从第一列到第 n 列，这里的行数是 step</span><br>            <span class="hljs-keyword">if</span> (!canPlaceAt(step, i, queens)) <span class="hljs-comment">// 遍历第 1 到第 step-1 个 queen，看这个 queen 能不能放在这里</span><br>                <span class="hljs-keyword">continue</span>;<br>            queens[step] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queen</span>(step, i);<br>            DFS(queens, n, step + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPlaceAt</span><span class="hljs-params">(<span class="hljs-type">int</span> step, <span class="hljs-type">int</span> y, Queen[] queens)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= step - <span class="hljs-number">1</span>; i++)<br>            <span class="hljs-comment">// 如果在同一列或对角线</span><br>            <span class="hljs-keyword">if</span> (y == queens[i].y || <br>                Math.abs(step - queens[i].step) == Math.abs(y - queens[i].y))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>racket 代码如下（can-place? 过程给我写麻了…），仍旧以行作为 step——</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs racket">(define-struct queen (step y) #:transparent)<br>; 判断 (step . y) 位置是否合法<br>(define (can-place? path step y) ; 只要既有的 path 中没有和要放置的 path 处于同一行，同一列或对角线，则合法<br>  (andmap <br>    (λ (queen)<br>      (and (not (= (queen-y queen) y))<br>           (not (= (abs (- (queen-step queen) step))<br>                   (abs (- (queen-y queen) y))))))<br>    path))<br><br>(define (n-queens n)<br>  (let DFS ([path empty])<br>    (define step (add1 (length path)))<br>    (if (= (length path) n)<br>        (println path) ; base case<br>        (for ([y (in-range 1 (add1 n))]) ; 迭代从 1 到 n 列<br>          (when (can-place? path step y)<br>            (DFS (append path (list (make-queen step y)))))))))<br><br></code></pre></div></td></tr></table></figure><p>哦瓦！</p><p><img src="https://i.loli.net/2021/02/03/sJDeV3hPQFrTgOW.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象七原则，单例模式，简单工厂模式</title>
    <link href="/2021/02-03%E4%B8%83%E5%8E%9F%E5%88%99%EF%BC%8C%E5%8D%95%E4%BE%8B%EF%BC%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html"/>
    <url>/2021/02-03%E4%B8%83%E5%8E%9F%E5%88%99%EF%BC%8C%E5%8D%95%E4%BE%8B%EF%BC%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>最近忧心忡忡……该沉下心来，好好运动，好好学习了。</p><h1 id="面向对象七原则"><a href="#面向对象七原则" class="headerlink" title="面向对象七原则"></a>面向对象七原则</h1><p>面向对象编程有七个设计原则，相较于设计模式来说，它们是“根基”——</p><ul><li>单一职责原则（Single Responsibility Principle，SRP）</li><li>开闭原则（Open-Closed Principle，OCP）</li><li>里氏代换原则（Liskov Substitution Principle，LSP）</li><li>依赖倒转原则（Dependency Inversion Principle，DIP）</li><li>接口隔离原则（Interface Segregation Principle，ISP）</li><li>合成复用原则（Composite Reuse Principle，CRP）</li><li>迪米特法则（<strong>Law</strong> of Demeter，LoD）</li></ul><p>面向对象的程序应当是可复用，易维护的，而要做到这一点，遵守七个原则是不可或缺的。</p><p>单一职责原则，就是要求<strong>控制类的粒度</strong>，让<strong>一个类只负责一个功能领域中的相应职责</strong>。也就是说，让各个类各司其职，将不同的职责封装到不同的类中，不能让某个类一手包办所有事情。因为，<strong>一个类的职责越多，它被复用的可能性就越小</strong>。</p><p>开闭原则，就是要求软件<strong>对扩展开放，对修改封闭</strong>，即尽量在不修改原有代码的情况下进行扩展。</p><p>里氏代换原则，就是要求<strong>所有应用基类的地方都可以使用子类对象且不发生错误</strong>（用术语说，这玩意是<strong>透明</strong>的）。也就是说尽量使用基类类型，而不使用子类类型。<strong>父类应当是抽象类或接口</strong>。在 Java 编程中，我们常常使用数据结构的接口作为要使用的数据结构的类型也是遵循了这样一个原则。如<code>List&lt;Integer&gt; arr = new ArrayList&lt;&gt;();</code>。基类的数组可以引用子类对象也是这样一个原理。</p><p>依赖倒转原则，就是要求<strong>细节应当依赖于抽象</strong>，而非抽象依赖于细节。也就是说，<strong>要针对接口编程</strong>，而非针对实现编程。Java 将数据结构定义成接口遵循了这个原则。上面的例子<code>List&lt;Integer&gt; arr = new ArrayList&lt;&gt;();</code>也实现了依赖倒转原则，它将一个具体对象<strong>依赖注入</strong>到了一个抽象的接口中，<strong>所谓针对抽象层编程</strong>（所使用的对象只能使用抽象层中定义的方法）。</p><blockquote><p>一般来说，抽象是依赖于细节的。比如，我们从数字，字符串等数据类型里抽象出 Comparable 接口；从向量，链表里抽象出 iterable 接口（实际上是抽象出来这些数据类型所共有的某些性质）……这些接口，也就是“抽象”，是从细节中来的！而我们在定义新的数据类型的时候，是根据需要和设计，让这个数据类型实现所需的一些功能，这时候就为这些功能规定相应接口（或者已有的接口）并 implements，这时就有了“倒转”，细节是依赖于抽象了！</p></blockquote><p>接口隔离原则，就是要求<strong>使用多个专门的接口，而非一个总接口</strong>，也就是说，客户端不应该依赖于那些它不需要的接口（这会破坏程序的封装性，带来很多无用代码）。这和单一职责原则是相似的。</p><p>合成复用原则，就是要求<strong>尽量使用组合，而非继承达到复用的目的</strong>。也就是说，尽量使用委托的手段。因为继承会让子类与父类耦合程度很高，父类的实现细节会暴露给子类，从而破坏封装性。而且从基类继承的实现是静态的，无法在运行时改变。</p><p>迪米特法则，就是要求<strong>对象与尽量少的其他对象进行通信</strong>。符合迪米特法则的系统在要修改某个模块时，会尽量少地影响其他模块，从而降低系统的耦合度。具体来说，就是系统中的对象只和它的“朋友”通信。且这里的“朋友”要尽量少。</p><h1 id="创建对象的艺术——创建型模式"><a href="#创建对象的艺术——创建型模式" class="headerlink" title="创建对象的艺术——创建型模式"></a>创建对象的艺术——创建型模式</h1><p>创建型模式（Creational Pattern）关注对象的创建过程，以<strong>将对象的创建和使用分离，在使用对象时无需关注其创建细节，从而降低系统的耦合度</strong>。</p><p>创建型模式主要回答三个问题——创建什么（What）？谁创建（Who）？什么时候创建（When）？</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>所谓单例模式，就是<strong>只有单个实例</strong>的类。显然，要实现单例模式，构造函数必须对外界不可见。</p><p>一个问题是，为什么要使用单例模式，而非使用全为 static 方法（成员）的类呢？但就其达到的结果来说，两者是等同的，但是两者的<strong>语义</strong>是不同的。static 关键字代表<strong>所有实例共同持有</strong>，其虽然能够保证成员唯一性，但是这并非是它的直接意图。并且单例模式的类可以有继承，能够实现面相抽象层编程的需要。像 Spring 中使用的 Bean 一般来说都是单例的。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>其使用场景是那些确实只需要一个实例的情况，比如 windows 的任务管理器，无论有多少个实例，其所表示的东西都是相同的，如当前各进程的情况，CPU，内存的占用率等等。</p><p>单例模式有三种实现——懒汉式，饿汉式，IoDH（延迟加载）。<strong>懒汉式在客户端第一次获取该类实例时进行初始化，其后直接返回单例，懒汉式为了维护线程安全性需要进行特殊处理；饿汉式在类加载时进行初始化，保证线程安全，但是其可能在初始化后得不到使用，从而有资源（内存）上的浪费；IoDH 结合了懒汉式和饿汉式的优点，保证在第一次请求该类实例时进行初始化，而其线程安全性由 Java 虚拟机保证</strong>。</p><h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><p>饿汉式是最简单的单例模式的实现。顾名思义，饿汉，所以它要贪婪，无论这个类调不调用，先构造这个单例再说。所以，饿汉式是指<strong>类加载时即进行初始化</strong>。</p><p>一个简单的实例如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EagerSingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EagerSingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EagerSingleton</span>(); <span class="hljs-comment">// !    </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">EagerSingleton</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* . . . */</span> &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-comment">// . . .</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>显然，它会造成一定的资源的浪费，因为可能 getInstance() 并没有被执行时，实例就已经被初始化，从而造成资源上的浪费。</p><p>需要注意的是，实例和构造函数应当是 private 的。</p><h2 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h2><p>懒汉式是懒惰（lazy）的，它只在需要它的时候上场。也就是说，懒汉式指在第一次请求实例时进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LazySingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LazySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//！</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LazySingleton</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* . . . */</span> &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) <span class="hljs-comment">// 未初始化</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingleton</span>();<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-comment">// . . .</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>显然，getInstance 方法是线程不安全的，在多线程条件下无法保证只有一个实例。给该方法添加 synchronized 关键字可以保证线程安全性，但是这会非常影响系统性能，那么，只给构造这一行 synchronized 关键字如何呢？这样如果已经被初始化，同步代码块就不会被执行了！比如这样——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 未初始化</span><br>        <span class="hljs-keyword">synchronized</span> (LazySingleton.class) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但这仍旧是线程不安全的！如果线程 a，b 并发执行，同时达到 synchronized 代码块，仍然会创建多个实例。必须要在 synchronized 关键字内再次进行检查（这个称为<strong>双重检查锁定</strong>），并且要对 instance 使用 volatile 关键字进行修饰以保证其可见性。结果代码如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LazySingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LazySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//！</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LazySingleton</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* . . . */</span> &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 未初始化</span><br>        <span class="hljs-keyword">synchronized</span> (LazySingleton.class) &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingleton</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-comment">// . . .</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="IoDH（延迟加载）式单例"><a href="#IoDH（延迟加载）式单例" class="headerlink" title="IoDH（延迟加载）式单例"></a>IoDH（延迟加载）式单例</h2><p>延迟加载（IoDH）使用 Java 提供的静态内部类并让实例由其持有，实例如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* . . . */</span> &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HolderClass</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> HolderClass.instance;<br>    &#125;<br>    <span class="hljs-comment">// . . .</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>顾名思义，这个 instance 只有在 getInstance 方法第一次被调用时才加载。<strong>且线程安全性被 Java 虚拟机所保证</strong>。是最优解。但是该手段是局限于编程语言的，很多语言不支持它。</p><h2 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h2><p>单例模式的优点在于，其<strong>可以严格控制客户端的访问</strong>，且只有一个对象实例，因此可以节约系统资源。同时其可以进行扩展，比如允许一定数量的实例（称为多例类）。</p><p>缺点在于，<strong>其没有抽象层</strong>，因而扩展有困难，且<strong>职责过重，违背了单一职责原则，其既要负责业务，又要提供创建对象的方法（工厂方法），对象的创建和对象本身的功能耦合了</strong>。最后，单例的对象如果丢失了引用，可能被 GC 掉，这很多时候是不符合预期的。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式并不属于 23 条设计模式，但是也是比较常用的。</p><p>所有工厂模式的初衷是将类的创建和使用分离，具体来说，如果客户端要使用一个类，<strong>它不应该既创建这个类，又使用这个类</strong>，否则会造成耦合。</p><p>简单工厂模式其实就是将所需类的创建的责任交给一个所谓的<strong>工厂类</strong>，从而客户端不需要再负责类的创建，只需要负责类的使用，即进行了解耦。</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><h3 id="ver-0-1"><a href="#ver-0-1" class="headerlink" title="ver 0.1"></a>ver 0.1</h3><p>考虑书中所举的例子——给用户提供一个图表库，其给定参数生成相应的图表…假设现在已经有了柱状图，饼状图，折线图…下面的代码为了简便，省略掉初始化图表所需要的其他数据。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chart</span> &#123;<br>    <span class="hljs-keyword">private</span> String type;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chart</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-built_in">this</span>.type = type;<br>        <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;histogram&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 初始化柱状图</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;pie&quot;</span>)) &#123;<br>            <span class="hljs-comment">//初始化饼状图</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;line&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 初始化折线图</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;histogram&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 展示柱状图</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;pie&quot;</span>)) &#123;<br>            <span class="hljs-comment">//展示饼状图</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;line&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 展示折线图</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>客户端将如下调用——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chart</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chart</span>(<span class="hljs-string">&quot;line&quot;</span>);<br>        graph.display();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>问题在哪里呢？首先，太多 if-else 了，可能有性能上的影响（而且也太过不优雅了）；然后，类的创建和类的使用都耦合在这一个类里，职责过重，违反了单一职责原则；最后，如果要添加新产品，需要更改源代码（而且是两处），违反了开闭原则。简单工厂只能解决这里的“然后”。</p><h3 id="ver-0-2"><a href="#ver-0-2" class="headerlink" title="ver 0.2"></a>ver 0.2</h3><p>第一步的优化是抽象出这些图表的共同性质（哲学上的），定义一个抽象父类（图表），而这些具体的图表则作为对这个父类的子类或实现。这样，可以将 Chart 类拆分，将每个具体实现的代码分别放置到不同的类中。在这里，父类使用抽象类实现（书中使用的是接口，我认为抽象类更符合这里的语义）。总之得到这样的类图（子类一定有成员变量，其构造函数是一定有参数的，这里省略了）——</p><p><img src="https://i.loli.net/2021/02/03/p3NMC6PLIDz7Tlf.png"></p><p>之后，客户端应如下调用——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chart</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LineChart</span>();<br>        graph.display();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在，没有那些 if-else 逻辑了，如果要新增需求（新的表），只需要编写新的子类即可。但是这里类的创建和类的使用仍然是客户端同时负责的，因此仍旧有耦合。</p><h3 id="ver-1-0"><a href="#ver-1-0" class="headerlink" title="ver 1.0"></a>ver 1.0</h3><p>为了解决这耦合，可以使用简单工厂模式。而为此，上面的 if-else 又要被请回来了（这绝非必须，只不过是这个设计模式要求这样而已）。</p><p>总之，这里定义一个工厂类，它要接管所有 Chart 类的构造和初始化（区分开是因为构造后可能仍旧并非是所需的实例）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChartFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Chart <span class="hljs-title function_">getChart</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;histogram&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 返回一个柱状图的实例</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;pie&quot;</span>)) &#123;<br>            <span class="hljs-comment">//返回一个饼状图的实例</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equalsIgnoreCase(<span class="hljs-string">&quot;line&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 返回一个折线图的实例</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 或者抛个异常之类的</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>客户端将这样调用——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chart</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=</span> ChartFactory.getChart(<span class="hljs-string">&quot;line&quot;</span>);<br>        graph.display();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在，解决了创建和使用关系的问题，客户端只有使用的职责，创建的职责交由工厂类执行。但是仍有一个问题——如果要更改要展示的图表，需要更改源代码，违反了开闭原则。这样每次更改后都需要重新编译，无法”热更新“。解决方式是将这个字符串保存在配置文件中，使用一定的库进行读取。这里不需要赘述了。</p><p>一个简化的点是，可以将工厂类和抽象产品类结合，作为抽象产品类的一个方法。这样可以简化掉一个类，但是会导致类间的关系有点古怪。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chart</span>&#123;<br>    <span class="hljs-comment">// . . .</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Chart <span class="hljs-title function_">factoryMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// . . .</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单工厂模式可以归纳出如下角色——<strong>工厂，抽象产品，具体产品</strong>。其关系如下——</p><p><img src="https://i.loli.net/2021/02/03/Jm3hjWitEsNFA8f.png"></p><p>抽象产品作为产品的父类，应当持有所有产品的公共代码，各个具体产品持有各自的私有代码。工厂是简单工厂模式的核心，它负责创建所有产品实例的内部逻辑。</p><p>使用工厂模式创建对象，相较于使用 new 或反射机制等创建对象，其优势在于对对象的创建和使用进行了解耦，使实现更加灵活。如果在构造后还需要进行其他处理，只需要在工厂类中进行处理即可，不需再付诸在客户端中。如果产品需求更新，只需更改工厂类的源代码即可。</p><p>简单工厂模式的优点在于——</p><ol><li>分离了对象的创建和使用，降低耦合性。</li><li>客户端无需知道所创建实例的具体类型，只需给定参数即可。</li><li>参数可以由配置文件给出，系统更加灵活。</li></ol><p>缺点在于——</p><ol><li>工厂类负责了所有产品的创建逻辑，<strong>其职责仍旧是过重的</strong>。</li><li>如果增加新的具体产品，需要修改工厂类的创造逻辑，增加维护成本。（下一个要学习的设计模式——工厂方法模式将解决这个问题，使新增产品不需要修改已有代码）</li><li>系统中类的个数会增加，不利于理解和维护。</li><li>工厂方法是静态的，不利于继承。（我猜测抽象工厂模式可以解决这个问题）</li></ol><p><img src="https://i.loli.net/2021/02/03/sJDeV3hPQFrTgOW.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板方法</title>
    <link href="/2021/01-27%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html"/>
    <url>/2021/01-27%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><blockquote><p>思来想去，还是不使用这本书了。有点脱离实践，而且实例太少，太简单，翻来看去也看不出各个设计模式的应用面究竟在哪里……于是我又搞了一本《设计模式的艺术 软件开发人员内功修炼之道》。</p></blockquote><p>这一章介绍的两个设计模式都是基于继承的。</p><h1 id="模板方法（Template-Method）模式"><a href="#模板方法（Template-Method）模式" class="headerlink" title="模板方法（Template Method）模式"></a>模板方法（Template Method）模式</h1><p><img src="https://i.loli.net/2021/01/15/SB6g8ZMKO1hGdvw.png"></p><p>我的手头上有个工具（tool），它可以用来做某些事情。在使用这个工具之前，我们需要找到（find）这个工具，准备（prepare）这个工具（比如把它从一堆东西里翻出来），然后使用（use）它，最后收拾（clean）它。它用程序语言怎么去描述呢？</p><p>首先，这里的工具肯定是一个抽象的概念，不存在不指代任何具体事物的所谓“工具”，所以这里的工具必定是一个<strong>抽象类</strong>。但是，我们能够确定使用它的一个<strong>流程</strong>，所以不应当使用接口（其实使用接口和 default 方法也是可行的，但是一个问题是接口不能使用 final 关键字，即使是 default 方法。）。于是，我们可以得到如下代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;寻找工具……&quot;</span>); <span class="hljs-comment">// 这一步对所有工具来说都是一样的</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 如果要防止被外界直接调用，也可以使用 protected，不过这里跟着书上的来。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clean</span><span class="hljs-params">()</span>; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeUseOf</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 必须使用 final！否则设计模式会被破坏。</span><br>        <span class="hljs-comment">// 这里当然也可以加入更加复杂的逻辑</span><br>        find();<br>        prepare();<br>        use();<br>        clean();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>显然，这里的抽象类 Tool 承担了<strong>模板</strong> (Template) 的作用，它规范了任何 Tool 范畴下的事物（也就是其子类）的使用<strong>流程</strong>（即 makeUseOf 方法）。子类只需要重写（实现）prepare，use，clean 方法即可。</p><blockquote><p>为什么这里的 makeUseOf 是 final 方法？因为这个流程是所有 Tool 所共有的，任何 Tool 都不应该离开这个流程。而如果不使用 final，且该方法被子类重写，这会导致<strong>从概念上来说</strong>子类已经不是这个父类的种概念了。而且这个设计模式也被破坏掉了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wrench</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Tool</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;准备扳手……&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用扳手……&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clean</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;整理扳手……&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wrench</span>().makeUseOf();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种设计模式是<strong>对抽象类的一种应用</strong>。它和接口——实现的这种设计规则相区别的一个很大的不同是，它规定了其子类的某种使用流程，即使该流程所调用的方法都是抽象方法。这显然在现实生活中能找到充分的例子。比如上面说的 Tool，我们并不知道这 Tool 究竟指代的是哪个具体的工具，但是我们终归是能够归纳出所有 Tool 所共有的一些东西。</p><p>模板方法就是这样一种设计模式——<strong>抽象的父类定义处理流程的框架（这个流程中所使用的方法中应存在抽象方法），而子类则去实现该流程中的具体处理（其中的抽象方法）</strong>。</p><p>模板方法实现了所谓的<strong>反向控制</strong>，即父类调用子类的操作，通过对子类的具体实现扩展不同的行为。</p><p>下面简单提及书中的例子。例子要求实现一个 display 程序，能对一个特定类型的数据（如字符，字符串，etc……显然对于任意种类的数据都必须单独处理，比如创建其对应的类）进行格式化输出。假设在经过一些实践后，我们对任意类型的数据（对应的 display 类）都能够归纳出一定的流程——<strong>首先创建开头，再创建五次正文</strong>（为什么是五次？问甲方去）<strong>，再创建结尾</strong>。于是，我们可以应用模板方法进行这样的抽象——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// AbstractDisplay.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDisplay</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        open();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>            print();<br>        close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// CharDisplay.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDisplay</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> ch;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CharDisplay</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ch = ch;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;&lt;&lt;&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(ch);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//StringDisplay.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDisplay</span> &#123;<br>    <span class="hljs-keyword">private</span> String str;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> width;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StringDisplay</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-built_in">this</span>.str = str;<br>        <span class="hljs-built_in">this</span>.width = str.getBytes().length; <span class="hljs-comment">// 使用 getBytes 可以保证如果存在占两个字节大小，且字宽也两倍于等宽字体中单个字符大小的字符（比如中文，日语）也能够正常显示。</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLine</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 辅助函数，用以生成开头一行和结尾一行</span><br>        System.out.print(<span class="hljs-string">&quot;+&quot;</span>); <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++)<br>            System.out.print(<span class="hljs-string">&quot;-&quot;</span>);<br>        System.out.print(<span class="hljs-string">&quot;+&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span>&#123;<br>        printLine();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;|&quot;</span>+str+<span class="hljs-string">&quot;|&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>&#123;<br>        printLine();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Main 文件省略。使用了模板方法的好处是，如果要修改处理的流程，比如要改成 print10 次，只需要更改抽象父类即可。如果不对这流程进行抽象，每次要更改需求就需要更改所有实现类了。</p><p>模板方法的一个问题是，子类必须要了解父类中所定义的流程，也就是说要理解父类中定义的抽象方法的调用时机，否则子类的编写是比较困难的。这说明父类和子类是<strong>紧密联系</strong>的（紧耦合？）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux 及图形界面的安装</title>
    <link href="/2021/01-06%E7%BA%B5%E8%A7%88ArchLinux%E7%9A%84%E5%AE%89%E8%A3%85.html"/>
    <url>/2021/01-06%E7%BA%B5%E8%A7%88ArchLinux%E7%9A%84%E5%AE%89%E8%A3%85.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>回到家里，决定把之前使用的系统（win10 和 Fedora）删掉，把硬盘的分区表改成 GPT 并安装 ArchLinux 和图形界面。打算把安装过程好好记录一下，同时也是概括一下，让之后再安装 ArchLinux 的时候不会只死跟着安装指南，不但要知其然，还要知其所以然嘛。<del>同时也联系一下我之前学过的一点关于开机引导的知识，网络配置的知识等，从而让我能够有一个感性（但是系统）的认识。总之什么相关的都涉及一下。</del>（摸了）</p><p>顺便也要去了解一下图形界面的安装……还有常用的一些工具，如中文字体，fctix 框架，wine（如果有必要的话）等的安装。</p><p>这里使用 VirtualBox 虚拟机来安装以方便截图和记录之类的……</p><h1 id="概括安装步骤"><a href="#概括安装步骤" class="headerlink" title="概括安装步骤"></a>概括安装步骤</h1><p>这里准备使用 KDE 桌面，使用 NetworkManager 提供网络服务。</p><p>ArchLinux 的<strong>安装</strong>步骤主要有以下内容——</p><ol><li>验证启动模式（是 BIOS 还是 UEFI）</li><li>配置和检查网络连接</li><li>使用 fdisk 建立磁盘分区，对于 MBR 分区表的磁盘，必须建立根分区和交换分区，对于 GPT 分区表磁盘，如果使用 UEFI，则还需建立 EFI 系统分区（如果使用 BIOS，则会按照兼容 MBR 的方式进行加载，不需要 EFI 系统分区，但是需要一个至少 1M 的 BIOS boot 分区，这里可以直接放到 34-2047 扇区里）</li><li>格式化各分区，交换分区使用<code>mkswap</code>命令，根分区使用<code>mkfs.ext4</code>命令，EFI 系统分区使用<code>mkfs.fat -F32</code>命令。</li><li>挂载分区</li><li>编辑镜像源（可选），在 mnt 下安装必须的软件包 base，linux，linux-firmware，networkmanager，sudo，vim 等</li><li>生成 fstab 文件（该文件应该标识了各分区的 mount 情况以便开机时自动 mount）</li><li>chroot 到新安装的系统，配置时区，设置 hostname，root 的密码等，启动 networkmanager 服务……</li><li><strong>安装引导程序</strong>（！），启动微码更新，重启</li></ol><p>然后是配置网络以及图形界面——</p><ol><li>创建新的用户供日常使用，添加到 sudo</li><li>配置网络</li><li>安装 KDE 图形界面，配置 startx（不使用登陆管理器之类的，每次手动 startx 来登录图形界面）</li><li>安装显卡驱动</li></ol><h1 id="安装-ArchLinux"><a href="#安装-ArchLinux" class="headerlink" title="安装 ArchLinux"></a>安装 ArchLinux</h1><p>虚拟机设定使用 EFI 模式。下面的操作不完全按照上面的顺序。</p><h2 id="验证启动模式"><a href="#验证启动模式" class="headerlink" title="验证启动模式"></a>验证启动模式</h2><p>首先要验证启动模式是 BIOS 还是 UEFI。检查<code>/sys/firmware</code>目录，如果该目录下存在 efi 文件夹，则为 UEFI，否则为 BIOS。</p><h2 id="配置网络连接"><a href="#配置网络连接" class="headerlink" title="配置网络连接"></a>配置网络连接</h2><p>首先使用<code>ping baidu.com</code>检查是否能 ping 通（在虚拟机下这玩意是开箱即用的），如果不能 ping 通，则需手动配置网络。有线……谁知道呢，直接使用<code>dhcpcd</code>命令试试？（这之前或许要把网卡打开之类的），对于无线，应当通过<code>iwctl</code>来连接。</p><h2 id="建立磁盘分区"><a href="#建立磁盘分区" class="headerlink" title="建立磁盘分区"></a>建立磁盘分区</h2><p>使用<code>fdisk</code>命令来建立磁盘分区。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ fdisk /dev/sda<br></code></pre></div></td></tr></table></figure><p>首先输入 g，创建 GPT 分区表，然后使用 n 分别创建三个分区——UEFI System 分区（1G 大小），交换分区和根分区。并使用 t 更改这三个分区的 type。分区结果如图——</p><p><img src="https://i.loli.net/2021/01/06/FINUuBoKXZymb7E.png"></p><p>记得使用 w 保存。</p><blockquote><p>在输入 last sector 的时候，使用+xG 这样的形式能够非常容易地规划分区的大小。</p></blockquote><h2 id="格式化各分区并挂载"><a href="#格式化各分区并挂载" class="headerlink" title="格式化各分区并挂载"></a>格式化各分区并挂载</h2><p>UEFI System 分区是 FAT32 格式，交换分区是交换分区格式，根分区这里使用 xfs 格式。使用如下命令对这些分区进行格式化。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mkfs.fat -F32 /dev/sda1 <span class="hljs-comment"># EFI 系统分区</span><br>mkswap /dev/sda2 <span class="hljs-comment"># 交换分区</span><br>swapon /dev/sda2<br>mkfs.xfs /dev/sda3 <span class="hljs-comment"># 根分区</span><br></code></pre></div></td></tr></table></figure><p>然后使用如下命令进行挂载。要注意的是，应先挂载根分区，再挂载 efi 分区。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mount /dev/sda3 /mnt      <span class="hljs-comment"># 挂载根分区</span><br><span class="hljs-built_in">mkdir</span> /mnt/boot<br>mount /dev/sda1 /mnt/boot <span class="hljs-comment"># 挂载 efi 分区</span><br></code></pre></div></td></tr></table></figure><h2 id="配置源，安装系统"><a href="#配置源，安装系统" class="headerlink" title="配置源，安装系统"></a>配置源，安装系统</h2><p>应编辑&#x2F;etc&#x2F;pacman.conf，取消注释 multilib 源，并添加 archlinuxcn 源。</p><p>使用 pacstrap 安装必须的软件包。这里连带着把 KDE 图形界面的东西也安装了。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">pacstrap /mnt base linux linux-firmware networkmanager vim sudo xorg xorg-xinit plasma kde-applications xdg-user-dirs grub efibootmgr fcitx<br><span class="hljs-comment"># 这里还应当安装中文输入法，中文字体等</span><br></code></pre></div></td></tr></table></figure><blockquote><p>linux-firmware 是固件相关的软件包，里面有很多必须的驱动。</p></blockquote><p>然后生成 fstab 并 chroot 到新系统中。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br><span class="hljs-comment"># 这个工具……</span><br>arch-chroot /mnt<br></code></pre></div></td></tr></table></figure><h2 id="对系统进行配置"><a href="#对系统进行配置" class="headerlink" title="对系统进行配置"></a>对系统进行配置</h2><p>配置主要有设置时区，修改 hostname，设置 root 账号的 password，创建新用户等。</p><p>设置时区——</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>hwclock --systohc<br></code></pre></div></td></tr></table></figure><p>编辑&#x2F;etc&#x2F;hostname 和&#x2F;etc&#x2F;hosts 文件——</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># /etc/hostname</span><br>myhostname<br><br><span class="hljs-comment"># /etc/hosts</span><br>127.0.0.1localhost<br>::1localhost<br>127.0.1.1myhostname.localdomainmyhostname<br></code></pre></div></td></tr></table></figure><p>**编辑&#x2F;etc&#x2F;locale.gen 文件，取消注释 en_US.UTF-8 和 zh_CN. *行。然后调用 locale-gen 程序**。</p><p><strong>使用 passwd 命令修改 root 的密码</strong>。</p><h3 id="设置-startx"><a href="#设置-startx" class="headerlink" title="设置 startx"></a>设置 startx</h3><p>我决定不使用显示管理器，而是在 tty 中直接使用 startx 登录图形界面。</p><p>设置 startx 应当编辑&#x2F;etc&#x2F;X11&#x2F;xinit&#x2F;xinitrc（当然，如果~&#x2F;.xinitrc 存在，会优先执行它）。这里对它进行备份，然后使它中只有一行内容<code>exec startplasma-x11</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> /etc/X11/xinit/xinitrc /etc/X11/xinit/xinitrc.bak<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;exec startplasma-x11&#x27;</span> &gt; /etc/X11/xinit/xinitrc<br></code></pre></div></td></tr></table></figure><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">useradd -m <span class="hljs-string">&#x27;aoymykn&#x27;</span> <span class="hljs-comment"># -m 意思是创建用户主目录</span><br>passwd aoymykn <span class="hljs-comment"># 修改密码</span><br></code></pre></div></td></tr></table></figure><p>使用<code>visudo</code>命令编辑 sudoers，将该用户添加到 sudo 中。这里需要取消注释<code>Default targetpw</code>和<code>ALL ALL=(ALL) ALL</code>两行。</p><h2 id="安装系统引导"><a href="#安装系统引导" class="headerlink" title="安装系统引导"></a>安装系统引导</h2><p>使用该命令安装系统引导——</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB<br><br>grub-mkconfig -o /boot/grub/grub.cfg  <span class="hljs-comment"># 自动生成配置文件</span><br></code></pre></div></td></tr></table></figure><p>重启！</p><h3 id="BIOS-x2F-UEFI，MBR-x2F-GPT-以及-GRUB-的关系"><a href="#BIOS-x2F-UEFI，MBR-x2F-GPT-以及-GRUB-的关系" class="headerlink" title="BIOS&#x2F;UEFI，MBR&#x2F;GPT 以及 GRUB 的关系"></a>BIOS&#x2F;UEFI，MBR&#x2F;GPT 以及 GRUB 的关系</h3><p>TODO: 摸了</p><h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><p>TODO: 摸了</p><blockquote><p>写这篇文章前前后后安装了 3 次，都快能默写了 www</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开始学习设计模式——迭代器模式和适配器模式</title>
    <link href="/2021/01-01%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <url>/2021/01-01%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>开始看结城浩的《图解设计模式》～（对日本人写的书总有种莫名其妙的亲近感，或许是因为他们的语言比较……轻松？）</p><blockquote><p>这个老师似乎也写过 Java 多线程相关的书籍，先观望一个。</p></blockquote><p>什么是设计模式（Design Pattern）？我认为，我们在不断地编写代码的过程中，在不断地 debug，重构，思考中，经常会发现一些“套路”，发现这样那样编写能让代码容易维护，容易复用，写起来优雅 etc… 对这些“套路”进行系统的分析，归纳出来概念，形式，确定它的适用范围……这样所诞生的就是设计模式，它归根结底是从丰富的实践经验中抽象出来的，又反作用于我们的实践，帮助我们编写更加有可复用性，可维护性，高内聚低耦合的代码。<strong>就这方面</strong>（！类比只是类比，而不是论证，只负责提供一种感性经验罢了）来说，设计模式与具体的编程的关系，就如哲学同具体科学的关系一样。</p><blockquote><p>设计模式用来表现内部组件如何被<strong>组装</strong>在一起。一场话剧能由无数届演员来演，可是剧情（剧中人与人的<strong>关系</strong>）总是变动较少的。</p></blockquote><blockquote><p>其实我觉得粗糙地说，<code>for (int i = 0; i &lt; arr.length; i++)</code>这样的也算是设计模式 w</p></blockquote><blockquote><p>面向对象是一种设计模式，面向过程也是一种设计模式，Lisp 语言的宏编程也是一种设计模式，这是毫无疑问的。</p></blockquote><p>设计模式的目标有二——<strong>复用</strong>和易维护。应时时刻刻记住这两点。</p><p>不过也正如学习哲学一样，如果没有积累丰富的感性经验（无论是对日常生活的，还是对科学的），上来就整抽象的东西容易钻到牛角尖里，无法联系实际看问题。希望这本书能够提供足够的实例让我积累感性经验。</p><p>一个非常非常非常非常需要注意的地方是，此书基于 Java 2，所以<strong>没有泛型</strong>（因为这点，或许书中很多代码需要重构），没有函数式特性，没有 foreach 的语法糖……随便翻了几页，还觉得它有时候讲的不全面……应当批判地学习，同时应当多联系 Java 的源码。</p><p>先开个头，学一学它讲解的最早的两个设计模式——Iterator 迭代器模式和 Adapter 适配器模式。</p><h1 id="Iterator-模式——迭代器"><a href="#Iterator-模式——迭代器" class="headerlink" title="Iterator 模式——迭代器"></a>Iterator 模式——迭代器</h1><p>Iterator 模式归根结底是为（以各种方式）遍历各种不同的数据结构提供一套相同的接口，它满足这样的形式——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Iterator</span> <span class="hljs-variable">iter</span> <span class="hljs-operator">=</span> colle.iterator(); <span class="hljs-comment">// 这其实……也算是一个工厂模式？</span><br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123; <span class="hljs-comment">// 当然我们也都知道，现在 Java 提供了一套 foreach 的语法糖来自动使用迭代器</span><br>    <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> iter.next();<br>    . . .<br>&#125;<br><span class="hljs-comment">// Java 为实现了 java.lang.iterable 的实现提供了这样的语法糖……</span><br><span class="hljs-keyword">for</span> (item i : aggregate) &#123;<br>    . . .<br>&#125;<br></code></pre></div></td></tr></table></figure><p>迭代器的优点在于，它抽象了对对象的遍历操作，让对各种不同集合（容器）对象的遍历的操作都变得统一。如果没有这种设计模式的话，该怎么办呢？那对每种数据结构，都需要<strong>根据它的具体实现</strong>（！）来确定对它的遍历方式，比如对于数组，我们就用<code>for (int i = 0; i &lt; arr.length; i++)</code>，对于链表，我们就<code>for (Node i = head; i != null; i = i.next)</code>，那对于树，对于堆，对于图呢？对于哈希表的拉链实现和数组——红黑树实现呢？对这样的形式该如何实现？显然，必须要根据其内部数据结构（和需要迭代的方式）来决定实现。迭代器其实也可以说是对这里的循环变量 i 抽象化了。</p><p>因此就可以使用迭代器模式。根据书中的一个例子来说——</p><p><img src="https://i.loli.net/2020/12/29/xblpFUkzGRIE8Hn.png"></p><p>在这里，Aggregate 表示一种集合（容器）类型接口，它只提供 iterator 接口。Iterator 接口就是迭代器接口，hasNext 判断是否还能继续迭代，next 方法则是获取一个元素，并让迭代器指针后移指向下一个元素。BookShelf 是为了实验而创建的数据结构，它实现 Aggregate 接口，内部存储 Book 对象（以数组形式），last 表示下一个要插入的元素的位置（同时也是已插入的元素的数量）。它的 iterator 方法返回一个对它自身的迭代器。需要注意的是，<strong>是迭代器包含类，而不是类包含迭代器</strong>，因为一个类可以同时存在多个迭代器进行迭代。</p><p>上源码。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Aggregate.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> MyIterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//MyIterator.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyIterator</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    T <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//Book.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//BookShelf.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookShelf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&lt;Book&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> Book[] books;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getBookAt</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">return</span> books[i];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendBook</span><span class="hljs-params">(Book book)</span> &#123;<br>        books[last++] = book;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookShelf</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>        books  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>[size];<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> MyIterator&lt;Book&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookIterator</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后是最重要的迭代器代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//BookIterator.java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BookIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyIterator</span>&lt;Book&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br>    <span class="hljs-keyword">private</span> BookShelf bookshelf;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookIterator</span><span class="hljs-params">(BookShelf obj)</span> &#123;<br>        bookshelf = obj;<br>        index = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> index &lt; bookshelf.getLength();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> bookshelf.getBookAt(index++);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>它的使用如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BookShelf</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookShelf</span>(<span class="hljs-number">10</span>);<br>        books.appendBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;双城记&quot;</span>));<br>        books.appendBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;毁灭&quot;</span>));<br>        books.appendBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;罗密欧与朱丽叶&quot;</span>));<br>        MyIterator&lt;Book&gt; iter = books.iterator();<br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            System.out.println(iter.next().getName());<br>        &#125;<br>        <span class="hljs-comment">//也可以使用 for 循环来使用迭代器</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>一个原则是，对于声明类型，能用基类就用基类，能用接口就用接口。</p></blockquote><p>同时，迭代器也允许使用不同的迭代方式，只需要更改 next 和 hasNext 方法即可，比如跳跃着遍历，反向遍历……还能在迭代器内部暂存信息并不暴露给外界，比如遍历树的时候在迭代器里放个栈，队列之类的。这显然是符合抽象的。</p><p>问题：Java 中 iterable 是什么？它和迭代器有什么关系？</p><h1 id="Adapter-模式——适配器"><a href="#Adapter-模式——适配器" class="headerlink" title="Adapter 模式——适配器"></a>Adapter 模式——适配器</h1><p>所谓适配器模式，就是将别人的不能直接复用的代码拿来进行一些包装，让它能够被复用。这里帮助别人的代码适配我们的需要的设计模式就叫适配器（Adapter），也叫包装器（Wrapper），因为它不直接使用别人的代码，而是进行一些包装后使用。就像笔记本的适配器把 220 伏的交流电转成 12 伏的直流电一样。Adapter 的意思是“使……相互适合的东西”。</p><p>适配器模式中需要四个角色——Client，Target，Adapter，Adaptee，它们的关系是——Client（笔记本电脑）使用 Adapter（电源适配器），将 Adaptee（220 伏交流电）转换成它所需要的 Target（12 伏直流电）。其中 Client 是调用适配器的对象，Adapter 是适配器，Adaptee 是别人的需要进行包装的代码（因此不应直接修改），Target 是 Client 所需的方法。</p><p>适配器模式有两种实现——</p><ul><li>类适配器模式（使用<strong>继承</strong>的适配器）</li><li>对象适配器模式（使用<strong>委托</strong>的适配器）</li></ul><blockquote><p>此书给出的类适配器模式我觉得有一些漏洞，出现了抽象泄露的问题（虽然作者不可能没有意识到这个问题，因为习题 1 就涉及到了这个问题）。我认为，在设计自己的类库（就比如这里实现的适配器，对别人的类库进行包装，其实可以认为这里的 Target，Adapter，Adaptee 是自己设计出来的类库（其中 Adaptee 是“别人的代码”，在设计适配器的时候不应该对 Adaptee 进行任何改动），Client 是使用该类库的客户端）的时候，应该认为用户是“愚蠢”的，否则面向对象的<strong>封装</strong>原则就被破坏了。</p></blockquote><p><img src="https://i.loli.net/2020/12/31/SWk6B9IcCF4qKmN.png"></p><p>这张图非常好地表现了适配器的功能和（对象适配器模式的）形式。</p><h2 id="类适配器实例"><a href="#类适配器实例" class="headerlink" title="类适配器实例"></a>类适配器实例</h2><p>所谓类适配器模式，就是编写 Adapter 继承 Adaptee，实现所需要的接口（Target）。</p><p>本书提供了这样一个实例——</p><p><img src="https://i.loli.net/2020/12/31/rMxnDy5g4PuCfYe.png"></p><p>首先有一个 Banner 类，这里假设是别人已经编写好的，要复用它。它提供了两个功能——将字符串用括号包围或用*包围，它的实现是非常简单的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Banner.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Banner</span> &#123;<br>    <span class="hljs-keyword">private</span> String str;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Banner</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-built_in">this</span>.str = str;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showWithParen</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;(%s)&quot;</span>, str));<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showWithAster</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;*%s*&quot;</span>, str));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们的需求（也就是 Target）是 Print 接口，Print 接口假设有两个语法，使用成对括号包围字符串规定字符串变细，使用**包围则是规定字符串加粗。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Print.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Print</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span>; <span class="hljs-comment">// abstract 对于接口其实是无必要的，毕竟只有 default 方法能够添加实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>PrintBanner 担任 Adapter 的角色，它要提供 Target（因此就要实现 Print 接口），同时继承 Adaptee 以复用其代码。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//PrintBanner.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintBanner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Banner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Print</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintBanner</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-built_in">super</span>(str);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.showWithParen();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.showWithAster();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后是 Main，Main 担任 Client 的角色，它使用 Adapter 提供的 Print 接口。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Print</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintBanner</span>(<span class="hljs-string">&quot;hello, happy world&quot;</span>); <span class="hljs-comment">// 我觉得有点问题。</span><br>        p.printStrong();<br>        p.printWeak();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可见，Adaptee 的操作被包装（wrap）起来了，用户（Client）通过使用 Adapter 提供的接口（Target）来间接访问 Adaptee。</p><p>但我认为这里的抽象有一些问题——<strong>如何保证用户必然使用 Print 接口来作为声明类型</strong>？如果用户偏偏不按需求来，使用 PrintBanner 作为声明类型，进行这样的操作怎么办？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">PrintBanner</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintBanner</span>(<span class="hljs-string">&quot;hello,happy world&quot;</span>);<br>p.showWithAster(); <span class="hljs-comment">// 合法！</span><br>p.showWithParen();<br></code></pre></div></td></tr></table></figure><p>这在语法上并无问题，但是这显然<strong>破坏了封装</strong>！用户不应该能通过任何途径来<strong>直接</strong>访问到 Adaptee。在这个示例中不会出问题，但若是联想上面的笔记本电源适配器的例子，就相当与是说用户可以直接把 220V 的交流电连接在笔记本电脑（而不是转换成 12V 直流电之后）上了，这不就出了事？我想也没有语法能够屏蔽父类的方法，只能重写或将父类方法改成 protected，但这也是不好的，我们很多时候不能更改别人的代码。</p><p>因此我认为类适配器有这样的缺陷——类库设计者必须与使用者做<strong>约定</strong>，要求使用者必须使用 Target 作为声明类型，才能正常使用。而且如果想要复用的是 final 类，则是不能使用的。</p><h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><p>对象适配器容易描述。它是指 Adapter 包含一个 Adaptee 实例，通过<strong>委托</strong>（也就是将方法的执行交给另一个类（实例）执行）的方式让 Client 访问 Adaptee。</p><p>该方法相对于类适配器只需要更改 PrintBanner 类。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//PrintBanner.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintBanner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Print</span>&#123;<br>    <span class="hljs-keyword">private</span> Banner banner;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintBanner</span><span class="hljs-params">(String str)</span> &#123;<br>        banner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Banner</span>(str);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span> &#123;<br>        banner.showWithParen();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span> &#123;<br>        banner.showWithAster();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样的一个好处是，不再需要和 Client 做额外约定了，无论 Client 使用 Print 还是 PrintBanner 作为声明类型，都不会出问题。</p><blockquote><p>这一段是自己的想法，可能有错误。<br>我认为对象适配器模式中适配器的角色<strong>更加符合其概念</strong>。一般来说，<strong>Adapter 提供的功能应当是 Adaptee 的子集</strong>，也就是说，Adapter 能实现的方法，Adaptee 应当能实现，Adapter 不能实现的方法，Adaptee 也可能可以实现。比如，有一个库，能够把各种图片格式相互转换，比如 png, jpg, tiff, psd, pdf 等，但这时我只需要将 png 转换成其它格式，我就据此编写一个适配器，使用 Adaptee 功能的子集。而且使用委托的对象适配器模式，其结构也更加符合之前对适配器的感性理解。<br>然后考虑类适配器，类适配器使用继承来复用代码。而继承，虽然就概念来说，子类是基类的属概念，但是就功能，具体程度来说，子类是比基类更加具体的，在基类的基础上<strong>提供更多功能</strong>。因此这就和上面我所认为的 Adapter 同 Adaptee 提供的功能的关系相悖了。就上面的电源适配器的例子来说，就像是给 220V 交流电的电源<strong>加了个组件</strong>，让它能够转换成 12V 直流电，<strong>这个电源原本输出 220V 交流电的能力是没有改变的</strong>。这时就必须和用户做约定（Target），要求用户使用该 12V 的直流电。但是用户也有权力不遵守约定……</p></blockquote><p>对象适配器的 UML 类图如图。</p><p><img src="https://i.loli.net/2020/12/31/OdVDhZRkug7ybLr.png"></p><blockquote><p>学会看 UML 图还是比较方便的。</p></blockquote><p>使用适配器模式的目的是对现有的类进行适配，让其可复用，在出现 bug 的时候，也能够容易确定 bug 的位置出于 Adapter 中（假如 Adaptee 经过充分测试的话）。如果要去修改已经充分测试的类，则必须重新进行测试。</p><p>适配器模式也能够方便地让版本适配，从而让新旧版本兼容，让能够同时维护新版本和旧版本变得简单。</p><p><img src="https://i.loli.net/2020/12/31/eulizV3af98Sr5T.png"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>java.util.Properties 可以像这样管理键值对——</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">year</span><span class="hljs-operator">=</span><span class="hljs-number">2021</span><br><span class="hljs-attribute">month</span><span class="hljs-operator">=</span><span class="hljs-number">4</span><br><span class="hljs-attribute">day</span><span class="hljs-operator">=</span><span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>它提供了两个方法，帮助从<strong>流</strong>（<strong>这个需要去学习！</strong>）中取出属性（property）或将属性写入流中。要求使用 Adapter 适配器模式，编写一个将属性保存在文件中的 FileProperties 类。</p><p>扮演 Target 角色的 FileIO 接口如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//FileIO.java</span><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileIO</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFromFIle</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToFile</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(String key, String value)</span>; <span class="hljs-comment">// 设置键值对</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getValue</span><span class="hljs-params">(String key)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>扮演 Adapter 角色的 FileProperties 类如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//FileProperties.java</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileProperties</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileIO</span> &#123;<br>    <span class="hljs-keyword">private</span> Properties p;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileProperties</span><span class="hljs-params">()</span> &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFromFIle</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filename))) &#123;<br>            p.load(file);<br>        &#125;<br>    &#125; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToFile</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filename))) &#123;<br>            p.store(file,<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        p.setProperty(key, value);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getValue</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> p.getProperty(key);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Client 角色如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FileIO</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileProperties</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            f.readFromFIle(<span class="hljs-string">&quot;file.txt&quot;</span>);<br>            f.setValue(<span class="hljs-string">&quot;year&quot;</span>, <span class="hljs-string">&quot;21435&quot;</span>);<br>            f.setValue(<span class="hljs-string">&quot;month&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);<br>            f.setValue(<span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-string">&quot;2222&quot;</span>);<br>            f.writeToFile(<span class="hljs-string">&quot;newFile.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这本书将设计模式中各个组成部分称为“角色”相当精妙，而且有趣。感觉遇到了一个好的开始。</p><p>等回家后第一时间去学 Spring……其它的都缓缓。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Thread 的一些代码</title>
    <link href="/2020/12-26%E5%85%B3%E4%BA%8EThread%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.html"/>
    <url>/2020/12-26%E5%85%B3%E4%BA%8EThread%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>哈哈哈哈哈哈哈！</p></blockquote><!--Hello, Happy World--><p>这一篇文章参考《Java 并发编程之美》的第一章，实现一下里面的一些示例。</p><h1 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h1><p>让一个类可以作为线程运行有三种方式——继承<code>Thread</code>类并重写<code>run</code>方法，实现<code>Runnable</code>接口并实现<code>run</code>方法，使用<code>FutureTask</code>方式。其中第二个方式需要通过<code>Thread</code>类的接受<code>Runnable</code>对象的构造器进行，它也可以使用 lambda 表达式或匿名实现类来进行，因为<code>Runnable</code>是一个函数式接口。</p><p>继承方法代码如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadFromExtends</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;Hello, Happy World!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFromExtends</span>(); <span class="hljs-comment">// 直接调用构造函数即可生成这样的一个线程的实例</span><br>        instance.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过实现<code>Runnable</code>接口的方法如下——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadFromImplements</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I was happy&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFromImplements</span>()); <span class="hljs-comment">// Thread 类接受一个 Runnable 函数式接口实例</span><br>        instance.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>还可以使用匿名实现类和 lambda 表达式——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;通过 Runnable 接口的匿名实现类来实现创建 Thread&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;有 lambda 表达式，方便很多！&quot;</span>);<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">threadC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Main::method);<br>    &#125;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;也可以用方法作为参数，这和 lambda 是一致的&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>FutureTask 方式等将来遇到再说。</p><h1 id="synchronized，wait，notify"><a href="#synchronized，wait，notify" class="headerlink" title="synchronized，wait，notify"></a>synchronized，wait，notify</h1><p>Java 中任何对象都有<strong>监视器锁</strong>（这是<code>Object</code>类所持有的，而任何对象都是<code>Object</code>对象）。其提供了<code>wait</code>，<code>notify</code>，<code>notifyAll</code>等方法用来进行某种线程间的通知和等待。这些方法都应当在同步代码块中进行，否则会抛出<code>IllegalMonitorStateException</code>异常。</p><p>当线程进入某个对象的同步代码块（使用<code>synchronized</code>关键字定义的代码块或方法），它就持有该对象的监视器锁。此时，任何其它线程都将被阻塞到这个对象的同步代码块之外，除非它们获得锁。</p><p>如果线程调用<code>wait</code>方法，它将<strong>被阻塞挂起，并释放锁</strong>。该线程遇到两个情况会恢复到 runnable 状态——其它线程调用<code>notify</code>或<code>notifyAll</code>方法将其唤醒，或该线程被 interrupted（也就是该线程的<code>interrupt</code>方法被调用）。</p><p>线程从挂起到可以运行可能在没有被 notify，没有被 interrupt，没有超时的时候也能发生，这称作<strong>虚假唤醒</strong>，为防虚假唤醒，应当用 while 包裹 wait 方法（当然，虚假唤醒仅仅是其中一个因素，如果该线程被唤醒后发现其执行的条件不满足，其应当必须再次放弃锁并挂起阻塞）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 防止虚假唤醒</span><br><span class="hljs-keyword">synchronized</span> (obj) &#123;<br>    <span class="hljs-keyword">while</span> （条件不满足）<br>        obj.wait();<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面给出一个简单的生产者消费者的例子，使用监视器锁来协调消费者线程和生产者线程的同步。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> Queue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 我居然试图给它加上 volatile，我在干什么？既然 final 是不可修改的，它就无所谓可见性了——不会被改变的东西，就无所谓对它的修改能不能让所有线程都及时看到</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 用来填充 queue</span><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 生产函数</span><br>        <span class="hljs-keyword">synchronized</span> (queue) &#123; <span class="hljs-comment">// 在生产时，不允许消费</span><br>            <span class="hljs-keyword">while</span> (queue.size() == MAX_SIZE) <br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait(); <span class="hljs-comment">// while 不能加到 try 里，因为还要再执行呢，即使被中断了，循环还是要继续做的</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            queue.add(ele);<br>            System.out.println(<span class="hljs-string">&quot;生产 1&quot;</span>);<br>            queue.notifyAll(); <span class="hljs-comment">// 这里只有两个线程，所以用 notify 和 notifyAll 是没有区别的。</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 消费函数</span><br>        <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">0</span>) <br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            queue.remove();<br>            System.out.println(<span class="hljs-string">&quot;消费 1&quot;</span>);<br>            queue.notifyAll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) produce();&#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) consume();&#125;);<br>        producer.start();<br>        consumer.start();<br>        Thread.sleep(<span class="hljs-number">5</span>);<br>        System.exit(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p>调用 wait 时，线程会释放锁并阻塞，因为 wait 方法而阻塞的线程可以是多个的。如果有线程调用 notify，则其中一个线程会被唤醒，如果调用 notifyAll，则所有阻塞在 wait 方法的线程都会被唤醒。</p><p>调用 wait 方法时，<strong>只有该锁会被释放</strong>，该线程持有的其它锁是不会被释放的，下面用代码展示，线程 A 持有资源 1 后持有资源 2 并阻塞，线程 B 延迟执行并试图持有资源 2 然后持有资源 1——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程 A 持有资源 1&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;线程 A 试图持有资源 2&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程 A 持有资源 2&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;线程 A 释放资源 2 并阻塞&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    resource2.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程 A 释放资源 1&quot;</span>);<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程 B 试图获取资源 2&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程 B 获取资源 2\n 线程 B 试图获取资源 1&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span>(resource1) &#123;&#125;<br>        &#125;<br>    &#125;);<br>    threadA.start();<br>    threadB.start();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出为——</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">线程 A 持有资源 1</span><br><span class="hljs-comment">线程 A 试图持有资源 2</span><br><span class="hljs-comment">线程 A 持有资源 2</span><br><span class="hljs-comment">线程 A 释放资源 2 并阻塞</span><br><span class="hljs-comment">线程 B 试图获取资源 2</span><br><span class="hljs-comment">线程 B 获取资源 2</span><br><span class="hljs-comment">线程 B 试图获取资源 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>可以看到，线程 A 被阻塞后只释放了资源 2 的锁，仍持有资源 1 的锁。</p><h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1><p>yield 是一个静态方法，它表示当前线程让出剩余的时间片，立即进行线程调度。yield 并不常用。线程调度器可以无条件忽略该请求。（如果被忽略，这剩余的时间里它都要阻塞吗？）</p><p>给两个例子——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">yieldTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">ME</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(ME+<span class="hljs-string">&quot; yield&quot;</span>);<br>                Thread.<span class="hljs-keyword">yield</span>();<br>            &#125;<br>        &#125;<br>        System.out.println(ME+<span class="hljs-string">&quot; Over&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Main::yieldTest).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果似乎同书中所讲的不一样……搁置。</p><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>当线程阻塞在<code>wait</code>，<code>sleep</code>，<code>join</code>的时候如果被其它线程中断，将会抛出<code>InterruptedException</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;a 启动并阻塞&quot;</span>);<br>            Main.class.wait(); <span class="hljs-comment">// 对于静态方法，应当这样使用，对于实例方法，应该 this.wait();</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;被中断啦&quot;</span>);<br>            <span class="hljs-keyword">return</span>; <br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;这一段不可能被执行，除非虚假唤醒了&quot;</span>);<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Main::interruptTest);<br>        a.start();<br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        a.interrupt();<br>        a.join(); <span class="hljs-comment">// join 方法等待线程结束</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p>与查看和设置对象的中断标志位相关的方法有三个——<code>interrupt</code>， <code>isInterrupted</code>， <code>interrupted</code>。其中 interrupted 是 static 方法，它处理调用该方法的线程（这就是为什么它采取过去式的形式）。</p><p><code>interrupt</code>方法中断线程，它实质是设置线程的中断标志位为 true，并非是直接“终结”线程。如果该线程被中断时阻塞在 wait，sleep 或 join 方法中，它会在这些地方抛出 InterruptedException。</p><p><code>isInterrupted</code>方法检查线程是否被中断。</p><p><code>interrupted</code>检查<strong>当前</strong>线程是否中断。如果中断，则返回 true，并清除<strong>中断标志位</strong>。如果未被中断，则返回 false。总之无论如何，调用该方法后中断标志位会被重置为 false。调用它应该使用 Thread.interrupted() 的形式。</p><p>一个不断检查中断并在被中断时优雅退出的例子是——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; workNotOver()) &#123;<br>            <span class="hljs-comment">// 干活！</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; <span class="hljs-comment">// 如果中途被中断</span><br>        <span class="hljs-comment">// 在 sleep，wait 或 join 的时候被中断了，进行一些操作</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 必要的清理</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>当所有线程都因为无法获得所需资源被阻塞，这种情况就称为<strong>死锁</strong>。一个典型的例子是，线程 A 独占资源 1, 线程 B 独占资源 2, 此时线程 A 请求资源 2 才能继续进行，线程 B 请求资源 1 才能继续进行，A 和 B 因此就都无法进行了。</p><blockquote><p>HR：只要你能给我解释死锁，我就给你 Offer。<br>我：只要你给我 Offer，我就给你解释死锁。</p></blockquote><p>死锁有四个条件，任意条件不满足，死锁就不会发生——</p><ul><li><strong>互斥条件</strong>：线程对资源的访问是排他性的，即该资源只容许被一个线程占用，如果有其它线程尝试获取，则只能等待该线程释放资源。</li><li><strong>请求并持有</strong>（不如说持有并请求）：一个线程已经持有至少一个资源，但又要请求其他资源，而该其它资源被其它线程占用。</li><li><strong>不可剥夺</strong>：线程占有的资源只能由自己释放，其它线程无法干涉。</li><li><strong>环路等待</strong>：发生死锁时必然存在线程——资源的环形链。定义这样的线程集合{T0,T1,T2,..,Tn}，其中 T0 请求 T1 占有的资源，T1 请求 T2 占有的资源……Tn 请求 T0 占有的资源。</li></ul><p>考虑之前提的死锁的例子——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程 A</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(<span class="hljs-string">&quot;A 获取资源 1&quot;</span>);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<span class="hljs-comment">// 确保 B 已经获取资源 2</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <br><br>                System.out.println(<span class="hljs-string">&quot;A 尝试获取资源 2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;A 获取资源 2（不可能发生！）&quot;</span>); <br>                &#125;<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-comment">//线程 B</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                System.out.println(<span class="hljs-string">&quot;B 获取资源 2&quot;</span>);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<span class="hljs-comment">// 确保 A 已经获取资源 1</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <br><br>                System.out.println(<span class="hljs-string">&quot;B 尝试获取资源 1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;B 获取资源 1（不可能发生！）&quot;</span>); <br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>synchronized 满足互斥条件和不可剥夺条件——任意资源只能同时被一个线程占有，锁只能被持有线程释放。</p><p>请求并持有条件也是满足的，A 在持有 1 的情况下请求 2,B 在持有 2 的情况下请求 1。这里也是满足环路等待的。</p><p>避免死锁通过让死锁的必要条件不满足来实现，但是我们只能破坏环路等待和请求并持有条件。在这里，只需要让 A 和 B 申请资源的顺序一致即可，也就是确定<strong>资源申请的有序性</strong>。</p><h1 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h1><p>Java 中线程分为两类，守护线程（daemon 线程，这个词在 linux 里也有用到，所谓的 systemd，这里的 d 就是 daemon）和是用户线程（user 线程）。JVM 中很多线程，如垃圾回收线程，是 daemon 进程。一个典型的用户线程是 main 方法的线程。</p><p>JVM 只有在所有用户线程都结束的时候才会退出。见该实例——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br>    &#125;).start();<br>    System.out.println(<span class="hljs-string">&quot;主线程完了&quot;</span>);<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">这时候调用 jps，发现该 JVM 进程还没有退出。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">aoymykn@aoymykn-PC:~/public/blog$ jps</span><br><span class="hljs-comment">21332 Main </span><br><span class="hljs-comment">21383 Jps</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>可以通过<code>setDaemon</code>方法设置该线程为 daemon 线程。该方法不能在线程执行的时候调用，否则会抛<code>IllegalThreadStateException</code>。</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal 类能够让每个线程对变量进行访问的时候，访问的是自己线程的变量（也就是说相当于把状态变量变成局部变量，给了它封闭性了）。</p><p>ThreadLocal 变量的行为是，<strong>让访问这个变量的每个线程都有该变量的一个本地副本，当线程对该变量进行操作的时候，实际上是操作自己本地内存（栈）里面的变量</strong>。（这样是不是就能避免本地缓存和主内存不一致的问题，从而保证可见性？它可以替代 volatile 吗？）</p><blockquote><p>剩下的，之后再说。</p><p>并发真是个麻烦的东西……再次认识到，现在的编程语言对并发的抽象是差劲的，完全不能从编程语言本身来判断结果……必须要付诸到机器底层……好家伙，这更暴露出来了我的基本功不足。需要加强了！</p></blockquote><hr><p>思来想去，决定现在先搁置并发，对我来说，这样一个全新（而且庞大，晦涩）的领域如果一头扎进去，我基本上在毕业之前就找不到工作了。</p><p>当前需要专注的东西实在是非常明显的——<strong>Java EE，框架，设计模式，计网以及数据结构和算法</strong>！别再雨露均沾了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公钥算法和私钥算法</title>
    <link href="/2020/12-24%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%E7%AE%97%E6%B3%95.html"/>
    <url>/2020/12-24%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%E7%AE%97%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><h1 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h1><p><strong>对称加密算法</strong>，其解密密钥和加密密钥是<strong>相同的</strong>，正因为解密密钥和加密密钥相同，所以该密钥不能公开。所以对称加密算法又称<strong>私钥算法</strong>。常用的对称加密算法有** DES 加密算法<strong>和</strong> AES 加密算法**。</p><p><strong>非对称加密算法</strong>，其加密和解密的密钥是<strong>不一样</strong>的，<strong>其中公开的叫公钥，私有的叫私钥。公钥和私钥是成对的；公钥加密的数据，有且只有对亚它的私钥能解密；私钥加密的数据，有且只有对应它的公钥能解密</strong>（所以其实公钥和私钥的概念同加密密钥和解密密钥的概念并非是同一的）。</p><p><strong>SSH 是非对称加密的</strong>。它默认使用 RSA 加密。</p><p>这里随机生成了一对 RSA 密钥，私钥如下——</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">-----BEGIN PRIVATE KEY-----<br>MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQD3lkA6dVbIIcE5<br>X12EjbsInujgYzU84Qo29LcFtn1zyODplCB6r4yKp8r5yu2v2FRErXE3/+YfkaKa<br>9lW2JCYHFAm7KK6sXZ/qAMK9HljERjPvIEy9oTMQDQfnSjyU8xJ7zsLh/I108ibB<br>R1SdIoIn+sJmJu7YVsPY52M5JTG3pQFTkkcBSYnTfs0Wdjbu9cnkYR0Gp6dWj12C<br>17fe1xQxiF0tL90QCckx9g84arlXwRo+0o6JLWwbHzUZeELeeXetFu96k8VI5946<br>bf+iFVq6ECqPzaKv3X9wkfjrV9B/PWDsDbPJ6PYd+6C1RBWJCDsf6jhR2YmWlATL<br>DLpsio/VAgMBAAECggEBAO8ZIOnTi302a922JR/vp6IJpKed5znlsfGknmNb+wco<br>BVxNephAlB8LL8/Pk37wEWFJhj8oV9pA0KGKJvgBLOBFD6i4/wbiW56mIWp1tg/G<br>JD1YGgQ/eoqTqwBIBv1pSH5cDIQlW46Gk7qv4hzlyIBHgBkanCo8kGIWAxKawsqv<br>HrbFlPd/omaeQ44t+KfTTImSDsVvIAyd6OzqRVJVAivwSTwKh0V24gmvBXR/a+iV<br>xAha6pxl8W/nb/RFRVNgr76i1jgFR/eejfgdBqMCKEZU96h4VeWA3j9RQnVKVD14<br>Phc8IbzNtpEUkIeaDqGrduOamHqK3nQ+giKnaA7MO0ECgYEA/O+F/fQGDHTjl7EZ<br>Xf3DJlJ4kssihn5P6h/4Aj9TPoMudZV3GalencXBpH9pL1esFSNdXnYmdsqvO/d1<br>2ugfhyJh3Di/AAeMILVGzeHR2FER8b/rLCIuKsWgJaELbBzlrj4wetWiFxc0eyEa<br>jRYktbZu1pFxJo0W5hLjdrwbZ/kCgYEA+pYjdJgz3FmpJ5Otqy/5c3kP9b07PyqH<br>YOXXjdXWFtUAjHXZ1kIeWGhPLmY+jvFw5IeESZWFR8Hmj7NL2LC2+allwHaWHZFC<br>OAU76L2uC9IQ1BCLxZtrDeXdPvZnkUZj+t/I+l4/I9OY/P/64OUjzMy6op5geJd7<br>8gj2osqadb0CgYEAhXaJ2F+r1WTUNtWfEgZ1s8Hul16SgC8kUeC+h8kMTr7/g9Hz<br>P1osb8nKjNciFHYJejnn6ZEkaKg4YMcJrBGxmSeeRYq31fcljJi6nKZciOz2L/7Z<br>w7bhb3ZKM7DPiyOQWim8gQQ6/D4lVhc4oFuf0TZLM/MYpoPqIkqzNZK6T1kCgYAX<br>Xqkv1oH/qtz7s+oebPr2qfOzF1LPMUgu4UCZGbg9qN/EObl3IfNyi0fXK/HpotrE<br>dV8A/dDQQGUgQbhxHQnzfrjemjCl0UY7s0FDE22H7K9lF6XxZ+0z/pwDozdFdSsd<br>2oED2IZK8RDzh2v+TWBpWS6Ou/aDSJ1mlS9rPznogQKBgQDMkyFJnkDT3acyf6Ze<br>Wjen6omH6JgE2s+uJGLi6rKZFmz994EHdTEI1EVZG65mfh2lxpiaoF76y16+uIOO<br>Vae9KwoqraBnclZXXuuFwW4sVoMCvBNr26U1y7SUTqZeDm06lshvHa+2xKTPLTFA<br>uhr1oZJ7uyGsqvdGkPaBm3qzNg==<br>-----END PRIVATE KEY-----<br></code></pre></div></td></tr></table></figure><p>公钥如下——</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">-----BEGIN PUBLIC KEY-----<br>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA95ZAOnVWyCHBOV9dhI27<br>CJ7o4GM1POEKNvS3BbZ9c8jg6ZQgeq+MiqfK+crtr9hURK1xN//mH5GimvZVtiQm<br>BxQJuyiurF2f6gDCvR5YxEYz7yBMvaEzEA0H50o8lPMSe87C4fyNdPImwUdUnSKC<br>J/rCZibu2FbD2OdjOSUxt6UBU5JHAUmJ037NFnY27vXJ5GEdBqenVo9dgte33tcU<br>MYhdLS/dEAnJMfYPOGq5V8EaPtKOiS1sGx81GXhC3nl3rRbvepPFSOfeOm3/ohVa<br>uhAqj82ir91/cJH461fQfz1g7A2zyej2HfugtUQViQg7H+o4UdmJlpQEywy6bIqP<br>1QIDAQAB<br>-----END PUBLIC KEY-----<br></code></pre></div></td></tr></table></figure><p>使用公钥加密”Hello, Happy World!”，得到如下字符串——</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode"><span class="hljs-number">7</span>fmMleOdHEcS<span class="hljs-number">3</span>k<span class="hljs-number">61</span>RD<span class="hljs-name">m0</span>DK<span class="hljs-number">7</span>Y<span class="hljs-number">6</span>grJSwc<span class="hljs-symbol">NZcbsvXWTbMfcklbCsKvmF2</span>oeOthSxlJQVhp<span class="hljs-number">0</span>KR/<span class="hljs-number">6</span>/<span class="hljs-number">0</span>HBjWri<span class="hljs-number">64</span>YGSaws<span class="hljs-number">7</span>KbJKZTd<span class="hljs-number">6</span>EZ<span class="hljs-symbol">nxhXESPb4</span>HGOl<span class="hljs-symbol">nazdRIXhMtCYY9</span>BtiRp<span class="hljs-symbol">npw58</span>iPd<span class="hljs-number">7</span><span class="hljs-meta">O4</span>Xzv<span class="hljs-number">7</span>Rli<span class="hljs-number">4</span>HAXPdwl<span class="hljs-number">6</span>OmaOVRBJwqaW<span class="hljs-number">3</span>GBsMQKsXpeL/UCcvLcfUFUJIVrUOPw<span class="hljs-number">+1</span>A<span class="hljs-number">9</span>tfouxCeql+Kd+MI<span class="hljs-symbol">NlehnxNMYLCglEL86</span>RLDclD<span class="hljs-number">1</span>VLxY<span class="hljs-symbol">nuFgvvQHD5</span>ueXu<span class="hljs-number">+2</span>RglPD<span class="hljs-number">0</span>UHfll<span class="hljs-number">2</span>CUbj<span class="hljs-number">9</span>Uacuzs<span class="hljs-number">2</span>euKsSHZP<span class="hljs-number">1</span>S<span class="hljs-number">1</span>zqTG<span class="hljs-meta">o4</span>PUrDgsk<span class="hljs-number">5</span>v<span class="hljs-number">68</span>tBxWaD<span class="hljs-number">26</span>Dyqz<span class="hljs-name">G5</span>u<span class="hljs-number">0</span>zrMXOlX/<span class="hljs-number">4</span>w==<br></code></pre></div></td></tr></table></figure><p>将该字符串使用私钥进行解密，得到如下结果——</p><figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span> Happy World!<br></code></pre></div></td></tr></table></figure><p>可不可以拿它生成的公钥当私钥使，它生成的私钥当公钥使？理论上是可以这么干的，但是至少这里 ssh 使用的 rsa 加密不允许这样干。</p><h2 id="非对称加密是如何传输数据的"><a href="#非对称加密是如何传输数据的" class="headerlink" title="非对称加密是如何传输数据的"></a>非对称加密是如何传输数据的</h2><p>如果使用对称加密算法，加解密使用同一个密钥，这样就需要对方和自己都要持有密钥才能进行，但如果把密钥也一起传过去，就存在密码泄露的可能。而非对称加密算法……至少不会存在这样的可能。</p><p>非对称加密算法传输数据的过程如下——</p><ol><li>首先<strong>接收方</strong>生成一对密钥，接收方自己持有私钥。</li><li>接收方将公钥发送给<strong>发送方</strong>。</li><li>发送方用公钥对数据进行加密，发送给接收方。</li><li>接收方用私钥解密数据。</li></ol><p>可以看到，这个过程中，私钥是不暴露在传输过程中的，因而保证了传输过程的安全性。</p><h2 id="公钥算法进行签名"><a href="#公钥算法进行签名" class="headerlink" title="公钥算法进行签名"></a>公钥算法进行签名</h2><p>公钥加密的数据<strong>只有</strong>私钥能够解密，私钥加密的数据<strong>只有</strong>公钥能解密，因此，如果某人用他的私钥加密数据并发布，其他人发现使用此人的公钥能解密该数据，说明这个数据一定是此人发布的。在这里，用私钥加密数据称为“签名”，其他人可以用公钥来验证该签名。</p><p>数字签名能够保证——</p><ol><li>信息是签名者自己签名发送的（他的私钥，他很难否认）。</li><li>信息未经过更改。</li></ol><h2 id="公钥算法的缺点"><a href="#公钥算法的缺点" class="headerlink" title="公钥算法的缺点"></a>公钥算法的缺点</h2><p><strong>慢</strong>！它比对称加密算法慢一两个数量级。因此它不适合对大量原始数据进行加密。</p><p>可以结合公钥算法和私钥算法，可以用公钥算法法来作为“引子”，实际传输使用私钥算法，其实质是把对称加密算法中使用的密钥使用非对称加密算法进行传输（这是为了防止在传输过程中暴露），从而避免非对称加密算法存在的一些缺点。</p><ol><li>发送方首先使用对称加密算法加密数据</li><li>接收方通过公钥机制生成一对公私钥，将公钥发送给发送方。</li><li>发送方将对称加密算法中的密钥使用公钥加密，发送给接收方。</li><li>接收方进行解密，得到对称加密算法的密钥。</li><li>发送方将加密的数据发送给接收方。</li><li>接收方通过密钥解密。</li></ol><h1 id="ssh-是什么"><a href="#ssh-是什么" class="headerlink" title="ssh 是什么"></a>ssh 是什么</h1><p>ssh 是 Secure Shell 的缩写，它是专为远程登录会话和其他网络服务提供安全性的<strong>协议</strong>。</p><p>ssh 协议使用<strong>对称加密</strong>，<strong>非对称加密</strong>和<strong>散列</strong>来确保信息的传输。客户端和服务器之间的 SSH 连接分为三个阶段：</p><ol><li>客户端对服务器的验证。</li><li>生成会话密钥以加密所有通信。</li><li>客户端认证。</li></ol><p>TODO：描述一下具体的</p><h1 id="github（git）怎样使用-ssh"><a href="#github（git）怎样使用-ssh" class="headerlink" title="github（git）怎样使用 ssh"></a>github（git）怎样使用 ssh</h1><p>push 的时候，可以使用 github 的账户密码作为验证，也可以使用 ssh 进行验证，要使用 ssh，应当在 github 网页端设置自己的公钥。要注意的是，一个公钥只能对应一个仓库。</p><p>TODO：同上</p>]]></content>
    
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初涉并发编程 3——对象的共享</title>
    <link href="/2020/12-23%E5%88%9D%E6%B6%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB.html"/>
    <url>/2020/12-23%E5%88%9D%E6%B6%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><blockquote><p>维护并发程序的安全性，其关键在于：<strong>正确管理对共享的可变状态的访问</strong>。</p></blockquote><p>上一节讲述如何让对象同步访问相同数据，这一节介绍如何<strong>共享</strong>和<strong>发布</strong>对象。</p><p>所谓的共享是指，一个对象可被多个线程访问，发布是指，一个对象能够在当前作用域之外的代码引用（这句话实际上是说，使该对象被不在当前作用域的变量引用），也就是说它逃逸出去了，这和之前所学的“逃逸分析”中的逃逸应该是同义的。</p><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>同步代码块和同步方法不仅能用于实现原子性或确定<strong>临界区</strong>（Critical Section），同步还有一个重要的方面：<strong>内存可见性</strong>（Memory Visibility）。<strong>我们不仅希望防止当某个线程在使用对象状态时该状态被其它线程修改，也希望确保当一个线程修改了对象状态后，其它线程能够看到发生的状态变化</strong>。</p><p>考虑如下代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoVisibility</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> ready;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> number;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (!ready)<br>                Thread.<span class="hljs-keyword">yield</span>();<br>            System.out.println(number);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderThread</span>().start();<br>        number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 外国人真喜欢这个梗</span><br>        ready = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里，ready 和 number 的赋值可能被<strong>重排序</strong>（Reordering，它是编译器进行优化的结果），导致 number 还没有被赋值时，ready 已经被赋值。因此，这里有可能会输出 0，也有可能该 ReaderThread 会持续循环下去，因为它可能看不到 ready 被修改（<del>为啥？while 不应该会无数次地检查 ready 的值吗？难道重排序会把这个判断条件挪到外面去？</del> 应该是因为现在的 JDK 版本做了很多优化，这种错误不容易复现了）。所以说应该使用锁使 number，ready 的赋值成为原子操作。</p><blockquote><p>我是知道为什么之前看那本 Java 并发程序设计，说多线程破坏了编程语言的抽象性了，这 tm 的把底全揭出来了，甚至都不能相信指令先后执行的顺序……</p></blockquote><p>为了避免这种问题，应当这样来解决——<strong>只要有数据在多个线程之间共享，就使用正确的同步</strong>。</p><h2 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h2><p>该程序显示了缺乏同步的程序中可能产生错误结果的一种情况：<strong>失效数据</strong>。读线程查看 ready 时可能得到一个失效值，除非每次访问变量时都使用同步。</p><p>getter 和 setter 是非线程安全的，因为如果某个线程调用了 setter，另一个调用 getter 的线程可能会看到更新后的 value，也可能看不到。可以使用 synchronized 关键字来修饰 getter 和 setter 以保证可见性。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@NotThreadSafe</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MutableInteger</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-comment">//线程不安全的，需要同步关键字来修饰</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> value; &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; value = n; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意的是，64 位操作（对 double，long）是非原子的，并且它不止会导致失效数据问题。应当使用<code>volatile</code>来声明（这样只能保证可见性）或用锁保护。</p><h2 id="volatile——确保可见性"><a href="#volatile——确保可见性" class="headerlink" title="volatile——确保可见性"></a>volatile——确保可见性</h2><p><code>synchronized</code>关键字保证<strong>可见性和原子性</strong>，而<code>volatile</code>关键字保证<strong>变量</strong>的<strong>可见性</strong>。也就是说，它保证变量能获得最新的变量值。可见性问题是由于计算机的<strong>多级缓存</strong>机制引起的。</p><p>考察下面的代码，它必定陷入无限循环——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 无限循环，等待 flag 变为 true 时才跳出循环</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!flag); <span class="hljs-comment">//这里如果给 while 代码块一个 sysout，或者给 flag 加上 volatile 关键字，则能正常执行</span><br>        System.out.println(<span class="hljs-number">42</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>        t.start();<br>        <span class="hljs-comment">// sleep 的目的是等待线程启动完毕，也就是说进入 run 的无限循环体了</span><br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>volatile</code>关键字保证变量的可见性，简单来说，当某个线程对变量进行修改后，在该线程后执行的线程能够看到该变量的更改，这是通过下面两条规则实现的——</p><ul><li>线程对变量进行修改后，要立刻写回到主内存中。</li><li>线程对变量读取的时候，必须从主内存读，不能从缓存读。</li></ul><p>线程启动的时候，线程的栈中不仅包含它的局部变量，也包含线程所需要的共享变量（通常存在堆里）的<strong>副本</strong>。</p><p>对于共享的（没有<code>volatile</code>关键字的）变量来说，JVM 约定变量在工作内存中发生变化的时候，必须要回写到主内存（迟早，但并非马上），并且，当对变量读取频率很高的时候，它会持续读取缓存中的值（这就是问题所在！空的 while 循环读取太快了，因此如果添加别的代码，比如 IO，降低读取的速度，就能让 JVM 去读主内存而非缓存了）。对于<code>volatile</code>变量，在工作内存中发生变化的时候，<strong>马上</strong>就要回写到主内存，读取时则必须要从主内存中读取。</p><h2 id="发布和溢出"><a href="#发布和溢出" class="headerlink" title="发布和溢出"></a>发布和溢出</h2><p>关于发布（Publish）和逸出（Escape），发布的意义如前所述，逸出是指，<strong>本不应该发布的对象被发布</strong>。</p><p>溢出的一个常见情况是发布了 private 变量——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeStates</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] states = &#123;<span class="hljs-string">&quot;AK&quot;</span>,<span class="hljs-string">&quot;AL&quot;</span>,<span class="hljs-string">&quot;DDDA&quot;</span>&#125;;<br>    <span class="hljs-keyword">public</span> String[] getStates() &#123; <span class="hljs-keyword">return</span> states; &#125; <span class="hljs-comment">// 这返回的可是一个数组！这让外界能够更改 states 的状态了！</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里，states 就逸出了它的作用域（类中），这个本应是私有的变量被发布了。</p><p>构造函数可能会让 this 逸出。</p><p>TODO: 摸了</p><h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>实现线程安全性的最简单方式之一是<strong>线程封闭</strong>（Thread Confinement）——不共享数据。当某个对象被封闭在一个线程中时，这将自动实现线程安全性，而不需要额外的同步，即使该对象本身不是线程安全的（毕竟对这个对象来说，它所处的是单线程的环境）。</p><p>显然，局部变量是线程封闭的。</p><h3 id="Ad-hoc-线程封闭"><a href="#Ad-hoc-线程封闭" class="headerlink" title="Ad-hoc 线程封闭"></a>Ad-hoc 线程封闭</h3><p>（这什么怪名字）</p><p>TODO，我想先看看别的书（Java 并发编程之美）再说。</p>]]></content>
    
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初涉并发编程 2——线程安全性</title>
    <link href="/2020/12-22%E5%88%9D%E6%B6%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7.html"/>
    <url>/2020/12-22%E5%88%9D%E6%B6%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>此章节讲解线程安全性以及 Java 提供的一些加锁机制。</p><h2 id="多线程程序编写的核心"><a href="#多线程程序编写的核心" class="headerlink" title="多线程程序编写的核心"></a>多线程程序编写的核心</h2><p>线程和锁之于并发编程，就如工字钢和铆钉之于房屋建筑。要想建筑坚固，钢材和铆钉的正确使用是必要的。要编写<strong>线程安全</strong>的代码，<strong>其核心就在于要对状态访问操作进行管理，特别是对共享的（shared）和可变的（Mutable）状态的访问</strong>。这里的状态指的是存储在状态变量（如静态&#x2F;实例域）中的数据。其也可能包括其他依赖对象的域，比如 Map 的状态不仅保存在 HashMap 对象本身，也抱存在无数个 Map.Entry 对象中。对象的状态包含任何<strong>外部可见</strong>的数据。</p><p>“共享”意味着对象能够被多个线程<strong>同时</strong>访问，“可变”指对象的值在生命周期内会发生变化。线程安全要求各线程以同步机制来协调对可变状态的访问。</p><p><del>Java 提供的主要同步机制是 synchronized 关键字，但是 volatile，显式锁（Explicit Lock）和原子变量等也是同步机制的一部分。</del>（这句话可能已经过时了）</p><h2 id="线程安全类"><a href="#线程安全类" class="headerlink" title="线程安全类"></a>线程安全类</h2><p>当访问一个可变状态又没有使用合适的同步，就容易出现错误，有三种方法修复它——</p><ol><li>不共享该状态</li><li>更改其为不可变状态</li><li>使用同步机制（大多数情况下……只有这个选择了吧）</li></ol><p>这些方法或许会导致代码的重大更改，所以应当<strong>从一开始就设计一个线程安全的类</strong>。同时，<strong>良好的封装</strong>也让线程安全更容易实现——访问某个变量的代码越少，越容易确保对变量的访问实现正确同步。然后，性能优化只有在必须优化，且优化必定有效果时才进行。“提前优化是万恶之源”。</p><p>（我认为）线程安全类可以这样定义——<strong>其实际行为和其应当的行为完全一致，而无论单线程环境或是多线程环境，无论不同线程对其的调用顺序如何，无论有无采取同步机制</strong>。也就是说，不需要外界的程序（类）进行任何额外的同步或协同操作，这个类总是正确工作的（其实这时候在外界看来，线程安全类提供的所有操作都是原子的）。</p><p>无状态的对象一定是线程安全的，因为它和其它对象没有共享状态，各玩各的，不会相互影响。</p><h2 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h2><p>（注意，这里说的是机制，它并不局限于语言！）</p><p>线程安全性要求，多个线程之间的操作无论采用何种执行时序或交替方式，都要保证<strong>不变性</strong>不被破坏。（“不变”是指在某个线程执行该操作的这整个周期中不变）</p><p>考虑下面的代码，它描述了一个非线程安全的 Servlet，其功能为返回一个整型变量的因数分解（它是一个数组），同时缓存上一次的值，如果为同一个值，则直接返回缓存中的值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@NotThreadSafe</span> <span class="hljs-comment">// 这是作者定义的注解，只起描述作用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeCachingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;BigInteger&gt; lastNumber = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(); <span class="hljs-comment">// 先无论这是什么玩意</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;BigInteger[]&gt; lastFactors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest reg, ServletResponse resp)</span> &#123;<br>        <span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> extractFromRequest(reg);<br>        <span class="hljs-keyword">if</span> (i.equals(lastNumber.get())) <span class="hljs-comment">// 缓存命中</span><br>            encodeIntoResponse(resp, lastFactors.get()); <span class="hljs-comment">// 这些原子类的所有操作都是原子的</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            BigInteger[] factors = factor(i);<br>            lastNumber.set(i);<br>            lastFactors.set(factors);<br>            encodeIntoResponse(resp, factors);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的不变性的条件之一是，lastNumber 缓存的值的因数之积应当等于 lastFactors 中的值（这个条件在一个线程执行这个操作的整个周期中都不能被改变），这里显然是线程不安全的。通过加锁机制，可以简单地为操作提供原子性，从而保证线程安全性。</p><h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><p>Java 提供了一种内置的锁来支持原子性——同步代码块（Synchronized Block）。它可以作为关键字来修饰一个方法（对于静态方法，它使用 Class 对象作为对象，对于实例方法，使用 this 来作为对象），也可以以这种形式来规定一个代码块，这里的 lock 可以是任何类型的对象（书中说是 Class 对象，我觉得是翻译错误，它没理由接受一个<code>java.lang.Class</code>对象）——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    . . .<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里对象的作用是提供一个实现同步的锁，他称为<strong>内置锁</strong>（Intrinsic Lock）或<strong>监视器锁</strong>（Monitor Lock，这个似乎是用的更多的术语）。<strong>该锁为其保护起来的代码块提供原子性——每次只能有一个线程执行代码块</strong>。当有一个线程进入该代码块，它将获得该代码块的锁，即使该线程被切换出去，其它线程也无法进入代码块，直到该线程执行完代码块并释放锁。因此，这里的一组语句是作为一个<strong>不可分割的单元</strong>执行的。</p><p>上面的 Servlet 中的 service 方法如果使用 synchronized 关键字修饰的话，就能正确地缓存了——每一时刻仅有一个线程能执行该方法，但是它的并发性是非常糟糕的（不过这不是线程安全问题，是性能问题），因为当多个请求到来的时候，它只能串行处理，即使有多处理器也无济于事。</p><p>内置锁是可<strong>重入</strong>的，也就是说，<strong>一个线程如果持有了一个对象的锁，它还能再次获取这个对象的锁并保证不会发生死锁</strong>。重入的一个实现是给锁关联一个计数器和其所有者线程，如果计数器值为 0 则说明其未被持有，当线程请求一个未被持有的锁时，JVM 记录锁的持有者，将计数器值设为 1, 如果该线程再次请求，则计数器递增，每次退出代码块时，计数器递减，计数器为 0 时锁被释放。</p><blockquote><p>可重入锁的粒度是“线程”而不是“调用”。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 因为对象锁是可重入的，所以这样使用不会产生死锁。</span><br><span class="hljs-comment">// 这里把 doSomething 方法设为实例方法而非静态方法，是因为如果是静态方法，则相当于是先获取 Son 的 Class 对象锁（这个似乎叫类锁？），再获取 Super 的 Class 对象锁，它只能证明一个线程能同时持有多个锁，而不能证明内置锁是可重入的。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Super</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;do something&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Super</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;do some preparation&quot;</span>);<br>        <span class="hljs-built_in">super</span>.doSomething();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>().doSomething();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 上面的例子不明显，换一个</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                            System.out.println(<span class="hljs-string">&quot;hello, world!&quot;</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="用锁保护状态"><a href="#用锁保护状态" class="headerlink" title="用锁保护状态"></a>用锁保护状态</h2><p>锁要求其保护的代码被串行访问，因此可以通过锁构造一些<strong>协议</strong>来实现对共享状态的独占访问（就如上面的 Servlet 中的缓存）。</p><p><strong>访问共享对象的复合操作必须是原子操作以避免产生竞态条件</strong>。如果用同步来协调对某个变量的访问，则在访问该变量的所有位置都应当使用同步。当使用锁来协调对某个变量的访问时，在访问变量的所有地方都应当使用同一个锁。这种情况下，称状态变量被这个锁<strong>保护</strong>。<strong>如果对象的不变性涉及多个状态变量时，不变性条件中的每一个变量都必须被同一个锁保护</strong>。</p><p>一种约定是，<strong>将所有可变状态封装到对象的内部并通过内置锁对所有访问可变状态的代码路径进行同步以避免并发访问</strong>。这种加锁协议是非强制的。</p><p>为什么不给每一个方法都设置<code>synchronized</code>关键字？因为这会导致许多多余的同步，而且<strong>并不能保证外界对其的复合操作是原子的</strong>，比如线程安全的<code>Vector</code>类，这样使用的话，仍然会出现竞态条件，还会导致活跃性和性能问题。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!vector.contains(element))<br>    vector.add(element);<br></code></pre></div></td></tr></table></figure><h2 id="活跃性和性能"><a href="#活跃性和性能" class="headerlink" title="活跃性和性能"></a>活跃性和性能</h2><p>上面的 Servlet 是<strong>不良并发</strong>（Poor Concurrency）的。下面的新的实现进行了更改。它重新引入了两个计数器，分别计数调用次数和缓存命中次数。它引入两个同步代码块，第一个同步代码块检查是否命中，第二个同步代码块更新缓存。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ThreadSafe</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CachingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br>    <span class="hljs-meta">@GuardedBy(&quot;this&quot;)</span> <span class="hljs-keyword">private</span> BigInteger lastNumber; <span class="hljs-comment">//这里不需要使用原子引用了</span><br>    <span class="hljs-meta">@GuardedBy(&quot;this&quot;)</span> <span class="hljs-keyword">private</span> BigInteger[] lastFactors;<br>    <span class="hljs-meta">@GuardedBy(&quot;this&quot;)</span> <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> counts;<br>    <span class="hljs-meta">@GuardedBy(&quot;this&quot;)</span> <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> hits;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getHits</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> counts;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getCacheHitRatio</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) hits / (<span class="hljs-type">double</span>) counts;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest reg, ServletResponse resp)</span> &#123;<br>        <span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> extractFromRequest(reg);<br>        BigInteger[] factors = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            counts++;  <span class="hljs-comment">// 对于两个计数器的操作其实也可以分解在更细的代码块中，但是这样会带来不必要的锁的切换的开销。</span><br>            <span class="hljs-keyword">if</span> (i.equals(lastNumber)) &#123; <span class="hljs-comment">//缓存命中</span><br>                hits++;<br>                factors = lastFactors.clone(); <span class="hljs-comment">// 我怀疑这个 clone 的必要性！</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (factors == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 未命中</span><br>            factors = factor(i); <span class="hljs-comment">// 因数分解操作可能是耗时的，并且它不需要状态变量，因此可以不包裹在同步代码块中，以尽量提高并发性。</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 缓存的因数分解和值必须同时被更新，这是毫无疑问的。</span><br>                lastNumber = i;<br>                lastFactors = factors.clone(); <span class="hljs-comment">// 同样，这里的 clone 我也持怀疑态度。</span><br>            &#125;<br>        &#125;<br>        encodeIntoResponse(resp, factors); <span class="hljs-comment">//这里应当返回 factors，如果返回 lastFactors，则也需要包裹在同步代码块中。</span><br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>我认为这里使用 clone 是没有必要的。毕竟，若不使用 clone，在不在同步代码块时若 lastFactors 被赋了新值，只不过是它指向了一个新的地址，原来的地址仍旧是被 factors 引用着的，所以用不用 clone 无关紧要。这里没有任何代码调用过 lastFactors 的 setter 吧？</p></blockquote><p>重新构造后的该类<strong>取得了在简单性（对整个方法进行同步）与并发性（对尽可能短的代码路径进行同步）中的平衡</strong>。不要盲目地为了性能而放弃简单性，因为这会导致维护困难，破坏线程安全性。</p><blockquote><p>执行时间较长的计算或可能无法快速完成的操作（如 I&#x2F;O），<strong>一定不要持有锁</strong>。</p></blockquote><p><img src="https://s3.ax1x.com/2020/12/22/rDeJHg.png"></p><p>换个图床……</p>]]></content>
    
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 语句快速复习</title>
    <link href="/2020/12-21SQL%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0.html"/>
    <url>/2020/12-21SQL%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>出于面试的需要，快速复习（虽然这么说，但我现在只会增删改查而已，复杂的查询早忘了，毕竟学过以后好久没再使用过）一下 SQL 的<strong>语法和</strong>。这里仅仅关注语法——数据库设计，调优等不是我现阶段（可能也包括将来）追求的目标，</p><p>这里使用 mariaDB 进行学习，使用 vscode 和 SQLTools 插件。很据《SQL 必知必会》第四版学习，表和数据使用作者在其网站中提供的 <a href="https://forta.com/wp-content/uploads/books/0672336073/TeachYourselfSQL_MySQL.zip">文件</a>。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>数据库 (database) 使用表 (table) 来存储数据。<strong>模式</strong> (schema) 可以描述表的信息。表可以通过模式来 create，也可以直接给定各列来 create，这里可以联想类，对象和匿名实现类的关系。</p><p>表通过行列来存储数据。表由列 (column) 组成，每一列都代表部分信息。每一列都有自己的数据类型。数据是按行存储的。每个记录 (record) 为一行 (row)。</p><blockquote><p>列也叫字段 (field)。</p></blockquote><p>每一行都有一列（或多列）来唯一地标识自己。比如学生的学号，记录用户操作的用户名，时间戳（只有用户名，只有时间戳都不能唯一地确定一个操作，因为同一时间戳可以有多个用户操作，同一个用户可以有多个时间戳的操作，而同一个用户在同一个时间戳内只能执行一个操作）。这个（几）列称为主键 (primary key)。主键并非是强制要求的，但是其应当有。</p><p>主键满足以下要求——</p><ul><li>任何两个记录的主键不能重复。</li><li>主键中每一列都不能为 NULL</li><li>下面两个要求我测试了一下，可以啊……怪</li><li>主键列的值不允许被更新</li><li>主键值不能重用（被删除后，该主键无法赋给新行）</li></ul><p>SQL 是 Structured Query Language（结构化查询语言）的缩写。它负责与数据库（或许更准确的来说，是 DBMS，Database Management System 数据库管理系统）沟通。</p><blockquote><p>结构化的语言可以认为是用呈一定结构的自然语言来进行编程的语言，如 C#的 LINQ，Common Lisp 的 Loop 宏，其也都是一种结构化语言。</p></blockquote><h1 id="SELECT——检索数据"><a href="#SELECT——检索数据" class="headerlink" title="SELECT——检索数据"></a>SELECT——检索数据</h1><blockquote><p>SQL 使用–进行单行注释，使用 C 风格的&#x2F;**&#x2F;进行多行注释。</p></blockquote><p><code>SELECT</code>语句从一个或多个表中检索信息。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 检索一列</span><br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> Products; <span class="hljs-comment">-- 这将返回所有行的 prod_name。</span><br><br><span class="hljs-comment">-- 检索多列</span><br><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price <br><span class="hljs-keyword">FROM</span> Products;<br><span class="hljs-comment">-- 检索所有 （实际上查询了整个表）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Products;<br></code></pre></div></td></tr></table></figure><h2 id="DISTINCT——保证检索值唯一"><a href="#DISTINCT——保证检索值唯一" class="headerlink" title="DISTINCT——保证检索值唯一"></a>DISTINCT——保证检索值唯一</h2><p><code>SELECT</code>可以使用<code>DISTINCT</code><strong>子句</strong>来约束，保证每一行都是唯一的（也就是说过滤掉完全重复的行）。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> vend_id <span class="hljs-keyword">FROM</span> Products;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">BRS01</span><br><span class="hljs-comment">DLL01</span><br><span class="hljs-comment">FNG01</span><br><span class="hljs-comment">FNG01</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> vend_id <br><span class="hljs-keyword">FROM</span> Products;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">BRS01</span><br><span class="hljs-comment">DLL01</span><br><span class="hljs-comment">FNG01</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h2 id="LIMIT——限制结果数量"><a href="#LIMIT——限制结果数量" class="headerlink" title="LIMIT——限制结果数量"></a>LIMIT——限制结果数量</h2><p><code>SELECT</code>语句返回匹配的行——可能是所有，也可能是前 1000 行或其他数字。使用<code>LIMIT</code>子句可以限制最多返回多少行。<code>LIMIT</code>可以和<code>OFFSET</code>搭配使用，表示从某一行开始返回。<code>OFFSET</code>是<strong>零索引</strong>的。所以<code>LIMIT i</code>和<code>LIMIT i OFFSET 0</code>同义。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name<br><span class="hljs-keyword">FROM</span> Products<br>LIMIT <span class="hljs-number">5</span>; <span class="hljs-comment">-- 这是 MySQL 和 MariaDB 的语法，其它 SQL 语法不一样。</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> prod_name <span class="hljs-comment">-- 关键字可以联合使用</span><br><span class="hljs-keyword">FROM</span> Products<br>LIMIT <span class="hljs-number">5</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">5</span>;  <span class="hljs-comment">-- 从第 5 行开始检索。</span><br></code></pre></div></td></tr></table></figure><h2 id="ORDER-BY——排序结果"><a href="#ORDER-BY——排序结果" class="headerlink" title="ORDER BY——排序结果"></a>ORDER BY——排序结果</h2><p>应该假定，<strong>如果不明确进行排序，则检索到的数据的顺序是无意义的</strong>。</p><p><code>ORDER BY</code>子句让各记录根据其一个列或多个列的值来排序。使用<code>ASC</code>（升序排序，它是默认的）和<code>DESC</code>（降序）关键字来规定升序还是降序排序。要降序排序的每一列都需要明确给定<code>DESC</code>。</p><p>需要注意的是，<code>ASC</code>&#x2F;<code>DESC</code>需要给在列名后面…就像副词的用法。</p><blockquote><p>DESC 是 DESCENDING 的缩写，ASC 是 ASCENDING 的缩写。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name<br><span class="hljs-keyword">FROM</span> Products <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name; <span class="hljs-comment">-- 根据名字排序</span><br><br><span class="hljs-keyword">SELECT</span> prod_id, prod_price, prod_name<br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_price, prod_name;<span class="hljs-comment">-- 先按 price 排序，如果 price 相等，按 name 排序。</span><br><br><span class="hljs-keyword">SELECT</span> prod_id, prod_price, prod_name<br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">2</span>, <span class="hljs-number">3</span>; <span class="hljs-comment">-- 也可以根据列位置来排序，比如这里的 2 代表 price，3 代表 name。这样的缺点是如果列位置改变，数字也需要改变，而且如果排序的根据不在结果列里（比如我想根据 desc 进行排序，虽然我不要这个数据），则无法这样使用。</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> prod_id, prod_price, prod_name<br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_price <span class="hljs-keyword">DESC</span>, prod_name, prod_desc <span class="hljs-keyword">DESC</span>; <span class="hljs-comment">-- 先根据 price 降序排列，如果 price 相等，再根据 name 升序排列，如果 name 相等，则根据 desc 降序排列。</span><br></code></pre></div></td></tr></table></figure><h1 id="WHERE——过滤数据"><a href="#WHERE——过滤数据" class="headerlink" title="WHERE——过滤数据"></a>WHERE——过滤数据</h1><p><code>WHERE</code>子句如此重要，以至于要给它一个 h1 标题 XD。</p><p>检索所有行的情况是很少的，通常需要依据一定的需要提取表数据的一个子集。</p><p>只检索所需数据，需要指定<strong>搜索条件</strong> (search criteria), 其也称为<strong>过滤条件</strong> (filter condition).<code>WHERE</code>就是提供这样功能的子句。</p><p><code>WHERE</code>提供很多操作符，如<code>=</code>, <code>&lt;&gt;</code>(<code>!=</code>), <code>&lt;</code> ,<code>&lt;=</code> ,<code>&gt;</code>,<code> &gt;=</code>, <code>!&lt;</code>（不小于）, <code>!&gt;</code>（不大于）, <code>BETWEEN</code> （它接受<code>a AND b</code>这样的形式的第二个参数）, <code>IS NULL</code>。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-operator">=</span> <span class="hljs-number">3.49</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name <span class="hljs-keyword">DESC</span>;<br></code></pre></div></td></tr></table></figure><blockquote><p>同时使用<code>ORDER BY</code>和<code>WHERE</code>时，<code>ORDER BY</code>应当放到<code>WHERE</code>后。</p></blockquote><h2 id="AND-amp-OR"><a href="#AND-amp-OR" class="headerlink" title="AND &amp; OR"></a>AND &amp; OR</h2><p>其还可用<code>OR</code>和<code>AND</code>来连接多个条件。<code>AND</code>子句优先级更高。可以使用括号来决定运算顺序。（事实上，除了加减乘除，其他任何包括不同优先级运算符的表达式都应该强制使用括号来规定运算顺序。）</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-operator">=</span> <span class="hljs-number">3.49</span> <br>  <span class="hljs-keyword">AND</span> prod_name <span class="hljs-operator">!=</span> &quot;ignored&quot;<br>  <span class="hljs-keyword">OR</span> prod_desc <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name <span class="hljs-keyword">DESC</span>;<br></code></pre></div></td></tr></table></figure><h2 id="IN——在……之中"><a href="#IN——在……之中" class="headerlink" title="IN——在……之中"></a>IN——在……之中</h2><p><code>IN</code>子句用途是枚举条件的可选范围。它接受一对原括号扩起来的，用逗号分割的一组合法值。它<strong>也可以包含其他 SELECT 语句</strong>，但是该 select 要求返回只有一列的表，比如<code>SELECT id from user;</code>。</p><blockquote><p>顺带一提，一行一列的表同字面量（如字符串，数字之类的东西）是一样的效果。比如这样一个没有实际意义且性能低下但可供演示的例子——<code>SELECT * FROM place WHERE place_name = (SELECT place_name FROM place WHERE place_name=&quot;北京&quot; LIMIT 1)</code>。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  prod_name, prod_price<br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">IN</span> (&quot;DLL01&quot;, &quot;BRS01&quot;) <span class="hljs-comment">-- 等同于 vend_id = &quot;DLL01&quot; OR vend_id = &quot;BRS01&quot;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br></code></pre></div></td></tr></table></figure><h2 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h2><p><code>NOT</code>顾名思义，对结果取非。注意其位置，它放在每一个条件前。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  prod_name, prod_price<br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> vend_id <span class="hljs-keyword">IN</span> (&quot;DLL01&quot;, &quot;BRS01&quot;)  <span class="hljs-comment">-- 有趣的是，这里的 NOT 也可以放到 IN 的前面</span><br><span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> prod_name <span class="hljs-operator">=</span> &quot;King doll&quot;<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br></code></pre></div></td></tr></table></figure><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>所谓通配符，就是根据值的一部分来进行匹配的特殊字符。通配符和字面值组合成为的搜索条件称为<strong>搜索模式</strong>（search pattern）。显然，通配符只能用来匹配字符串。</p><h2 id="LIKE-操作符"><a href="#LIKE-操作符" class="headerlink" title="LIKE 操作符"></a>LIKE 操作符</h2><p>此书说技术上来说 LIKE 不是操作符……先放着。</p><p><code>LIKE</code>是一个谓词（predicate……不得不联想到 Lisp 里的谓词）用来判断字符串<strong>是否匹配该搜索条件</strong>。一般说“用<code>LIKE</code>进行通配搜索”。</p><h3 id="通配符-1"><a href="#通配符-1" class="headerlink" title="%通配符"></a>%通配符</h3><p><code>%</code>通配符用来匹配任何字符出现任意次数（就如同 regex 的。*吗？）。</p><p>比如下面的搜索模式检查 name 是否以 Fish 开头。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> &quot;Fish%&quot;;<br></code></pre></div></td></tr></table></figure><blockquote><p>%可以匹配 0 个或任意多个字符，但是 NULL 不行，LIKE “%”不能匹配 NULL。</p></blockquote><blockquote><p>一个需要注意的地方是，许多 DBMS 会用空格来填充未使用的地方，比如假设某列有 50 个字符，只用了 10 个字符，其后 40 个字符会被填充为空格，这有时候会对通配搜索产生影响。</p></blockquote><h3 id="通配符-2"><a href="#通配符-2" class="headerlink" title="_通配符"></a>_通配符</h3><p><code>_</code>通配符匹配且只匹配一个字符，Over。</p><h3 id="通配符-3"><a href="#通配符-3" class="headerlink" title="[] 通配符"></a>[] 通配符</h3><p><code>[]</code>通配符用法就如 regex 中的<code>[]</code>。mariaDB 不支持集合通配符，所以 pass。</p><hr><blockquote><p>时代变啦，本来是为找工作学习 SQL，现在已经找到了。但是还是得继续学习。争取将来忘记了啥语法之类的时候只看这篇文章就够了。 顺便，现在改用 Mysql……毕竟这玩意是最常用的（而且懒得装新的数据库了）</p></blockquote><h1 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h1><p>…</p><blockquote><p>最近专注毕设，毕业之前估计是不会再去主动学了。等工作时接触再继续吧。——2021.05.04</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初涉并发编程 1——基本概念</title>
    <link href="/2020/12-20%E5%88%9D%E6%B6%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
    <url>/2020/12-20%E5%88%9D%E6%B6%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>从这篇文章起，都是在 openSUSE 环境下，使用 vscode 编写的了～</p><p>主要是按照《Java 并发编程实战（Java concurrency in practice）》来学习的，或许也会参考其他书籍。我目前仅有对多线程编程的一点非常粗糙的理解，需要大量的实践和理论学习来补足。</p><p>一个必须要明确的问题是，看这本书，并非是要学习 java 中的并发编程，而是通过 Java 来学习并发编程的思想。在这里，思想才是真正的<strong>内容</strong>，语言只不过是这思想的表现<strong>形式</strong>而已。将来去学设计模式，也应该坚持这一点。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>简单来说，<strong>进程</strong>就是一个程序（存放在硬盘里的，静态的代码&#x2F;机器码）的一次执行，或者说是一个程序的<strong>生命周期</strong>。而线程，则是进程所创建的“<strong>轻量级进程</strong>”。对于 Java 程序来说，JVM 就是 Java 程序的进程，它维护数个线程，如执行 main 方法的主线程，GC 线程等。</p><p>就如之前所学习到的，各个进程之间一般上来说是相互隔离的，它们只能通过操作系统提供的一些方法来相互通信，如信号量，socket，共享内存，管道等。而进程下的各线程可以<strong>共享</strong>线程的资源。对于 Java 程序来说，各个线程都共享进程的方法区和堆，各个线程都私有栈和 PC。</p><p><strong>线程是 CPU 调度的最小单位</strong>。进程间的上下文切换消耗很大，而线程间的切换则消耗相对较小（这里减少的消耗似乎主要来源于线程间共享的资源，即堆的资源，因为是共享的，所以内存缺页的情况会较少，更容易命中……之类的），所以线程也叫轻量级进程。</p><h2 id="串行和并行"><a href="#串行和并行" class="headerlink" title="串行和并行"></a>串行和并行</h2><p>所谓串行，就是指一连串的操作依次进行，它们是有严格的顺序关系的，没有两个操作是同时进行的。</p><p>而并行，则是说其中有部分（或全部）操作是（严格上来说）同时执行的。并行只有在多核 CPU 的计算机中才能进行。</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>TODO: 摸了</p><h2 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h2><p>并发是指在<strong>宏观</strong>上来说，两个（或多个）操作是同时执行的。这时，计算机底层可能是串行的（所有操作可以都在一个所谓的主事件循环里进行，就如以前的 GUI 程序），也可能是并行的，可能是单线程的，也可能是多线程的。所以并发并不等于并行。</p><h1 id="为什么要多线程？"><a href="#为什么要多线程？" class="headerlink" title="为什么要多线程？"></a>为什么要多线程？</h1><p>首先一个原因是，多线程让程序<strong>更容易维护</strong>（把原本互相并行的操作，分割成一个个串行的操作），<strong>降低开发的成本</strong>（好家伙，有什么比这一条更重要？）。同时，多线程也能够<strong>增加资源利用率</strong>，在进行某些需要等待的操作时（比如等待外界的输入输出），能够空出手来干其他事（即使对单核处理器也如此）；对于现代的多用户系统，多线程能够保证用户和程序的<strong>公平性</strong>。</p><p>还有硬件上的原因。随着摩尔定律的失效，CPU 的频率遇到瓶颈，那些硬件厂商迫不得已，只能往 CPU 里塞更多的核心，为了利用好这些核心，多线程是必要的。比如说，单线程的程序跑在双核的计算机上，只能利用 50%性能，在 128 核的计算机上则只能利用不到 1%的性能。</p><p>不过无论如何，多线程最香的一点在于它让建模简单了，<strong>它将复杂，异步的工作流分解为一组简单，同步的工作流</strong>——每个工作流在一个单独的线程中执行，并在特定的同步位置进行交互。它能够简化异步事件，让每一个组件都像是一个单线程程序。学习多线程，实际上就是学习如何让各线程间保持同步。</p><blockquote><p>这可能会让你以为，在单核处理器的情况下，编写并发代码是没有意义的。然而，有些情况下，并发模型会产生更简单的代码，光是为了这个目的就值得舍弃一些性能。——《On Java 8》</p></blockquote><h1 id="多线程带来的问题"><a href="#多线程带来的问题" class="headerlink" title="多线程带来的问题"></a>多线程带来的问题</h1><p>多线程要求开发者考虑三个问题——安全性，活跃性，以及性能问题。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>如果线程间没有采取适当的同步措施，多个线程之间<strong>不可预测的执行顺序</strong>可能会让程序出现错误。并且这种错误是难以发现的，间歇性出现的。</p><h3 id="竞态条件（Race-Condition）"><a href="#竞态条件（Race-Condition）" class="headerlink" title="竞态条件（Race Condition）"></a>竞态条件（Race Condition）</h3><p>考虑这样的代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Counter</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>                Counter.count();<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>                Counter.count();<br>        &#125;);<br>        a.start();<br>        b.start();<br>        a.join();<br>        b.join();<br>        System.out.println(Counter.count()); <span class="hljs-comment">// 结果是不可预测的，可能是 1000 到 2000 的任何值</span><br>        System.exit(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>问题发生在 count 方法里，count++并非是原子操作，查看 count 的字节码，可以看到，其字节码有 6 步，这里简化它有三步——get 值（到栈顶），计算，put 值。它是<strong>读取——修改——写入</strong>操作。</p><blockquote><p><del>原子操作指不可被打断的操作，也就是说，当一个线程在执行原子操作的时候，该操作（块）保证不会被其他线程执行，即使该线程被切换出去。通过一定的加锁机制能够给与一串操作以原子性</del>（不知道如何正确定义原子性…这里被删掉的定义的外延似乎不能包括那种真正不可再分的原子操作，比如下面所示的字节码的单行，因为这样的操作在多处理器环境下完全可以是并行的，而锁将不允许并行。或许是我脑子里没货导致的……但是这里其实并不需要纠结，在实践中是能够分辨出来的）</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">int</span> <span class="hljs-string">count();</span><br><span class="hljs-attr">Code:</span><br>    <span class="hljs-attr">0:</span> <span class="hljs-string">getstatic</span>   <span class="hljs-comment">#2  // Field count:I</span><br>    <span class="hljs-attr">3:</span> <span class="hljs-string">dup</span><br>    <span class="hljs-attr">4:</span> <span class="hljs-string">iconst_1</span><br>    <span class="hljs-attr">5:</span> <span class="hljs-string">iadd</span><br>    <span class="hljs-attr">6:</span> <span class="hljs-string">putstatic</span>   <span class="hljs-comment">#2  // Field count:I</span><br>    <span class="hljs-attr">9:</span> <span class="hljs-string">ireturn</span><br></code></pre></div></td></tr></table></figure><p>要知道，线程可以在进行到任意一行时进行线程调度。考虑下面的情况——</p><p><img src="https://i.loli.net/2020/12/19/DxmSh9zpiRyNXju.png"></p><p>经历了两次 count 操作，它们正常的情况应该是分别返回 9，10，而这里全部都返回了 9。count 在两次递增后值应当为 11, 但结果却为 10。可以说，有一次递增操作<strong>丢失</strong>了。这里显然，<strong>不恰当的运行时线程交替执行的顺序导致了错误的结果</strong>。这是没有充分同步造成的。</p><p>上面描述的是一种常见的并发安全问题——<strong>竞态条件（Race Condition）</strong>中的“<strong>先检查后执行（Check-Then-Act）</strong>”。它是指<strong>结果的正确性取决于多个线程的交替执行时序</strong>这样的情况。或者说，结果的正确性取决于运气。（老实说，我觉得 condition 或许翻译成“情况”更好）</p><p>大多数竞态条件的本质是“<strong>观察结果的失效</strong>”。<del>比如这里的 count 方法，当一个线程获取了 count 的值后，它实际上已经无法再知道它所持有的 count 的值是否还是原来的 count 的值，而它却要拿这种不确定的结果来进行运算。如果该结果自始至终都是未改变的，则不会出现问题。但若是有改变，这里就失效了。</del>（该方法属于读取——修改——写入操作，有一定的共通性，但也有其个性）。</p><p>（单例模式的？）延迟初始化也是先检查后执行的一个常见例子。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (ins == <span class="hljs-literal">null</span>) <br>    <span class="hljs-type">return</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">instance</span>(); <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ins;<br></code></pre></div></td></tr></table></figure><p>这里由于不一致的调用顺序，可能会导致多个线程执行该方法后返回不一样的实例。</p><h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><p>安全性是指，“<strong>永远不发生糟糕的事情</strong>”，而活跃性则是指，“<strong>正确的事情终究会发生</strong>”。在这里，死锁，饥饿，活锁等会导致活跃性问题。（或许死锁和饥饿的区别在于，死锁和活锁时所有线程都无法执行，饥饿时只有一部分线程无法执行……但无论如何，这都是我们不想看到的）</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>我们不仅要求正确的事情终究要发生，也要求正确的事情尽快发生。多线程程序相较于单线程程序，引入了多余的运行时开销——<strong>线程间的上下文切换和对临界区操作时同步机制带来的开销</strong>。前者如处理不当，会导致 CPU 时间主要用于线程调度而非运行，后者往往会抑制编译器的性能优化，使内存缓冲区中数据无效。</p>]]></content>
    
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Java 的泛型</title>
    <link href="/2020/12-12%E5%85%B3%E4%BA%8EJava%E7%9A%84%E6%B3%9B%E5%9E%8B.html"/>
    <url>/2020/12-12%E5%85%B3%E4%BA%8EJava%E7%9A%84%E6%B3%9B%E5%9E%8B.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>根据《Java 核心技术卷 1》的第 8 章稍微了解一下泛型。</p><p>Java 的泛型归根结底是一种<strong>语法糖</strong>，当我们定义一个泛型类，比如 Pair&lt;T,U&gt;，又去声明两个实现，比如 Pair&lt;String, Integer&gt;，Pair&lt;Integer, LocalDate&gt;，这并不会真的在编译期多整出两个类出来（C++的模版是这样干的），在运行时，泛型类其实归根结底只有一个<code>raw type</code>。</p><p>考虑如下代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T,U&gt; &#123;<br>    <span class="hljs-keyword">public</span> T first;<br>    <span class="hljs-keyword">public</span> U second;<br>    Pair(T a, U b) &#123;<br>        first = a;<br>        second = b;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123; <span class="hljs-comment">// 类型擦除后的 raw type，编译器会自动处理类型转换</span><br>    <span class="hljs-keyword">public</span> Object first;<br>    <span class="hljs-keyword">public</span> Object second;<br>    Pair(Object a, Object b) &#123;<br>        first = a;<br>        second = b;<br>    &#125;<br>&#125;<br>Pair&lt;Integer,String&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>,<span class="hljs-string">&quot;456&quot;</span>); <br>System.out.println(a.getClass()); <span class="hljs-comment">// Class Pair</span><br>System.out.println(a.second.length()); <br></code></pre></div></td></tr></table></figure><p>可以看到，<code>a.getClass()</code>并不能返回什么 Class Pair&lt;Integer,String&gt;，编译期会将泛型的类型<strong>擦除</strong>（擦除后获得的 raw type 为它继承的第一个类&#x2F;接口，如果没有，则是 Object，所以本书建议将带方法的接口放在前，而标签接口，如<code>RandomAccess</code>等接口放到最后，以防止添加更多类型转换），所有的泛型类的实例其实都是<code>raw Type</code>类型。只不过编译器会自动处理类型转换罢了。</p><h1 id="为什么要泛型"><a href="#为什么要泛型" class="headerlink" title="为什么要泛型"></a>为什么要泛型</h1><p>泛型机制相较于杂乱地使用 Object 变量进行强制类型转换的代码来说更有<strong>安全性</strong>和可读性，它对使用容器类型尤其有用。</p><p>我认为 Java 中的泛型，实际上就是编译期的类型检查机制，对变量类型进行各种各样的约束，从而保证不出错误，同时也方便编写。比如，要求泛型类必须实现 Comparable 接口（这个接口也是泛型的，它标识能够与什么对象进行比较），这样就能够方便大胆地对泛型变量调用<code>compareTo</code>方法而不用担心抛出异常，因为这是编译器保证了的。</p><p>比如，我之前按照《算法》中的排序算法，编写如下代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(Comparable[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) <span class="hljs-comment">// 每一次外层排序排好一个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>; j &gt; i; j--)<br>            <span class="hljs-keyword">if</span> (less(arr[j], arr[j - <span class="hljs-number">1</span>]))<br>                exch(arr, j, j - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里，将 Comparable 数组作为参数，它抛出一个警告，要求不要使用 raw type，这里可以改成<code>Comparable&lt;T&gt;</code>，但也可以这样改——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(T[] arr)</span> &#123; <span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>好家伙，这样不是看起来更舒服一些？而且能让编译器替我们做检查，妙哇！</p><h2 id="extends-和-super"><a href="#extends-和-super" class="headerlink" title="extends 和 super"></a>extends 和 super</h2><p>泛型中可以有两个关键字——<code>extends</code>和<code>super</code>。</p><h2 id="泛型之前"><a href="#泛型之前" class="headerlink" title="泛型之前"></a>泛型之前</h2><p>Java 在提供泛型之前，泛型是通过<strong>继承</strong>实现的（啥？）。考虑没有泛型的 ArrayList——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span> &#123; <span class="hljs-comment">// before generic classes</span><br>    <span class="hljs-keyword">private</span> Object[] elementData; <span class="hljs-comment">// 其实现在也是这样的</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123; . . . &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object o)</span> &#123; . . . &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当我们试图获取一个值的时候，必须要对它进行强制类型转换——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">files</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>files.add(<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 这是完全没有约束的，全靠程序员“自觉”</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> (String) files.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 有点麻烦，还可能出事，因为……</span><br>files.add(<span class="hljs-number">123</span>); <span class="hljs-comment">// 合法的！</span><br><span class="hljs-type">String</span> <span class="hljs-variable">anotherOne</span> <span class="hljs-operator">=</span> (String) files.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 要抛 ClassCastException 异常啦</span><br></code></pre></div></td></tr></table></figure><p>显然，这里如果加入泛型，就能在编译期进行语法检查，防止这种操作了。</p><h1 id="为什么不能声明泛型数组？"><a href="#为什么不能声明泛型数组？" class="headerlink" title="为什么不能声明泛型数组？"></a>为什么不能声明泛型数组？</h1><p>原因就是，会<strong>绕过类型检查</strong>。编译器无法发现类型错误，</p><p>考虑如下代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T1,T2&gt;&#123;<br>    T1 first;<br>    T2 second;<br>    Pair(T1 t1,T2 t2) &#123;<br>        <span class="hljs-built_in">this</span>.first=t1;<br>        <span class="hljs-built_in">this</span>.second=t2;<br>    &#125;<br>&#125;<br><br>Pair&lt;Integer,String&gt;[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//这里只能用 raw type 才能过编译</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;Integer,String&gt;(<span class="hljs-number">123</span>,<span class="hljs-string">&quot;456&quot;</span>); <span class="hljs-comment">// 正常操作</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;String,Double&gt;(<span class="hljs-string">&quot;www&quot;</span>,<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 过不了</span><br>Object[] objArr = (Object[]) arr;<br>objArr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;String,Double&gt;(<span class="hljs-string">&quot;www&quot;</span>,<span class="hljs-number">1.0</span>); <span class="hljs-comment">// No Problem! </span><br></code></pre></div></td></tr></table></figure><p>假设泛型数组是合法的，则用户可以向上转型，将其转化为<code>Object</code>数组，然后向其插入其它类型的该泛型，这在语法上是没有任何问题的——它们的 raw type 都是一样的嘛，所以不会抛<code>java.lang.ArrayStoreException</code>（如果试图向该<code>Object</code>数组里插入别的类型就会抛这个异常），只有到使用中才会发现问题，抛出<code>java.lang.ClassCastException</code>。</p><p>总之，泛型数组会导致编译期的泛型机制失去约束的意义，需要泛型数组应当使用<code>ArrayList</code>。</p><p>但是，<strong>泛型数组可以作为方法参数传入</strong>，还蛮奇妙的。或许是因为，作为函数参数使用时，其使用是方法设计者规定，而非是用户规定的，所以它是被“封装”了的，能够避过用户的骚操作。这是 Java 对方法设计者的信任吗？</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构为什么使用接口定义？</title>
    <link href="/2020/12-11%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%EF%BC%9F.html"/>
    <url>/2020/12-11%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%EF%BC%9F.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><blockquote><p>其实后来才想到，抽象类也是可以作为数据结构的抽象层的，但是问题是 Java 是单继承的语言，如果使用抽象类作为抽象层，这就会导致一个数据结构只能为某种或某系列数据结构，这样的关系只能是树形的。</p><p>而这是不符合常理的——你可以把一个 List 看作栈，看作队列，看作数组，甚至看作 Map 和 Set（这当然可以实现！只要提供相同接口，管它里面是什么实现！只是不能达到哈希表的查询速度罢了）现实中各个数据结构的关系应当是一种有向无环图的关系，<strong>一个具体的底层实现对应什么数据结构实际上是取决于我们如何看待它的</strong>。而看待它的方式实际上也就是对它的操作方式，也就是接口。所以 Java 将接口作为数据结构的定义是比较合理的。</p></blockquote><p>Java 容器框架中的接口为</p><p><img src="https://i.loli.net/2020/12/11/6lH8Bd3CPqsFnkU.png"></p><p>框架中的类为</p><p><img src="https://i.loli.net/2020/12/11/K5yJzamr18u9YOg.png"></p><blockquote><p>这张图似乎已经过时了，ArrayQueue 这个类没了，现在要使用队列应当使用 Queue 作为声明类型，LinkedList 或 ArrayList，ArrayDeque 作为实际类型。</p><p>Stack 没有出现在这里，因为它是 vector 实现的，老黄历了。</p></blockquote><p>这是不符合我的常识的，为什么类似 Queue，List 这样的数据结构要用接口来定义，而不是用一个抽象类之类的来定义？</p><p>我认为，这里牵扯到了……数据结构的<strong>本质</strong>问题，一个数据结构究竟是因为什么而成为这个数据结构？比如讨论队列，我们知道，队列能够在头部删除元素，能够在尾部删除元素，队列可以用数组实现，也可以用链表实现……再比如讨论二叉堆，堆有两个基本方法 swim 和 sink，它们实现删除堆顶，插入新元素等功能，我们可以使用数组实现，也可以使用树实现。</p><p>答案是显然的，一个数据结构是因为对它的操作方法（算法）从而成为这个数据结构，因为它的具体实现的变化并不影响这个数据结构的实质（这么说是有点形而上学的，我认为接口与实现的关系，就如形式与内容的关系，而不是瓶与酒的关系，它们之间是会互相制约的）。</p><p>在这里，将数据结构定义为接口，将接口和实现分开，这似乎是现代容器类库常用的……设计模式。</p><p>以 Abstract 开头的一些抽象类，是对这些接口的部分实现（从而方便类库实现者的编写，实现接口中所有方法有时候太麻烦了），这里实际上可以通过在接口的方法中使用 default 关键词实现相同的作用……为什么 Java 容器类设计者没有这样考虑？</p><blockquote><p>  因为当时还没有 default 关键字。</p></blockquote><p>接口与实现分离，也能让我们能够方便地更改选择的实现，而不需要对代码进行太多改动，比如——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br></code></pre></div></td></tr></table></figure><p>我们定义一个<code>List&lt;Integer&gt;</code>接口对象，赋给它一个<code>ArrayList&lt;Integer&gt;</code>。然后对它进行一些操作。然后经过几次迭代，我突然不想用<code>ArrayList</code>了，<code>LinkedList</code>更符合需求，这时候我们只需要更改一处地方即可。并且我们不需要担心其后会出现什么 bug，或者编译错误之类，因为这个接口对象所能够调用的方法是受其声明类型决定的。</p><p>还可以这样认为，声明类型是出于我们的需要，是从问题出发而选择的，声明类型就是在这个问题中，我们对这个对象的<strong>看待方式</strong>。比如，我们喝水时，我们是将水看待成一种能满足一定生理需求的东西，而不将它看待成氢氧化合物，不看待成液体，不看待成物质（当然，这些都是水的种概念），因为只有“满足一定生理需求的东西”才是最接近问题空间的。问题不是它究竟是什么（这种定义是可以无限地下的），而在于我们需要它是什么。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点击 Run 按钮时，JVM 做了什么？</title>
    <link href="/2020/12-10%E7%82%B9%E5%87%BBRun%E6%8C%89%E9%92%AE%E6%97%B6%EF%BC%8CJVM%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.html"/>
    <url>/2020/12-10%E7%82%B9%E5%87%BBRun%E6%8C%89%E9%92%AE%E6%97%B6%EF%BC%8CJVM%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>考虑如下 Java 代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Student.java 文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayName</span><span class="hljs-params">()</span> &#123;<br>        System.out.printf(<span class="hljs-string">&quot;my name is %s\n&quot;</span>, name);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Main.java 文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stud</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;arisa&quot;</span>);<br>        stud.sayName();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当执行 Main 类的 main 方法时（这里就假设我们在使用 IDEA，点击了 main 前面的：arrow_forward: 按钮吧！）</p><ol><li>首先，调用 javac，将 Main.java 编译成 java 字节码文件，即 Main.class。</li><li>使用 java 执行 Main.class 文件。这时，一个 JVM 进程被启动，它通过 classpath 路径找到 Main.class 文件，使用类加载器（<code>ClassLoader</code>）将<strong>类信息加载到运行时数据区的方法区</strong>内。然后，在堆中生成指向类信息的<code>Class</code>对象。这是 Java 的类加载过程（这里得提出一个问题，Class 对象中究竟存储了什么？不会只有一个指向类信息的指针和一堆偏移量吧？）。然后是链接和初始化。</li><li>JVM 找到 Main 的主程序入口（应该是通过 Class 对象找到的），执行 main 方法。</li><li>main 方法的第一句为<code>String stud = new Student(&quot;arisa&quot;)</code>，它要求 JVM 创建一个 Student 对象的实例。JVM 将首先检查 Student 类是否被加载（如果没有加载，则方法区中不存在 Student 类的信息，因此无法创建实例）。这里显然是未被加载的。因此，将会进行类的加载过程。<br>进行处理的首先是<code>AppClassLoader</code>。（当然，在这之前总得将 Student.java 编译并弄到内存里）它将委托它的父类加载器<code>ExtClassLoader</code>进行加载，<code>ExtClassLoader</code>再委托它的父类加载器<code>BootstrapClassLoader</code>进行加载。<code>BootstrapClassLoader</code>没有父类加载器，因而它将尝试加载，加载失败后，它将返回，由<code>ExtClassLoader</code>进行加载，其也将加载失败，由<code>AppClassLoader</code>进行加载。这就是类加载器的所谓双亲委派机制。Main.class 也是如此加载的。</li><li>类加载后，JVM 在<strong>堆</strong>中分配一个新的 Student 实例的内存。然后调用构造函数初始化 Student 的实例。每个 Student 的实例都持有对<strong>方法区中 Student 类信息</strong>的引用。之后，将该实例的地址赋给 stud。这里的 stud 称为对象引用，它指向的堆中实际的对象称为对象实例。stud 存储在栈中，而它指向的对象实例存在于堆中。</li><li>然后它准备执行 stud.sayName()。JVM 根据 stud 这个引用找到在堆中的 Student 对象实例，然后根据 Student 对象持有的引用定位到方法区中 Student 的类信息中的方法表，获得 sayName() 的字节码地址。</li><li>将 stud 作为参数（应该……如此），执行 sayName() 方法。（就像 python 中定义实例方法需要显式指明 self 一样，实例方法其实是需要对象实例作为参数的，因为实例方法其实也是只存在一个的，就如静态方法一样，它无法保存类的实例的地址在方法里，所以类的实例要传递给实例方法）。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于类的加载</title>
    <link href="/2020/12-10%E5%85%B3%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD.html"/>
    <url>/2020/12-10%E5%85%B3%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><p>当我们 new 一个对象，或者使用对象的静态方法，静态变量等操作时，JVM 会先检查类是否被加载（我们知道，它被加载到方法区），如果未加载，则使用类加载器（<code>ClassLoader</code>）将类进行加载并<strong>初始化</strong>。这里需要注意的是，初始化并非是一定发生的。调用类的静态常量（静态常量存在方法区中，在链接阶段被初始化，静态变量也存在于方法区中，不过要在初始化阶段通过<code>&lt;clinit&gt;()</code>方法初始化）等操作并不会触发类的初始化。</p><p>类的生命周期可以分为 7 步——<strong>加载</strong>，<strong>验证</strong>，<strong>准备</strong>，<strong>解析</strong>，<strong>初始化</strong>，<strong>使用</strong>和<strong>卸载</strong>。其中，类的初始化过程为前五步。</p><p>验证，准备，解析过程可以归结为<strong>链接</strong>过程。因而，一般说类的初始化过程分为三步——<strong>加载</strong>，<strong>链接</strong>，<strong>初始化</strong>。</p><p>再次强调，类的初始化不是一定发生的。但是如果要使用一个类，其加载和链接是必定发生的。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载主要完成——</p><ol><li>通过全类名获取定义类的二进制字节流（通过 ZIP，JAR 包，Class 文件以及其他）到内存中</li><li>将字节流代表的静态存储结构（也就是 Class 字节码）转换为方法区的<strong>运行时</strong>数据结构</li><li>在<strong>堆</strong>（！）中生成一个代表该类的<code>java.lang.Class</code>对象，它是方法区的这些数据的<strong>访问入口</strong></li></ol><p>总之，是把 Class 字节码加载到方法区中，然后在堆中生成<code>Class</code>对象作为其入口。</p><p>其中，<strong>第一步（获取类的二进制字节流）是高度可自定义的。可以自定义类加载器（重写类加载器的<code>loadClass()</code>方法）来控制字节流的获取方式。</strong></p><blockquote><p>数组类型不通过类加载器执行，而是 JVM 直接创建。</p></blockquote><p>关于这一步，<strong>类加载器</strong>和<strong>双亲委派机制</strong>是需要学习的。</p><p>加载阶段和链接阶段是可以并行执行的。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是链接的第一步，它主要是验证 Class 文件（当然，已经被加载到方法区了）的合法性。</p><p><img src="https://i.loli.net/2020/12/10/BPLWlZMCSYReHDc.png"></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段主要<strong>为 static 变量在方法区（！）中分配内存并设置初始值</strong>。</p><p>该阶段，静态变量和静态常量的行为是不同的，比如我们定义<code>public static int variable = 123; public static final int constant = 456;</code>，在这一步中，<code>variable</code>会被赋<code>int</code>型的零值（0），而<code>constant</code>会被赋值 456。这表明——</p><ul><li>静态常量的初始化在准备（链接）阶段就被完成。</li><li>静态变量的<strong>真正的</strong>初始化在类初始化过程<code>&lt;clinit&gt;()</code>方法中进行。在准备阶段只会被赋变量类型的初始值。</li></ul><p>因此，调用类的静态常量不会触发类的初始化操作，就是因为其在准备阶段已经被初始化过了，可以直接使用。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析就是将常量池中的符号引用替换为直接引用的过程。解析动作主要针对类或接口，字段（field），类方法，接口方法，方法类型，方法句柄和调用限定符这 7 类符号引用进行。</p><p>这里的直接引用是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄。在运行时，这些符号引用必须被转换成直接引用，因此 JVM 才能明确获得它们的位置。比如，当程序要执行一个方法，系统就需要明确知道这个方法所在的位置。JVM 为每个类都准备了一个方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只需要知道它在方法表中的偏移量。（有点麻，这个之后肯定还得继续学习）</p><p>总之，<strong>解析是虚拟机将常量池中的符号应用替换为直接引用的过程，也就是得到类或字段，方法在内存中的指针或偏移量</strong>。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化是类加载的最后一步，其真正地执行类中定义的 Java 程序代码（static 声明和 static 初始化块）。它会合并所有 static 的代码，将其组合为<code>&lt;clinit&gt;()</code>方法并执行。类的初始化并非是一定会被执行的。</p><blockquote><p>类的初始化只有在主动使用类（静态变量，静态方法，实例变量，实例方法……）时出现，其有五种情况——</p><ol><li>当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时，比如 new 一个类，读取一个静态字段（未被 final 修饰）、或调用一个类的静态方法时。<ul><li>当 jvm 执行 new 指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当 jvm 执行 getstatic 指令时会初始化类。即程序访问类的静态变量（不是静态常量，常量会被加载到运行时常量池）。</li><li>当 jvm 执行 putstatic 指令时会初始化类。即程序给类的静态变量赋值。</li><li>当 jvm 执行 invokestatic 指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 Class.forname(“…”).newInstance() 等等。 如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 （包含 main 方法的那个类），虚拟机会先初始化这个类。</li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类。</li><li><strong>「补充 <a href="https://github.com/Snailclimb/JavaGuide/issues/745">issue745</a>」</strong> 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol></blockquote><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>类的卸载就是该类的<code>Class</code>对象被 GC。</p><p>类的卸载有三个前提——</p><ol><li>该类所有实例对象被 GC，即堆中不存在该类的实例对象</li><li>该类没有在其它任何地方被引用</li><li><strong>该类的类加载器实例被 GC</strong></li></ol><p><strong>JDK 自带的三个类加载器 BootstrapClassLoader,ExtClassLoader,AppClassLoader 不会被 GC，因而它们加载的类不会被卸载</strong>。</p><p>学这些只是让我更加清楚地认识到，JVM 和字节码是必须要深入学习的…</p><h1 id="类加载器（ClassLoader）"><a href="#类加载器（ClassLoader）" class="headerlink" title="类加载器（ClassLoader）"></a>类加载器（ClassLoader）</h1><p>类加载器的作用就是将。class 文件加载到内存的方法区中。</p><p>Java 内置了三个 ClassLoader。除了 BootstrapClassLoader，其他类加载器都由 Java 实现，它们都继承自 java.lang.ClassLoader。按加载的优先级，它们由顶层向底层分为：</p><ol><li><code>BootstrapClassLoader</code>是启动类加载器，它由 C++实现，加载<code>%JAVA_HOME%/lib</code>目录下的 jar 包和类，或者被<code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><code>ExtensionClassLoader</code>是扩展类加载器，它加载目录<code>%JRE_HOME%/lib/ext</code>下的 jar 包和类，或者被<code>java.ext.dirs</code>系统变量所指定路径下的 jar 包。</li><li><code>AppClassLoader</code>是应用程序类加载器，它面向用户，加载当前应用 classpath 下所有 jar 包和类。</li></ol><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>每一个类都有加载它的类加载器。类加载器默认使用<strong>双亲委派模型</strong>。即类加载时，系统（该类加载器）首先判断当前类是否被加载过，如果已加载则直接返回，如果未加载，则尝试加载。</p><p>加载时，该类加载器首先会把请求委派给父类加载器的<code>loadClass()</code>处理。因此，该请求会被递归传送到顶层的启动类加载器<code>BootstrapClassLoader</code>中。当父类加载器无法处理时，才由自己处理。当父类加载器为 null 时，会启动类加载器<code>BootstrapClassLoader</code>作为父类加载器。</p><p><strong>双亲委派模型可以避免类的重复加载，并保证 Java 的核心 API 不被篡改</strong>。</p><p>应该注意，这里的“双亲”只是用来指代“辈分”，而不是用来指代“父母”。</p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通过继承<code>ClassLoader</code>，我们可以自定义自己的类加载器。</p><p><img src="https://i.loli.net/2020/12/10/iGmcEZOxaTwkBJU.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Java 运行时的内存区域</title>
    <link href="/2020/12-08%E5%85%B3%E4%BA%8EJava%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.html"/>
    <url>/2020/12-08%E5%85%B3%E4%BA%8EJava%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>每运行一个 Java 程序，它就要启动一个 Java 虚拟机的实例，所以说，Java 虚拟机的生命周期是和进程相同的（或许这里顺序该交换一下），一个 Java 虚拟机维护一个进程。</p><p>Java 虚拟机会将其管理的内存划分为若干不同的数据区域——</p><p><img src="https://i.loli.net/2020/12/08/eMzuqLdg4sJCWQS.png"></p><p>可以看到，Java 运行时管理的内存区域包括程序计数器（PC），虚拟机栈（VM Stack），本地方法栈（Native Method Stack），堆（Heap），方法区和直接内存。</p><p>其中，每个线程都拥有（且<strong>私有</strong>）——</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p>以下区域被所有线程共享——</p><ul><li>堆</li><li>方法区（可以认为方法区是虚拟机的一种规范，对于 HotSpot 虚拟机，元空间（JDK1.8 以后）是它的实现。所以可以说元空间就是方法区）</li><li>直接内存（不是运行时数据区的一部分）</li></ul><h1 id="运行时各数据区域"><a href="#运行时各数据区域" class="headerlink" title="运行时各数据区域"></a>运行时各数据区域</h1><p>简述下各区域及其作用。</p><h2 id="Java-虚拟机栈（VM-Stack）"><a href="#Java-虚拟机栈（VM-Stack）" class="headerlink" title="Java 虚拟机栈（VM Stack）"></a>Java 虚拟机栈（VM Stack）</h2><p>Java 内存可以粗糙地区分为<strong>堆内存</strong>（heap）和<strong>栈内存</strong>（stack）。其中，<strong>每一个线程的虚拟机栈就是这里的栈，或者说是这里的栈中局部变量表部分</strong>（局部变量表存储当前函数的局部变量，包括编译期可知的 8 个基本数据类型和对象引用）。其作用就如 C 语言中的函数调用栈。其存储一个个<strong>栈帧</strong>（Stack frame）。栈帧会在 return 语句或抛出异常后弹出。</p><blockquote><p>栈中只存储对象的引用，对象的实例一般来说存放在堆中。但是，如果某方法中使用的对象没有被返回，没有被外界调用，该对象是可以分配在栈上的。这种机制称为<strong>逃逸分析</strong>。</p></blockquote><blockquote><p>每一个栈帧都拥有：局部变量表，操作数栈，动态链接，方法出口信息。（这啥啊……）</p></blockquote><p>Java 虚拟机栈会出现两种错误——<code>StackOverFlowError</code>和<code>OutOfMemoryError</code>。</p><p><code>stackOverFlowError</code>：若栈的深度超过 Java 虚拟机的最大深度，此时若不允许动态扩展栈的内存大小，则抛出该错误。（或许 99%的<code>stackOverFlowError</code>错误都是因为递归忘记写出口了吧：）</p><p><code>OutOfMemoryError</code>：Java 虚拟机中无空闲内存，且垃圾回收器无法提供更多内存时，该错误会被抛出。</p><p>每个线程都有自己的虚拟机栈，因为它们都要进行函数调用，在线程切换后，要能够恢复此时的上下文。基于相同的理由，<strong>每个对象也都私有自己的 PC</strong>。</p><h2 id="程序计数器（PC）"><a href="#程序计数器（PC）" class="headerlink" title="程序计数器（PC）"></a>程序计数器（PC）</h2><p>程序计数器（Program Counter Register）可以认为是一个线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>。分支，循环，跳转，异常处理等功能都需要 PC 来完成。在多线程切换时，每个线程都需要记录当前线程执行的位置，从而在获得运行权限的时候能够从切换前的位置继续执行（<strong>线程恢复</strong>），这也是 PC 的工作。</p><p>程序计数器是唯一不会出现<code>OutOfMemoryError</code>的内存区域。</p><blockquote><p>PC 在执行 native 方法的时候，其值为 undefined（？），即不起作用。</p></blockquote><h2 id="本地方法栈（Native-Method-Stack"><a href="#本地方法栈（Native-Method-Stack" class="headerlink" title="本地方法栈（Native Method Stack)"></a>本地方法栈（Native Method Stack)</h2><p>本地方法栈同虚拟机栈功能相似，唯一的区别在于虚拟机栈用来执行 Java 方法，本地方法栈则用来执行 Native 方法。</p><h2 id="堆（Heap）——存放对象实例"><a href="#堆（Heap）——存放对象实例" class="headerlink" title="堆（Heap）——存放对象实例"></a>堆（Heap）——存放对象实例</h2><blockquote><p>这里的堆指的并非数据结构中的堆。其用的是 heap 的英文释义——<strong>（凌乱的）一堆；许多；大量</strong>。</p></blockquote><p>堆是 JVM 管理的最大的一块内存区域。其唯一的目的在于存放对象的实例。<strong>几乎所有</strong>的对象实例（和数组）都分配在堆中（一些技术，如 JIT，逃逸分析的成熟会导致一些微妙的变化——一些对象不分配在堆中而是栈中）。堆是垃圾收集器管理的主要区域，因此也被称作** GC 堆（Garbage Collected Heap）**。</p><p>堆分为三部分——新生代（Young Generation），老年代（Old Generation）和永久代（Permanent Generation），JDK1.8 后，永久代被移除，取而代之的是元空间（MetaSpace）。或者说，方法区的实现由永久代改为了元空间。</p><p>堆是各线程共享的。因而是线程不安全的。</p><p><img src="https://i.loli.net/2020/12/09/j7AZXEqspLxhr2S.png"></p><p>新生代包括 Eden（亚当，意义不言而喻）区和两个 Survivor 区（称为 s0，s1，或 from，to 区）。对象一般首先在 Eden 区分配，在经过一次<strong>新生代垃圾回收</strong>后，如果对象还存活，则进入 s0，s1，年龄加 1（或初始年龄设为 1），年龄增长到一定程度则晋升到老年代。</p><p>堆中容易出现<code>OutOfMemoryError</code>错误。其主要有几种情况——</p><ul><li><code>OutOfMemoryError: GC Overhead Limit Exceeded</code>：JVM 花太多时间进行垃圾回收，并且只能回收很少的堆空间。</li><li><code>OutOfMemoryError: Java heap space</code>：创建新对象时堆空间用尽。（堆空间与设定有关，与计算机内存无关）</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与堆一样，也是各个线程共享的。它用于存储已被虚拟机加载的<strong>类信息</strong>（即反射所使用的信息。这些信息是用来描述类的，因此也叫类的元数据）、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码</strong>等数据。</p><p><strong>在规范中，方法区逻辑上属于堆。但方法区又有一个别名非堆（Non-Heap），与堆区别开来</strong>。</p><p>在 Java 8 之后，方法区的实现改为元空间，它使用直接内存。最大元空间大小默认为 unlimited，因此，元空间溢出的可能性更小。如果溢出，说明计算机的物理内存被用尽。</p><blockquote><p>元空间会抛出<code>OutOfMemoryError: MetaSpace</code>错误。</p></blockquote><h3 id="方法区与永久代的关系"><a href="#方法区与永久代的关系" class="headerlink" title="方法区与永久代的关系"></a>方法区与永久代的关系</h3><blockquote><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p><p>——引用自 <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_251-%e6%96%b9%e6%b3%95%e5%8c%ba%e5%92%8c%e6%b0%b8%e4%b9%85%e4%bb%a3%e7%9a%84%e5%85%b3%e7%b3%bb">JavaGuide</a></p></blockquote><h3 id="运行时常量池（Runtime-constant-pool）"><a href="#运行时常量池（Runtime-constant-pool）" class="headerlink" title="运行时常量池（Runtime constant pool）"></a>运行时常量池（Runtime constant pool）</h3><p>运行时常量池是方法区的一部分，其用于存放编译期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。<strong>字符串常量池在堆中，运行时常量池在方法区中</strong>（元空间中）。</p><blockquote><p><del>字面量指代码文件中直接给定的量，如”hello”, 3, 233l 等。</del></p><p>符号引用简单来说就是包含一定信息的符号，经过几层解析后，其最终指向一个具有类型和层次的字符串。见 <a href="https://www.zhihu.com/question/30300585/answer/51335493">JVM 里的符号引用如何存储？</a></p></blockquote><p>常量池中存储对象的引用，实际对象仍旧存储在堆中。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存不是虚拟机运行时数据区的一部分，但是其会经常被频繁使用。其也会抛出<code>OutOfMemoryError</code>错误。</p><blockquote><p>JDK1.4 中新加入的 <strong>NIO(New Input&#x2F;Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>——同上</p></blockquote><h1 id="关于常量池"><a href="#关于常量池" class="headerlink" title="关于常量池"></a>关于常量池</h1><p><strong>只要使用 new 方法，便需要创建新的对象。</strong></p><h2 id="String-类的常量池"><a href="#String-类的常量池" class="headerlink" title="String 类的常量池"></a>String 类的常量池</h2><h3 id="String-对象的两种创建方式"><a href="#String-对象的两种创建方式" class="headerlink" title="String 对象的两种创建方式"></a>String 对象的两种创建方式</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>; <span class="hljs-comment">// 先检查常量池中有无&quot;abcd&quot;，若无则在常量池中创建对象，然后再让 s1 指向该对象，否则直接指向</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abcd&quot;</span>); <span class="hljs-comment">// 在堆中创建</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abcd&quot;</span>); <span class="hljs-comment">// 在堆中创建</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> s3.intern(); <span class="hljs-comment">// 检查常量池</span><br>System.out.println(s1==s2); <span class="hljs-comment">//false</span><br>System.out.println(s2==s3); <span class="hljs-comment">//false</span><br>System.out.println(s1==s4); <span class="hljs-comment">//true，它们指向同一个常量池中的对象</span><br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/09/C62kwnioRW5uFaO.png"></p><p>如图。当使用 new 创建的时候，则创建在堆中，通过字面量创建则创建在（或者指向）常量池中。当然，字符串常量池也在堆中。</p><p>也可以使用 intern 方法，这是一个 Native 方法，它检查常量池，如果包含，则直接返回常量池中该字符串的引用，如果不包含，<strong>则在常量池中记录对该字符串的引用（此处存疑），并返回该引用</strong>。</p><p>这里好像有问题，见如下代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br>System.out.println(s1 == s2); <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><p>这里，如果 intern 的行为是在常量池中记录对该字符串的引用并返回的话，s2 理应和 s1 指向同一个对象，但是结果确是 false……怪东西。</p><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串拼接会重新创建对象，所以应当尽量避免多个字符串的拼接，如果需要拼接，应当使用 StringBuilder（线程不安全）和 StringBuffer（线程安全，但性能较差）类。</p><p>两个常量池中的对象拼接，其结果在常量池中，堆上创建的对象（与堆上的对象或常量池中对象）拼接则创建在堆中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<span class="hljs-comment">//常量池中的对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2; <span class="hljs-comment">//在堆上创建的新的对象      </span><br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<span class="hljs-comment">//常量池中的对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s1 + <span class="hljs-string">&quot;ing&quot;</span>; <span class="hljs-comment">// 堆中对象和常量池中对象拼接，仍然在堆中创建</span><br>System.out.println(s3 == s4);<span class="hljs-comment">//false</span><br>System.out.println(s3 == s5);<span class="hljs-comment">//true</span><br>System.out.println(s4 == s5);<span class="hljs-comment">//false</span><br>System.out.println(s3 == s6);<span class="hljs-comment">//false</span><br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/09/5Ngx1dvKGaIpZ3V.png"></p><h3 id="new-String-“hello”-创建几个字符串对象？"><a href="#new-String-“hello”-创建几个字符串对象？" class="headerlink" title="new String(“hello”) 创建几个字符串对象？"></a>new String(“hello”) 创建几个字符串对象？</h3><p>答案是一个或两个。JVM 首先检查常量池中是否存在字符串常量”hello”。如果存在，则只在堆中创建一个字符串常量”hello”，如果不存在，则先在池中创建，再在堆中创建。因此是一个或两个。</p><h2 id="包装类型的常量池"><a href="#包装类型的常量池" class="headerlink" title="包装类型的常量池"></a>包装类型的常量池</h2><p><strong>字符串常量池存在于堆中</strong>，<strong>而运行时常量池存在于方法区中</strong>。</p><p>八种包装类型中，六种包装类型都实现了常量池技术。它们是四种整型 Byte，Short，Integer 和 Long，Boolean 和 Character，两种浮点数 Float 和 Double 没有实现。</p><p>四种整型包装类创建了 [-128,127] 范围类的相应类型的缓存数据，Character 实现了数据在 [0, 127](从<code>\u0000</code>到<code>\u007f</code>）范围的缓存数据，Boolean 直接返回 True 和 False（也就是说，所有 Boolean 的变量，其值为 true 的都&#x3D;&#x3D;常量池中的 TRUE，其值为 false 的都&#x3D;&#x3D;常量池中的 FALSE)。</p><p>在自动装箱（如通过字面量初始化）时，Java 在编译时会自动封装代码，从而使用常量池中的对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>; <span class="hljs-comment">// 其将被编译成 Integer i1 = Integer.valueOf(40);</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">40</span>); <span class="hljs-comment">// 不利用缓存，直接在堆中创建新对象</span><br>System.out.println(i1==i2);<span class="hljs-comment">//false</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) <br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)]; <span class="hljs-comment">// 直接利用方法区中的缓存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>同时，需要明确，<strong>运算符和&#x3D;&#x3D;操作符不适用于包装类</strong>，因而其会被拆箱后进行运算。但是实际工作中，不应当依赖这种自动装箱机制，对于包装类，应当使用 equals 方法进行比较。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">40</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span>;<br>System.out.println(i3 == i1 + i2); <span class="hljs-comment">// true, 其会被自动拆箱为 i3.intValue() == i1.intValue() + i2.intValue();</span><br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/10/TZJIqwKVWfnA7pY.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些经典排序算法及其 Java 实现</title>
    <link href="/2020/12-07%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6Java%E5%AE%9E%E7%8E%B0.html"/>
    <url>/2020/12-07%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6Java%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>学习算法总是从排序开始的，我这再次重新学习也不例外。主要根据《算法图解》，《算法第四版》这几本书进行重新学习，其中算法第四版是值得特别学习的。</p><p>这里尽量按算法第四版中讲述的顺序来。从最糟糕的选择排序，到插入排序，到优化插入排序的希尔排序（终于进入 n*logn 的领域了！），再到归并排序，快排，堆排序……</p><p>下面的排序算法都默认按照升序排列。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是最简单的排序，它每次选择数组中一个最小或最大的元素，将其置于数组的首位，然后对子数组进行相同操作，直到整个数组有序。</p><p>下面是选择排序的代码——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">select_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123; <span class="hljs-comment">// 将 a[i] 同 a[i+1..arr.length] 中的最小值交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> i; <span class="hljs-comment">// 这里的 min 是最小元素的 index</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; len; j++)<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min]) <br>                min = j; <span class="hljs-comment">//发现了新的最小值，更新 min</span><br>        exch(arr, i, min); <span class="hljs-comment">//交换 arr[i] 和 arr[min]</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>选择排序的比较次数约为 n^2&#x2F;2 次，交换次数为 n 次。选择排序的比较次数和交换次数不随输入的变化而变化，无论输入是完全随机还是基本有序，这说明选择排序<strong>并没有利用到输入数据的原始状态</strong>。插入排序改善了这一点。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序遵循这样的逻辑——将一个元素插入到已经有序的元素内。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123; <span class="hljs-comment">//遍历 arr[1..len]，将其每一位都插入到其前面的数组中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= <span class="hljs-number">1</span>; j--) <span class="hljs-comment">//将 arr[j] 插入到 arr[0..j] 中，其中 arr[0..j] 必定有序</span><br>      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) <span class="hljs-comment">//这里的 if 的判断可以加到 for 循环里，就不需要这个 if 了，但是这样逻辑更清楚一些</span><br>        exch(arr,j,j-<span class="hljs-number">1</span>);<span class="hljs-comment">// 如果待插入元素小于其前面的元素（逆序），则交换</span><br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">//如果不小于，则说明待插入元素已经到达正确位置</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>插入排序的最优比较次数是 n，最优交换次数是 0，最坏（完全逆序，每次插入需要插到数组首位）比较次数是 n^2&#x2F;2，最坏交换次数是 n^2&#x2F;2，平均（每次插入都正好插到正中间）交换次数是 n^2&#x2F;4，平均比较次数是 n^2&#x2F;4。显然，插入排序是优于选择排序的。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是插入排序的改进。它定义间隔 h，以此将数组分为 h 个子数组（如，定义 h 为 2，则数组可以分为 0，2，4，6……和 1，3，5，7……），对任一子数组都进行插入排序（这使不相邻的元素也能够进行交换，因此能够减少交换次数），使任一子数组都有序，这时原数组称为 h 有序数组；然后减少 h，重复以上过程，直到最后 h 达到 1，此时的排序等同于插入排序，从而保证原数组有序。（可以认为，希尔排序的过程就是整体从无序越来越趋近有序的过程，前面提到过，插入排序对基本有序的数组是非常适合使用的）</p><p>这里的 h 一般使用等比数列 1&#x2F;2(3^n - 1) 中（它的值为 1,4,13,40,121,364,1093……）大于等于 n&#x2F;3 的第一个元素，这里的 n 为数组长度。之后，每次将 h 除以 3（获取数列中前一项），重复操作，直到最后一次 h 为 1，操作后数组有序。</p><p>比如对数组</p><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123; 1, 10, 2, 6, 4, 6, 8, 1, 0, 3, 5, 9, 3, 2 &#125;</span><br></code></pre></div></td></tr></table></figure><p>n 为 14，则 14&#x2F;3 &#x3D;&#x3D; 4， 选择 4 为 h，则分割出来的子数组为——</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">// 横着看<br>1<span class="hljs-number"> 4 </span>0 3<br>10<span class="hljs-number"> 6 </span>3 2<br>2<span class="hljs-number"> 8 </span>5<br>6<span class="hljs-number"> 1 </span>9<br></code></pre></div></td></tr></table></figure><p>上代码！</p><p>这里对每一次的 h 有序数组中的各子数组是在同一个 for 循环里（for (int i &#x3D; h; i &lt; len; i++)）进行的，它对任一个下标为 i 的元素都插入到它所属的子数组中（下标为 i-h,i-2h,i-3h…）。当然也可以每次直接排完一个子数组，但那样写起来更加复杂。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//间隔</span><br>    <span class="hljs-keyword">while</span> (h &lt; len / <span class="hljs-number">3</span>) h = h * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">//等比数列的性质……总之这里得到大于等于 len/3 的数列中的第一个元素</span><br>    <br>    <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//h==1 的时候执行最后一次，此时是整个数组基本有序，对整个数组进行插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h; i &lt; len; i++) &#123;<span class="hljs-comment">//每一个子数组的插入排序都在这里完成，可别把 i++写成 i+=h 了，这样就只排了其中一个子数组！</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= h; j-=h) &#123;<span class="hljs-comment">//将 arr[j] 插入到 arr[j-h],arr[j-2*h],arr[j-3*h]... 中</span><br>                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - h])<br>                    exch(arr, j, j - h);<br>       <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">//同插入排序，写地更易懂些</span><br>            &#125;<br>        &#125;  <br>        h /= <span class="hljs-number">3</span>; <span class="hljs-comment">//该数列满足这样的条件，其元素每次除以三就能获得前一项</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序可以这样描述——每次找到一个元素作为切分，将其置于正确的位置，并让其左边的元素都小于等于它，让其右边的元素都大于等于它，其后对其左右数组再次进行同样操作，直到数组长度为 1 或 0 时结束。</p><p>快排用 Haskell 代码能够非常优雅地描述。</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">sort</span> :: [a] -&gt; (a -&gt; a -&gt; <span class="hljs-type">Bool</span>) -&gt; [a] <span class="hljs-comment">-- fn 为比较函数 </span><br><span class="hljs-title">sort</span> [] fn = []<br><span class="hljs-title">sort</span> [x] fn = [x]<br><span class="hljs-title">sort</span> (x:xs) fn = <br>    lesser ++ [x] ++ larger<br>    <span class="hljs-keyword">where</span> <br>        lesser = sort [i | i &lt;- xs, fn i x] fn<br>        larger = sort [i | i &lt;- xs, not $ fn i x] fn<br></code></pre></div></td></tr></table></figure><p>“让其左边的元素都小于等于它，让其右边的元素都大于等于它”这个操作需要使用两个指针，每次找到的元素将其交换，当两个指针交错或相同则跳出，将切分元素与后一个指针交换，就能达到置于正确位置的目的，然后对左右数组进行递归操作。快速排序的时间复杂度为 O(nlogn)，空间复杂度为 O(1)，为原地 (in-place) 排序。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123; <span class="hljs-comment">//初值是 arr,0,arr.length</span><br>    <span class="hljs-keyword">if</span> (end - start &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//递归的 base case，这里可以优化成在数组长度小于一定值（5~15）时使用插入排序</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; <span class="hljs-comment">// i 在第一次循环时值为 pivot 的下一个元素的 index</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> end;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> start; <span class="hljs-comment">// 切分的 index</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">while</span> (arr[++i]&lt;arr[pivot]) <span class="hljs-keyword">if</span> (i == end - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//找到第一个大于等于 pivot 的元素，if 防止越界</span><br>        <span class="hljs-keyword">while</span> (arr[pivot]&lt;arr[--j]) <span class="hljs-keyword">if</span> (j == start) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//找到第一个小于等于 pivot 的元素，这里的 if 在 pivot 为 start 的时候是冗余的，毕竟自己总是大于等于自己的，j 自减后，j==start 的时候一定会跳出 while。</span><br>        <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//i，j 交错，循环结束</span><br>        exch(arr, i, j); <span class="hljs-comment">//将大的移到右边，小的移到左边</span><br>    &#125;<br>    exch (arr, pivot, j); <span class="hljs-comment">//这次交换时，j 在前，指向最后一个小于等于 pivot 的元素，i 在后，指向第一个大于等于 pivot 的元素，这里当然得同 j 交换，不然就把一个大于等于 pivot 的元素放到前面去了，如果这个元素大于 pivot，则就无法满足条件了。如果切分使用最后一个元素，这里就应当使用 i 了</span><br>    quicksort (arr, start, j);<br>    quicksort (arr, j + <span class="hljs-number">1</span>, end);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后是一个非常骚的实现，不过有一些不必要的交换——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 区间前闭后闭</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> lastIndex)</span> &#123;<br>     <span class="hljs-comment">// 基线条件</span><br>        <span class="hljs-keyword">if</span> (lastIndex - startIndex &lt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<br>        <span class="hljs-comment">// 以尾部为 pivot</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[lastIndex];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftPointer</span> <span class="hljs-operator">=</span> startIndex - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 最后一次遍历时将会对 pivot 进行移动</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= lastIndex; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= pivot) &#123; <span class="hljs-comment">//可以认为这里的 i 是用来统计小于等于 pivot 的元素的数量的（并且将这样的元素都往前移）</span><br>                leftPointer++;<br>                exch(arr, i, leftPointer);<br>            &#125;<br>        &#125;<br>        sort(arr, startIndex, leftPointer - <span class="hljs-number">1</span>);<br>        sort(arr, leftPointer, lastIndex);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种实现实际上就是在遍历中维护数组和一个指针，并保证这样的状态——这个指针及其左边的所有元素始终小于等于 pivot。每次遇到小于等于 pivot 的元素，指针和数组将进行变动以维护该状态。最后一次遍历时，参与比较的是标兵本身，最终指针的位置就是标兵应当处在的位置。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是典型的分治算法。在每次排序中，它将数组分成两份，对两份进行排序，然后将其归并 (merge) 到一起。这里的归并使用辅助空间则容易编写。</p><p>归并排序的递归（<strong>自顶向下</strong>）方法很容易编写——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] temp;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">temp</span>[arr.length]; <span class="hljs-comment">//temp 数组用于 merge 操作中暂存元素</span><br>    sort(arr,<span class="hljs-number">0</span>, arr.length);<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">if</span> (end - start &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//长度为 0 或 1 的数组不需要排序</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>    sort(arr, start, mid); <span class="hljs-comment">// 排序 arr[start..mid]</span><br>    sort(arr, mid, end); <span class="hljs-comment">// 排序 arr[mid..end]</span><br>    merge(arr, start, mid, end);<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">// 将 arr[start..mid] 和 arr[mid..end] 归并，首先将其移动到辅助数组中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i++)<br>        temp[i] = arr[i];<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid;<br>    <span class="hljs-comment">// 双指针法…找到 temp[i],temp[j] 中较小的那个，将其移入归并数组中</span><br>    <span class="hljs-comment">//这里不用 while 循环，能用 for 就用 for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> start; p &lt; end; p++)<br>        <span class="hljs-keyword">if</span> (i &gt;= mid)<br>            arr[p] = temp[j++]; <span class="hljs-comment">// 第一个数组到顶了，后面只用迁移第二个数组</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt;= end)<br>            arr[p] = temp[i++]; <span class="hljs-comment">//第二个数组到顶</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; arr[j]) <span class="hljs-comment">//两数组都没到顶，找小的那个</span><br>            arr[p] = temp[i++];<br>    <span class="hljs-keyword">else</span><br>            arr[p] = temp[j++];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>自底向上的归并排序也是容易理解的，它每次把数组分为长度为 1,2,4,8,16……（直到其长度大于数组长度）的子数组，对每个这样的子数组，两两进行归并操作（对于每次归并操作，其两个子数组一定是在前一次归并中已经被<strong>排序</strong>的，而长度为 1 的子数组是有序的）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; len &lt; arr.length; len *= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// len 为每个待归并的子数组长度</span><br>        <span class="hljs-comment">// 对每个长度的每个子数组，这里的 i 是数组的起始，数组的长度为 len</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - len; i += len*<span class="hljs-number">2</span>) &#123; <br>            <span class="hljs-comment">// merge 数组 [i,i + len/2],[i + len/2+1, i + len]</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span>  <span class="hljs-operator">=</span> left + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.min(arr.length - <span class="hljs-number">1</span>, left + len + len - <span class="hljs-number">1</span>);<br>            merge(arr, left, mid, right);<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>关于堆及其提供的两个方法 swim，sink，见 [这篇文章](..&#x2F;12-03 关于堆 heap&#x2F;)。</p><p>堆排序的过程可以如下理解——</p><ol><li>首先将数组构建成一个堆（如果要升序排序，则构建大顶堆，如果要降序排序，则构建小顶堆），这构建过程表现在对堆中的<strong>从 N&#x2F;2 到 1 <strong>为下标的元素进行 sink 操作（对没有子节点的元素进行 sink 方法是无意义的，从后往前使用 sink 方法保证对任何调用 sink 方法的元素，其</strong>子节点都是堆</strong>。也可以对所有元素调用 swim 方法，但这样显然是更加低效的，不像 sink 方法能够利用其左右节点是已经堆有序这样的性质）。</li><li>然后，每次将堆顶元素同堆尾元素交换，将堆的长度-1，然后对堆顶调用 sink 方法（即让堆重新有序），这样就达到了把堆顶元素置于正确位置的目的。（这过程就像选择排序，每次找到一个最大&#x2F;小的元素，移到数组尾端。但是堆排序所需的比较更少，因为相比与选择排序，堆能够以常数时间找到最大&#x2F;小的元素，并且在之后只需要 logn 次比较来让数组重新堆有序）</li><li>重复步骤二，直到堆的长度为 1。</li><li>下面给出的实现中只排序了 arr[1:]，所以最终需要把 arr[0] 插入到其后的已排序数组中。或许将堆的编号从零开始计算会省去这一步？有点麻烦。<strong>这里也可以对 exch 和 sink 方法进行修改，将其接受的索引都减 1。</strong></li></ol><blockquote><p>这里为什么是从 N&#x2F;2 开始？因为通过数学方法可以证明，N&#x2F;2 是从后往前数第一个有左右子节点的节点。</p><br/><p>首先需要明确 N&#x2F;2 的数学意义是随 N 的奇偶而变的，如果 N 为偶数，则 N&#x2F;2 则为数学意义上的 N&#x2F;2，如果 N 为奇数，则 N&#x2F;2 则要理解成 Math.floor(N &#x2F; 2.0)，其将向下取整（实际上是进行了带余数的除法，余数被舍弃了），这时候 (N - 1) &#x2F; 2 才等价于数学意义上的 N&#x2F;2。</p><br/><p>当 N 为偶数的时候，N&#x2F;2 节点的左子结点为 N &#x2F; 2 * 2 &#x3D; N，为堆中最后一个节点，当 N 为奇数的时候，N&#x2F;2 等价于 (N - 1) &#x2F; 2，其右子节点为 (N - 1) &#x2F; 2 * 2 + 1 &#x3D; N，为堆中最后一个节点。</p><br/><p>因此，堆中最后一个节点必然是 N&#x2F;2 的子节点，所以 N&#x2F;2 必然是最后一个有左右节点的节点（N&#x2F;2 有最后一个子节点，则 N&#x2F;2 + 1 必然没有子节点）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(Comparable&lt;T&gt;[]arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> N/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">1</span>;i--)<br>        sink(arr,i,N); <span class="hljs-comment">// 构建堆</span><br>    <br>    <span class="hljs-keyword">while</span> (N &gt; <span class="hljs-number">1</span>) &#123;<br>        exch(arr,<span class="hljs-number">1</span>,N); <span class="hljs-comment">// 每次将堆顶和堆尾交换</span><br>        sink(arr,<span class="hljs-number">1</span>,--N); <span class="hljs-comment">// 将 N-1，然后对堆顶进行 sink 操作</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable&lt;T&gt;[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr==<span class="hljs-literal">null</span>||arr.length&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    heapSort(arr); <span class="hljs-comment">// 堆排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length;i++) <span class="hljs-comment">// 这里只排序了 arr[1:]，因此需要对 arr[0] 插入到后面的数组中</span><br>        <span class="hljs-keyword">if</span> (less(arr[i-<span class="hljs-number">1</span>],arr[i])) <span class="hljs-comment">// 这里的 less 的含义是 arr[i-1]&gt;arr[i]</span><br>            exch(arr,i-<span class="hljs-number">1</span>,i);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-f552e4ec247aa71c9bd549924bdbc255_720w.jpg?source=1940ef5c"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 equals 和 hashCode 方法</title>
    <link href="/2020/12-06%E5%85%B3%E4%BA%8Eequals%E5%92%8ChashCode%E6%96%B9%E6%B3%95.html"/>
    <url>/2020/12-06%E5%85%B3%E4%BA%8Eequals%E5%92%8ChashCode%E6%96%B9%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><h1 id="为何重写-equals-就必须重写-hashCode"><a href="#为何重写-equals-就必须重写-hashCode" class="headerlink" title="为何重写 equals 就必须重写 hashCode"></a>为何重写 equals 就必须重写 hashCode</h1><p>有这样一条定则——<strong>如果重写了 equals 方法，就一定要重写 hashCode 方法</strong>。</p><p>这是因为，对象的 hashCode 是同对象的值<strong>相关联</strong>的，如果两个对象相等，则两个对象的 hashCode 也应当相等。可是，Object 类的 hashCode 方法其返回值只与对象的地址相关联，因此，如果只重写 equals 方法，就会导致这样一种情况——两个 equal 的对象，其 hashCode 却是不相等的。这会导致在 HashSet，HashMap 之类的利用哈希表进行映射的数据结构出现问题。</p><p>HashSet，HashMap 的哈希函数遵循这样的逻辑——如果两个对象拥有不同的哈希值，则它们是必定不同的，如果拥有相同的哈希值（这是<strong>哈希碰撞</strong>的情况，两个对象不相等，但其哈希值经过再次混淆后相同），则调用 equals 方法再判断是否确实为相等的对象。</p><p>我们编写 hashCode，没有必要强求一个对象必然要得到独一无二的 hashCode，这是不可能的，尽量减少碰撞即可。</p><blockquote><p> 注：&#x3D;&#x3D;运算符比较的是两个变量的<strong>值</strong>，对于基本类型，则比较的是它们的值，对于引用类型，则比较的是它们存储的<strong>地址</strong>，因此，只有两个引用类型的变量（即使其类型不同也可以，比如一个子类的<strong>对象引用</strong>和一个父类的对象引用指向一个子类的对象）指向同一个地址（或者说，堆里的同一个<strong>对象实例</strong>）的时候&#x3D;&#x3D;才返回真。</p></blockquote><h2 id="从-HashSet-的源码入手"><a href="#从-HashSet-的源码入手" class="headerlink" title="从 HashSet 的源码入手"></a>从 HashSet 的源码入手</h2><p>当我们调用 HashSet 的 add 实例方法的时候，会发生什么？看看源码吧。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>     <span class="hljs-comment">// 这里的 map 是个 HashMap&lt;E, Object&gt;类的实例，说明 HashSet 是通过 HashMap 实现的</span><br>     <span class="hljs-comment">// PRESENT 是一个 final static 的 Object 对象，这里显然只是用来置位的，没有实际作用</span><br>     <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>; <br> &#125;<br></code></pre></div></td></tr></table></figure><p>再看看 HashMap 的 put 方法。HashMap 使用的是数组——链表结构，如果某个链表长度大于阀值（8）且数组长度大于 64，则该链表将被转换为红黑树结构，否则会将数组的长度乘 2。不过判断的流程还是一致的——首先将元素的 hashCode 使用杂凑函数进行处理，确定其插入位置，如果插入位置为空，则直接插入，（对于数组——链表）否则遍历该位置的所有元素，对每一个元素进行判断；首先比较哈希值是否相等，如果相等，则判断其是否是同一对象，判断其是否 equal，如果是则说明是重复的 key，对该 key 进行处理，如果到最后都未找到，则将其插入尾端。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-comment">// HashMap 中使用的哈希方法，它对对象的 hashCode 进行杂凑</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>); <br>&#125;<br><br><span class="hljs-comment">// 这代码写出来是不是不想给人看的？？？</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i; <span class="hljs-comment">// 这里的 Node 是一个实现了 Entry 的类，其有链表结构</span><br>    <span class="hljs-comment">// table 是整个哈希表。它是数组——链表结构或是数组——红黑树结构</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) <br>        n = (tab = resize()).length;<br>    <br>    <span class="hljs-comment">// 这个 if-else 是重点！</span><br>    <span class="hljs-comment">// 如果要插入的位置没有元素，则直接插入</span><br>    <span class="hljs-comment">// 这里需要注意的是，这个位置是对象的哈希对 n 取余的结果，所以存在这个位置的元素的哈希值并不一定是相等的</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)   <span class="hljs-comment">// 在 n 等于 2 的幂次方的时候，(n-1)&amp;hash==hash&amp;n，并且前者效率更高，这也是为什么 HashMap 的容积使用 2 的幂次方</span><br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 如果有元素，则需要遍历该位置的所有元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 需要注意的是，||的优先级是更高的。</span><br>        <span class="hljs-comment">// 这里的 p 是碰撞位置的链表的第一个元素……至少最初是</span><br>        <span class="hljs-comment">// 它先看该元素的 hash 和链表中该位置的 hash 是否相等 （这里就能看到，如果没有重写 hashCode 方法，对于任意非重复插入的对象实例，这个 p.hash == hash 将始终为假，equals 方法将不被调用）</span><br>        <span class="hljs-comment">// 然后看 (k = p.key) == key，即这两个 key 是否指向同一个对象，如果不是，则调用 equals 方法比较</span><br>        <span class="hljs-comment">// 如果这个 if 检查成功，说明这两个对象真的是相同的，因此将 e 的值设为 p，等待下一步对其值进行更新并返回</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p; <br>        <span class="hljs-comment">// 如果这个位置是一个 TreeNode，则说明使用的是红黑树结构</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 遍历 p 位置所在链表，找到第一个与其哈希相同，且指向同一个对象或 equal 的节点，如果到最后还没有找到，则插入到尾端。无论如何，e 保存了最终的位置，无论是插入还是更新`。</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123; <br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// put 也要承担更改元素的作用</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>PS：HashSet 和 HashMap，IdentityHashMap 允许插入 null 或以 null 为 key。它的哈希将为 0。</p><h1 id="PS：看看-IdentityHashMap"><a href="#PS：看看-IdentityHashMap" class="headerlink" title="PS：看看 IdentityHashMap"></a>PS：看看 IdentityHashMap</h1><p>IdentityHashMap 则是另一个极端。与 HashMap 不同，它只比较元素的内存地址（即 Object 的 hashCode 方法，或者说可以理解成&#x3D;&#x3D;运算符）来判断其是否是同一个 key，而不关心是否 equal。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object x, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> System.identityHashCode(x); <span class="hljs-comment">// 这个 hashCode 调用其父类，即 Object 类的 hashCode 方法，而无论它是否重写 hashCode</span><br>    <span class="hljs-comment">// Multiply by -127, and left-shift to use least bit as part of hash</span><br>    <span class="hljs-keyword">return</span> ((h &lt;&lt; <span class="hljs-number">1</span>) - (h &lt;&lt; <span class="hljs-number">8</span>)) &amp; (length - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 代码有点晦涩，只需要看到其中没有调用 equals 方法就够了……</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> maskNull(key);<br><br>    retryAfterResize: <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">final</span> Object[] tab = table;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> hash(k, len);<br><br>        <span class="hljs-keyword">for</span> (Object item; (item = tab[i]) != <span class="hljs-literal">null</span>;<br>             i = nextKeyIndex(i, len)) &#123;<br>            <span class="hljs-keyword">if</span> (item == k) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> (V) tab[i + <span class="hljs-number">1</span>];<br>                tab[i + <span class="hljs-number">1</span>] = value;<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> size + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// Use optimized form of 3 * s.</span><br>        <span class="hljs-comment">// Next capacity is len, 2 * current capacity.</span><br>        <span class="hljs-keyword">if</span> (s + (s &lt;&lt; <span class="hljs-number">1</span>) &gt; len &amp;&amp; resize(len))<br>            <span class="hljs-keyword">continue</span> retryAfterResize;<br><br>        modCount++;<br>        tab[i] = k;<br>        tab[i + <span class="hljs-number">1</span>] = value;<br>        size = s;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于数据结构中的堆（heap）</title>
    <link href="/2020/12-03%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%A0%86.html"/>
    <url>/2020/12-03%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%A0%86.html</url>
    
    <content type="html"><![CDATA[<!--Hello, Happy World--><p>注，这里的堆指的都是<strong>二叉堆</strong>。</p><h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><p>可以认为，堆是这样一种二叉树，它的每一个节点的值都大于（或小于）其两个子节点的值。前者称为大根堆，或大顶堆，后者称为小根堆，或小顶堆。</p><p>堆很容易用完全二叉树来表示，因而使用数组模拟堆是合理的。可以用这样的数组来模拟堆——它从 1 开始计数，对每一个节点 i，其左子结点为 i*2，其右节点为 i*2+1，其父节点为 i&#x2F;2。树的根节点为 1。</p><p>堆对解决诸如找到数组的前 k 大（小）的元素这样的问题是极其合适的。对于找到前 K 大的元素这个问题，可以构造一个小顶堆，对数组中每一个元素，如果其大于小顶堆的顶（这说明该元素大于已经找到的元素的最小值），则更新堆。遍历完成后堆中元素就为前 K 大的元素。</p><p>堆也被用作构造<strong>优先队列（Priority Queue）</strong>。这种队列有着这样的性质——它能在 O(log n) 时间内取出最小（最大）元素，在 O(log n) 时间内插入元素。下面给出优先队列的实现。</p><h1 id="堆的一般方法"><a href="#堆的一般方法" class="headerlink" title="堆的一般方法"></a>堆的一般方法</h1><p>一般的堆有两个方法，<code>swim(int):void</code>和<code>sink(int):void</code>。它们分别是将元素上浮和下沉。</p><h2 id="swim-方法"><a href="#swim-方法" class="headerlink" title="swim 方法"></a>swim 方法</h2><p>swim 方法表示将一个元素更新（或插入）后上浮。</p><p>可以想象这样一个场景——一个黑社会里新来了一个人，他能力比他的领导强，因而抢了领导的位置，领导变成了他的下属。这个过程一直循环，直到他的上司比他强为止，或者（当然，也可能根本进不去循环，他就是最菜的 w）。当然，这里的“强”如何区分取决于堆是大顶堆还是小顶堆。</p><p>下面给出其实现——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span> <span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123; <span class="hljs-comment">// 这里的 k 给的是数组的下标</span><br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span> &amp;&amp; stronger(arr[k], arr[k / <span class="hljs-number">2</span>])) &#123; <span class="hljs-comment">// 当 k 还没到根节点，且 k 比它的父节点“强”</span><br>        exch(arr, k, k / <span class="hljs-number">2</span>);<br>        k = k / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="sink-方法"><a href="#sink-方法" class="headerlink" title="sink 方法"></a>sink 方法</h2><p>sink 方法表示将一个元素下沉。一个通常的应用是，删除了堆顶，然后将堆尾元素置于堆顶并调用 sink(1)，使其置于合适位置。</p><p>可以想象这样一个场景——一个领导退休了，空降了个乐色，他的位置被下面的人顶掉（这是黑社会，不是阶级社会：-) ），他就成为了这个“下面的人”的下属，这个过程一直循环，直到他比他的下属都强为止。</p><p>要注意的是，他应当是被下面的两个人中比较“强”的那个顶掉，因为如果是被弱的顶掉，这个弱的也会被再顶掉（不满足堆的性质了）。</p><p>下面给出实现——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">while</span> (k * <span class="hljs-number">2</span> &lt; arr.size()) &#123; <span class="hljs-comment">// 如果他还有下级的话 w</span><br>        <span class="hljs-comment">// 这里找出 k 的两个子节点中更“强”的哪一个</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; arr.size() &amp;&amp; stronger(arr[i + <span class="hljs-number">1</span>], arr[i])) i++;<br>        <br>        exch (arr, i, k);<br>        k = i;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="优先队列的实现"><a href="#优先队列的实现" class="headerlink" title="优先队列的实现"></a>优先队列的实现</h1><p>下面实现优先队列。其接受一个或两个参数——堆的长度和 Comparator。优先队列主要需要实现两个方法——removeTop 方法和 insert 方法，前者移除堆顶元素，将堆尾元素移到堆顶并调用 sink 方法，后者插入元素到堆尾并调用 swim 方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PQ</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> Comparator&lt;T&gt; comparator;<br>    <span class="hljs-keyword">private</span> T[] arr;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 指向堆的最后一个元素</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PQ</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 这里的 n 是堆的最大大小</span><br>        arr = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>[n + <span class="hljs-number">1</span>];<br>        comparator = (i, j) -&gt; i.compareTo(j); <span class="hljs-comment">// 默认为构造小顶堆</span><br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PQ</span><span class="hljs-params">(<span class="hljs-type">int</span> n, Comparator&lt;T&gt; comparator)</span> &#123;<br>        <span class="hljs-built_in">this</span>(n);<br>        <span class="hljs-built_in">this</span>.comparator = comparator;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span> &#123;<br>        arr[++n] = t;<br>        swim(n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">removeTop</span><span class="hljs-params">()</span> &#123;<br>        exch(<span class="hljs-number">1</span>, n);<br>        <span class="hljs-type">T</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[n];<br>        arr[n--] = <span class="hljs-literal">null</span>;<br>        sink(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        res.append(<span class="hljs-string">&quot;PQ[&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            res.append(arr[i] + (i == n ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;, &quot;</span>));<br>        res.append(<span class="hljs-string">&quot;] size=&quot;</span> + (arr.length - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123; <span class="hljs-comment">// 这里的 k 给的是数组的下标</span><br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span> &amp;&amp; stronger(k, k / <span class="hljs-number">2</span>)) &#123; <span class="hljs-comment">// 当 k 还没到根节点，且 k 比它的父节点“强”</span><br>            exch(k, k / <span class="hljs-number">2</span>);<br>            k = k / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">while</span> (k * <span class="hljs-number">2</span> &lt;= n) &#123; <span class="hljs-comment">// 如果他还有下级的话 w</span><br>            <span class="hljs-comment">// 这里找出 k 的两个子节点中更“强”的哪一个</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k * <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt;= n &amp;&amp; stronger(i + <span class="hljs-number">1</span>, i))<br>                i++;<br>            <span class="hljs-keyword">if</span> (!stronger(i, k))<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果 i 不比 k 强</span><br>            exch(i, k);<br>            k = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">stronger</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> comparator.compare(arr[i], arr[j]) &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="找到数组前-k-小的元素"><a href="#找到数组前-k-小的元素" class="headerlink" title="找到数组前 k 小的元素"></a>找到数组前 k 小的元素</h1><p>对于 <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">这一题</a>，要找到数组的前 k 小的元素，则需要维护一个大小为 k 的大顶堆，其中元素代表当前找到的 k 个最小元素，然后遍历数组，如果找到的数小于大顶堆中最大的数，则更新堆，否则不做动作。这里只需要更改一下 insert 方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123; <span class="hljs-comment">// 将 i 插入到堆中</span><br>    <span class="hljs-keyword">if</span> (!isFull()) &#123; <span class="hljs-comment">// 如果堆未满</span><br>        arr[++p] = i;<br>        swim(p);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; arr[<span class="hljs-number">1</span>]) &#123;<br>        arr[<span class="hljs-number">1</span>] = i;<br>        sink(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/03/z3iPZeSqWufBLbU.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概观 java 的面向对象</title>
    <link href="/2020/11-13%E6%A6%82%E8%A7%82java%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <url>/2020/11-13%E6%A6%82%E8%A7%82java%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</url>
    
    <content type="html"><![CDATA[<p><strong>这一篇文章有非常多的错误……或许将来得“重构”。</strong></p><blockquote><p>Java 的面向对象只允许单继承，这方便了系统的设计，但是需要注意的是，这是不符合现实世界的规律的，现实世界是“多继承”的，比如水，它是液体，氢氧化合物，解渴的东西……</p></blockquote><h1 id="类和实例的初始化"><a href="#类和实例的初始化" class="headerlink" title="类和实例的初始化"></a>类和实例的初始化</h1><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// instance field initialization</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> t;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// object field initialization</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;father&#x27;s static init block&quot;</span>);<br>    &#125;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;father&#x27;s instance init block&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;father&#x27;s constructor&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">test2</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;son&#x27;s static init block&quot;</span>);<br>        test1  = <span class="hljs-number">2</span>;<br>        test2 = <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;son&#x27;s instance init block&quot;</span>);<br>        t = <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Son</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;son&#x27;s constructor&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;world!&quot;</span>);<br>        System.out.println(Son.test1);<br>        System.out.println(Son.test2);<br>        Son.sayHello();<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>().t);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><del>关于对象（object）和实例（instance），可以认为对象是更为广泛的概念，是同上下文无关的，而实例则是相对的，实例必须是某个类（class）的实例，而对象可以不指一个特定类的对象。</del></p><p>域（field）可以认为是类的属性，变量，成员，etc..</p><p>上面的代码输出结果如下</p><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">world!<br>father&#x27;s<span class="hljs-keyword"> static</span> init block<br>son&#x27;s<span class="hljs-keyword"> static</span> init block<br>1<br>4<br>hello!<br><br>father&#x27;s<span class="hljs-built_in"> instance </span>init block<br>father&#x27;s<span class="hljs-keyword"> constructor</span><br>son&#x27;s<span class="hljs-built_in"> instance </span>init block<br>son&#x27;s<span class="hljs-keyword"> constructor</span><br>1<br></code></pre></div></td></tr></table></figure><p>可见，类的静态初始化 (static initialization) 和静态初始化块 (static initialization block) 在第一次调用类的方法或变量（无论是实例方法&#x2F;变量还是静态方法&#x2F;变量）时<strong>同时</strong>进行。首先是父类，然后是子类。其调用的顺序同上下文相关（见 test1 和 test2）……这两个不应该同时使用。</p><p>然后是类的实例化，首先是父类的对象初始块 (object initialization block) 和对象域初始化（object field initialization）同时进行（见变量 t），就如同上一段的静态、**。然后是父类的构造器。然后是子类的对象初始化块和对象域初始化，最终是子类构造器。</p><p>总之，当我们第一次创建一个对象的实例时，首先是类的静态初始化过程（如果之前没有初始化过），首先是父类，然后是子类；然后是类的实例初始化和构造过程，一样地，首先是父类，然后是子类。</p><p><strong>（父类静态初始化-&gt;子类静态初始化）-&gt;父类实例初始化-&gt;父类构造器-&gt;子类实例初始化-&gt;子类构造器</strong></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p><strong>多态</strong>（polymorphism）指一个对象变量能够指示多种实际类型的现象。比如，假设 neko 是 animal 派生的子类，则一个 neko 的实例既能够指示 animal（它的超类），也能够指示 rabbit。而其能够自动选择调用哪个方法，则叫<strong>动态绑定</strong>（dynamic binding）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>        StdOut.println(<span class="hljs-string">&quot;wuwu&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Neko</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>        StdOut.println(<span class="hljs-string">&quot;nyanya&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">niconiconi</span><span class="hljs-params">()</span> &#123;<br>        StdOut.println(<span class="hljs-string">&quot;niconiconi&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Animal[] animals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>[<span class="hljs-number">2</span>];<br>        animals[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        animals[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Neko</span>();<br>        animals[<span class="hljs-number">0</span>].say(); <span class="hljs-comment">// &quot;wuwu&quot;</span><br>        animals[<span class="hljs-number">1</span>].say(); <span class="hljs-comment">// &quot;nyanya&quot;</span><br><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">neko</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Neko</span>(); <span class="hljs-comment">// neko 究竟是啥类型，得看它调用哪个构造器。但是如此使用的话 neko 就不能使用 Neko 类独有的方法和变量了</span><br>        neko.say(); <span class="hljs-comment">// &quot;nyanya&quot;</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">refer</span> <span class="hljs-operator">=</span> neko;<br>        refer.say(); <span class="hljs-comment">// &quot;nyanya&quot; 这里就是动态绑定喽？</span><br>    neko.niconiconi();<span class="hljs-comment">//报错！显示这个方法不是 Animal 的</span><br>    ((Neko)neko).niconiconi(); <span class="hljs-comment">// 现在它能了</span><br>    <br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        ((Neko)dog).say(); <span class="hljs-comment">// 报错！父类不能强转成子类，那上面的喵喵为什么可以呢？因为它本来就是引用的子类变量，只不过是父类类型而已。并且这个错误是 runtime 的！显然，对于 public 方法，是动态绑定的</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，选择调用哪个 say 方法是动态绑定的，<strong>看变量的实际类型</strong>。比如，这里定义 neko 是 Animal 类型（这里，Animal 是 neko 的<strong>声明类型</strong>），却给他引用了一个 Neko 变量，它的 say 被 JVM 动态绑定到了 Neko 的类方法上。同时，<strong>它所能调用的方法是受其声明类型所限制的，如果要调用的方法（或类成员）不在超类的域内，则会出现编译错误，必须将该类强制转换为其实际类型才能调用其独有的方法</strong>。</p><p>同时，超类数组能够存储子类，但是子类数组不能存储超类。比如，动物数组可以存储兔子，而兔子数组不能存储动物，这是很容易理解的，因为动物不全是兔子。一个类型的数组不应该存储超出该类型范畴的类型（这里的范畴不是哲学上的范畴，而是“用某种概念界定的范围”）。</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>当某个类中存在有含 abstract 关键字的方法，则该类为抽象类（也可以定义一个类为抽象类，即使其不含抽象方法），这样的方法称为抽象方法，它不需要提供实现（这是子类的活）。抽象类无法被实例化（但是可以有构造器）。继承抽象类的类可以不定义完其超类的所有抽象方法（如此则这个类也是抽象类）。Java 提供的数据结构中，如 map，list，set 等都是抽象类，HashMap，LinkedList，HashSet 等则是它们的子类。</p><p>抽象类虽然不能实例化，但是能够作为声明类型，如——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Set&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br></code></pre></div></td></tr></table></figure><p>这样是合法的。</p><p>关于抽象类，作为一个其他领域的例子，哲学上的物质范畴同抽象类是比较接近的，没有脱离具体事物单独存在的<strong>物质本身</strong>，一切物质都是具体的事物。可是一切物质又都有层次性，结构性……<del>人的概念也是一样，人既具有自然性，也具有社会性，就后者来说，没有脱离一定阶级地位的人。因此，在讨论社会性的人的时候，它也是抽象的。</del></p><p>抽象类或是接口可以认为是<strong>抽象层</strong>的东西，根据面向对象的设计原则，应当尽量面向抽象层编程——这表现在声明类型应当为接口或抽象类。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射库 (reflection library) 提供了一个工具库，以编写<strong>动态操纵 Java 代码</strong>的程序。这种<strong>在运行时分析类的能力</strong>就是反射。</p><p>反射机制可以用来——</p><ul><li>在运行时 (runtime) 分析类</li><li>在运行时获取对象的实际类型</li><li>…</li></ul><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p>Java 运行时环境为所有对象都维护一个“运行时类型信息”，JVM 通过它来<del>确定对象的实际类型，</del>选择相应的方法。</p><p>Class 类就是这个类型信息，一个 Class 对象代表一个类型。每个类型都有代表它的 Class 对象，<strong>即使这个类型不是一个类</strong>。Class 对象可以用如下方法获得——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>System.out.println(a.getClass());<br>System.out.println(<span class="hljs-type">int</span>.class); <span class="hljs-comment">// 就像 static 的变量……不过 int 并非是一个类就是了</span><br>System.out.println(<span class="hljs-type">int</span>[].class);<br><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(Class.forName(<span class="hljs-string">&quot;java.lang.Integer&quot;</span>));<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 受检异常，只能说很丑陋</span><br>    e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其输出是</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.Integer<br><span class="hljs-built_in">int</span><br><span class="hljs-keyword">class</span> [I <span class="hljs-comment">// int 数组是这样的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.Integer<br></code></pre></div></td></tr></table></figure><p>Class 有一个很有用的方法 newInstance，它<strong>动态创建一个类的实例</strong>（酷！）。这个方法只能使用无参构造器，如果要使用带参构造器，则使用 Constructor 类的 newInstance 方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">newInt</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Integer&quot;</span>).newInstance();<br></code></pre></div></td></tr></table></figure><h2 id="java-lang-reflect"><a href="#java-lang-reflect" class="headerlink" title="java.lang.reflect"></a>java.lang.reflect</h2><p>反射机制最重要的内容是——<strong>检查类的结构</strong>。</p><p>java.lang.reflect 包中提供了三个类——Field, Method 和 Constructor，它们用于描述类的域，方法和构造器。不仅能通过它们来检查类的结构，还能通过它们来动态访问其域，方法，构造器（动态创建类的实例）。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口 (interface) 是对类的一组<strong>需求描述</strong>，它们要遵从接口描述的统一格式进行定义（也因此可以统一地被使用，最典型的就是 Comparable 接口了，实现 (implement) 了这个接口的类都可以使用 Arrays.sort 方法进行排序，就像某种标准化的协议一样。</p><p>同时，接口可以被作为声明类型或强制转换的结果，就如抽象类一样。instanceof 可以查看类是否实现了这个接口。</p><p>接口内可以增加静态方法和静态常量，接口方法可以被提供一个默认 (default) 实现。</p><h1 id="lambda-表达式和函数式接口"><a href="#lambda-表达式和函数式接口" class="headerlink" title="lambda 表达式和函数式接口"></a>lambda 表达式和函数式接口</h1><p><strong>lambda 表达式的实质是匿名实现类。</strong></p><p>lambda 表达式为 Java 提供了简易的函数式编程能力。Java 的 lambda 表达式实质上是一种<strong>函数式接口</strong>（这是为了语言的简单性，一致性）。</p><p>函数式接口指的是只有一个抽象方法的接口。<strong>函数式接口是能实例化的（一切接口都能够作为声明类型，但是不能作为实际类型）</strong>，但是需要在其后跟随代码块（或者 lambda 表达式）来实现其抽象方法。</p><p>lambda 一个常用的地方是排序方法中的自定义比较器——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Arrays.sort(arr, (a, b) -&gt;  b.compareTo(a));<br>Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o2.compareTo(o1);<br>    &#125;<br>&#125;);<br><br>Comparator&lt;Integer&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123; <span class="hljs-comment">//可以实例化！</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o2.compareTo(o1);<br>    &#125;<br>&#125;;<br>Function&lt;String, Integer&gt; toInteger = s -&gt; Integer.valueOf(s);  <span class="hljs-comment">// 可以使用 lambda 表达式进行实例化</span><br></code></pre></div></td></tr></table></figure><p>但是 lambda 表达式终究要被转换为接口实例，它不能直接赋值给一个变量（因为无法推断其要转换为哪个接口，而且 Java 没有提供函数类型）。</p><p>Java 提供了：: 运算符，能够将方法转换为 lambda 表达式（从而转换为函数式接口），这种形式叫做<strong>方法引用</strong>。当然，前提是接受参数和返回类型应当与函数式接口中定义的抽象方法一致。</p><p>:: 运算符的形式为——</p><ul><li>Class::staticMethod</li><li>Object::instanceMethod</li><li>Class::instanceMethod</li></ul><p>第三种情况中，第一个参数会成为方法的目标。比如 String::compareToIgnoreCase 转换为 (x, y) -&gt; x.compareToIgnoreCase(y)。</p><p>this 和 super 也是可以使用的。lambda 表达式中的 this 指的是其所处对象，而非该函数式接口实例。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HHW</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNegative</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNegative_instance</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123; <span class="hljs-comment">// 不使用 static 在语义上没有任何意义，此处仅为展示</span><br>        <span class="hljs-keyword">return</span> i &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br>List&lt;Integer&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">HHW</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HHW</span>();<br><br><span class="hljs-comment">// 下面四种都是合法的</span><br>a.removeIf(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Integer&gt;()&#123; <span class="hljs-comment">// 其接受一个 T，返回一个布尔值</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Integer t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;);<br>a.removeIf(i -&gt; i &lt; <span class="hljs-number">0</span>);<br>a.removeIf(HHW::isNegative); <span class="hljs-comment">// 等同于 i -&gt; HHW.isNegative(i)</span><br>a.removeIf(t::isNegative_instance); <span class="hljs-comment">// 等同于 i -&gt; t.isNegative_instance(i)</span><br></code></pre></div></td></tr></table></figure><p>与此相似的还有构造器引用，形如——</p><ul><li>Class::new</li></ul><p>其调用该 Class 的构造器，具体是哪一个构造器取决于上下文。</p><p>这里写个适合静态数组的 foreach——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HHW</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">foreach</span><span class="hljs-params">(T[] arr, Consumer&lt;T&gt; c)</span> &#123;<br>        <span class="hljs-keyword">for</span>(T i : arr)<br>            c.accept(i);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        foreach(arr, (i) -&gt; &#123;<br>            System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>lambda 表达式给 Java 提供了闭包功能，即其可以捕获 (captured) 表达式外的变量，这里可以将 lambda 表达式看作一个实例对象，捕获的变量成为该对象的实例变量，并被其维护。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">repeatMessage</span><span class="hljs-params">(String text, <span class="hljs-type">int</span> delay)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">ActionListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> event -&gt; &#123;<br>        a++; <span class="hljs-comment">// 这样就要报错了，a 必须为 final</span><br>        System.out.println(text); <span class="hljs-comment">// 在这里，text 被 lambda 表达式捕获了</span><br>    &#125;;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(delay, listener).start;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">repeatMessage</span><span class="hljs-params">(String text, <span class="hljs-type">int</span> delay)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        <span class="hljs-type">ActionListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> event -&gt; &#123;<br>            System.out.println(i + <span class="hljs-string">&quot; &quot;</span> + text);  <span class="hljs-comment">// 也要报错</span><br>        &#125;;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(delay, listener).start;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是，Java 的闭包中的自由变量必须是实际上的最终变量（effectively final)，意思是其在初始化之后不会再被赋新值，否则在并发时可能出现问题。</p><h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><p>类的加载是类加载器 (Class Loader) 执行的，其有如下步骤——<strong>加载</strong>，<strong>链接</strong>，<strong>初始化</strong>。</p><p>似乎类的初始化不是一定进行的？</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>类的加载就是 Java 字节码（java 文件编译后的 class 文件中的内容就是字节码）加载到内存中，并且其静态数据（静态变量，静态方法，常量池（指类名，方法名，成员名等？），代码）被转换为运行时的数据结构，存储在方法区 (method area，一种特殊的堆）中，然后在堆（heap）生成对应这个类的 java.lang.Class 对象。Class 对象是独一无二的，一个类有且只有一个 Class 对象。</p><p>有 Class 对象的类型有——</p><ul><li>类</li><li>接口</li><li>数组</li><li>注解</li><li>void</li><li>包装类</li><li>……</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接过程是 Java 二进制代码（指的是加载步骤中，字节码转换成的运行时数据结构吗？）合并到 JVM 的运行状态的过程。</p><p>首先其将会检查类的结构，确保安全性问题。</p><p>然后它<strong>为类变量（static）分配内存</strong>，并设置其初始值（对于对象，应当是 null，对于基本类型，应当是 0 或 false 等）。同时，对于静态常量（static final），其将直接被初始化，存入常量池。（常量池应当只存储 static 常量，其逻辑上存在于方法区，实际上存在于堆）这些内存都在方法区分配。</p><p>最后，它将常量池内的符号引用（变量名）替换为直接引用（地址）的过程。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化过程将首先调用<strong>类构造器</strong>&lt;clinit&gt;()，其将合并 static 代码的赋值操作和 static 代码块并执行。</p><p>它将首先初始化该类的父类，如果其父类并未被初始化的话。</p><h2 id="类在什么时候加载"><a href="#类在什么时候加载" class="headerlink" title="类在什么时候加载"></a>类在什么时候加载</h2><p>类的初始化（初始化则必然要加载）发生在类的<strong>主动引用</strong>时。</p><p>主动引用的情况有——</p><ul><li>main 所在的类<strong>最先</strong>被初始化</li><li>new 一个类</li><li>调用类的静态成员（除了 final）和静态方法</li><li>使用 Reflect 类对类进行反射调用</li><li>将被初始化的类的父类</li></ul><p>在被动引用时，类不会初始化，其情况有——</p><ul><li>引用一个类的静态域，只有真正声明这个静态域的类才会被初始化（比如子类引用父类的静态域，只有父类初始化）</li><li>定义类的引用数组</li><li>引用类的静态常量（其在链接阶段就存在常量池中）</li></ul><p><img src="https://i.loli.net/2020/11/28/OGs7pPx6dovRqlB.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动机——我的 atoi 函数</title>
    <link href="/2020/11-11%E8%87%AA%E5%8A%A8%E6%9C%BA%E2%80%94%E2%80%94%E6%88%91%E7%9A%84atoi%E5%87%BD%E6%95%B0.html"/>
    <url>/2020/11-11%E8%87%AA%E5%8A%A8%E6%9C%BA%E2%80%94%E2%80%94%E6%88%91%E7%9A%84atoi%E5%87%BD%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<p>编译原理没好好听（不如说脑子里没有那种思维），现在要遭重啦！</p><h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">这道题</a> 要求实现 atoi 函数，它要求将一个字符串转成整型，并且有以下要求——</p><ul><li>如果转换失败，返回 0</li><li>忽略不限数量的前置零</li><li>能判断正负</li><li>有效的整数后可能有非法字符，应当能够处理所有有效整数</li><li>如果整型溢出，则返回整型的最大值或最小值</li></ul><p>比如，对输入“      -42”，返回-42，对输入“  +43hello”，返回 43，对”he is a 5”，返回 0</p><h1 id="我的实现——一万个条件判断"><a href="#我的实现——一万个条件判断" class="headerlink" title="我的实现——一万个条件判断"></a>我的实现——一万个条件判断</h1><p>这里是我之前写的代码——</p><p>首先检查输入，如果输入为空，或者长度为 1，则直接返回结果。</p><p>然后排除前置零，找到第一个非零元素。判断该元素是否是+，-或数字。</p><p>然后找到数字的第一个有效位置，从此处开始找到数字的最后一个有效位置。</p><p>此时，数字的符号，开始位置和结束位置已经决定，下面就不言自明了。</p><p>关于溢出的判断，可以看到每次递增都是 res &#x3D; res * 10 + temp，在计算前对 res 进行判断。</p><p>对于正数，需要看是否大于 MAX_VALUE&#x2F;10，如果大于，则必定越界。如果等于，则判断 temp 是否小于 7（整型的上界的个位是 7），如果 temp 小于 7 则不越界，如果其小于 MAX_VALUE&#x2F;10 则也不越界。</p><p>负数遵循相似的判断方法，如果 temp 小于-8（整型的下界的个位是 8），则必定越界。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">myAtoi</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">//对输入进行判断</span><br>    <span class="hljs-keyword">if</span> (s.isEmpty())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.length()==<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 长度为 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s.charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (temp&gt;=<span class="hljs-number">0</span> &amp;&amp; temp&lt;=<span class="hljs-number">9</span>)<br>            <span class="hljs-keyword">return</span> temp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 首先找到第一个不为空格的元素，如果这个 char 不是-,+或数字，则返回 0，否则继续操作</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 指向第一个非 whitespace 的数</span><br><br>    <span class="hljs-comment">// 首先找到第一个非 space 的元素</span><br>    <span class="hljs-keyword">while</span> (s.charAt(pointer) == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <br>        pointer++;<br>        <span class="hljs-keyword">if</span> (pointer == s.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 全为空格</span><br>    &#125;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> s.charAt(pointer);<br><br>    <span class="hljs-comment">// 检查这第一个非 space 的元素是否是数字或+,-，如果不是则转换失败</span><br>    <span class="hljs-keyword">if</span> (!(Character.isDigit(first) || first == <span class="hljs-string">&#x27;-&#x27;</span> || first == <span class="hljs-string">&#x27;+&#x27;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 判断正负。如果有正负号，则应当将 pointer++，指向第一个数字</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">positive</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 判断正负</span><br>    <span class="hljs-keyword">if</span> (first == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>        positive = <span class="hljs-literal">false</span>;<br>        pointer++;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first == <span class="hljs-string">&#x27;+&#x27;</span>)<br>        pointer++;<br><br>    <span class="hljs-keyword">if</span> (!Character.isDigit(s.charAt(pointer)))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 正负已经被 positive 确定，pointer 指向第一个数字（也或许不是数字）了，现在获取最后一个有效数字</span><br>    <span class="hljs-type">int</span> end;<br>    <span class="hljs-keyword">for</span> (end = pointer; end &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(end)); end++); <br>    <span class="hljs-comment">// 这时候 end 可能为数组长度 s.length()，或者是数字的最后一个元素的后一个元素</span><br>    end--; <span class="hljs-comment">//现在 end 是数字的最后一个元素了</span><br><br>    <span class="hljs-comment">// 已经知晓有效数字的开始位置 start，结束位置 end，正负 positive</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> pointer; i &lt;= end; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!positive) temp = -temp;<br>        <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE/<span class="hljs-number">10</span> || res == Integer.MAX_VALUE/<span class="hljs-number">10</span> &amp;&amp; temp &gt; <span class="hljs-number">7</span>) <br>            <span class="hljs-keyword">return</span> Integer.MAX_VALUE; <span class="hljs-comment">// 判断是否溢出。为什么是 temp &gt; 7？ 因为整型最大值的个位数是 7</span><br>        <span class="hljs-keyword">if</span> (res &lt; Integer.MIN_VALUE/<span class="hljs-number">10</span> || res == Integer.MIN_VALUE/<span class="hljs-number">10</span> &amp;&amp; temp &lt; -<span class="hljs-number">8</span>) <br>            <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>        res = res * <span class="hljs-number">10</span> + temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，这个实现是非常……臃肿的，代码并不好修改（也不好看），if 和 return 到处都是。虽然我 no bug AC 了，但是这绝对是机缘巧合。这样多分支的玩意出现 bug 轻而易举。</p><p>于是去翻了下题解，卧槽？DFA？还有这种操作？原来这种流程复杂的玩意可以用自动机优雅地解决……我是没想到编译原理里的东西可以用到这里……这必须得学习一波了。</p><h1 id="DFA-的实现"><a href="#DFA-的实现" class="headerlink" title="DFA 的实现"></a>DFA 的实现</h1><p>状态转移图如下，start 为初始，signed 为判断正负，in_number 则是正在处理有效数字，end 为转换失败或转换完成</p><p><img src="/images/oss/20210822082214.PNG"></p><p>然后贴上状态转移表。这个表描述任意条件下遇到各种字符的处理方法。比如在 start 条件下，遇到 number 则跳转到 in_number 下</p><table><thead><tr><th align="center"></th><th align="center">‘ ‘</th><th align="center">+&#x2F;-</th><th align="center">number</th><th align="center">other</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">start</td><td align="center">signed</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">signed</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">in_number</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td></tr></tbody></table><p>总之先贴上题解的 python 代码——</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">INT_MAX = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>INT_MIN = -<span class="hljs-number">2</span> ** <span class="hljs-number">31</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automaton</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.state = <span class="hljs-string">&#x27;start&#x27;</span> // 代表当前状态<br>        self.sign = <span class="hljs-number">1</span> // 代表符号<br>        self.ans = <span class="hljs-number">0</span> // 代表结果<br>        self.table = &#123; // 状态转移表<br>            <span class="hljs-string">&#x27;start&#x27;</span>: [<span class="hljs-string">&#x27;start&#x27;</span>, <span class="hljs-string">&#x27;signed&#x27;</span>, <span class="hljs-string">&#x27;in_number&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>],<br>            <span class="hljs-string">&#x27;signed&#x27;</span>: [<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;in_number&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>],<br>            <span class="hljs-string">&#x27;in_number&#x27;</span>: [<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;in_number&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>],<br>            <span class="hljs-string">&#x27;end&#x27;</span>: [<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>],<br>        &#125;<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_col</span>(<span class="hljs-params">self, c</span>): // 根据字符来获取状态转移表的列<br>        <span class="hljs-keyword">if</span> c.isspace():<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&#x27;-&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> c.isdigit():<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, c</span>): // 根据字符进行操作。注意，是先更改状态，再进行操作<br>        self.state = self.table[self.state][self.get_col(c)]<br>        <span class="hljs-keyword">if</span> self.state == <span class="hljs-string">&#x27;in_number&#x27;</span>:<br>            self.ans = self.ans * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(c)<br>            self.ans = <span class="hljs-built_in">min</span>(self.ans, INT_MAX) <span class="hljs-keyword">if</span> self.sign == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">min</span>(self.ans, -INT_MIN)<br>        <span class="hljs-keyword">elif</span> self.state == <span class="hljs-string">&#x27;signed&#x27;</span>:<br>            self.sign = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">myAtoi</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span>: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        automaton = Automaton()<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>: // 遍历字符串<br>            automaton.get(c) <br>        <span class="hljs-keyword">return</span> automaton.sign * automaton.ans<br></code></pre></div></td></tr></table></figure><p>下面默写一次 java 版本！</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automation</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        START, SIGNED, IN_NUMBER, END<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    State state;<br>    HashMap&lt;State, State[]&gt; table;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Automation</span><span class="hljs-params">()</span> &#123;<br>        state = State.START;<br>        table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;State, State[]&gt;();<br>        table.put(State.START, <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.START, State.SIGNED, State.IN_NUMBER, State.END &#125;);<br>        table.put(State.SIGNED, <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123;State.END, State.END, State.IN_NUMBER, State.END&#125;);<br>        table.put(State.IN_NUMBER, <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123;State.END, State.END, State.IN_NUMBER, State.END&#125;);<br>        table.put(State.END, <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.END, State.END, State.END, State.END &#125;);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_col</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (Character.isDigit(c))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123; <span class="hljs-comment">// 每一个状态进行什么处理在这里实现</span><br>        state = table.get(state)[get_col(c)]; <span class="hljs-comment">//state 转到下一个状态</span><br>        <span class="hljs-keyword">if</span> (state == State.SIGNED) <br>            sign = c==<span class="hljs-string">&#x27;+&#x27;</span>? <span class="hljs-number">1</span>: -<span class="hljs-number">1</span>; <span class="hljs-comment">//从+/-判断正负</span><br>        <span class="hljs-keyword">if</span> (state == State.IN_NUMBER) &#123;<br>            <span class="hljs-comment">//首先判断 ans*10 再加上这个数是否越界</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (c - <span class="hljs-string">&#x27;0&#x27;</span>) * sign;<br>            <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE/<span class="hljs-number">10</span> || res == Integer.MAX_VALUE/<span class="hljs-number">10</span> &amp;&amp; temp &gt; <span class="hljs-number">7</span>) &#123;<br>                res = Integer.MAX_VALUE;<br>                state = State.END; <span class="hljs-comment">// 越界了，强行将状态置为 END</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (res &lt; Integer.MIN_VALUE/<span class="hljs-number">10</span> || res == Integer.MIN_VALUE/<span class="hljs-number">10</span> &amp;&amp; temp &lt; -<span class="hljs-number">8</span>) &#123;<br>                res =  Integer.MIN_VALUE;<br>                state = State.END;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            res = res * <span class="hljs-number">10</span> + temp;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">myAtoi</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">Automation</span> <span class="hljs-variable">automation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Automation</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c: s.toCharArray())<br>            automation.get(c);<br>        <span class="hljs-keyword">return</span> automation.res;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总之学习了！</p><h1 id="举一反三——isValidNumber"><a href="#举一反三——isValidNumber" class="headerlink" title="举一反三——isValidNumber"></a>举一反三——isValidNumber</h1><p>不实践，如何敢说自己掌握了？</p><p><a href="https://leetcode-cn.com/problems/valid-number/">这一题</a>，要求判断一个数字字符串是否为合法数字。合法字符串应当只包括如下内容（以及前置后置空格）——</p><ul><li>数字 0 到 9</li><li>指数 e （科学计数法的那个玩意）</li><li>正负号-&#x2F;+</li><li>小数点。</li></ul><p>数字可以分为三个部分——数字，指数符号 e，指数，其中数字可以有正负和小数点，如-43.2。指数是可选的，但是如果有 e，则必须要有指数。其中指数必须为整数，可以有正负号，比如-43.2e-10…</p><p>然而题目告诉我，像。1 这样的也合法，wtf？</p><p>于是，容易画出状态转移图——</p><p>不画了，有点麻烦（没有舒服的软件可用）……草稿纸上手画后直接写状态转移表（这个有问题）——</p><table><thead><tr><th align="center"></th><th align="center">WHITESPACE</th><th align="center">+&#x2F;-</th><th align="center">number</th><th align="center">.</th><th align="center">e</th><th align="center">other</th></tr></thead><tbody><tr><td align="center">START</td><td align="center">START</td><td align="center">SIGN</td><td align="center">INTEGER</td><td align="center">DECIMAL_POINT</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">SIGN</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">INTEGER</td><td align="center">DECIMAL_POINT</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">INTEGER</td><td align="center">END</td><td align="center">ERROR</td><td align="center">INTEGER</td><td align="center">DECIMAL_POINT</td><td align="center">E</td><td align="center">ERROR</td></tr><tr><td align="center">DECIMAL_POINT</td><td align="center">END</td><td align="center">ERROR</td><td align="center">DECIMAL</td><td align="center">ERROR</td><td align="center">E</td><td align="center">ERROR</td></tr><tr><td align="center">DECIMAL</td><td align="center">END</td><td align="center">ERROR</td><td align="center">DECIMAL</td><td align="center">ERROR</td><td align="center">E</td><td align="center">ERROR</td></tr><tr><td align="center">E</td><td align="center">ERROR</td><td align="center">E_SIGN</td><td align="center">E_NUMBER</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">E_SIGN</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">E_NUMBER</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">E_NUMBER</td><td align="center">END</td><td align="center">ERROR</td><td align="center">E_NUMBER</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">END</td><td align="center">END</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr></tbody></table><p>这里需要注意的是，-.1e10 是合法的，-1.e10 是合法的，但是-.e10 是不合法的，1. 是合法的，.1 是合法的，但。是不合法的，因此显然需要保存是否已经检测到数字……</p><p>不过可以定两个小数点的状态，让 start-&gt;dot-&gt;digit 和 start-&gt;digit-&gt;dot 两条路径不经过同一个 dot 状态，就如下面官方题解给出的状态转移表……这样也不需要做多余判定了。两个状态可以叫做 POINT_WITH_INT 和 POINT_WITHOUT_INT</p><p>下面是实现——</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automation</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        START, SIGN, INTEGER, DECIMAL_POINT, DECIMAL, E, E_SIGN, E_NUMBER, END, ERROR<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> flag;<br>    State state;<br>    HashMap&lt;State, State[]&gt; table;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Automation</span><span class="hljs-params">()</span> &#123;<br>        state = State.START;<br>        flag = <span class="hljs-literal">false</span>;<br>        table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;State, State[]&gt;();<br>        table.put(State.START,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.START, State.SIGN, State.INTEGER, State.DECIMAL_POINT, State.ERROR, State.ERROR &#125;);<br>        table.put(State.SIGN,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.ERROR, State.ERROR, State.INTEGER, State.DECIMAL_POINT, State.ERROR, State.ERROR &#125;);<br>        table.put(State.INTEGER,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.END, State.ERROR, State.INTEGER, State.DECIMAL_POINT, State.E, State.ERROR &#125;);<br>        table.put(State.DECIMAL_POINT,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.END, State.ERROR, State.DECIMAL, State.ERROR, State.E, State.ERROR &#125;);<br>        table.put(State.DECIMAL,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.END, State.ERROR, State.DECIMAL, State.ERROR, State.E, State.ERROR &#125;);<br>        table.put(State.E,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.ERROR, State.E_SIGN, State.E_NUMBER, State.ERROR, State.ERROR, State.ERROR &#125;);<br>        table.put(State.E_SIGN,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.ERROR, State.ERROR, State.E_NUMBER, State.ERROR, State.ERROR, State.ERROR &#125;);<br>        table.put(State.E_NUMBER,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.END, State.ERROR, State.E_NUMBER, State.ERROR, State.ERROR, State.ERROR &#125;);<br>        table.put(State.END,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.END, State.ERROR, State.ERROR, State.ERROR, State.ERROR, State.ERROR &#125;);<br>        table.put(State.ERROR,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>[] &#123; State.ERROR, State.ERROR, State.ERROR, State.ERROR, State.ERROR, State.ERROR &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_col</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (Character.isDigit(c))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;e&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123; <span class="hljs-comment">// 每一个状态进行什么处理在这里实现</span><br>        state = table.get(state)[get_col(c)]; <span class="hljs-comment">// 转到下一个状态</span><br>        <span class="hljs-comment">// ... 好像没有要做的处理的亚子</span><br>        <span class="hljs-keyword">if</span> (state == State.INTEGER || state == State.DECIMAL)<br>            flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 考虑到有 1. .3 这样的数字是合法，而一个小数点是非法的……必须得暂存起来了</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 需要考虑合法的终结状态有 DECIMAL_POINT，INTEGER,DECIMAL，E_NUMBER 和 END，其他状态结束都是非法的，然后要考虑以小数点结束时，是否已经有合法数字了</span><br>        <span class="hljs-keyword">return</span>  flag &amp;&amp; (<br>                state == State.INTEGER ||<br>                state == State.DECIMAL_POINT ||<br>                state == State.DECIMAL || <br>                state == State.E_NUMBER || <br>                state == State.END);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">Automation</span> <span class="hljs-variable">automation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Automation</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray())<br>            automation.get(c);<br>        <span class="hljs-keyword">return</span> automation.isValid();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后看题解，wtf？路漫漫其修远兮啊……</p><p><img src="https://i.loli.net/2020/11/12/P279vhoX3OySaGn.png"></p><p>舒服多了，也不需要一个额外的 bool 值来让代码变丑，最终也只需要判断最后是不是状态 3,5,6,8（8 由状态 3,5,6 跳转，负责判断有没有后置 0）……</p><p>下面重写一次状态转移表，就不再实现了。</p><table><thead><tr><th align="center"></th><th align="center">space</th><th align="center">+&#x2F;-</th><th align="center">number</th><th align="center">.</th><th align="center">e</th><th align="center">other</th></tr></thead><tbody><tr><td align="center">START</td><td align="center">START</td><td align="center">SIGN</td><td align="center">NUMBER</td><td align="center">DOT_WITHOUT_INT</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">SIGN</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">NUMBER</td><td align="center">DOT_WITHOUT_INT</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">NUMBER</td><td align="center">END</td><td align="center">END</td><td align="center">NUMBER</td><td align="center">DOT_WITH_INT</td><td align="center">E</td><td align="center">ERROR</td></tr><tr><td align="center">DOT_WITH_INT</td><td align="center">END</td><td align="center">ERROR</td><td align="center">NUMBER</td><td align="center">ERROR</td><td align="center">E</td><td align="center">ERROR</td></tr><tr><td align="center">DOT_WITHOUT_INT</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">NUMBER</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">E</td><td align="center">ERROR</td><td align="center">E_SIGN</td><td align="center">E_NUMBER</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">E_SIGN</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">E_NUMBER</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">E_NUMBER</td><td align="center">END</td><td align="center">ERROR</td><td align="center">E_NUMBER</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">END</td><td align="center">END</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr><tr><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td><td align="center">ERROR</td></tr></tbody></table><p>NUMBER，DOT_WITHOUT_INT，E_NUMBER 和 END 是终结状态，如果最终自动机处于这几个状态，则识别成功。</p><p><img src="https://i.loli.net/2020/11/12/T7AykRZrEXo632l.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>NFA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于一些世界语的学习资源</title>
    <link href="/2020/08-15%E4%B8%96%E7%95%8C%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90.html"/>
    <url>/2020/08-15%E4%B8%96%E7%95%8C%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90.html</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.zz9pza.net/tajpi/en/">输入法 Tajpi</a></p><p><strong>学习课程</strong></p><p>1.<a href="http://zh-cn.lernu.net/">Lernu!</a></p><p>E@I（教育@在网络）推出的免费学习世界语的网站，上面有很多课程可选，从初级到高级的都有。初级：<a href="http://zh-cn.lernu.net/kursoj/ap/index.php">Ana Pana</a> 、<a href="http://zh-cn.lernu.net/kursoj/mek/index.php">Mi estas komencanto</a> ；中级：<a href="http://zh-cn.lernu.net/kursoj/jnijk/index.php">Jen nia IJK</a>、<a href="http://zh-cn.lernu.net/kursoj/ap2/index.php">Ana renkontas</a> ；高级：<a href="http://zh-cn.lernu.net/kursoj/kio_okazas/index.php">Kio okazas</a>、<a href="http://zh-cn.lernu.net/kursoj/gerda_malaperis/">Gerda malaperis</a>。（可能要翻墙）</p><p>2.<a href="http://www.duolingo.com/">Duolingo</a></p><p>多邻国在语言学习界鼎鼎大名，就不用多介绍了，有网页版、以及 iOS 和安卓的 App。目前只有 <a href="https://www.duolingo.cn/course/eo/en/Learn-Esperanto-Online">用英文学世界语的课程</a>（截止今年已有 37 万多人在上面学习），以及 <a href="https://www.duolingo.cn/course/eo/es/Learn-Esperanto-Online">用西班牙学世界语的课程</a>（预计 16 年 6、7 月份会上线），中文学习世界语的课程我们正在积极申请中。</p><p>3.<a href="http://kurso.com.br/">Kurso de Esperanto</a></p><p>巴西人出的世界语学习软件，支持 win、linux 和 mac。课程内容丰富，有互动和练习，有指导老师。缺点：发音一股巴葡味</p><p>4.<a href="http://pacujo.net/esperanto/course/">Pacujo 世界语函授课程</a>（英文授课）</p><p>一共 10 课，会自动分配指导老师，学完就了解了世界语的基本语法。</p><p>5.<a href="http://kursosaluton.org/">Saluton</a></p><p>国际世界语协会（UEA）出品，直接学习法，图文并茂，有发音。</p><p>6.<a href="https://www.youtube.com/user/pasportotutamondo/videos">Pasporto al la tuta mondo</a> （须翻墙）（<a href="http://list.youku.com/albumlist/show%3Fid%3D17743369%26ascending%3D1%26page%3D1">优酷链接</a>，无需翻墙）</p><p>视频教学，一共 16 课，Youtube 上可看。</p><p>7.<a href="https://www.youtube.com/watch%3Fv%3DmWbyXVSiCxw">Mazi en Gondolando</a> （youtube，须翻墙）（已添加 <a href="http://www.tudou.com/programs/view/AAmZopgs3WE/">土豆链接</a>，无需翻墙）</p><p>动画片</p><p>8.<a href="http://eduinf.waw.pl/esp/lern/uem/index.php">Universala Metodo</a></p><p>完全直接法看图自学</p><p>\9. <a href="http://learn.esperanto.com/zh/">Zagrba Metodo</a></p><p>据说是入门最快的世界语课程</p><p><strong>发音：</strong></p><p><a href="http://zh.forvo.com/languages/eo/">Forvo</a>：是个开放的发音词典，基本上所有单词都能找到真人发音</p><p><strong>词典</strong>：</p><p><a href="http://vortaro.net/">Vortaro.net</a>： 最权威的世界语原文词典 （须有注册）</p><p><a href="http://www.reta-vortaro.de/revo/">Reta Vortaro</a>：开放的世界语词典</p><p><a href="http://www.simplavortaro.org/">Simpla Vortaro</a>：基于 Reta Vortaro，界面漂亮</p><p><a href="http://zh-cn.lernu.net/">Lernu 词典</a>：词典在 lernu 首页的右下角</p><p><strong>例句&#x2F;语料库</strong>：</p><p><a href="http://tekstaro.com/">Tekstaro</a>: 可最权威的世界语书籍中查询单词</p><p><a href="http://tatoeba.org/epo/">Tatoeba</a>：开放的句子库，上面世界语条目数仅次于英语</p><p><strong>写作批改、语法问题咨询：</strong></p><p><a href="https://www.italki.com/notebooks/esperantohttps%3A//www.italki.com/teachers/professional/esperanto%3Fref%3Desperanto%26utm_source%3Desperanto%26utm_medium%3Dpartner%26utm_campaign%3Daffiliate">Italki 社区</a>：可以提交自己写的短文，有热心的网友批改。</p><p><a href="https://www.facebook.com/groups/konsultejo/">Lingva Konsulejo</a>：Facebook 世界语语法问题咨询小组，回复很快。</p><p><strong>听力</strong></p><p><a href="https://www.youtube.com/user/Evildela">Evildea</a>：世界语界的 Papi 酱，每天</p><p><a href="http://muzaiko.info/">Muzaiko</a>：最最 mojosa 的世界语网络电台</p><p><a href="http://esperanto.cri.cn/">ĈRI</a>：中国国际广播电台世界语广播</p>]]></content>
    
    
    
    <tags>
      
      <tag>世界语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《CGMA colour and light》笔记</title>
    <link href="/2020/07-30%E3%80%8ACGMA%20colour%20and%20light%E3%80%8B%E7%AC%94%E8%AE%B0.html"/>
    <url>/2020/07-30%E3%80%8ACGMA%20colour%20and%20light%E3%80%8B%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h2 id="week-1-the-inportant-of-values-part-1-design-a-picture"><a href="#week-1-the-inportant-of-values-part-1-design-a-picture" class="headerlink" title="week 1 the inportant of values, part 1: design a picture"></a>week 1 the inportant of values, part 1: design a picture</h2><p>一个色彩课程为什么要从构图入手？因为——</p><blockquote><p>simple values and simple shapes（shape 侧重剪影，平面，form 侧重三维的事物的形状） are the driving force behind every good composition.<br><strong>简单的色值和简单的形状是好的作品的背后的驱动力</strong></p></blockquote><p>构图，<strong>实际上包括不止是形状，还有色值</strong>。</p><h2 id="week-2-the-inportant-of-values-part-2-painting-form"><a href="#week-2-the-inportant-of-values-part-2-painting-form" class="headerlink" title="week 2 the inportant of values, part 2: painting form"></a>week 2 the inportant of values, part 2: painting form</h2><p>第一周和第二周只关注 value，学习<strong>五大调子</strong>，或者说 values——allow us to paint even the most complex forms in nature.</p><h2 id="week-3-color-temperature"><a href="#week-3-color-temperature" class="headerlink" title="week 3 color temperature"></a>week 3 color temperature</h2><p>the holy grail of color theory——color temperature</p><p>这个教程最不同的地方在于，它从色温入手来学习颜色。我们没必要死扣现实中的那种真实的色彩（这种色彩，实际上可以认为是太阳光，或者其他光源作用下的色彩，它实际上<strong>是受色温规律支配的</strong>（当然，究竟是不是，我不在乎），而在实际绘画中，有多少人是真的按照完全写实的来？很多画师都会把色彩的调子拉开（亮面和暗面的颜色），或压平，但是色温规律是不会变的）。<br>但同时也要记住，这里的色温规律也只是一般的规律。不能拿来直接使用，而是作为一种理论，融合在实践中，指导我们绘制和分析画作。同时它也不是教条（真正普适的只有素描的五大调子吧），可以在一定的情况下去破坏它。</p><h2 id="week-4-color-keys"><a href="#week-4-color-keys" class="headerlink" title="week 4 color keys"></a>week 4 color keys</h2><p>color key 是一种概念艺术，类似概念图之类的玩意，在小画布上，细节较抽象，快速表现色彩，情绪，氛围（显然这就很适合拿来做学习，就像色彩的小色稿）。</p><h2 id="week-5-concept-art-part-1-planning"><a href="#week-5-concept-art-part-1-planning" class="headerlink" title="week 5 concept art, part 1: planning"></a>week 5 concept art, part 1: planning</h2><p>概念艺术，使用我们脑子里的一个 idea，开始绘制一幅 concept art 图</p><h2 id="week-6-concept-art-part-2-Painting-the-final"><a href="#week-6-concept-art-part-2-Painting-the-final" class="headerlink" title="week 6 concept art, part 2: Painting the final"></a>week 6 concept art, part 2: Painting the final</h2><p>动员前面所学的所有东西，色值，色温，构图……来完成这幅图</p><h2 id="week-7-materials-and-mark-making"><a href="#week-7-materials-and-mark-making" class="headerlink" title="week 7 materials and mark-making"></a>week 7 materials and mark-making</h2><p>似乎是创造质感，纹理？还不太明确，等学到这里的时候再改。</p><p>mark 似乎是构图的元素，C 线，S 线和直线</p><p>TODO: 摸了</p><h2 id="week-8-master-study"><a href="#week-8-master-study" class="headerlink" title="week 8 master study"></a>week 8 master study</h2><p><strong>遵循几个世纪以来的艺术教育传统</strong>，通过一张杰作，对它进行全面的研究，来扩展我们的知识 </p><h2 id="goal"><a href="#goal" class="headerlink" title="goal"></a>goal</h2><p>significantly raise your level of competency and skill, and put you on the path of accelerated learning<br>显著提高你的能力和技能水平， 让你走上加速学习的道路</p><p>and after years of good practice…</p><p>mastery!</p><h1 id="week-1-the-inportant-of-values-part-1-design-a-picture-1"><a href="#week-1-the-inportant-of-values-part-1-design-a-picture-1" class="headerlink" title="week 1 the inportant of values, part 1: design a picture"></a>week 1 the inportant of values, part 1: design a picture</h1><blockquote><p>maybe <strong>the most important week</strong> of the class. </p></blockquote><p>构图这么重要？因为 simple values and simple shapes are the driving force behind every good composition.    </p><blockquote><p>art is based on a mastery of the basics and there is nothing more <strong>fundamental</strong> (than values and shapes).</p></blockquote><p>可见，好的，简单的色值和形状是<strong>基础的</strong>（fundamental 而非 basic，基础！基础指所有其它的具体的，复杂的内容都搭在这上面，就像骨架，像低级，而基本指的是简单，入门等，这两个是有区别的，基础不一定基本……甚至不一定好学。就像机器语言，汇编语言是一切高级语言的基础……）。</p><h2 id="goal-1"><a href="#goal-1" class="headerlink" title="goal"></a>goal</h2><blockquote><p>after this week you will have——<br>an understanding of <strong>what makes an effective picture works</strong><br>a procedure（过程） for better designing your own pictures<br>An understanding of <strong>simplification</strong>（简化，不用说就知道，这个非常非常非常非常非常重要）: what it is and how to achieve it<br>The ability to imbue a <strong>strong emotional idea</strong> into your compositions<br>A method for deciding <strong>where to place elements</strong> within a composition <strong>for maximum impact</strong><br>An editor’s sense for <strong>detecting what doesn’t work</strong>  </p></blockquote><ol><li>了解什么让画作有……味道</li><li>更好设计画作的过程</li><li>理解简化，它是什么，如何实现</li><li>如何让作品富有感情</li><li>决定如何放置画作中的元素，让它效果最大化</li><li>编辑者的意识——理解什么无法起作用（删繁就简？）</li></ol><h2 id="designing-principle"><a href="#designing-principle" class="headerlink" title="designing principle"></a>designing principle</h2><p>从一开始作画，就确定整幅画的 designing principle，设计原则，或者说构图？（确定 shape，或者说剪影之类的，这是通过对比实现的）</p><p>通过亮暗对比（明暗交界线）的三角构图，它坚实，<strong>易读</strong>。<br><img src="https://i.loli.net/2020/05/24/Jg4mlrx6zWQGeIZ.png"></p><p>将 designing principle 视为——the simple idea behind a composition, its <strong>DNA</strong>. </p><p>它应当是简单的，因为整个画作都要从它开始构建。any sense of detail or any intricacy, any little color change or value shift or a shape intricacy is hinges on the design principle. <strong>任何细节或任何复杂性，任何微小的颜色变化或值偏移或形状复杂性都取决于设计原理</strong>。</p><p>它的三个属性（可以共有）——</p><ol><li>shape-based（上面的就是这样的，通过形状来构图）</li><li>path（引导人的视线）</li><li>value pattern（明暗模式？？）</li></ol><p>我觉得吧，1 和 3 都是依靠对比来体现的，2 是依靠疏密啊，相近色啊之类的来实现的。</p><h3 id="basic-marks"><a href="#basic-marks" class="headerlink" title="basic marks"></a>basic marks</h3><ul><li>C-curve</li><li>S-curve</li><li>Stright</li></ul><p><img src="https://i.loli.net/2020/05/24/v63Ir4GPeCMNRb5.png"></p><p>curve 是线条，curve 组成的封闭图形，就是 shape，形状。</p><p>我们应当使用 mark，<strong>记号</strong>来简化自然界中的复杂形状。</p><p><img src="https://i.loli.net/2020/05/24/HZ4oaz9en1XhMbk.png"><br><strong>简单&#x3D;漂亮</strong>。自然界的形状总是过于复杂，就像地图上的路线图。</p><p>因此，我们需要简化，我们一直在简化。</p><p>而通过这种简化，通过这三种记号，我们将通向** design**。</p><p><strong>design——Simplifying the shapes found in the real world, and using them as the foundation for our work.</strong><br><strong>设计——简化真实世界的形状，以它们作为我们的作品的基础。</strong></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><h4 id="design-gives-things-a-reason-to-exist"><a href="#design-gives-things-a-reason-to-exist" class="headerlink" title="design, gives things a reason to exist"></a>design, gives things a reason to exist</h4><p><img src="https://i.loli.net/2020/05/24/gW2AruynUNlTM5o.png"><br>显然的 S 曲线。或者说，这幅图的设计原则，DNA，就是 S 曲线。但是同时，不能完全符合某个记号，必须要增添戏剧性，真实性，也就是说必须要去主动破坏（添加波澜）这曲线。<strong>设计原则和画面元素，就像特殊和一般的关系，设计原则要隐藏在画面元素后，由画面元素来表示，而这种表示也不能是直接的，是带有偶然性的</strong>。</p><p><strong>design, gives things a reason to exist</strong>.<br><strong>画面元素应当有存在的理由</strong>。<br>构成记号的元素有构成的理由，破坏（这种破坏不能是全盘推倒，而只是小小的变化）记号的元素也有破坏的理由。不能添加对设计原则起损害作用的元素，除非你改变了心意，突然想表达其他东西 w。</p><p>突然感觉，他们实际上和我们对待艺术是不同的，他们将表达作为第一位，对情绪和氛围更加看重，而我们则注重正确与否，注重真实，技法等作为第一位……从这方面上来说，倒也没有孰优孰劣。但是从我的目标而言，我是要两手抓，两手硬的……</p><h4 id="focus-point"><a href="#focus-point" class="headerlink" title="focus point"></a>focus point</h4><p><img src="https://i.loli.net/2020/05/24/awhefNQXWLbzGd9.png"><br>经典，Z 字构图。它引导人的视线从前景到背景，给画面深度感。</p><p>同时，这个 Z 曲线也突出了画面顶上的骑士。因为他起了破坏这个 Z 曲线的作用。而右边的骑士则不被重视，因为他处在次要地位。</p><p>这引出了一个概念——focus point。</p><p>focus point is——<br><strong>The singular thing the picture is about</strong><br><strong>The reason the picture exists</strong>  </p><p>焦点是画作（镜头）的中心，是作品的存在理由，是作品中的奇特之处（当然，这种“奇特”是其它部分的元素对比出来的）。</p><p><strong>设计原则应当决定于焦点</strong>，也就是说，构图啊，色彩啊，色调啊，一切其它的东西，都要服务于焦点，服务于你想表达的东西。</p><p>焦点可以不止一个，可以有主要的，有次要的，同样，构图也可以不止是一个记号，可以是多个记号的混合，比如上面那幅就是三个直线的组合。</p><p><img src="https://i.loli.net/2020/05/24/pJtudPiqg1a8cVK.png"><br>比如这幅的焦点。</p><p>画面可以只要焦点吗？不是不可以。<strong>画面中的其他元素起着影响氛围和感情的作用</strong>。而实际上焦点只所以是焦点，也是因为有其它次要元素。但是次要元素不能喧宾夺主，比如这副，后面的山啊，树啊，都很虚（所以这里没有说山是一个 C 曲线）。</p><h4 id="如何看待一幅画？"><a href="#如何看待一幅画？" class="headerlink" title="如何看待一幅画？"></a>如何看待一幅画？</h4><p>看待一幅画，最首要的是看待两个方面——<strong>色值和形状</strong>，这两方面并非孤立，而是要相互联系地看待。</p><p>所谓色值，就是看待不同色值的分配，是否符合三大面五大调子？能够造成一个焦点（当然，这是和形状共同看待的）？</p><p>所谓形状，就是看待不同形状（形状的区分是根据色值来的）的分配，放置等，是否大，中，小形状分配得当？是否运用 C 曲线，S 曲线和直线来引导视线和确定焦点？</p><p><img src="https://i.loli.net/2020/07/25/hfJY3Ruq1CvMWce.png"></p><p>两个反面例子。</p><p>色值问题是毋庸置疑的，这个太过明显了。<br>首先，它们<strong>没有充分利用空间</strong>，画中充斥着大量的<strong>“死亡空间”</strong>，（我认为这两幅画都可以将地平线调高，在这些没有被利用的死亡空间里多做一些文章）简单的修改是首先让构图符合三分法则，对两幅画，将树和树叶往左挪一下，移到 3&#x2F;2 的位置。<br>然后，它们<strong>形状的区分</strong>做的不好，整幅画只有大形状和中形状，没有小形状，因此构图很不自然，让两幅画毫无生气和焦点。</p><p><img src="https://i.loli.net/2020/07/25/9VhnixT3dGjHODR.png"></p><p>一个不是完全正面的例子。它形状分配不错，能引导人的视线，值也比较正确，但是它<strong>缺乏焦点</strong>，同时缺少小形状来中和中大形状（显得缺乏细节），或许最近的这一片饱和度比较高的绿，应该更加强调饱和度，并且提高亮度，总之就是提高前景的对比。同时这一条道路或许也得修改一下。然后，左下三分之一的位置，应当放置一些小形状作为焦点，比如马，动物，etc</p><h1 id="week-2"><a href="#week-2" class="headerlink" title="week 2"></a>week 2</h1><p>TODO: 摸了</p><h1 id="week-3"><a href="#week-3" class="headerlink" title="week 3"></a>week 3</h1><p>这一周要学到——</p><ul><li>An understanding of how color and light work together in nature</li><li>An understanding of color temperature as natures color theory</li><li>Various methods of interpreting and applying color temperatures to your painting practice</li><li>An understanding of how color acts in light and shadow families</li><li>An appreciation of the power of grays</li><li>The answer to the question, “What color should I choose?</li><li>对现实中的光和色的理解</li><li>对以色温作为自然的色彩理论的理解</li><li>在绘画练习中解释和应用色温原理的多种方法</li><li>对光家族和影家族里颜色的作用的理解</li><li>对灰的力量的理解</li><li>对“我该选择什么颜色”的理解</li></ul><p><strong>颜色只有在明暗正确的情况下起作用。当你不知道怎么选择颜色的时候，当你觉得你颜色怪怪的的时候，先去看看你的调子对不对</strong>。</p><h2 id="color-terminology"><a href="#color-terminology" class="headerlink" title="color terminology"></a>color terminology</h2><p>色彩的术语。各种颜色的名称，我觉得实际上保留六种就可以了，红黄蓝，橙，绿，紫，然后用冷暖，亮暗，灰（非灰即纯）等形容词来修饰它们。这实际上就是概括了** HSV——色相，饱和度和明度——色彩的三个属性<strong>，非常具有</strong>实践意义**。</p><h2 id="color-temperature"><a href="#color-temperature" class="headerlink" title="color temperature"></a>color temperature</h2><p>色温。色温无法测量，它是相对的，需要上下文（当然，对于单一的颜色，或者当我们把色环一分为二，分为冷暖色的时候，它的上下文就是白色。</p><p>色温的范畴是<strong>冷暖</strong>。我们对冷暖的认识应该是天生的，但是这种天生也是人类长期生产生活实践中发展来的，但是应该仍旧属于自然性…就如手部的复杂肌肉和骨骼也是跟随着生产生活实践的发展而发展的。动物怕火，而人类不怕，应当就是这样的例证。而我们所谓的暖色也是和火相关的。比如红色，橙色，黄色。</p><p>冷和暖是相对的，互为依存的。没有暖就没有冷，没有冷就没有暖；冷和暖在一定情况下是可以共存的，除了最暖的色和最冷的色，每一个色都能作为冷色和暖色，当它的上下文比他更暖或更冷时。</p><p><img src="https://i.loli.net/2020/05/25/Ovlz2sdU4xVqjtL.png"><br>将 RYB 色环分为 12 色，我认为，最符合实践需要的方式是用四个色作为分界，黄绿色，黄色，紫色，紫红色，这样能给每一个颜色的冷暖方向都找到依据。</p><p>因此，色环分为冷暖两个家族……我选择用集合这个词。冷暖的集合和光影的集合的区别在于，后者有清晰的界限（明暗交界线），而前者的差异更加微妙，不止是色相，<strong>饱和度的改变也会改变冷暖</strong>。暖灰色在暖色中会显得冷，因而它就属于冷的集合，可是它的色相又在暖的集合……总之很微妙，根据实际来，具体分析。</p><p>同时，因为色温总是相对的，我们应当对每一个颜色都添加上冷暖这样的形容词，红色总是抽象的，冷红，暖红，就比较有实践意义。</p><p>需要注意的是，<strong>蓝色要变成暖色，要从紫红色方向走</strong>。</p><h2 id="色温的表现"><a href="#色温的表现" class="headerlink" title="色温的表现"></a>色温的表现</h2><p>就如颜色有温度，光也有温度，也有冷光和暖光（当然，也有中性光），画画应当从确定光源温度开始。</p><p><strong>物体的受光面总是往光源色上靠拢</strong>。</p><p>画画从固有色开始，从平庸的开始。</p><p>TODO: 摸了</p>]]></content>
    
    
    
    <tags>
      
      <tag>画画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atom 下 common lisp 的环境搭建</title>
    <link href="/2020/06-30Atom%E4%B8%8Bcommon%20lisp%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <url>/2020/06-30Atom%E4%B8%8Bcommon%20lisp%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    
    <content type="html"><![CDATA[<p>几个月前的文章，可能将来还有参考意义…</p><p>搭建这破环境让我费了些脑筋，总之记录下来。</p><h1 id="下载-sbcl-和-slime"><a href="#下载-sbcl-和-slime" class="headerlink" title="下载 sbcl 和 slime"></a>下载 sbcl 和 slime</h1><ol><li><p>下载和安装 <a href="http://www.sbcl.org/platform-table.html">sbcl</a> （老实说，这点击表格里的元素来下载……我之前好多次都直接忽略过去了）</p></li><li><p>从 github 上克隆 slime——  </p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/slime/slime<br></code></pre></div></td></tr></table></figure></li></ol><h1 id="配置-atom-slime"><a href="#配置-atom-slime" class="headerlink" title="配置 atom-slime"></a><del>配置 atom-slime</del></h1><p>atom 需要以下插件——language-lisp, atom-slime, parinfer（拿缩进来控制代码结构……python 并感，但是真的很酷！）</p><blockquote><p>其中，从 atom 上直接获取的 atom-slime 的 REPL 有一些问题（已解决，但是未“推送”到 atom 上……需要从 github 上手动 clone 最新的版本），导致其输出令我难以忍受，而且下方的状态栏的字体不好看，因此进行一些修改。</p><ol><li><p>从 github 上 clone atom-slime，并安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/sjlevine/atom-slime<br><span class="hljs-built_in">cd</span> ./atom-slime<br>apm install<br></code></pre></div></td></tr></table></figure></li><li><p>编辑其下的 lib&#x2F;atom-slime-status-view.coffee，搜索 monospace，把那个 style 删掉。</p></li><li><p>将该文件夹移到 你的用户名&#x2F;.atom&#x2F;packages 下</p></li><li><p>完成！</p></li></ol></blockquote><h1 id="我选择-slima"><a href="#我选择-slima" class="headerlink" title="我选择 slima"></a>我选择 slima</h1><p>atom-slime 似乎缺乏维护，slima 是一个从 atom-slime fork 下来的 project，它仍在积极维护中，并且解决了上述的问题（虽然字体仍然难看）。不过我希望它能够更加全面地利用 GUI 界面的威力，让鼠标用途更多些。</p><p><img src="https://i.loli.net/2020/12/03/Tiz4fYmByUVthK3.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Lisp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clisp 学习笔记 2-列表</title>
    <link href="/2020/06-20clisp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%88%97%E8%A1%A8.html"/>
    <url>/2020/06-20clisp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%88%97%E8%A1%A8.html</url>
    
    <content type="html"><![CDATA[<h1 id="cons-amp-atom-amp-list"><a href="#cons-amp-atom-amp-list" class="headerlink" title="cons &amp; atom &amp; list"></a>cons &amp; atom &amp; list</h1><p>对于列表，应当如此抽象——</p><p>可以认为，cons 函数是做这样一件事——把两个对象结合成一个有两个元素的对象，使用 car 取第一个对象，使用 cdr 取其余对象。或者说，car 和 cdr 是两个指针。</p><p><img src="https://i.loli.net/2020/06/13/by3j5opOT94YDlQ.png"></p><p>这种 cons 表示法叫做箱子表示法（box），因为每一个 cons 对象用箱子表示。而列表，则是一连串箱子。</p><p>要注意的是，包含列表的列表叫做嵌套列表，否则叫平坦列表（flatlist），或者叫序列 sequence。</p><p>谓词 consp 判断元素是否 cons 对象。<strong>不是 cons 对象的就是 atom</strong>。列表是特殊的，空列表等同于 nil，它也是 atom，而非空列表是 cons。</p><p>因此，我们可以定义 listp——</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> our-listp (<span class="hljs-name">obj</span>)<br>    (<span class="hljs-name">or</span> (<span class="hljs-name">null</span> obj) (<span class="hljs-name">consp</span> obj))) <span class="hljs-comment">; 如果 obj 是 nil，那它是空列表，是列表，如果是 cons 对象，也是列表。</span><br><br>(<span class="hljs-name">defun</span> our-atom (<span class="hljs-name">obj</span>) <span class="hljs-comment">; 为什么不遵守谓词的命名？</span><br>    (<span class="hljs-name">not</span> (<span class="hljs-name">consp</span> obj))) <span class="hljs-comment">; 不是 cons 的，就是 atom。因此，其他数据结构，比如序列，也是 atom！</span><br></code></pre></div></td></tr></table></figure><h1 id="equal-amp-eql"><a href="#equal-amp-eql" class="headerlink" title="equal &amp; eql"></a>equal &amp; eql</h1><p>每次调用 cons（和 list），lisp 都会分配一块新的内存给两个指针，因此使用同样的参数调用两次 cons，其数值上一样，但是并非是同一个对象。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">eql</span> (<span class="hljs-name">cons</span> &#x27;A <span class="hljs-literal">nil</span>) (<span class="hljs-name">cons</span> &#x27;A <span class="hljs-literal">nil</span>))<br>NIL<br><br>(<span class="hljs-name">equal</span> (<span class="hljs-name">cons</span> &#x27;A <span class="hljs-literal">nil</span>) (<span class="hljs-name">cons</span> &#x27;A <span class="hljs-literal">nil</span>))<br>T<br></code></pre></div></td></tr></table></figure><p>可见，eql 比较是否是一个对象，equal 比较是否数值相同。就像 python 里 is 和&#x3D;&#x3D;的关系，前者是判断是否是一个对象——在内存里是同一块地址，后者判断是否数值相同。</p><h1 id="指针？不存在的"><a href="#指针？不存在的" class="headerlink" title="指针？不存在的"></a>指针？不存在的</h1><p>lisp 只有引用，没有指针。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">setf</span> x &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) y x)<br>(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)<br>&gt; (<span class="hljs-name">setf</span> (<span class="hljs-name">car</span> x) <span class="hljs-number">3</span>)<br><span class="hljs-number">3</span><br>&gt; x<br>(<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)<br>&gt; y<br>(<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) <span class="hljs-comment">; 可见，x 和 y 指向同一个地址</span><br>&gt; (<span class="hljs-name">eql</span> x y)<br>T<br></code></pre></div></td></tr></table></figure><h1 id="建立列表"><a href="#建立列表" class="headerlink" title="建立列表"></a>建立列表</h1><p>复制列表——copy-list 和 copy-tree</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">defun</span> our-copy-list (<span class="hljs-name">lst</span>) <span class="hljs-comment">; 只对 flatlist 起作用</span><br>    (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> lst)<br>        <span class="hljs-literal">nil</span><br>        (<span class="hljs-name">cons</span> (<span class="hljs-name">car</span> lst) (<span class="hljs-name">our-copy-list</span> (<span class="hljs-name">cdr</span> lst)))))<span class="hljs-comment">; 可见，只有 cdr 是复制的，这里的 car 如果不是 atom（因而使 cons），那就变成引用了，要出篓子。</span><br><br><span class="hljs-comment">; 举个例子</span><br>&gt; (<span class="hljs-name">setf</span> x &#x27;((<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) <span class="hljs-number">1</span> <span class="hljs-number">2</span>) y (<span class="hljs-name">copy-list</span> x))<br>((<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) <span class="hljs-number">1</span> <span class="hljs-number">2</span>)<br>&gt; (<span class="hljs-name">setf</span> (<span class="hljs-name">car</span> (<span class="hljs-name">car</span> y)) <span class="hljs-number">3</span>) <span class="hljs-comment">; 更改的是 y</span><br><span class="hljs-number">3</span><br>&gt; x<br>((<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) <span class="hljs-number">1</span> <span class="hljs-number">2</span>) <span class="hljs-comment">; 可见，第一个 cons 的 car，即 (1 2 3) 仍旧是被引用了。</span><br><br>&gt; (<span class="hljs-name">defun</span> our-copy-tree (<span class="hljs-name">lst</span>)<br>    (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> lst)<br>        <span class="hljs-literal">nil</span><br>        (<span class="hljs-name">cons</span> (<span class="hljs-name">our-copy-tree</span> (<span class="hljs-name">car</span> lst)) (<span class="hljs-name">our-copy-tree</span> (<span class="hljs-name">cdr</span> lst))))) <span class="hljs-comment">; 既复制 car，也复制 cdr</span><br></code></pre></div></td></tr></table></figure><h1 id="其他存取函数"><a href="#其他存取函数" class="headerlink" title="其他存取函数"></a>其他存取函数</h1><p>其他存取函数都是通过 car 和 cdr 定义的，nth 和 nthcdr 分别找到第几个位置的 car 和 cdr。nth 相当于是 (car (nthcdr index lst))</p><p>它们都是零索引的，即从 0 开始计数。</p><p>同时，还有从 fitst 到 tenth，取相对应位置的对象。它们是非零索引的。如，(second x) 相同于 (nth 1 x)</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">nth</span> <span class="hljs-number">0</span> &#x27;(a b c)) <span class="hljs-comment">;xxxth 其实是英文的序数词，比如 15th，15 日这样的</span><br>A<br>&gt; (<span class="hljs-name">nthcdr</span> <span class="hljs-number">2</span> &#x27;(a b c))<br>(<span class="hljs-name">C</span>)<br></code></pre></div></td></tr></table></figure><h1 id="映射函数（mapping-function）"><a href="#映射函数（mapping-function）" class="headerlink" title="映射函数（mapping function）"></a>映射函数（mapping function）</h1><p>所谓映射函数，就是对列表元素都进行函数调用，将结果作为一个列表返回。最常用的是 mapcar。</p><p>此外，maplist 和 mapcar 接受一样的参数，但是 maplist 对每一个 cdr（包括该 cons 本身）进行调用，最终返回结果的 list。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">mapcar</span> #&#x27;(lambda (x) (+ x <span class="hljs-number">10</span>)) &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br>(<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span>)<br><br>&gt; (<span class="hljs-name">maplist</span> #&#x27;(lambda (lst) lst) &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)) <span class="hljs-comment">;lambda 接受一个 list 而非 atom</span><br>((<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) (<span class="hljs-number">2</span> <span class="hljs-number">3</span>) (<span class="hljs-number">3</span>))<br></code></pre></div></td></tr></table></figure><h1 id="列表模拟的数据结构"><a href="#列表模拟的数据结构" class="headerlink" title="列表模拟的数据结构"></a>列表模拟的数据结构</h1><p>这些数据结构都是 cons 对象，它们的操作函数都是共同的，你要抽象成什么结构，就用什么函数。</p><h2 id="树（tree）"><a href="#树（tree）" class="headerlink" title="树（tree）"></a>树（tree）</h2><p>cons 对象可以想象成二叉树，car 代表左子树，cdr 代表右子树。<br>比如对 (a (b c) d)，其结构可以想象为——<img src="https://i.loli.net/2020/06/13/GlbTckLWAUQ84u5.png"></p><p>substitute 接受三个参数，新值，原值，一个<strong>序列</strong>，它会返回这样一个副本，其中将序列里的所有原值变为新值，要注意的是，这里的原值，新值等，是按 car 找的。</p><p>subst 则对树起作用，即它遍历所有 atom 而非原列表的所有 car。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> our-subst (<span class="hljs-name">new</span> old tree-node)<br>    (<span class="hljs-name">if</span> (<span class="hljs-name">equal</span> old tree-node)<br>        new<br>        (<span class="hljs-name">if</span> (<span class="hljs-name">atom</span> tree-node) <span class="hljs-comment">; 如果 tree-node 是 atom（包括 nil</span><br>            tree-node <span class="hljs-comment">; 初始用例被迫使用在这里……</span><br>            (<span class="hljs-name">cons</span> (<span class="hljs-name">our-subst</span> new old (<span class="hljs-name">car</span> tree-node))<br>                  (<span class="hljs-name">our-subst</span> new old (<span class="hljs-name">cdr</span> tree-node)))))) <span class="hljs-comment">; 这种 car 和 cdr 同时进行递归，叫双重递归，遍历树时常用。</span><br></code></pre></div></td></tr></table></figure><h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><p>集合，同数学或 python 中的 set。</p><p>它有 member 函数，测试一个元素是否在集合内，如果是，则返回从这个元素开始的部分。至于为什么这么用，我还不知道。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">member</span> &#x27;b &#x27;(a b c))<br>(<span class="hljs-name">B</span> C)<br></code></pre></div></td></tr></table></figure><p>member 同时有 test 和 key 参数，test 参数表明使用什么函数进行测试，key 参数是首先对元素进行处理的函数，简单来说，member 对 set 的每一个元素先用 key 进行转换，然后用 test 对转换后的元素和接受的值进行测试，成功则结束函数，返回此时的 cdr。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">member</span> &#x27;A &#x27;((b) (c) (a) (d)) <span class="hljs-symbol">:key</span> #&#x27;car)<br>((<span class="hljs-name">A</span>) (<span class="hljs-name">D</span>))<br><br>&gt; (<span class="hljs-name">member</span> <span class="hljs-number">3</span> &#x27;((<span class="hljs-number">2</span>) (<span class="hljs-number">3</span>) (<span class="hljs-number">1</span>) (<span class="hljs-number">4</span>) (<span class="hljs-number">5</span>)) <span class="hljs-symbol">:key</span> #&#x27;car <span class="hljs-symbol">:test</span> #&#x27;&lt;) <span class="hljs-comment">; 测试只有在成功时停止，成功时，3&lt;4，此时返回真，此时的元素为 (4)，取其后的值</span><br><span class="hljs-comment">; 也可以认为——询问每一个元素的 car 是否满足 3 &lt; 它。</span><br></code></pre></div></td></tr></table></figure><p>member-if 函数则是测试是否有元素满足一个谓词。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">member-if</span> #&#x27;oddp &#x27;(<span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span>)) <span class="hljs-comment">;oddp——奇数谓词</span><br>(<span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span>)<br></code></pre></div></td></tr></table></figure><p>adjoin 函数可以认为是 set 的添加，只有在 set 中无此元素，才添加它。它是 cons 的变种</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">adjoin</span> &#x27;b &#x27;(a b c))<br>(<span class="hljs-name">A</span> B C)<br>&gt; (<span class="hljs-name">adjoin</span> &#x27;z &#x27;(a b c))<br>(<span class="hljs-name">Z</span> A B C)<br></code></pre></div></td></tr></table></figure><p>然后是并集 (union)、交集 (intersection) 以及补集 (complement)，它们是由函数 union 、 intersection 以及 set-difference 实现的。这个不用多说了。</p><h1 id="序列（sequence）"><a href="#序列（sequence）" class="headerlink" title="序列（sequence）"></a>序列（sequence）</h1><p>序列可以认为是一系列有特定顺序的对象（虽然是一串 cons 序列，或者说链表模拟的）。</p><p>length 函数，返回序列的长度。这个不用解释，都有。</p><p>subseq 函数，返回子序列。第一个参数为序列第二个参数是第一个开始引用的元素的 index，第三个参数（可选）是第一个不引用进来的元素的 index。</p><p>subseq 是复制还是引用？<strong>复制</strong>，这其实是显然的 www 因为从中间抠出来一个子序列，最后一个 cons 元素的 cdr 必须（设置）为 nil，所以有副作用，所以应当是复制。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">setf</span> x &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>))<br>(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>)<br>&gt; (<span class="hljs-name">eql</span> (<span class="hljs-name">cdr</span> x) (<span class="hljs-name">subseq</span> x <span class="hljs-number">1</span>))<br>NIL <span class="hljs-comment">; 复制</span><br></code></pre></div></td></tr></table></figure><p>reverse 函数返回颠倒的序列。注意，它是引用的！</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">reverse</span> &#x27;(A B C))<br>(<span class="hljs-name">C</span> B A)<br><br>(<span class="hljs-name">defun</span> mirror? (<span class="hljs-name">seq</span>) (  <span class="hljs-comment">; 可见变量名可以随便玩</span><br>    (<span class="hljs-name">let</span> ((<span class="hljs-name">len</span> (<span class="hljs-name">length</span> seq)))<br>        (<span class="hljs-name">and</span> (<span class="hljs-name">evenp</span> len)<span class="hljs-comment">;evenp 为偶数谓词（oddp 为奇数谓词）这里似乎直接钦定回文应当是偶数了……罢了</span><br>            (<span class="hljs-name">let</span> ((<span class="hljs-name">mid</span> (<span class="hljs-name">/</span> len <span class="hljs-number">2</span>)))<br>                (<span class="hljs-name">equal</span> (<span class="hljs-name">subseq</span> seq <span class="hljs-number">0</span> mid) (<span class="hljs-name">subseq</span> (<span class="hljs-name">reverse</span> seq) <span class="hljs-number">0</span> mid)))))))<br></code></pre></div></td></tr></table></figure><p>**sort **函数。sort 是破坏性的，它有副作用——更改原序列。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">setf</span> x &#x27;(<span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>))<br>(<span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>)<br>&gt; (<span class="hljs-name">sort</span> x #&#x27;&lt;) <span class="hljs-comment">;comp 参数是必要的</span><br>(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>)<br>&gt; x<br>(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>) <span class="hljs-comment">; 可见 x 的值改变了，不是副本。如果要保留原结果，应当传入副本。</span><br></code></pre></div></td></tr></table></figure><p>every 和 some 函数接受序列和一个谓词，前者检测是否所有元素都符合谓词，后者则检测是否有些元素符合谓词。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">every</span> #&#x27;oddp &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>))<br>T<br>&gt; (<span class="hljs-name">some</span> #&#x27;evenp &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br>T<br>&gt; (<span class="hljs-name">every</span> #&#x27;&gt; &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>) &#x27;(<span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span>)) <span class="hljs-comment">; 也可以接受多个序列，此时是比较每一个 nth，如果长度不同，则按最短的那个序列来</span><br>T<br></code></pre></div></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>push 和 pop 函数，再熟悉不过了，要注意的是，它 push 和 pop 在 cons 对象最前而非最后。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> my-push (<span class="hljs-name">obj</span> stack) (<span class="hljs-name">setf</span> stack (<span class="hljs-name">cons</span> obj stack)))<br>(<span class="hljs-name">defun</span> my-pop (<span class="hljs-name">stack</span>) (<span class="hljs-name">let</span> ((<span class="hljs-name">top</span> (<span class="hljs-name">car</span> stack))) (<span class="hljs-name">setf</span> stack (<span class="hljs-name">cdr</span> stack)) top))<br></code></pre></div></td></tr></table></figure><p>使用 push 定义 reverse——</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> my-reverse(<span class="hljs-name">lst</span>)<br>    (<span class="hljs-name">let</span> ((<span class="hljs-name">res</span> ()))<br>        (<span class="hljs-name">dolist</span> (<span class="hljs-name">obj</span> lst)<br>            (<span class="hljs-name">push</span> obj res))<br>        res))<br></code></pre></div></td></tr></table></figure><p>正如 adjoin 是 cons 的变种，pushnew 是 push 的变种，只有栈中没有该元素才入栈。</p><h2 id="点状列表（dotted-list）"><a href="#点状列表（dotted-list）" class="headerlink" title="点状列表（dotted list）"></a>点状列表（dotted list）</h2><p>点状列表就是 cdr 为 atom 且不为 nil 的列表。<img src="https://i.loli.net/2020/06/13/emrSZybvC9XElqQ.png"></p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">cons</span> &#x27;a &#x27;b)<br>(<span class="hljs-name">A</span> . B) <span class="hljs-comment">; 如此显示</span><br></code></pre></div></td></tr></table></figure><h2 id="关联列表（assoc-list）"><a href="#关联列表（assoc-list）" class="headerlink" title="关联列表（assoc-list）"></a>关联列表（assoc-list）</h2><p>关联列表就像 python 的字典，它容易表示映射（mapping）。它使用点状列表来表示。</p><p>assoc 函数用来取……键值对？它也有 key 和 test 参数。同时，也有 assoc-if。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">setf</span> trans &#x27;((+ . <span class="hljs-string">&quot;add&quot;</span>) (- . <span class="hljs-string">&quot;subtract&quot;</span>)))<br>((<span class="hljs-name">+</span> . <span class="hljs-string">&quot;add&quot;</span>) (<span class="hljs-name">-</span> . <span class="hljs-string">&quot;subtract&quot;</span>))<br><br>&gt; (<span class="hljs-name">assoc</span> &#x27;+ trans)<br>(<span class="hljs-name">+</span> . <span class="hljs-string">&quot;add&quot;</span>)<br>&gt; (<span class="hljs-name">assoc</span> &#x27;* trans)<br>NIL<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Lisp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clisp 学习笔记 1-简述</title>
    <link href="/2020/06-11clisp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E7%AE%80%E8%BF%B0.html"/>
    <url>/2020/06-11clisp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E7%AE%80%E8%BF%B0.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>现在看来，学习 Lisp 更多是为了学习而非工程实践，因此当时我实在不应该选择 Common Lisp，它工程味道太浓了。将来再要去接触 Lisp，首选 Racket，而若是为了工程实践，则 Clojure。</p><p>——2022.01.02</p></blockquote><span id="more"></span><p><del>…… 我决定去学 Haskell 了，再见，Racket！</del></p><p><del>…… 我决定去学 Racket 了，再见，Clojure！</del></p><p><del>…… 我决定去学 Clojure 了，再见，common lisp！</del></p><p><del>你好，common lisp，我又决定先来找你玩了！</del></p><p>我又决定去学 Haskell 和 Clojure 了，再见，common Lisp！</p><blockquote><p>哈哈哈哈哈哈哈</p></blockquote><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><p>Q：为什么学 lisp？<br>A：它酷！</p><p>Q：酷有个屁用？<br>A：****！</p><p>Q：根据哪里学的？<br>A：<a href="https://acl.readthedocs.io/en/latest/zhCN/">ANSI Common Lisp</a></p><h1 id="lisp-语言的形式"><a href="#lisp-语言的形式" class="headerlink" title="lisp 语言的形式"></a>lisp 语言的形式</h1><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;hello!world!&quot;</span>) <span class="hljs-comment">; 我是注释</span><br></code></pre></div></td></tr></table></figure><p>lisp 语言<strong>只有一种形式</strong>（数据和代码都采用这种格式）（不算注释的话）——上述的前序表达式。</p><p>lisp 语言<strong>必须使用括号包裹</strong>。否则在某些时候无法判断表达式什么时候结束，比如——</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">+</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)<br>(<span class="hljs-name">+</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>)<br>(<span class="hljs-name">/</span> (<span class="hljs-name">-</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span>) (<span class="hljs-name">-</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span>))<br></code></pre></div></td></tr></table></figure><h1 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h1><p>lisp 是这样求值的——  </p><ol><li>首先从左至右对<strong>实参</strong>求值。</li><li>实参的值传入以操作符命名的<strong>函数</strong>。</li></ol><p>在这个例子中——</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">+</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>)<br></code></pre></div></td></tr></table></figure><p>lisp 对 2 求值，结果为 2，对 3 求值，结果为 3，对 4 求值，结果为 4，对 5 求值，结果为 5，然后将这些值传给+函数，返回 14。</p><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="符号-symbol-和列表-lists"><a href="#符号-symbol-和列表-lists" class="headerlink" title="符号 symbol 和列表 lists"></a>符号 symbol 和列表 lists</h2><p>符号是单词（words），其不能（无法？）对自身求值，应当使用’引用。</p><p>由括号包裹的零个或多个元素称为<strong>列表</strong>。列表应该使用’来引用，因为其结构和函数调用的结构相同，lisp 会认为这是函数调用。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; &#x27;Hello!world123 <span class="hljs-comment">;symbol</span><br>HELLO!WORLD123<br><br>&gt; &#x27;(the list (a b c) has <span class="hljs-number">3</span> elements) <span class="hljs-comment">;list</span><br>(<span class="hljs-name">THE</span> LIST (<span class="hljs-name">A</span> B C) HAS <span class="hljs-number">3</span> ELEMENTS)<br></code></pre></div></td></tr></table></figure><p>quote 函数（它不遵守 CLisp 既定的求职规则），它和引用起相同作用。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; &#x27;(+ <span class="hljs-number">3</span> <span class="hljs-number">2</span>)<br>(<span class="hljs-name">+</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>)<br><br>&gt; (<span class="hljs-name">quote</span> (+ <span class="hljs-number">3</span> <span class="hljs-number">2</span>))<br>(<span class="hljs-name">+</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><h2 id="列表表示-lisp-程序"><a href="#列表表示-lisp-程序" class="headerlink" title="列表表示 lisp 程序"></a>列表表示 lisp 程序</h2><p><strong>lisp 的程序是用列表来表示的，这是 lisp 最卓越的特性</strong>。lisp 的代码如果被引用，就对自身求值，如果没有，则被视为代码，按照求值规则求值后返回值。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">list</span> &#x27;(+ <span class="hljs-number">2</span> <span class="hljs-number">1</span>) (<span class="hljs-name">+</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>))<br>((<span class="hljs-name">+</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>) <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><p>因此，lisp 代码是容易写出 lisp 代码的。并且 lisp 程序员应经常地使用此特性来解决问题，“让 lisp 适应问题，而非让问题适应 lisp”。</p><h2 id="NIL"><a href="#NIL" class="headerlink" title="NIL"></a>NIL</h2><p>lisp 有两种方式表示空列表。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; ()<br>NIL<br>&gt; <span class="hljs-literal">nil</span> <span class="hljs-comment">;nil 显然是一个求值为 NIL 的 symbol</span><br>NIL<br></code></pre></div></td></tr></table></figure><h1 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h1><h2 id="cons"><a href="#cons" class="headerlink" title="cons"></a>cons</h2><p>cons 的第二个实参是列表（记住，列表是要引用的，否则它会被当成函数调用），它将第一个实参加入到第二个实参这个列表<strong>前</strong>，得到一个新列表。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">cons</span> &#x27;a &#x27;(b c d))<br>(<span class="hljs-name">A</span> B C D)<br><br>&gt; (<span class="hljs-name">cons</span> &#x27;a NIL)<br>(<span class="hljs-name">A</span>)<br><br>&gt; (<span class="hljs-name">cons</span> &#x27;(a b c) &#x27;(b))<br>((<span class="hljs-name">A</span> B C) B)<br><br>&gt; (<span class="hljs-name">cons</span> &#x27;(a b) &#x27;c) <span class="hljs-comment">; 瞎搞呢？看上去它是对 c 这个符号进行了一些处理……</span><br>((<span class="hljs-name">A</span> B) . C) <span class="hljs-comment">; 啥原因？</span><br></code></pre></div></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>list 将所有实参加入到一个列表中。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">list</span> &#x27;a &#x27;b &#x27;c)<br>(<span class="hljs-name">A</span> B C)<br><br>&gt; (<span class="hljs-name">list</span> &#x27;(a b) &#x27;(c (d e)))<br>((<span class="hljs-name">A</span> B) (<span class="hljs-name">C</span> (<span class="hljs-name">D</span> E)))<br></code></pre></div></td></tr></table></figure><h2 id="car-amp-cdr"><a href="#car-amp-cdr" class="headerlink" title="car &amp; cdr"></a>car &amp; cdr</h2><p>car 返回<strong>第一个</strong>元素，cdr 返回第一个元素后的所有元素（以列表的形式）。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">car</span> &#x27;(a b c))<br>A<br>&gt; (<span class="hljs-name">cdr</span> &#x27;(a b c))<br>(<span class="hljs-name">B</span> C)<br></code></pre></div></td></tr></table></figure><p>混合使用 car 和 cdr 可以取到列表中的任何元素。</p><h1 id="真假"><a href="#真假" class="headerlink" title="真假"></a>真假</h1><h2 id="谓词（predicate）"><a href="#谓词（predicate）" class="headerlink" title="谓词（predicate）"></a>谓词（predicate）</h2><p>谓词是 lisp 中返回真假的函数，就像其他语言的返回布尔值的函数。一般而言，其结尾是 p。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">listp</span> &#x27;(a b c))<br>T<br></code></pre></div></td></tr></table></figure><h2 id="not-amp-null"><a href="#not-amp-null" class="headerlink" title="not &amp; null"></a>not &amp; null</h2><p>t 表示逻辑真，t 也是对自身求值的，与 nil 相同。</p><p>逻辑假用 nil 表示。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">listp</span> <span class="hljs-number">26</span>)<br>NIL<br></code></pre></div></td></tr></table></figure><p>not 和 null 在逻辑上是不同的，前者判断是否是逻辑假，后者判断是否是空表，可是实际上其结果是相同的。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">null</span> <span class="hljs-literal">nil</span>) <span class="hljs-comment">; 空表</span><br>T<br><br>&gt; (<span class="hljs-name">not</span> <span class="hljs-literal">nil</span>) <span class="hljs-comment">; 逻辑假</span><br>T<br></code></pre></div></td></tr></table></figure><h2 id="条件表达式-if"><a href="#条件表达式-if" class="headerlink" title="条件表达式 if"></a>条件表达式 if</h2><p>if 接受三个实参，一个 test 表达式，一个 then 表达式，一个 else 表达式。if 会<strong>先</strong>对 test 表达式求值，如果为真，则求 then，否则求 else。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">if</span> (<span class="hljs-name">listp</span> &#x27;(a b c))<br>      (<span class="hljs-name">+</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>)<br>      (<span class="hljs-name">+</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>))<br><span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>if 也是特殊的操作符，如同 quote。if 不遵守求值规则之处在于，它对最后两个实参，只会求其中一个的值。因此，if 是<strong>不能用函数来实现</strong>的。</p><p>要注意的是，非 nil 的，都是 t</p><h2 id="and-amp-or"><a href="#and-amp-or" class="headerlink" title="and &amp; or"></a>and &amp; or</h2><p>and 和 or 都从左往右<strong>求值</strong>。但是，and 在遇到 NIL 时停止求值，返回 NIL 或最后一个参数的值，如果其他参数全为真</p><p>or 在遇到参数为逻辑真时停止求值，返回这个值</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">and</span> (<span class="hljs-name">+</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>) (<span class="hljs-name">+</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br><span class="hljs-number">5</span><br>&gt; (<span class="hljs-name">and</span> (<span class="hljs-name">+</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>) <span class="hljs-literal">nil</span>)<br><span class="hljs-literal">nil</span><br>&gt; (<span class="hljs-name">and</span> <span class="hljs-literal">nil</span> (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;rua&quot;</span>)) <span class="hljs-comment">; 遇到 nil 就停止求值了</span><br><span class="hljs-literal">nil</span><br><br>&gt; (<span class="hljs-name">or</span> (<span class="hljs-name">+</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>) <span class="hljs-literal">nil</span>)<br><span class="hljs-number">3</span><br>&gt; (<span class="hljs-name">or</span> <span class="hljs-literal">nil</span> (<span class="hljs-name">+</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>))<br><span class="hljs-number">3</span><br>&gt;(<span class="hljs-name">or</span> (<span class="hljs-name">+</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span>) (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">; 遇到 T 就停止求值</span><br><span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><p>and 和 or 这两个操作符称为<strong>宏</strong>，它们和特殊的操作符一样，可以绕过一般的求值规则。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>定义新函数的函数叫 defun（它显然也是不遵守求值规则的），它接受三个以上的实参——一个名字，一组用列表表示的实参（而这个实参中的内容将被作为函数的形参），以及一个或多个组成<strong>函数体</strong>的表达式。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">defun</span> say (<span class="hljs-name">obj</span>) (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> obj)) <span class="hljs-comment">;obj 是形参</span><br>SAY<br><br>&gt; (<span class="hljs-name">say</span> <span class="hljs-string">&quot;hello&quot;</span>)<br>hello<br>NIL<br><br>&gt; (<span class="hljs-name">SaY</span> <span class="hljs-string">&quot;hello&quot;</span>)<br>hello<br>NIL<br></code></pre></div></td></tr></table></figure><p>可见，在进行函数调用时，它会把函数名进行求值，转换成全大写的 symbol。</p><p>符号（symbol）就是变量（和函数）的名字，符号本身以对象存在。因此，符号和列表必须要以引用形式来使用，否则列表会被当成函数，符号会被当成变量。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>没啥可说的。</p><p>判断一个 tar 是否在一个列表中，如果是，返回这个 tar 及以后的子列表，否则返回 NIL。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> our-member (<span class="hljs-name">tar</span> lst)<br>    (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> lst)<br>        <span class="hljs-literal">nil</span><br>    (<span class="hljs-name">if</span> (<span class="hljs-name">eql</span> (<span class="hljs-name">car</span> lst) tar)<br>        lst<br>        (<span class="hljs-name">our-member</span> tar (<span class="hljs-name">cdr</span> lst))))) <span class="hljs-comment">; 别看了，我们 lisp 就是这样的。</span><br><br>(<span class="hljs-name">defun</span> fib (<span class="hljs-name">n</span>)<br>    (<span class="hljs-name">if</span> (<span class="hljs-name">or</span> (<span class="hljs-name">=</span> n <span class="hljs-number">1</span>) (<span class="hljs-name">=</span> n <span class="hljs-number">2</span>))<br>        <span class="hljs-number">1</span><br>        (<span class="hljs-name">+</span> (<span class="hljs-name">fib</span> (<span class="hljs-name">-</span> n <span class="hljs-number">1</span>)) (<span class="hljs-name">fib</span> (<span class="hljs-name">-</span> n <span class="hljs-number">2</span>))))) <span class="hljs-comment">; 最睿智的 fib 解决法</span><br></code></pre></div></td></tr></table></figure><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>最普遍的 clisp 输出函数时 format，接受两个两个及以上的实参，第一个实参决定要打印到的位置，第二个实参是字符串模板，剩余的实参通常是要插入到字符串模板。</p><p>t 表示输出送到缺省的地方（通常是顶层，或者是控制台？），<del>A 表示被填入的位置，</del>%表示换行符。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;~A plus ~A equals ~A. ~%&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> (<span class="hljs-name">+</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br><span class="hljs-number">2</span> plus <span class="hljs-number">3</span> equals <span class="hljs-number">5</span>. <span class="hljs-comment">;format 的输出</span><br>NIL <span class="hljs-comment">;format 的返回值</span><br></code></pre></div></td></tr></table></figure><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>clisp 的标准的输入函数是 read，当没有实参时，会读取缺省的位置，通常是顶层。它会返回输入的东西被处理后的结果。</p><p>read 非常强大，虽然还不知道到底如何强大 w</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">defun</span> askem (<span class="hljs-name">string</span>)<br>    (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;~A&quot;</span> string)<br>    (<span class="hljs-name">read</span>))<br><br>&gt; (<span class="hljs-name">askem</span> <span class="hljs-string">&quot;How old are you?&quot;</span>)<br>How old are you?<span class="hljs-number">29</span><br><span class="hljs-number">29</span><br></code></pre></div></td></tr></table></figure><h1 id="变量和赋值"><a href="#变量和赋值" class="headerlink" title="变量和赋值"></a>变量和赋值</h1><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>let 引入局部变量，它只在 let 的括号内有效。<br>let 表达式有两个部分，第一个部分是创建新变量，其格式为 (variable expression)。每一格变量会被赋予相对应表达式的值。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">&gt; (<span class="hljs-name">let</span> ((<span class="hljs-name">x</span> <span class="hljs-number">123</span>) (<span class="hljs-name">y</span> <span class="hljs-number">456</span>)) <span class="hljs-comment">; 每一个变量定义都是一个列表</span><br>    (<span class="hljs-name">+</span> x y)))<br><span class="hljs-number">579</span><br></code></pre></div></td></tr></table></figure><p>写一个要求用户输入数字的函数，如果输入的是数字，则返回它，否则返回该函数。</p><p><strong>之后，用&gt;标识返回值。</strong></p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> ask-number ()<br>    (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;enter a number:&quot;</span>)<br>    (<span class="hljs-name">let</span> ((<span class="hljs-name">val</span> (<span class="hljs-name">read</span>))) <span class="hljs-comment">; 创建变量</span><br>        (<span class="hljs-name">if</span> (<span class="hljs-name">numberp</span> val) <span class="hljs-comment">; 数字谓词</span><br>            val<br>            (<span class="hljs-name">ask-number</span>))))<br><br>(<span class="hljs-name">ask-number</span>)<br>&gt; enter a number:oh<br>&gt; enter a number:(<span class="hljs-name">aha</span>)<br>&gt; enter a number:<span class="hljs-number">23</span><br>&gt; <span class="hljs-number">23</span><br></code></pre></div></td></tr></table></figure><h2 id="defparameter-amp-defconstant"><a href="#defparameter-amp-defconstant" class="headerlink" title="defparameter &amp; defconstant"></a>defparameter &amp; defconstant</h2><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defparameter</span> *glob* <span class="hljs-number">99</span>) <span class="hljs-comment">; 全局变量通过 defparameter 声明，通常使用星号包围以避免与局部变量混淆</span><br>&gt; *GLOB*<br><br>(<span class="hljs-name">defconstant</span> limit (<span class="hljs-name">+</span> *glob* <span class="hljs-number">1</span>)) <span class="hljs-comment">; 全局常量不需要用星号包围，因为如果有相同名字就会产生错误</span><br>&gt; <span class="hljs-number">100</span><br><br>&gt; (<span class="hljs-name">boundp</span> &#x27;*glob*) <span class="hljs-comment">; 全局量谓词，检测是否是全局变量或全局常量</span><br>T<br></code></pre></div></td></tr></table></figure><h2 id="setf"><a href="#setf" class="headerlink" title="setf"></a>setf</h2><p>setf 是最普遍的赋值操作符。setf 的第一个实参可以为全局或局部变量，可以为符号，可以为表达式。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setf</span> *glob* <span class="hljs-number">98</span>) <span class="hljs-comment">; 给全局变量* glob *赋值 98</span><br>&gt; <span class="hljs-number">98</span><br><br>(<span class="hljs-name">let</span> ((<span class="hljs-name">n</span> <span class="hljs-number">10</span>))<br>   (<span class="hljs-name">setf</span> n <span class="hljs-number">2</span>) <span class="hljs-comment">; 给局部变量 n 赋值 2</span><br>   n)<br>&gt; <span class="hljs-number">2</span><br><br>(<span class="hljs-name">setf</span> x &#x27;(a b c)) <span class="hljs-comment">; 隐式创建全局变量 x，这是不推荐使用的</span><br>&gt; (<span class="hljs-name">A</span> B C)<br><br>(<span class="hljs-name">setf</span> (<span class="hljs-name">car</span> x) &#x27;n) <span class="hljs-comment">; 表达式也可以做第一个实参，此时更改这个实参引用的位置。</span><br>&gt; N<br><br>x<br>&gt; (<span class="hljs-name">N</span> B C)<br><br>(<span class="hljs-name">setf</span><br>    a &#x27;b<br>    c &#x27;d<br>    e &#x27;f) <span class="hljs-comment">; 偶数个实参，可以定义多个变量。返回最后一个符号</span><br></code></pre></div></td></tr></table></figure><p><strong>任何引用到特定位置的表达式都可以做 setf 的第一个实参</strong>。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程意味着<strong>只利用返回值，不造成副作用</strong>，函数式编程是 lisp 的主流范式，<strong>大部分 lisp 的内置函数都是函数式的</strong>。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">set</span> lst &#x27;(c a r a t))<br>&gt; (<span class="hljs-name">C</span> A R A T)<br><br>(<span class="hljs-name">remove</span> &#x27;a lst)<br>&gt; (<span class="hljs-name">C</span> R T) <span class="hljs-comment">; 这是一个新列表</span><br></code></pre></div></td></tr></table></figure><p>副作用越少，技术越高 w，这意味着尽量少用 setf 这类的函数。</p><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>迭代总是比递归自然的……</p><h2 id="do"><a href="#do" class="headerlink" title="do"></a>do</h2><p>do 宏是 clisp 的最基本的迭代操作符，和 let 类似，do 也可以创建局部变量。</p><p>第一个实参是一组变量的规格说明列表，每个元素是这样的形式 (varible initial update)。<br>第二个实参包含一个或多个表达式，第一个表达式测试迭代是否结束，最后一个表达式是 do 的返回值。<br>其余实参是 do 循环的函数体。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> show-squares (<span class="hljs-name">start</span> end)<br>    (<span class="hljs-name">do</span> ((<span class="hljs-name">i</span> start (<span class="hljs-name">+</span> i <span class="hljs-number">1</span>))) ((<span class="hljs-name">not</span> (<span class="hljs-name">&lt;</span> i end)) &#x27;done) <span class="hljs-comment">; 每次循环都测试条件，如果失败，则继续循环，直到成功，结束循环……如果能和 for 统一一下就好了……但是加上一个 not 就行……结束循环返回 done</span><br>        (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;~A ~A~%&quot;</span> i (<span class="hljs-name">*</span> i i))))<br><br>(<span class="hljs-name">show-squares</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span>)<br>&gt; <span class="hljs-number">2</span> <span class="hljs-number">4</span><br>&gt; <span class="hljs-number">3</span> <span class="hljs-number">9</span><br>&gt; <span class="hljs-number">4</span> <span class="hljs-number">16</span><br>&gt; <span class="hljs-number">5</span> <span class="hljs-number">25</span><br>&gt; DONE<br><br>(<span class="hljs-name">defun</span> show-squares (<span class="hljs-name">i</span> end) <span class="hljs-comment">; 递归版</span><br>    (<span class="hljs-name">if</span> (<span class="hljs-name">&gt;</span> i end)<br>        &#x27;done<br>        (<span class="hljs-name">progn</span> <span class="hljs-comment">; 相当于是创建了一个函数体，依次执行每一个表达式，返回最后一个的值</span><br>            (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;~A ~A~%&quot;</span> i (<span class="hljs-name">*</span> i i))<br>            (<span class="hljs-name">show-squares</span> (<span class="hljs-name">+</span> i <span class="hljs-number">1</span>) end))))<br></code></pre></div></td></tr></table></figure><h2 id="dolist"><a href="#dolist" class="headerlink" title="dolist"></a>dolist</h2><p>dolist 更为简单，它遍历一个列表。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> my-length (<span class="hljs-name">lst</span>)<span class="hljs-comment">; 获取列表长度</span><br>    (<span class="hljs-name">let</span> ((<span class="hljs-name">len</span> <span class="hljs-number">0</span>))<br>        (<span class="hljs-name">dolist</span> (<span class="hljs-name">obj</span> lst)　<span class="hljs-comment">; 对 lst 的每一个 obj，让 len+1</span><br>            (<span class="hljs-name">setf</span> len (<span class="hljs-name">+</span> len <span class="hljs-number">1</span>)))<br>        len)) <span class="hljs-comment">; 别忘记返回值啊傻子</span><br><br>(<span class="hljs-name">defun</span> my-length (<span class="hljs-name">lst</span>)<span class="hljs-comment">; 递归版……这个彩虹括号似乎并没有什么用……</span><br>    (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> lst)<br>        <span class="hljs-number">0</span><br>        (<span class="hljs-name">+</span> (<span class="hljs-name">my-length</span> (<span class="hljs-name">cdr</span> lst)) <span class="hljs-number">1</span>))) <span class="hljs-comment">; 但是这个递归不是尾递归，效率不够高</span><br><br>(<span class="hljs-name">defun</span> my-length (<span class="hljs-name">lst</span> len) <span class="hljs-comment">; 尾递归版本，舒服！从 0 开始调用</span><br>    (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> lst)<br>        len<br>        (<span class="hljs-name">my-length</span> (<span class="hljs-name">cdr</span> lst) (<span class="hljs-name">+</span> len <span class="hljs-number">1</span>))))<br></code></pre></div></td></tr></table></figure><h1 id="函数作为对象"><a href="#函数作为对象" class="headerlink" title="函数作为对象"></a>函数作为对象</h1><p>把函数当成变量一样的对象看待，是稀松平常的，js 喜欢这个。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">function</span> +)<br>&gt; #&lt;SYSTEM-FUNCTION +&gt;<br><br>#&#x27;+<br>&gt; #&lt;SYSTEM-FUNCTION +&gt;<br></code></pre></div></td></tr></table></figure><p>#’是 function 的缩写，就如同’是 quote 的缩写一样，</p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>函数可以作为实参传入。如 apply 函数。它接受任意数量的实参，但是要求<strong>第一个实参是函数，最后一个实参是列表</strong>。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">apply</span> #&#x27;+ &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br>&gt; <span class="hljs-number">16</span><br><br>(<span class="hljs-name">+</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)<br>&gt; <span class="hljs-number">16</span><br><br>(<span class="hljs-name">apply</span> #&#x27;+ <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> &#x27;(<span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br>&gt; <span class="hljs-number">16</span><br></code></pre></div></td></tr></table></figure><h2 id="funcall"><a href="#funcall" class="headerlink" title="funcall"></a>funcall</h2><p>funcall 进行一样的工作，但是不需要把实参包装成列表。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">funcall</span> #&#x27;+ <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)<br>&gt; <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>lambda，匿名函数一样的东西。它似乎不能赋值给变量</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">((<span class="hljs-name">x</span>) (<span class="hljs-name">+</span> x <span class="hljs-number">100</span>)) <span class="hljs-comment">; 这玩意运行不过去啊……</span><br><br>(<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span> y)<br>    (<span class="hljs-name">+</span> x y))<br>&gt; #&lt;FUNCTION :LAMBDA (<span class="hljs-name">X</span> Y) (<span class="hljs-name">+</span> X Y)&gt;<br><br>((<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span> y)(<span class="hljs-name">+</span> x y)) <span class="hljs-number">1</span> <span class="hljs-number">2</span>)<br>&gt; <span class="hljs-number">3</span><br><br>(<span class="hljs-name">funcall</span> #&#x27;(lambda (x) (+ x <span class="hljs-number">5</span>)) <span class="hljs-number">10</span>) <span class="hljs-comment">; 或者这样用</span><br>&gt; <span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>lisp 的变量默认没有类型（当然，值有类型）。</p><p>lisp 的内置类型组成了一个<strong>类的层级</strong>，任何对象总是不止属于一个类型。<br>比如，数字 27，按普遍性递增排序，其类型依次是 fixnum 、 integer 、 rational 、 real 、 number 、 atom 、t。</p><p>t 是所有类型的基类，每个对象都属于 t。</p><p>谓词 typep 接受一个对象和一个类型，判定对象是否为该类型，如果是，返回真。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">typep</span> <span class="hljs-number">27</span> &#x27;integer)<br>&gt; T<br></code></pre></div></td></tr></table></figure><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>lisp 是适合写 lisp 的语言，写代码的时候，不只是在语言中编程，也是在让语言适合程序。</p><p>lisp 的语法单一，一切都基于列表。<strong>lisp 本身就是 lisp 程序</strong>。</p><p>这一切是 lisp 最最典型，最最优雅的特性。</p><p>每一个 lisp 程序员都应当善用 lisp 的这些特性，在适应 lisp 的同时，也让 lisp 适应自己……</p><p>花里胡哨的！</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol><li>描述下列表达式求值之后的结果：</li></ol><p>(a) (+ (- 5 1) (+ 3 7))</p><p>(b) (list 1 (+ 2 3))</p><p>(c) (if (listp 1) (+ 1 2) (+ 3 4))</p><p>(d) (list (and (listp 3) t) (+ 1 2))</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">a</span>) <span class="hljs-number">14</span><br>(<span class="hljs-name">b</span>) (<span class="hljs-number">1</span> <span class="hljs-number">5</span>)<br>(<span class="hljs-name">c</span>) <span class="hljs-number">7</span><br>(<span class="hljs-name">d</span>) (<span class="hljs-name">NIL</span> <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><ol start="2"><li>给出 3 种不同表示 (a b c) 的 cons 表达式。</li></ol><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">cons</span> &#x27;a &#x27;(b c))<br>(<span class="hljs-name">cons</span> &#x27;a (<span class="hljs-name">cons</span> &#x27;b &#x27;(c)))<br>(<span class="hljs-name">cons</span> &#x27;a (<span class="hljs-name">cons</span> &#x27;b (<span class="hljs-name">cons</span> &#x27;c ())))<br></code></pre></div></td></tr></table></figure><ol start="3"><li>使用 car 与 cdr 来定义一个函数，返回一个列表的第四个元素。</li></ol><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> my-fourth (<span class="hljs-name">lst</span>) <br>    (<span class="hljs-name">car</span> (<span class="hljs-name">cdr</span> (<span class="hljs-name">cdr</span> (<span class="hljs-name">cdr</span> lst)))))<br></code></pre></div></td></tr></table></figure><ol start="4"><li>定义一个函数，接受两个实参，返回两者当中较大的那个。</li></ol><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> my-max (<span class="hljs-name">a</span> b)<br>  (<span class="hljs-name">if</span> (<span class="hljs-name">&gt;</span> a b)<br>      a<br>      b))<br></code></pre></div></td></tr></table></figure><ol start="5"><li>这些函数做了什么？</li></ol><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">a</span>) (<span class="hljs-name">defun</span> enigma (<span class="hljs-name">x</span>) <span class="hljs-comment">; 显然，x 是列表</span><br>      (<span class="hljs-name">and</span> (<span class="hljs-name">not</span> (<span class="hljs-name">null</span> x)) <span class="hljs-comment">; 如果列表为非空，才继续执行</span><br>           (<span class="hljs-name">or</span> (<span class="hljs-name">null</span> (<span class="hljs-name">car</span> x)) <span class="hljs-comment">; 如果第一个元素是 null，则停止执行，否则继续执行</span><br>               (<span class="hljs-name">enigma</span> (<span class="hljs-name">cdr</span> x)))))<br><br>(<span class="hljs-name">b</span>) (<span class="hljs-name">defun</span> mystery (<span class="hljs-name">x</span> y)<br>      (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> y)<br>          <span class="hljs-literal">nil</span> <span class="hljs-comment">; 如果 y 为空列表，返回 nil</span><br>          (<span class="hljs-name">if</span> (<span class="hljs-name">eql</span> (<span class="hljs-name">car</span> y) x) <span class="hljs-comment">; 显然，x 是一个值，y 是列表</span><br>              <span class="hljs-number">0</span> <span class="hljs-comment">; 如果有相等，返回 0</span><br>              (<span class="hljs-name">let</span> ((<span class="hljs-name">z</span> (<span class="hljs-name">mystery</span> x (<span class="hljs-name">cdr</span> y))))<br>                (<span class="hljs-name">and</span> z (<span class="hljs-name">+</span> z <span class="hljs-number">1</span>)))))) <span class="hljs-comment">; 如果 z 为 nil，没得算了。返回 nil，如果非，则返回 nil+1</span><br></code></pre></div></td></tr></table></figure><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">a</span>) 故意折腾人呢？<br>显然，是判断一个列表里是否有 NIL 或 ()，如果有，则返回 T，否则返回 NIL<br>(<span class="hljs-name">b</span>) 返回 y 列表中第一个 x 的 index……这个真的难以判断<br></code></pre></div></td></tr></table></figure><ol start="6"><li>下列表达式， x 该是什么，才会得到相同的结果？</li></ol><p>(a) &gt; (car (x (cdr ‘(a (b c) d))))<br>    B</p><p>(b) &gt; (x 13 (&#x2F; 1 0))<br>    13</p><p>(c) &gt; (x #’list 1 nil)<br>    (1)</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">a</span>) car<br><br>(<span class="hljs-name">b</span>) ???<br><br>(<span class="hljs-name">c</span>) apply<br></code></pre></div></td></tr></table></figure><ol start="7"><li>只使用本章所介绍的操作符，定义一个函数，它接受一个列表作为实参，如果有一个元素是列表时，就返回真，</li></ol><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> my-algo (<span class="hljs-name">lst</span>)<br>    (<span class="hljs-name">and</span> (<span class="hljs-name">null</span> lst) (<span class="hljs-name">or</span> (<span class="hljs-name">listp</span> (<span class="hljs-name">car</span> lst)) (<span class="hljs-name">my-listp</span> (<span class="hljs-name">cdr</span> lst)))))<br>    (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> lst)<br>        <span class="hljs-literal">nil</span> <span class="hljs-comment">; 不能手贱写大写的 NIL……草</span><br>        (<span class="hljs-name">or</span> (<span class="hljs-name">listp</span> (<span class="hljs-name">car</span> lst)) (<span class="hljs-name">my-listp</span> (<span class="hljs-name">cdr</span> lst)))))<br></code></pre></div></td></tr></table></figure><ol start="8"><li>给出函数的迭代与递归版本。<br>a. 接受一个正整数，并打印出数字数量的点。<br>b. 接受一个列表，并返回 a 在列表里所出现的次数。</li></ol><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">a.<br>迭代：<br>(<span class="hljs-name">defun</span> print-point (<span class="hljs-name">n</span>)<br>    (<span class="hljs-name">do</span> ((<span class="hljs-name">i</span> <span class="hljs-number">0</span> (<span class="hljs-name">+</span> i <span class="hljs-number">1</span>))) ((<span class="hljs-name">&gt;=</span> i n) &#x27;done)<br>            (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;.&quot;</span>)))<br><br>递归：<br>(<span class="hljs-name">defun</span> print-point (<span class="hljs-name">n</span>)<br>    (<span class="hljs-name">and</span> (<span class="hljs-name">not</span> (<span class="hljs-name">zerop</span> n))<br>        (<span class="hljs-name">progn</span> (<span class="hljs-name">format</span> <span class="hljs-literal">t</span> <span class="hljs-string">&quot;.&quot;</span>) (<span class="hljs-name">print-point</span> (<span class="hljs-name">-</span> n <span class="hljs-number">1</span>)))))<br><br>b.<br>迭代：<br>(<span class="hljs-name">defun</span> my-count (<span class="hljs-name">lst</span>)<br>    (<span class="hljs-name">let</span> ((<span class="hljs-name">len</span> <span class="hljs-number">0</span>))<br>        (<span class="hljs-name">dolist</span> (<span class="hljs-name">obj</span> lst)<br>            (<span class="hljs-name">if</span> (<span class="hljs-name">equal</span> obj &#x27;a)<br>                (<span class="hljs-name">setf</span> len (<span class="hljs-name">+</span> len <span class="hljs-number">1</span>))<br>                <span class="hljs-literal">nil</span>))<br>        len))<br><br>递归：<br>(<span class="hljs-name">defun</span> my-count (<span class="hljs-name">lst</span>)<br>    (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> lst)<br>        <span class="hljs-number">0</span><br>        (<span class="hljs-name">if</span> (<span class="hljs-name">equal</span> (<span class="hljs-name">car</span> lst) &#x27;a)<br>            (<span class="hljs-name">+</span> (<span class="hljs-name">my-count</span> (<span class="hljs-name">cdr</span> lst)) <span class="hljs-number">1</span>)<br>            (<span class="hljs-name">my-count</span> (<span class="hljs-name">cdr</span> lst)))))<br><br>尾递归：<br>(<span class="hljs-name">defun</span> my-count (<span class="hljs-name">count</span> lst)<br>    (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> lst)<br>        count<br>        (<span class="hljs-name">if</span> (<span class="hljs-name">equal</span> (<span class="hljs-name">car</span> lst) &#x27;a)<br>            (<span class="hljs-name">my-count</span> (<span class="hljs-name">+</span> <span class="hljs-number">1</span> count) (<span class="hljs-name">cdr</span> lst))<br>            (<span class="hljs-name">my-count</span> count (<span class="hljs-name">cdr</span> lst)))))<br></code></pre></div></td></tr></table></figure><ol start="9"><li>一位朋友想写一个函数，返回列表里所有非 nil 元素的和。他写了此函数的两个版本，但两个都不能工作。请解释每一个的错误在哪里，并给出正确的版本。</li></ol><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">a</span>) (<span class="hljs-name">defun</span> summit (<span class="hljs-name">lst</span>)<br>      (<span class="hljs-name">remove</span> <span class="hljs-literal">nil</span> lst)<br>      (<span class="hljs-name">apply</span> #&#x27;+ lst))<br><br>(<span class="hljs-name">b</span>) (<span class="hljs-name">defun</span> summit (<span class="hljs-name">lst</span>)<br>      (<span class="hljs-name">let</span> ((<span class="hljs-name">x</span> (<span class="hljs-name">car</span> lst)))<br>        (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> x)<br>            (<span class="hljs-name">summit</span> (<span class="hljs-name">cdr</span> lst))<br>            (<span class="hljs-name">+</span> x (<span class="hljs-name">summit</span> (<span class="hljs-name">cdr</span> lst))))))<br></code></pre></div></td></tr></table></figure><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">a</span>) <br>(<span class="hljs-name">defun</span> summit (<span class="hljs-name">lst</span>)<br>      (<span class="hljs-name">setf</span> lst (<span class="hljs-name">remove</span> <span class="hljs-literal">nil</span> lst)) <span class="hljs-comment">;remove 是无副作用的，要赋值才行</span><br>      (<span class="hljs-name">apply</span> #&#x27;+ lst))<br><br>(<span class="hljs-name">b</span>)<br>(<span class="hljs-name">defun</span> summit (<span class="hljs-name">lst</span>)<br>    (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> lst) <br>      <span class="hljs-number">0</span> <span class="hljs-comment">; 递归的出口</span><br>      (<span class="hljs-name">let</span> ((<span class="hljs-name">x</span> (<span class="hljs-name">car</span> lst))) <br>        (<span class="hljs-name">if</span> (<span class="hljs-name">null</span> x)<br>            (<span class="hljs-name">summit</span> (<span class="hljs-name">cdr</span> lst))<br>            (<span class="hljs-name">+</span> x (<span class="hljs-name">summit</span> (<span class="hljs-name">cdr</span> lst)))))))<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Lisp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界语学习资源</title>
    <link href="/2020/01-01%E4%B8%96%E7%95%8C%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90.html"/>
    <url>/2020/01-01%E4%B8%96%E7%95%8C%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90.html</url>
    
    <content type="html"><![CDATA[<p>兴趣使然罢了。应该不会坚持下去，因为找不到实践意义呢……</p><p><a href="http://www.zz9pza.net/tajpi/en/">输入法Tajpi</a></p><p><strong>学习课程</strong></p><p>1.<a href="http://zh-cn.lernu.net/">Lernu!</a></p><p>E@I（教育@在网络）推出的免费学习世界语的网站，上面有很多课程可选，从初级到高级的都有。初级：<a href="http://zh-cn.lernu.net/kursoj/ap/index.php">Ana Pana</a> 、<a href="http://zh-cn.lernu.net/kursoj/mek/index.php">Mi estas komencanto</a> ；中级：<a href="http://zh-cn.lernu.net/kursoj/jnijk/index.php">Jen nia IJK</a>、<a href="http://zh-cn.lernu.net/kursoj/ap2/index.php">Ana renkontas</a> ；高级：<a href="http://zh-cn.lernu.net/kursoj/kio_okazas/index.php">Kio okazas</a>、<a href="http://zh-cn.lernu.net/kursoj/gerda_malaperis/">Gerda malaperis</a>。（可能要翻墙）</p><p>2.<a href="http://www.duolingo.com/">Duolingo</a></p><p>多邻国在语言学习界鼎鼎大名，就不用多介绍了，有网页版、以及iOS和安卓的App。目前只有<a href="https://www.duolingo.cn/course/eo/en/Learn-Esperanto-Online">用英文学世界语的课程</a>（截止今年已有37万多人在上面学习），以及<a href="https://www.duolingo.cn/course/eo/es/Learn-Esperanto-Online">用西班牙学世界语的课程</a>（预计16年6、7月份会上线），中文学习世界语的课程我们正在积极申请中。</p><p>3.<a href="http://kurso.com.br/">Kurso de Esperanto</a></p><p>巴西人出的世界语学习软件，支持win、linux和mac。课程内容丰富，有互动和练习，有指导老师。缺点：发音一股巴葡味</p><p>4.<a href="http://pacujo.net/esperanto/course/">Pacujo世界语函授课程</a>（英文授课）</p><p>一共10课，会自动分配指导老师，学完就了解了世界语的基本语法。</p><p>5.<a href="http://kursosaluton.org/">Saluton</a></p><p>国际世界语协会（UEA）出品，直接学习法，图文并茂，有发音。</p><p>6.<a href="https://www.youtube.com/user/pasportotutamondo/videos">Pasporto al la tuta mondo</a> （须翻墙）（<a href="http://list.youku.com/albumlist/show%3Fid%3D17743369%26ascending%3D1%26page%3D1">优酷链接</a>，无需翻墙）</p><p>视频教学，一共16课，Youtube上可看。</p><p>7.<a href="https://www.youtube.com/watch%3Fv%3DmWbyXVSiCxw">Mazi en Gondolando</a> （youtube，须翻墙）（已添加<a href="http://www.tudou.com/programs/view/AAmZopgs3WE/">土豆链接</a>，无需翻墙）</p><p>动画片</p><p>8.<a href="http://eduinf.waw.pl/esp/lern/uem/index.php">Universala Metodo</a></p><p>完全直接法看图自学</p><p>\9. <a href="http://learn.esperanto.com/zh/">Zagrba Metodo</a></p><p>据说是入门最快的世界语课程</p><p><strong>发音：</strong></p><p><a href="http://zh.forvo.com/languages/eo/">Forvo</a>：是个开放的发音词典，基本上所有单词都能找到真人发音</p><p><strong>词典</strong>：</p><p><a href="http://vortaro.net/">Vortaro.net</a>： 最权威的世界语原文词典 （须有注册）</p><p><a href="http://www.reta-vortaro.de/revo/">Reta Vortaro</a>：开放的世界语词典</p><p><a href="http://www.simplavortaro.org/">Simpla Vortaro</a>：基于Reta Vortaro，界面漂亮</p><p><a href="http://zh-cn.lernu.net/">Lernu词典</a>：词典在lernu首页的右下角</p><p><strong>例句&#x2F;语料库</strong>：</p><p><a href="http://tekstaro.com/">Tekstaro</a>: 可最权威的世界语书籍中查询单词</p><p><a href="http://tatoeba.org/epo/">Tatoeba</a>：开放的句子库，上面世界语条目数仅次于英语</p><p><strong>写作批改、语法问题咨询：</strong></p><p><a href="https://www.italki.com/notebooks/esperantohttps%3A//www.italki.com/teachers/professional/esperanto%3Fref%3Desperanto%26utm_source%3Desperanto%26utm_medium%3Dpartner%26utm_campaign%3Daffiliate">Italki社区</a>：可以提交自己写的短文，有热心的网友批改。</p><p><a href="https://www.facebook.com/groups/konsultejo/">Lingva Konsulejo</a>：Facebook世界语语法问题咨询小组，回复很快。</p><p><strong>听力</strong></p><p><a href="https://www.youtube.com/user/Evildela">Evildea</a>：世界语界的Papi酱，每天</p><p><a href="http://muzaiko.info/">Muzaiko</a>：最最mojosa的世界语网络电台</p><p><a href="http://esperanto.cri.cn/">ĈRI</a>：中国国际广播电台世界语广播</p>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
