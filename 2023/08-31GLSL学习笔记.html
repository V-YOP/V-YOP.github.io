

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="友纪V-λOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="先把画画学好再说吧！">
<meta property="og:type" content="article">
<meta property="og:title" content="GLSL 学习笔记">
<meta property="og:url" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">
<meta property="og:site_name" content="友纪V-λOP">
<meta property="og:description" content="先把画画学好再说吧！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/myGo.gif">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/before.jpg">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/after.jpg">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seexprExp0.png">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seexprExp1.png">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/blackWhiteGradient.jpg">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/centerGradient.png">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/drawFn.png">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/drawSmoothFn.png">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/fnWithBackground.png">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rectangle.png">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/abstractPaint.png">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/translateExample.png">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rotateExample.gif">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/translateThenRotate.gif">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rotateThenTranslate.gif">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/takeAJump.gif">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/discreteDistanceField.png">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/patternExp3.gif">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/patternExp4.gif">
<meta property="og:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/dirtyWork.png">
<meta property="article:published_time" content="2023-08-31T11:49:00.000Z">
<meta property="article:modified_time" content="2023-11-12T03:44:40.418Z">
<meta property="article:author" content="友纪V-λOP">
<meta property="article:tag" content="CG">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/myGo.gif">
  
  
  <title>GLSL 学习笔记 - 友纪V-λOP</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="友纪V-λOP" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友纪V-λOP的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="GLSL 学习笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-08-31 19:49" pubdate>
        2023年8月31日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      21k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">GLSL 学习笔记</h1>
            
            <div class="markdown-body">
              <p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/myGo.gif" alt="其实我也在迷路"></p>
<h1 id="为啥学这玩意？"><a href="#为啥学这玩意？" class="headerlink" title="为啥学这玩意？"></a>为啥学这玩意？</h1><p>翻伊月クロ老师的本子时，发现他上调子完全只使用墨汁（纯黑）和网点，没有任何灰度，发现这种方式能很快出效果且很有味道，又意识到网点对打印机友好，将来要是打印自己的作品的话会很方便，不需要很好的打印机。</p>
<p>然后找到一个网点的笔刷，绘制时发现难以保证纯黑白的基础上做渐变（就像刮刀），下面是最终得到的效果和实现方式的说明，基本原理是对网点的滤镜应用一个有明显渐变的纯黑白的不透明度蒙版（在 ps 里是剪切蒙版？），即做一个减法。</p>
<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/before.jpg" alt="before"></p>
<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/after.jpg" alt="after"></p>
<ol>
<li>绘制网点</li>
<li>在网点下方建立一个图层，填充一个颜色</li>
<li>应用噪声滤镜，级别调到最高，生成就像电视没台时的噪声图</li>
<li>在噪声图层上创建一个图层，混合模式调整为线性光 Linear Light，它是线性减淡（相加）和线性加深（相乘、正片叠底）的混合，在亮度大于 0.5 时使用相加，小于 0.5 时使用线性加深</li>
<li>修改前景色为纯黑，背景色为纯白，在该图层拉一个前景色到背景色的渐变</li>
<li>合并这两个图层，做一个阈值滤镜，调整至边缘位置合适；渐变的拉的方式和阈值的设置会影响边缘的位置和柔软程度</li>
<li>将该图层转换为不透明度蒙版，置于网点图层下，bingo</li>
</ol>
<p>将图层中的每一个像素看作一个 0-1 之间的数字，将阈值看作布尔化（变为 0，1），将相加和相乘模式看作数字的相加相减，上述的过程是非常容易理解的。</p>
<p>现在还是放弃了研究网点的想法了，原因是这玩意更适用于打印，在屏幕上缩放级别的不同会影响灰度，而显然后者现在是更主要的受众。但不能说白费功夫了，研究实现该效果的过程中熟悉了图层，蒙版，混合模式等概念并建立了相应心智模型，同时意识到我以前光把着画笔工具不放的想法和行为是多么睿智。</p>
<p>然后发现 krita 允许通过 SeExpr 这门脚本语言进行绘图，其中有两个效果超级炫酷的示例（第一张简直壮观），引起了我很强烈的兴趣：</p>
<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seexprExp0.png" alt="SeExpr example 1"></p>
<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seexprExp1.png" alt="SeExpr example 2"></p>
<p>要是能在背景，材质等地方使用这样酷炫的材质岂不美哉？于是就来到这里了。然而 SeExpr 的学习材料实在太少（全互联网有 10 篇吗？），这里只得去拿和它思想一致的 glsl 来动手动脚。这里跟随 <a target="_blank" rel="noopener" href="https://thebookofshaders.com/?lan=ch">https://thebookofshaders.com/?lan=ch</a> 进行学习。SeExpr 的用法应当参考 <a target="_blank" rel="noopener" href="https://docs.krita.org/zh_CN/reference_manual/seexpr.html">https://docs.krita.org/zh_CN/reference_manual/seexpr.html</a>（Krita 的官方文档是好东西，值得反反复复看 10 遍）。本打算每个例子都用 SeExpr 实现一下，但是懒了。先把画画画好再说！</p>
<h1 id="glsl-是什么"><a href="#glsl-是什么" class="headerlink" title="glsl 是什么"></a>glsl 是什么</h1><p>glsl 与其说是编程语言，不如说是 DSL；glsl 语法和数据类型类似 C，glsl 脚本被交付给 GPU，在每一个像素上执行，用于修改该像素的颜色。可以认为 glsl 是一个接受像素坐标（和一些其他参数，称为 uniform；根据 GPU 的架构的性质，<strong>对每一个像素，uniform 的值均一致且不可变</strong>）的函数，返回像素颜色的函数，在这里，像素坐标是二元组，分别为 x，y 轴坐标（其实是四元组，但我们只看二维），其中<strong>原点在左下角</strong>；像素颜色为四元组，分别为 rgba 通道上的值。在 glsl 中，rgba 均使用 0-1 的浮点数表示，这种表示似乎称为 normalize 表示，它们乘以 255 会得到我们熟知的表示法。</p>
<p>下面是一个最简单的 glsl 脚本，它给整个画面从左到右做了一个黑白渐变：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 注释和 C 一样，行注释和块注释</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">样板代码，定义 float 的精度，这里定义为 medium 精度，还有 lowp 和 highp</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// uniforn 变量需定义出来</span><br><span class="hljs-comment">// 按照约定，uniform 变量使用 u_开头，gl 提供的内置的变量使用 gl_开头</span><br><span class="hljs-comment">// vec2 是二元向量，用来表示点或者向量，每个分量类型均为 float</span><br><span class="hljs-comment">// 此外，glsl 还提供了 vec3，vec4</span><br>uniform vec2 u_resolution; <span class="hljs-comment">// u_resolution 是画布的宽高，以像素为单位</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  能够从浮点数构造向量，如 vec3(1., 1., 1.)，它等价于 vec3(1.)，也能从向量构造向量，如 vec4(vec3(1.), 1) 得到 vec4(1., 1., 1., 1.)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  从向量中获取它的分量是十分符合直觉的，比如下面的 st.x 获取 st 的第一个分量，st.y 获取第二个分量，st.xy 获取 vec2(st.x, st.y)：</span><br><span class="hljs-comment">    vec2(st.x, st.y) = st.xy = st.rg = vec2(st[0], st[1]) = st</span><br><span class="hljs-comment">    vec4(st.y, st.y, st.x, st.x) = st.yyxx = st.ggrr</span><br><span class="hljs-comment">  具体使用什么表示法，看这个向量的语义和上下文，合法的表示法有：xyzw，rgba，stpq，他们之间不能混用</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 像 c 一样，脚本的“入口”</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同维数的向量能够做运算，这里是逐维度的除法</span><br>    <span class="hljs-comment">// gl_FragCoord 是四维的坐标信息，前两个分量为 x，y 轴的坐标</span><br>    vec2 st = gl_FragCoord.xy / u_resolution; <span class="hljs-comment">// st 是 gl_FragCoord 的标准化表示，它的 x，y 落在 0-1 之间</span><br>	gl_FragColor = vec4(vec3(st.x), <span class="hljs-number">1.</span>); <span class="hljs-comment">// 输出的颜色通过修改变量 gl_FragColor 来实现</span><br>    <span class="hljs-comment">// 在这里，输出颜色和 y 轴无关，x 越大，像素越亮，在画面最右亮度最大</span><br>    <span class="hljs-comment">// 也可以：gl_FragColor = vec4(vec3(1), st.x)，但这样如果屏幕有刷新，上次的结果</span><br>    <span class="hljs-comment">// 此外，glsl 支持 if-else，while，for（循环次数必须在“编译期”确定），三目表达式，但复杂语句可能会影响着色器性能，应尽量使用 glsl 提供的函数来完成功能，这些函数很多都是可以直接在硬件上执行的</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/blackWhiteGradient.jpg" alt="黑白渐变"></p>
<p>此外，glsl 支持 if-else，while，for（循环次数必须在“编译期”确定），三目表达式，但复杂语句可能会影响着色器性能，应尽量使用 glsl 提供的函数来完成功能，这些函数很多都是可以直接在硬件上执行的。</p>
<p>注意 glsl 很少会进行自动的类型转换，写浮点数时加上<code>.</code>是好习惯。</p>
<p>下面是另一个脚本，其使用了 distance 函数，绘制从中心开始的圆形渐变：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>	vec2 coor = gl_FragCoord.xy/u_resolution;<br>    <span class="hljs-type">float</span> dist = distance(vec2(<span class="hljs-number">.5</span>), coor) * <span class="hljs-number">2.</span>;<br>    <span class="hljs-comment">// 各边中点处亮度为 1</span><br>    gl_FragColor = vec4(vec3(dist), <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/centerGradient.png" alt="中心渐变"></p>
<p>教程关卡结束了！该来点烧脑子的东西了。下面的所有代码都有一个很大的问题——只考虑了画布为正方形的情况；但懒得研究了。</p>
<h1 id="绘制函数汗背景"><a href="#绘制函数汗背景" class="headerlink" title="绘制函数汗背景"></a>绘制函数汗背景</h1><p>在 glsl 中，函数可视化有两种方式——使用灰度来表达 y 轴，或者使用 y 轴来表达 y 轴，前者就是绘制像上面第一个例子的黑白渐变，其就是通过灰度绘制了 y&#x3D;x 的图像，后者就是在图像中实际绘制出函数曲线。</p>
<p>现在有个数学函数<code>y=x^2</code>，如何将它作为一条线绘制在画面上？具体来说就是，如何绘制这样的图像，它的大多数地方亮度为 0，该函数周围区域亮度为 1？</p>
<p>第一印象是，对每一个点，可以计算它到函数的距离，小于一定距离，则认为它在线上，绘制亮度为 1，否则绘制为 0，这里为了实现简单，只比较 y 轴方向的距离；代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br><span class="hljs-comment">// 检查点 st 是否在函数 y=x^2 上，即检查点 (st.x, st.y) 和 (st.x, st.x * st.x) 的距离是否小于定值</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isOnLine</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-comment">// 是的，这个距离直接做减法就行：D</span><br>    <span class="hljs-type">float</span> dist = distance(st, vec2(st.x, st.x * st.x));<br>    <span class="hljs-keyword">return</span> dist &lt; <span class="hljs-number">0.01</span>;<br>    <span class="hljs-comment">// 可以使用阶跃函数 step 来处理 dist，step 函数在入参小于特定值时返回 0，大于特定值时返回 1，这样就能避免这个三目运算符了，但是……可读性降低了，这真的好吗？</span><br>    <span class="hljs-comment">// return -step(0.01, dist) + 1.;</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>	vec2 st = gl_FragCoord.xy/u_resolution;<br>	gl_FragColor = vec4(vec3(isOnLine(st) ? <span class="hljs-number">1.</span> : <span class="hljs-number">0.</span>), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/drawFn.png" alt="画函数"></p>
<p>这种方法有两个缺点，第一是函数导数大时函数会画得更细，反之会画得更粗；第二是绘制出来的线条的边缘会非常硬——从 1 直接跃迁到 0 了，中间没有任何渐变。</p>
<p>第一个问题先不考虑，看第二个问题，如何把它画的更平滑一些？我们需要一个类似阶梯函数但中间要有一个平滑但微小的过渡的东西，让它在距离大于特定值时返回 0，距离小于该特定值时返回 0-1 之间的数，更小时返回 1（处理这个“更小”和“特定值”就是处理函数边缘的硬度）。<a target="_blank" rel="noopener" href="https://thebookofshaders.com/glossary/?search=smoothstep">smoothstep 函数</a> 满足我们的需求——它需要用户给定阶梯的开始和结束位置，通过某种插值法在中间生成平滑的过渡，下面是使用 smoothstep 函数来做的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br><span class="hljs-comment">// 若点在曲线上，返回 0-1 的值，否则返回 0</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">plot</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> dist = distance(st, vec2(st.x, st.x * st.x));<br>    <span class="hljs-keyword">return</span> smoothstep(<span class="hljs-number">0.002</span>, <span class="hljs-number">0.</span>, dist);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>	vec2 st = gl_FragCoord.xy/u_resolution;<br>	gl_FragColor = vec4(vec3(plot(st)), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/drawSmoothFn.png" alt=".. 还是尖锐一点好"></p>
<p>然后下一步，这函数的背景有点寡淡了，想给它加个背景，该怎么办？</p>
<p>考虑<code>plot(st)</code>的返回值，在大多数时候它返回 0，只有在函数附近时它才返回 1，我们的需求是，在 plot(st) 返回 0 的时候，显示背景色，在 plot(st) 返回 1 的时候显示前景色……在 plot(st) 在 0-1 之间的时候，返回前景色和背景色的混合……混合，混合……混合？</p>
<p>混合！答案实际上呼之欲出了——</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">gl_FragColor = plot * lineColor + (<span class="hljs-number">1</span> - plot) * background; <span class="hljs-comment">// 使用特定算法来混合前景色和背景色</span><br></code></pre></div></td></tr></table></figure>

<p>背景色当然也可以是计算出来的，这里同时使用背景色和曲线来可视化<code>y=x^2</code>，下面使用功能相同的 mix 函数来进行混合：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br><span class="hljs-comment">// 若点在曲线上，返回 0-1 的值，否则返回 0</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">plot</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> dist = distance(st, vec2(st.x, st.x * st.x)); <span class="hljs-comment">// 这里的 st.x * st.x，即要画的函数，也可以通过参数传进来</span><br>    <span class="hljs-keyword">return</span> smoothstep(<span class="hljs-number">0.02</span>, <span class="hljs-number">0.</span>, dist);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>	vec2 st = gl_FragCoord.xy/u_resolution;<br>    vec3 background = vec3(st.x * st.x);<br>    vec3 lineColor = vec3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">float</span> plot = plot(st);<br>    vec3 targetColor = vec3(mix(background, lineColor, plot)); <span class="hljs-comment">// mix(x, y, a) = (1 - a) * x + a * y</span><br>	gl_FragColor = vec4(targetColor, <span class="hljs-number">1.</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/fnWithBackground.png" alt="通过线和灰度来表示函数"></p>
<h1 id="组合图形"><a href="#组合图形" class="headerlink" title="组合图形"></a>组合图形</h1><p>就像绘画时复杂的形体可以认为是简单的几何体的组合，使用 glsl 也可以组合不同的形状来绘制复杂图形；最简单的组合显然是加法（加法需要做一个<code>clamp(0, 1)</code>来保证最终的值仍然是归一化的）和乘法，分别对应求两个图形的并集和交集，比如下面就用四个图形的交集绘制一个矩形：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>uniform vec2 u_resolution;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    vec2 st = gl_FragCoord.xy/u_resolution;<br>	<span class="hljs-type">float</span> color = <span class="hljs-number">1.</span>;<br>    <span class="hljs-type">float</span> left = step(<span class="hljs-number">.25</span>, st.x); <span class="hljs-comment">// 绘制左边框</span><br>    <span class="hljs-type">float</span> bottom = step(<span class="hljs-number">.25</span>, st.y); <span class="hljs-comment">// 绘制下边框</span><br>    <span class="hljs-type">float</span> right =  step(st.x, <span class="hljs-number">.75</span>); <span class="hljs-comment">// 绘制右边框（step(x, .5) = 1 - step(.5, x)）</span><br>    <span class="hljs-type">float</span> top =  step(st.y, <span class="hljs-number">.75</span>); <span class="hljs-comment">// 绘制下边框</span><br>    color *= left; <span class="hljs-comment">// 求四个图形的交集</span><br>    color *= bottom;<br>    color *= right;<br>    color *= top;<br>    gl_FragColor = vec4(vec3(color),<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rectangle.png"></p>
<p>该流程可以抽象成返回 float 的函数，返回 1 时表示需要绘制该图形，返回 0 时表示需要绘制背景，结合这样的函数和 mix 函数，就可以绘制多层的图像了，下面使用该方法临摹一幅抽象画：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>uniform vec2 u_resolution;<br><span class="hljs-comment">// 使用 floor 实现 step，just for practice</span><br>vec2 <span class="hljs-title function_">myStep</span><span class="hljs-params">(vec2 threshold, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">floor</span>(st - threshold) + <span class="hljs-number">1.</span>;<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">rectangle</span><span class="hljs-params">(vec2 start, vec2 end, vec2 st)</span> &#123;<br>	vec2 realStart = vec2(min(start.x, end.x), min(start.y, end.y)); <span class="hljs-comment">// 找到实际左下角的点</span><br>    vec2 realEnd = vec2(max(start.x, end.x), max(start.y, end.y)); <span class="hljs-comment">// 找到实际右上角的点</span><br>    vec2 bl = step(realStart, st); <span class="hljs-comment">// bottom left, 在起始点的左边时，x=0，否则 x=1；在起始点点下边时，y=0，否则 y=1</span><br>	vec2 tr = <span class="hljs-number">1.</span> - step(realEnd, st); <span class="hljs-comment">// top right, 在终止点的右边时，x=0，否则 x=1，在终止点上面时，y=0，否则 y=1</span><br>    <span class="hljs-keyword">return</span> bl.x * bl.y * tr.x * tr.y;<br>&#125;<br><br><span class="hljs-comment">// 画一幅抽象画</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    vec2 st = gl_FragCoord.xy/u_resolution.xy;<br>    vec3 background = vec3(<span class="hljs-number">247.</span>, <span class="hljs-number">239.</span>, <span class="hljs-number">220.</span>) / <span class="hljs-number">255.</span>;<br>    vec3 red = vec3(<span class="hljs-number">170.</span>, <span class="hljs-number">40.</span>, <span class="hljs-number">40.</span>) / <span class="hljs-number">255.</span>;<br>    vec3 orange = vec3(<span class="hljs-number">250.</span>, <span class="hljs-number">195.</span>, <span class="hljs-number">68.</span>) / <span class="hljs-number">255.</span>;<br>    vec3 skyBlue = vec3(<span class="hljs-number">17.</span>, <span class="hljs-number">83.</span>, <span class="hljs-number">140.</span>) / <span class="hljs-number">255.</span>;<br>    vec3 black = vec3(<span class="hljs-number">19.</span>, <span class="hljs-number">19.</span>, <span class="hljs-number">24.</span>) / <span class="hljs-number">255.</span>;<br><br>    vec3 color = background;<br>    <span class="hljs-comment">// 色块</span><br>    color = mix(color, red, rectangle(vec2(<span class="hljs-number">0.</span>,<span class="hljs-number">1.</span>), vec2(<span class="hljs-number">0.260</span>,<span class="hljs-number">0.590</span>), st));<br>    color = mix(color, orange, rectangle(vec2(<span class="hljs-number">0.920</span>,<span class="hljs-number">0.590</span>), vec2(<span class="hljs-number">1.</span>), st));<br>    color = mix(color, skyBlue, rectangle(vec2(<span class="hljs-number">0.730</span>,<span class="hljs-number">-1.000</span>), vec2(<span class="hljs-number">1.000</span>,<span class="hljs-number">0.120</span>), st));<br>    <span class="hljs-comment">// 竖线</span><br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.220</span>,<span class="hljs-number">0.000</span>), vec2(<span class="hljs-number">0.260</span>,<span class="hljs-number">1.0</span>), st));<br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.730</span>,<span class="hljs-number">-0.010</span>), vec2(<span class="hljs-number">0.77</span>,<span class="hljs-number">1.0</span>), st));<br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.910</span>,<span class="hljs-number">-0.020</span>), vec2(<span class="hljs-number">0.95</span>,<span class="hljs-number">1.0</span>), st));<br>    <span class="hljs-comment">// 横线</span><br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.</span>,<span class="hljs-number">0.590</span>), vec2(<span class="hljs-number">1.000</span>,<span class="hljs-number">0.640</span>), st));<br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.</span>, <span class="hljs-number">0.790</span>), vec2(<span class="hljs-number">1.000</span>,<span class="hljs-number">0.840</span>), st));<br>    color = mix(color, black, rectangle(vec2(<span class="hljs-number">0.220</span>,<span class="hljs-number">0.090</span>), vec2(<span class="hljs-number">1.000</span>,<span class="hljs-number">0.140</span>), st));<br>    gl_FragColor = vec4(color,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/abstractPaint.png" alt="还蛮抽象的"></p>
<h1 id="二维变换"><a href="#二维变换" class="headerlink" title="二维变换"></a>二维变换</h1><p>首先定义一个在原点处绘制坐标系和绘制一个描边矩形的函数，方便后面做示例：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159265359</span><br>uniform vec2 u_resolution;<br><span class="hljs-type">float</span> <span class="hljs-title function_">rectangle</span><span class="hljs-params">(vec2 start, vec2 end, vec2 st)</span> &#123;<br>	vec2 realStart = vec2(min(start.x, end.x), min(start.y, end.y)); <span class="hljs-comment">// 找到实际左下角的点</span><br>    vec2 realEnd = vec2(max(start.x, end.x), max(start.y, end.y)); <span class="hljs-comment">// 找到实际右上角的点</span><br>    vec2 bl = step(realStart, st); <span class="hljs-comment">// bottom left, 在起始点的左边时，x=0，否则 x=1；在起始点点下边时，y=0，否则 y=1</span><br>	vec2 tr = <span class="hljs-number">1.</span> - step(realEnd, st); <span class="hljs-comment">// top right, 在终止点的右边时，x=0，否则 x=1，在终止点上面时，y=0，否则 y=1</span><br>    <span class="hljs-keyword">return</span> bl.x * bl.y * tr.x * tr.y;<br>&#125;<br>vec2 <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">float</span> angle, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> mat2(<span class="hljs-built_in">cos</span>(angle),-<span class="hljs-built_in">sin</span>(angle),<br>                <span class="hljs-built_in">sin</span>(angle),<span class="hljs-built_in">cos</span>(angle)) * st;<br>&#125;<br><span class="hljs-comment">// 在原点处绘制坐标系</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">coorSys</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> xAxis = rectangle(vec2(<span class="hljs-number">-1.</span>, <span class="hljs-number">-.01</span>), vec2(<span class="hljs-number">1.25</span>, <span class="hljs-number">.01</span>), st) + rectangle(vec2(<span class="hljs-number">.49</span>, <span class="hljs-number">-.05</span>), vec2(<span class="hljs-number">.51</span>, <span class="hljs-number">.05</span>), st) + rectangle(vec2(<span class="hljs-number">.99</span>, <span class="hljs-number">-.1</span>), vec2(<span class="hljs-number">1.01</span>, <span class="hljs-number">.1</span>), st);<br>    <span class="hljs-type">float</span> yAxis = rectangle(vec2(<span class="hljs-number">-.01</span>, <span class="hljs-number">-1.</span>), vec2(<span class="hljs-number">.01</span>, <span class="hljs-number">1.25</span>), st) + rectangle(vec2(<span class="hljs-number">-.05</span>, <span class="hljs-number">.49</span>), vec2(<span class="hljs-number">.05</span>, <span class="hljs-number">.51</span>), st) + rectangle(vec2(<span class="hljs-number">-.1</span>, <span class="hljs-number">.99</span>), vec2(<span class="hljs-number">.1</span>, <span class="hljs-number">1.01</span>), st);<br>    vec2 arrowX = rotate(PI / <span class="hljs-number">-4.</span>, st - vec2(<span class="hljs-number">1.2</span>, <span class="hljs-number">0.</span>));<br>    vec2 arrowY = rotate(PI / <span class="hljs-number">4.</span>, st - vec2(<span class="hljs-number">0.</span>, <span class="hljs-number">1.2</span>));<br>    <span class="hljs-keyword">return</span> clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, xAxis + yAxis + rectangle(vec2(<span class="hljs-number">0.</span>), vec2(<span class="hljs-number">0.1</span>), arrowX)+ rectangle(vec2(<span class="hljs-number">0.</span>), vec2(<span class="hljs-number">0.1</span>), arrowY));<br>&#125;<br><span class="hljs-comment">// 中心在原点处，长宽均为 0.25 的描边矩形</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">box</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, rectangle(vec2(<span class="hljs-number">-.26</span>), vec2(<span class="hljs-number">.26</span>), st) - rectangle(vec2(<span class="hljs-number">-.24</span>), vec2(<span class="hljs-number">.24</span>), st));<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>每次对坐标进行修改时，我们就是在进行二维变换，最简单的二维变换包括平移，旋转，缩放，工业上这玩意应该是用齐次矩阵做的，但这里图简单。</p>
<p>如何理解二维变换？可以认为，每次对原坐标做映射，得到一个新坐标时，就是创建了一个对画布（后面把它称为世界坐标系）的新的<strong>视图</strong>坐标系（就像对数组或表的视图）。前面的学习中，其实也是在视图坐标系中绘制，只是它们正巧和世界坐标系一致罢了。当然，也可以以视图去建立视图，前者会成为后者的世界坐标系，相对和绝对嘛。</p>
<p>对每个像素，我们首先拿到的是它的世界坐标系的位置，我们需要找到这个像素在视图中的位置，并从视图的角度检查需要绘制何种内容。比如，将整个坐标系向右上角移动 (1, 1)。我们尝试在 (0, 0) 处绘制方块时，实际上就是在问，世界坐标系的哪里是我们的 (0, 0)？</p>
<p>为此，需要找到<strong>世界坐标系到视图的映射</strong>，下面的几种二维变换，实际上都是根据相应参数找到这样一个映射。</p>
<p>这个心智模型颇有些奇怪，第一印象是找到视图到世界坐标系的映射，但在这里似乎不适用，因为 glsl 做的是对世界坐标系的每一个坐标，检查它要画什么，而不是我要在（视图的）某个坐标画什么。前者的话，坐标的变换流程就会是 世界坐标系 -&gt; 视图 1 -&gt; 视图 2 -&gt; 当前视图，后者的话就是当前视图 -&gt; 视图 2 -&gt; 视图 1 -&gt; 世界坐标系。</p>
<p>实现了二维变换后，编写新的图形绘制函数的时候，只需要实现它在原点处的“单位”形状即可，后面的通过二维变换操作就行。</p>
<h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>要将坐标系平移到 (1, 2)，就需要以 (1, 2) 为原点建立一个坐标系，并始终在该坐标系下进行绘制，这样，代码在视图的 (0, 0) 处绘制时，实际上就是在世界坐标系的 (1, 2) 处绘制。</p>
<p>容易发现这样的对应关系：</p>
<table>
<thead>
<tr>
<th align="center">世界坐标系</th>
<th align="center">视图</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(0, 0)</td>
<td align="center">(-1, -2)</td>
</tr>
<tr>
<td align="center">(1, 2)</td>
<td align="center">(0, 0)</td>
</tr>
</tbody></table>
<p>实现很显然了：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// dir：平移方向</span><br><span class="hljs-comment">// st: 世界坐标系</span><br><span class="hljs-comment">// return: 视图坐标系</span><br>vec2 <span class="hljs-title function_">translate</span><span class="hljs-params">(vec2 dir, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st - dir;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>下面的代码中利用平移在 (1, 1) 处绘制了一个矩形，并绘制了此时的视图坐标系。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 样板代码和上面引用的函数均省略，只写 main</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">但实现个函数包装一下 mix，避免重复</span><br><span class="hljs-comment">原本绘制多层的时候，遵循这样的模式：</span><br><span class="hljs-comment">vec3 color = background;</span><br><span class="hljs-comment">color = mix(color, newColor, shape(..., st))</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">考虑 color 通过引用传进去，避免反复赋值，可惜没闭包</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(inout vec3 background, vec3 color, <span class="hljs-type">float</span> pct)</span> &#123;<br>    background = mix(background, color, pct);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>	vec2 st = gl_FragCoord.xy/u_resolution;<br>    <span class="hljs-comment">// 先 remap 一下空间（这其实也是创建了一个视图）</span><br>    st = st * <span class="hljs-number">4.</span> - <span class="hljs-number">1.</span>;<br>    vec3 c = vec3(<span class="hljs-number">0.</span>); <span class="hljs-comment">// 背景，纯黑</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), coorSys(st)); <span class="hljs-comment">// 原点处绘制纯白坐标系表示世界坐标系</span><br><br>    vec2 viewSt1 = translate(vec2(<span class="hljs-number">1.</span>), st); <span class="hljs-comment">// (1, 1) 处创建视图 1</span><br>    draw(c, vec3(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>), coorSys(viewSt1)); <span class="hljs-comment">// 视图 1 原点处绘制一个绿色坐标系表示视图</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), box(viewSt1)); <span class="hljs-comment">// 视图 1 原点处绘制矩形</span><br><br>    vec2 viewSt2 = translate(vec2(<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>), viewSt1); <span class="hljs-comment">// 从视图 1 处向 x 轴平移 1 再创建一个视图</span><br>    draw(c, vec3(<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">.5</span>), coorSys(viewSt2)); <span class="hljs-comment">// 视图 2 原点处绘制一个坐标系表示视图</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), box(viewSt2)); <span class="hljs-comment">// 视图 2 原点处绘制矩形</span><br><br>	gl_FragColor = vec4(c,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/translateExample.png" alt="示例"></p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转直接抄作业，总之是视图坐标系的旋转（恼），用初高中的知识应该就能推导出来，但我已经失掉这个能力了。实现和示例如下，移动到 (1, 1)，然后再随时间旋转。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">vec2 <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">float</span> angle, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> mat2(<span class="hljs-built_in">cos</span>(angle),-<span class="hljs-built_in">sin</span>(angle),<br>                <span class="hljs-built_in">sin</span>(angle),<span class="hljs-built_in">cos</span>(angle)) * st; <span class="hljs-comment">// st 应该是当作列向量看待了</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>	vec2 st = gl_FragCoord.xy/u_resolution;<br>    st = st * <span class="hljs-number">4.</span> - <span class="hljs-number">1.</span>;<br>    vec3 c = vec3(<span class="hljs-number">0.</span>); <span class="hljs-comment">// 背景，纯黑</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), coorSys(st)); <span class="hljs-comment">// 原点处绘制纯白坐标系表示世界坐标系</span><br><br>    vec2 viewSt1 = translate(vec2(<span class="hljs-number">1.</span>), st); <span class="hljs-comment">// (1, 1) 处创建视图 1</span><br>    vec2 viewSt2 = rotate(u_time, viewSt1); <span class="hljs-comment">// 旋转视图 1，得到视图 2</span><br>    draw(c, vec3(<span class="hljs-number">.3</span>, <span class="hljs-number">.3</span>, <span class="hljs-number">.5</span>), coorSys(viewSt2)); <span class="hljs-comment">// 视图 2 原点处绘制一个绿色坐标系表示视图</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), box(viewSt2)); <span class="hljs-comment">// 在视图 2 原点处绘制一个矩形</span><br>	gl_FragColor = vec4(c,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rotateExample.gif" alt="旋转示例"></p>
<h3 id="平移和旋转"><a href="#平移和旋转" class="headerlink" title="平移和旋转"></a>平移和旋转</h3><p>同时使用平移和旋转时，平移和旋转的先后顺序会影响最终效果，但使用这套心智模型的话很容易理解它们的差异。</p>
<p>假设随时间旋转。先平移再旋转时，就是先向前走 10 步，然后原地转圈圈；先旋转再平移，就是在当前位置旋转，然后对每个角度，都向前走 10 步，它们的差别通过下面的例子可以看到；前者就是普通的原地转圈圈，后者类似月球围绕地球运动且潮汐锁定。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>	vec2 st = gl_FragCoord.xy/u_resolution;<br>    st = st * <span class="hljs-number">4.</span> - <span class="hljs-number">2.</span>;<br>    vec3 c = vec3(<span class="hljs-number">0.</span>); <span class="hljs-comment">// 背景，纯黑</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), coorSys(st)); <span class="hljs-comment">// 原点处绘制纯白坐标系表示世界坐标系</span><br><br>    <span class="hljs-comment">// 交换这两行</span><br>    <span class="hljs-comment">// 因为不再使用原来的 st 了，可以直接对它赋值了</span><br>    st = translate(vec2(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>), st); <span class="hljs-comment">// 向前走 1</span><br>    st = rotate(u_time, st); <span class="hljs-comment">// 旋转</span><br><br>    draw(c, vec3(<span class="hljs-number">.3</span>, <span class="hljs-number">.3</span>, <span class="hljs-number">.5</span>), coorSys(st)); <span class="hljs-comment">// 视图原点处绘制一个绿色坐标系表示视图</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), box(st)); <span class="hljs-comment">// 视图原点处绘制一个矩形</span><br>	gl_FragColor = vec4(c,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/translateThenRotate.gif" alt="先平移再旋转"></p>
<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rotateThenTranslate.gif" alt="先旋转再平移"></p>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>缩放很好玩；如何把图形到原来的 2 倍呢？我们绘制图形还是同样的画，但需要这样一个效果，即我们在 (1, 0) 处绘制时，实际上要在 (2, 0) 处绘制，在 (2, 3) 处绘制时，实际上要在 (4, 6) 处绘制：</p>
<table>
<thead>
<tr>
<th align="center">世界坐标系</th>
<th align="center">视图</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(2, 0)</td>
<td align="center">(1, 0)</td>
</tr>
<tr>
<td align="center">(4, 6)</td>
<td align="center">(2, 3)</td>
</tr>
</tbody></table>
<p>很显然了，实现和示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// ratio：缩放倍率，为 2 表示放大 2 倍，为 0.5 表示缩小到 1/2</span><br>vec2 <span class="hljs-title function_">scale</span><span class="hljs-params">(<span class="hljs-type">float</span> ratio, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st / ratio;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>	vec2 st = gl_FragCoord.xy/u_resolution;<br>    st = st * <span class="hljs-number">4.</span> - <span class="hljs-number">2.</span>;<br>    vec3 c = vec3(<span class="hljs-number">0.</span>); <span class="hljs-comment">// 背景，纯黑</span><br>    draw(c, vec3(<span class="hljs-number">1.</span>), coorSys(st)); <span class="hljs-comment">// 原点处绘制纯白坐标系表示世界坐标系</span><br>	st = translate(vec2(<span class="hljs-number">1.1</span>), st);<br>    st = scale(<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">sin</span>(u_time)) * <span class="hljs-number">2.</span>, st); <span class="hljs-comment">// 做一种类似弹跳的效果</span><br>    draw(c, vec3(<span class="hljs-number">.3</span>, <span class="hljs-number">.3</span>, <span class="hljs-number">.5</span>), coorSys(st));<br>    draw(c, vec3(<span class="hljs-number">1.</span>), box(st));<br>	gl_FragColor = vec4(c,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/takeAJump.gif" alt="缩放示例"></p>
<h1 id="距离场"><a href="#距离场" class="headerlink" title="距离场"></a>距离场</h1><p>距离场是画面上任意一点同特定点的距离相关联的场，距离可以使用亮度来表示，距离越远，亮度越大。距离场并不是特定的几何图形，它是无穷大的，通过距离场来绘制各种东西是把它当作工具，而不是绘制它本身。利用距离场，能做出非常多有趣的效果，用途包括但不限于：</p>
<ol>
<li>绘制硬边和软边圆形</li>
<li>绘制对称圆形，矩形，四角星</li>
<li>为上述的形状描边</li>
</ol>
<p>注意下面的例子中使用 abs，max，min 等函数创建的视图。这个懒得截图了。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>uniform vec2 u_resolution;<br><br><span class="hljs-comment">// 普通画圆法，并非距离场，距离场是无限的</span><br><span class="hljs-comment">// c：圆心，r：半径，在圆内时返回 1，否则返回 0</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">circle</span><span class="hljs-params">(vec2 c, <span class="hljs-type">float</span> r, vec2 st)</span> &#123;<br>    <span class="hljs-comment">// 换成 smoothstep 就能做圆形渐变，非常 soft 的渐变</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.</span> - step(r, distance(c, st)); <span class="hljs-comment">// 避免使用 sqrt 能提高性能，但我又不是做游戏，不需要考虑性能</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  vec2 st = gl_FragCoord.xy/u_resolution.xy;<br>  vec3 color = vec3(<span class="hljs-number">0.0</span>);<br>  <span class="hljs-type">float</span> d = <span class="hljs-number">0.0</span>;<br><br>  <span class="hljs-comment">// 把坐标系转换为-1,1，原点为 0,0</span><br>  st = st *<span class="hljs-number">2.</span><span class="hljs-number">-1.</span>;<br><br>  <span class="hljs-comment">// 做到原点的距离场（这书给的示例实在太少了！）</span><br>  d = length(st);<br><br>  <span class="hljs-comment">// 离散距离场，很漂亮</span><br>  d = length(<span class="hljs-built_in">floor</span>(st * <span class="hljs-number">10.</span>) / <span class="hljs-number">10.</span>);<br><br>  <span class="hljs-comment">// 各种奇怪的距离场，可以把它们考虑成先对 st 做某种变换，再求变换后的点到原点的距离并展示</span><br>  <span class="hljs-comment">// 对每个 st，向左下移动 0.3 再求到原点的距离，这样，原点处的值为 0.3*sqrt(2)，0.3 处的值为 0，即最暗；相当于整个厂向右上移动了 0.3</span><br>  <span class="hljs-comment">// d = length(st -.3 );</span><br><br>  <span class="hljs-comment">// 对 st 取绝对值并向左下移动 0.3，相当于对上一个例子，把第一象限的内容对称变换到其他象限</span><br>  <span class="hljs-comment">// d = length( abs(st)-.3 );</span><br><br>  <span class="hljs-comment">// 在第一象限时，始终为 0，第三象限时正常做圆渐变，第二象限时，只和 x 坐标相关（y 恒为 0），第四象限时，只和 y 坐标相关（x 恒为 0）（注意这种性质能造成直线</span><br>  <span class="hljs-comment">// d = length(min(st, 0.));</span><br><br>  <span class="hljs-comment">// min 沿 y=-x 的轴对称</span><br>  <span class="hljs-comment">// d = length(max(st, 0.));</span><br><br>  <span class="hljs-comment">// 在第一象限时，始终为 0，把第一象限的内容对称变换到其他象限，我是说，全为 0</span><br>  <span class="hljs-comment">// d = length(min(abs(st), 0.));</span><br><br>  <span class="hljs-comment">// 在第一象限时，正常做圆渐变，把第一象限的内容对称变换到其他象限，我是说，和 length(st) 一致</span><br>  <span class="hljs-comment">// d = length(max(abs(st), 0.));</span><br><br>  <span class="hljs-comment">// 假设 0.3, 0.3 为圆心，在第三象限，正常做圆渐变，第一象限全为 0，第二象限只和 x 相关，第四象限只和 y 相关</span><br>  <span class="hljs-comment">// d = length( min(st-.3,0.) );</span><br><br>  <span class="hljs-comment">// 对上一个例子，把第一象限的内容对称变换到其他象限，形状类似一个十字</span><br>  <span class="hljs-comment">// d = length( min(abs(st)-.3,0.) );</span><br><br>  <span class="hljs-comment">// 假设 0.3, 0.3 为圆心，在第一象限，正常做圆渐变，第三象限全为 0，第二象限只和 y 相关，第四象限只和 x 相关</span><br>  <span class="hljs-comment">// d = length( max(st-.3,0.) );</span><br><br>  <span class="hljs-comment">// 对上一个例子，把第一象限的内容对称变换到其他象限，形状类似矩形</span><br>  <span class="hljs-comment">// d = length( max(abs(st)-.3,0.) );</span><br><br>  <span class="hljs-comment">// ==========================================================================================</span><br>  <span class="hljs-comment">// 可视化距离场，这个直接用距离来作为亮度，可以用来 debug</span><br>  gl_FragColor = vec4(vec3(d),<span class="hljs-number">1.0</span>);<br><br>  <span class="hljs-comment">// 其他可视化方法</span><br>  <span class="hljs-comment">// 使用 fract 做出同心圆（漏斗）效果</span><br>  <span class="hljs-comment">// gl_FragColor = vec4(vec3(fract(d * 10.0)),1.0);</span><br><br>  <span class="hljs-comment">// 绘制硬边图像</span><br>  <span class="hljs-comment">// gl_FragColor = vec4(vec3( step(.3,d) ),1.0);</span><br><br>  <span class="hljs-comment">// 描边，利用两个 step 相乘造成一个“脉冲”的函数</span><br>  <span class="hljs-comment">// gl_FragColor = vec4(vec3( step(.3,d) * step(d,.4)),1.0);</span><br><br>  <span class="hljs-comment">// 同上，但软边缘</span><br>  <span class="hljs-comment">// gl_FragColor = vec4(vec3( smoothstep(.3,.4,d)* smoothstep(.6,.5,d)) ,1.0);</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/discreteDistanceField.png" alt="离散距离场"></p>
<p>下面利用距离场和二维变换绘制了开头的 MyGo!!!!!! 的罗盘 logo，写得仓促，将就看。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br>uniform <span class="hljs-type">float</span> u_time;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159265359</span><br><br>vec2 <span class="hljs-title function_">translate</span><span class="hljs-params">(vec2 dir, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st - dir;<br>&#125;<br>vec2 <span class="hljs-title function_">scale</span><span class="hljs-params">(vec2 ratio, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st / ratio;<br>&#125;<br>vec2 <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">float</span> angle, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> mat2(<span class="hljs-built_in">cos</span>(angle),-<span class="hljs-built_in">sin</span>(angle),<br>                <span class="hljs-built_in">sin</span>(angle),<span class="hljs-built_in">cos</span>(angle)) * st;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(inout vec3 background, vec3 color, <span class="hljs-type">float</span> pct)</span> &#123;<br>    background = mix(background, color, pct);<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">shape0</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-keyword">if</span> (st.x &lt; <span class="hljs-number">0.</span> || st.y &lt; <span class="hljs-number">0.</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.</span>;<br>    <span class="hljs-type">float</span> a = <span class="hljs-number">2.414</span> * st.x - <span class="hljs-number">0.589</span>;<br>    <span class="hljs-keyword">return</span> clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, sign(st.y - a) - sign(st.y - st.x));<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">dist2line</span><span class="hljs-params">(<span class="hljs-type">float</span> k, <span class="hljs-type">float</span> b, vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> x = st.x;<br>    <span class="hljs-type">float</span> y = st.y;<br>    <span class="hljs-type">float</span> A = k;<br>    <span class="hljs-type">float</span> B = <span class="hljs-number">-1.</span>;<br>    <span class="hljs-type">float</span> C = b;<br>    <span class="hljs-type">float</span> dist = <span class="hljs-built_in">abs</span>(A * x + B * y + C) / <span class="hljs-built_in">sqrt</span>(A * A + B * B) ;<br>    <span class="hljs-keyword">return</span> dist;<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">belowLine</span><span class="hljs-params">(<span class="hljs-type">float</span> k, <span class="hljs-type">float</span> b, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> step(st.y - k * st.x - b, <span class="hljs-number">0.</span>);<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">lb</span><span class="hljs-params">(vec2 x, vec2 st)</span> &#123;<br>    vec2 r = step(st, vec2(x));<br>    <span class="hljs-keyword">return</span> r.x * r.y;<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">drawPart</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> test;<br>    test += (step(<span class="hljs-number">0.691</span>, length(st)) * step(length(st), <span class="hljs-number">0.8333</span>));<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    test += belowLine(<span class="hljs-number">-15.</span> * PI / <span class="hljs-number">180.</span>, <span class="hljs-number">0.2557</span>, st);<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, belowLine(<span class="hljs-number">-15.</span> * PI / <span class="hljs-number">180.</span>, <span class="hljs-number">0.2557</span>, vec2(st.y, st.x))) + test);<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    test += shape0(st) + shape0(vec2(st.y, st.x));<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    test -= clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, belowLine(<span class="hljs-number">-15.</span> * PI / <span class="hljs-number">180.</span>, <span class="hljs-number">0.2083</span>, vec2(st.x, st.y)));<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    test += belowLine(<span class="hljs-number">60.</span> * PI / <span class="hljs-number">180.</span>, <span class="hljs-number">0.</span>, vec2(st.y, st.x)) * lb(vec2(<span class="hljs-number">.24</span>), st);<br>    test = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, test);<br>    <span class="hljs-keyword">return</span> st.x &lt; <span class="hljs-number">0.</span> || st.y &lt; <span class="hljs-number">0.</span> ? <span class="hljs-number">0.</span> : test;<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">myGo</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> res;<br>    res += drawPart(st);<br>    st = rotate(<span class="hljs-number">90.</span> * PI / <span class="hljs-number">180.</span>, st);<br>    res += drawPart(st);<br>    st = rotate(<span class="hljs-number">90.</span> * PI / <span class="hljs-number">180.</span>, st);<br>    res += drawPart(st);<br>    st = rotate(<span class="hljs-number">90.</span> * PI / <span class="hljs-number">180.</span>, st);<br>    res += drawPart(st);<br>    st = rotate(<span class="hljs-number">90.</span> * PI / <span class="hljs-number">180.</span>, st);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>	vec2 st = gl_FragCoord.xy/u_resolution;<br>    vec3 blue = vec3(<span class="hljs-number">51.</span>, <span class="hljs-number">124.</span>, <span class="hljs-number">175.</span>) / <span class="hljs-number">255.</span>;<br>    st = st * <span class="hljs-number">2.</span> - <span class="hljs-number">1.</span>;<br>    st = rotate(u_time, st);<br>    vec3 c = blue;<br>    draw(c, vec3(<span class="hljs-number">1.</span>), myGo(st));<br>	gl_FragColor = vec4(c,<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>很多时候需要创建重复的图案，但是又不想挨个绘制，而是期待它们能自己就重复，使用 fract 函数创建的视图允许做到这一点。fract 函数获取浮点数的小数部分，只要将浮点数乘以 10，做个 fract，就能得到重复 10 次的图像：</p>
<table>
<thead>
<tr>
<th align="center">x（世界坐标系）</th>
<th align="center">x * 10</th>
<th align="center">fract(x * 10)（视图）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0.01</td>
<td align="center">0.1</td>
<td align="center">0.1</td>
</tr>
<tr>
<td align="center">0.11</td>
<td align="center">1.1</td>
<td align="center">0.1</td>
</tr>
<tr>
<td align="center">0.21</td>
<td align="center">2.1</td>
<td align="center">0.1</td>
</tr>
</tbody></table>
<p>这样，只要我们在视图的 0.1 处绘图时，在 0.01，0.11，0.21 这三个坐标都能看到同样的结果，因为它们都对应着视图的 0.1。这样的每个重复的结果称为子空间。</p>
<p>一些例子如下。需要注意，在构造子空间前进行变换时，会对整个子空间进行变换，例子 2，3，4 都应用了这点；构造子空间后进行变换，则是分别对每个子空间进行变换。例子 4 结合了距离场做了一个渐变圆，这效果感觉画画时可以用到。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>uniform vec2 u_resolution;<br>uniform <span class="hljs-type">float</span> u_time;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159265359</span><br><br>vec2 <span class="hljs-title function_">translate</span><span class="hljs-params">(vec2 dir, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st - dir;<br>&#125;<br>vec2 <span class="hljs-title function_">scale</span><span class="hljs-params">(vec2 ratio, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st / ratio;<br>&#125;<br>vec2 <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">float</span> angle, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> mat2(<span class="hljs-built_in">cos</span>(angle),-<span class="hljs-built_in">sin</span>(angle),<br>                <span class="hljs-built_in">sin</span>(angle),<span class="hljs-built_in">cos</span>(angle)) * st;<br>&#125;<br><br><span class="hljs-comment">// 长宽为 1，边平行于坐标轴，中心在原点的正方形，测试用</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">box</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    vec2 bl = smoothstep(<span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>+<span class="hljs-number">.01</span>, st);<br>    vec2 tr = smoothstep(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span><span class="hljs-number">-.01</span>, st);<br>    <span class="hljs-keyword">return</span> bl.x * bl.y * tr.x * tr.y;<br>&#125;<br><br>vec2 <span class="hljs-title function_">tile</span><span class="hljs-params">(<span class="hljs-type">float</span> zoom, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> fract(st * zoom);<br>&#125;<br><br><span class="hljs-comment">// 展示 tile 的用法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">example0</span><span class="hljs-params">(out vec4 glFragColor, vec2 st)</span> &#123;<br>    st = tile(<span class="hljs-number">10.</span>, st);<br>    glFragColor = vec4(vec3(box(st)), <span class="hljs-number">1.</span>);<br>&#125;<br><br><span class="hljs-comment">// 通过矩阵变换操作每个子空间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">example1</span><span class="hljs-params">(out vec4 glFragColor, <span class="hljs-type">float</span> time, vec2 st)</span> &#123;<br>    <span class="hljs-comment">// 取消注释这两行，看世界旋转</span><br>    <span class="hljs-comment">// st = translate(vec2(.5), st);</span><br>    <span class="hljs-comment">// st = rotate(time, st);</span><br><br>    st = tile(<span class="hljs-number">10.</span>, st); <span class="hljs-comment">// 创建子空间</span><br>    <span class="hljs-comment">// 对每个子空间</span><br>    st = translate(vec2(<span class="hljs-number">.5</span>), st);<br>    st = scale(vec2(<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2.</span>) / <span class="hljs-number">2.</span>), st);<br>    st = rotate(time, st);<br>    glFragColor = vec4(vec3(box(st)), <span class="hljs-number">1.</span>);<br>&#125;<br><br><span class="hljs-comment">// 对子网格中的奇偶行进行不同的变换，就像砖墙上的砖块或者地砖</span><br><span class="hljs-comment">// 要知道当前是奇数行还是偶数行，需要处理 fract 之前的 st，首先 mod(2.)，然后再检查其中小于 1.0 的即为奇数行</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">example2</span><span class="hljs-params">(out vec4 glFragColor, <span class="hljs-type">float</span> time, vec2 st)</span> &#123;<br>    st /= vec2(<span class="hljs-number">2.15</span>,<span class="hljs-number">0.65</span>)/<span class="hljs-number">1.5</span>; <span class="hljs-comment">// 调整一下 st 的比例</span><br>    <span class="hljs-type">float</span> TILE_NUM = <span class="hljs-number">5.</span>;<br>    <span class="hljs-type">float</span> isOdd = step(mod(st.y * TILE_NUM, <span class="hljs-number">2.0</span>), <span class="hljs-number">1.</span>); <span class="hljs-comment">// 奇数时为 1，偶数时为 0</span><br>    <span class="hljs-comment">// 需要在 fract 之前进行偏移，注意偏移量大小要和子空间数量相关，因为子空间数量和子空间大小相关</span><br>    st = translate(vec2(isOdd * <span class="hljs-number">.5</span> / TILE_NUM, <span class="hljs-number">.0</span>), st);<br>    <span class="hljs-comment">// 大家都来动一动！</span><br>    <span class="hljs-comment">// st = translate(vec2(((isOdd * 2.) - 1.) * time, .0), st);</span><br><br>    st = tile(TILE_NUM, st);<br>    st = translate(vec2(<span class="hljs-number">.5</span>), st);<br>    st = scale(vec2(<span class="hljs-number">.9</span>), st);<br>    glFragColor = vec4(vec3(box(st)), <span class="hljs-number">1.</span>);<br>&#125;<br><br><span class="hljs-comment">// https://thebookofshaders.com/edit.php#09/marching_dots.frag</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">example3</span><span class="hljs-params">(out vec4 glFragColor, <span class="hljs-type">float</span> time, vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> TILE_NUM = <span class="hljs-number">10.</span>;<br>    <span class="hljs-comment">// 能发现，这张图有两种运动模式，因此需要分类讨论</span><br>    <span class="hljs-type">float</span> mode = step(<span class="hljs-number">1.</span>, mod(time, <span class="hljs-number">2.</span>)); <span class="hljs-comment">// 第一种模式，定义其为 x 轴运动，返回 0，否则返回 1，对应第二种模式</span><br>    <span class="hljs-comment">// 同样需要讨论为奇数还是偶数，这里要同时适应 mode 为 0 和 1 的情况，为 0 时研究 y 轴，为 1 时研究 x 轴</span><br>    <span class="hljs-type">float</span> isOdd = step(mod(st.y * TILE_NUM * (<span class="hljs-number">1.</span> - mode) + st.x * TILE_NUM * mode, <span class="hljs-number">2.0</span>), <span class="hljs-number">1.</span>);<br>    st = translate(vec2(((isOdd * <span class="hljs-number">2.</span>) - <span class="hljs-number">1.</span>) * time) * vec2(<span class="hljs-number">1.</span> - mode, mode) / TILE_NUM, st);<br>    st = tile(TILE_NUM, st);<br>    st = translate(vec2(<span class="hljs-number">.5</span>), st);<br>    st = scale(vec2(<span class="hljs-number">.5</span>), st);<br>    glFragColor = vec4(vec3(box(st)), <span class="hljs-number">1.</span>);<br>&#125;<br><br><span class="hljs-comment">// 一个渐变圆，通过黑白比例而非灰度去控制亮度</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">example4</span><span class="hljs-params">(out vec4 glFragColor, <span class="hljs-type">float</span> time, vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> TILE_NUM = <span class="hljs-number">23.</span>;<br>    <span class="hljs-comment">// 视图移动到中心</span><br>    st = translate(vec2(<span class="hljs-number">0.5</span>), st);<br>    st = rotate(time, st);<br>    <span class="hljs-comment">// 视图再移动到第一个子空间的中心（不如此的话旋转会导致沿第一个子空间的左下角位置旋转，而不是沿第一个子空间中心旋转）</span><br>    <span class="hljs-comment">// 因为子空间绘图的时候并非以子空间中心为中心</span><br>    st = translate(vec2(- <span class="hljs-number">1.</span> / TILE_NUM / <span class="hljs-number">2.</span>), st);<br>    <span class="hljs-comment">// 计算当前的子空间到中心的距离，要求子空间中每一个点得到的距离都是相同的</span><br>    <span class="hljs-type">float</span> tileDistance = length(<span class="hljs-built_in">floor</span>(st * TILE_NUM))/ TILE_NUM;<br><br>    st = tile(TILE_NUM, st);<br><br>    <span class="hljs-comment">// 对每个子空间</span><br>    st = translate(vec2(<span class="hljs-number">.5</span>), st);<br>    st = scale(vec2(clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>,<span class="hljs-number">1.</span> - tileDistance * <span class="hljs-number">2.</span>)), st);<br>    glFragColor = vec4(vec3(<span class="hljs-number">1.</span> - box(st)), <span class="hljs-number">1.</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    vec2 st = gl_FragCoord.xy/u_resolution;<br>    example0(gl_FragColor, st);<br>    example1(gl_FragColor, u_time, st);<br>    example2(gl_FragColor, u_time, st);<br>    example3(gl_FragColor, u_time, st);<br>    example4(gl_FragColor, u_time, st);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>下图为例子3和例子4。</p>
<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/patternExp3.gif" alt="例子 3"></p>
<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/patternExp4.gif" alt="例子 4"></p>
<h1 id="圆形渐变半调子"><a href="#圆形渐变半调子" class="headerlink" title="圆形渐变半调子"></a>圆形渐变半调子</h1><p>“临摹”上面的第一张 SeExpr 作为结束。首先需要研究它们的效果。</p>
<p>第一张是圆形组成的半调子，能发现，每个圆形没有灰度变化，纯粹是根据每个小块黑白的比例来表示亮度的。</p>
<p>假设亮度从白到黑，圆形的大小从小到大的方向是 x 轴，垂直于此的方向为 y 轴，能发现 y 轴方向每一个圆形的间距都是一样的，显然，这里使用了 pattern 和距离场，x 轴方向越大就越暗。</p>
<p>但也能注意到，同一行中，随着 x 轴坐标变大，亮度并非是单调递增的，有时候会开一下倒车，这证明其中有一些随机性，但总体还是递增的。显然，对每一列，需要一个不同的亮度函数——想象柯里化，我们对每一列都构造一个这样的亮度函数。</p>
<p>但先忘记随机性，只考虑单调递增的情况。绘制这样的“单位”渐变的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 在 x=0 到 x=1 内，从 y=0 到 y=1 绘制该渐变</span><br><span class="hljs-comment">// density：0-1 内列的数量</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">magic</span><span class="hljs-params">(<span class="hljs-type">float</span> colNum, vec2 st)</span> &#123;<br>    <span class="hljs-comment">// 对每个子空间，获取该子空间的世界坐标，后面用来计算距离场</span><br>    vec2 dist = <span class="hljs-built_in">floor</span>(st * (colNum)) / colNum;<br>    <span class="hljs-comment">//创建子空间</span><br>    st = fract(st * colNum);<br>    <span class="hljs-comment">// 对每个子空间，获取它的亮度，并重映射到 (0, sqrt(2) / 2)（亮度为 1 时，对应圆的半径为 sqrt(2) / 2）</span><br>    <span class="hljs-comment">// 得到应当绘制的圆的半径</span><br>    <span class="hljs-type">float</span> r = lumaFn(dist) * <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2.</span>) / <span class="hljs-number">2.</span>;<br>    <span class="hljs-comment">// 在 (0.5, 0.5) 处绘制圆</span><br><br>    <span class="hljs-keyword">return</span> step(r, distance(st, vec2(<span class="hljs-number">0.5</span>)));<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>示例如下，有点丑，或许得调整这个亮度函数，但就这样了：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GL_ES</span><br>precision mediump <span class="hljs-type">float</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>uniform vec2 u_resolution;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159265359</span><br><br>vec2 <span class="hljs-title function_">translate</span><span class="hljs-params">(vec2 dir, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st - dir;<br>&#125;<br>vec2 <span class="hljs-title function_">scale</span><span class="hljs-params">(vec2 ratio, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> st / ratio;<br>&#125;<br>vec2 <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">float</span> angle, vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> mat2(<span class="hljs-built_in">cos</span>(angle),-<span class="hljs-built_in">sin</span>(angle),<br>                <span class="hljs-built_in">sin</span>(angle),<span class="hljs-built_in">cos</span>(angle)) * st;<br>&#125;<br><br><span class="hljs-comment">// 2D Random</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">random</span> <span class="hljs-params">(in vec2 st)</span> &#123;<br>    <span class="hljs-keyword">return</span> fract(<span class="hljs-built_in">sin</span>(dot(st.xy,<br>                         vec2(<span class="hljs-number">12.9898</span>,<span class="hljs-number">78.233</span>)))<br>                 * <span class="hljs-number">43758.5453123</span>);<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">noise</span> <span class="hljs-params">(in vec2 st)</span> &#123;<br>    vec2 i = <span class="hljs-built_in">floor</span>(st);<br>    vec2 f = fract(st);<br>    <span class="hljs-type">float</span> a = random(i);<br>    <span class="hljs-type">float</span> b = random(i + vec2(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>));<br>    <span class="hljs-type">float</span> c = random(i + vec2(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>));<br>    <span class="hljs-type">float</span> d = random(i + vec2(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>));<br>    vec2 u = f*f*(<span class="hljs-number">3.0</span><span class="hljs-number">-2.0</span>*f);<br>    <span class="hljs-keyword">return</span> mix(a, b, u.x) +<br>            (c - a)* u.y * (<span class="hljs-number">1.0</span> - u.x) +<br>            (d - b) * u.x * u.y;<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">lumaFn</span><span class="hljs-params">(vec2 st)</span> &#123;<br>    <span class="hljs-type">float</span> noise = clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, noise(st * <span class="hljs-number">2000.</span>));<br>    <span class="hljs-keyword">return</span> clamp(<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, st.y + (noise - <span class="hljs-number">0.4</span>) * st.y);<br>&#125;<br><span class="hljs-type">float</span> <span class="hljs-title function_">magic</span><span class="hljs-params">(<span class="hljs-type">float</span> colNum, vec2 st)</span> &#123;<br>    vec2 dist = <span class="hljs-built_in">floor</span>(st * (colNum )) / colNum;<br>    st = fract(st * colNum);<br>    <span class="hljs-type">float</span> r = lumaFn(dist) * <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2.</span>) / <span class="hljs-number">2.</span>;<br>    <span class="hljs-keyword">return</span> step(r, distance(st, vec2(<span class="hljs-number">0.5</span>)));<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    vec2 st = gl_FragCoord.xy/u_resolution.xy;<br>    <span class="hljs-type">float</span> COLNUM = <span class="hljs-number">40.</span>;<br>    st = rotate(PI / <span class="hljs-number">5.</span>, st);<br>    st = translate(vec2(<span class="hljs-number">0.</span>, <span class="hljs-number">-.5</span>), st);<br>    <span class="hljs-comment">// 对每一列，偏移 x 位置</span><br>    <span class="hljs-type">float</span> colX = <span class="hljs-built_in">floor</span>(st.x * COLNUM) / COLNUM;<br><br>    st = translate(vec2(<span class="hljs-number">0</span>, colX / <span class="hljs-number">5.</span>), st);<br>	st = st * <span class="hljs-number">2.</span>;<br>    <span class="hljs-type">float</span> n = magic(COLNUM, st);<br><br>    gl_FragColor = vec4(vec3(n), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="/2023/08-31GLSL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/dirtyWork.png" alt="和我的画一样糙"></p>
<p>当前学的东西其实非常有限，都是最基础的东西，但我意识到<strong>我不应该当前就去追求这种很“风格化”的东西，先把基础学好吧</strong>！之后或许会学一些 blender 和程序化建模来方便学习和实验，GLSL 和 SeExpr 就先这样了，已经收获足够多，必可活用于下一次。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CG/">CG</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-NC-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/09-17Perl%E5%85%A5%E9%97%A8.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Perl 入门</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06-09%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94MLP.html">
                        <span class="hidden-mobile">机器学习笔记——MLP</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start -->
<script src="/assets/prism-bundle.js"></script>
<script src="/assets/prism-plus.js" data-pjax=""></script>
<!-- hexo injector body_end end --></body>
</html>
