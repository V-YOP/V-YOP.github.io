

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="友纪V-λOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="最近感觉缺乏热情，找点新东西玩玩。编译原理是个好选择，之前半途而废了，这次能继续下去吗？">
<meta property="og:type" content="article">
<meta property="og:title" content="《Crafting Interpreters》学习笔记 1——词法分析，递归下降法">
<meta property="og:url" content="http://example.com/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/index.html">
<meta property="og:site_name" content="友纪V-λOP">
<meta property="og:description" content="最近感觉缺乏热情，找点新东西玩玩。编译原理是个好选择，之前半途而废了，这次能继续下去吗？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/lexigator.png">
<meta property="og:image" content="http://example.com/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/breakfast.png">
<meta property="og:image" content="http://example.com/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/image.png">
<meta property="og:image" content="http://example.com/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/image-1.png">
<meta property="og:image" content="http://example.com/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/sequence.png">
<meta property="article:published_time" content="2023-12-18T12:49:00.000Z">
<meta property="article:modified_time" content="2025-02-14T08:21:51.637Z">
<meta property="article:author" content="友纪V-λOP">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/12-18%E3%80%8ACrafting%20Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95/lexigator.png">
  
  
  <title>《Crafting Interpreters》学习笔记 1——词法分析，递归下降法 - 友纪V-λOP</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="友纪V-λOP" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友纪V-λOP的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="《Crafting Interpreters》学习笔记 1——词法分析，递归下降法">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-12-18 20:49" pubdate>
        2023年12月18日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">《Crafting Interpreters》学习笔记 1——词法分析，递归下降法</h1>
            
            <div class="markdown-body">
              <p>最近感觉缺乏热情，找点新东西玩玩。编译原理是个好选择，之前半途而废了，这次能继续下去吗？</p>
<p>跟随 <a target="_blank" rel="noopener" href="http://www.craftinginterpreters.com/contents.html">Crafting Interpreters</a> 这本书去学习，首先是用 java 实现一个 tree-walk interpreter，即生成 AST 之后直接进行解释执行。</p>
<hr>
<p>编译/解释有诸多步骤，每一步都是为了让下一步实现起来更方便。第一步是 scanning，即词法分析，把源代码的字符串读入为 token，比如有一行代码 <code>var language = &quot;lox&quot;;</code>，词法分析的结果是<code>[var, language, =, &quot;lox&quot;, ;]</code>。一般来说空白字符会被忽略，但某些语言中缩进很重要，比如 Haskell 和 python，这些语言中的空格显然也会被当作 token。</p>
<p>token 是后续分析的“原子”，词法分析就是把源代码中的字符去进行分组得到 token 序列。要分组，就得有个分组的规则，称为词法 lexical grammar，这个规则需要预先定义，定义该规则，就是定义何为“词汇”，这里它叫词素 Lexeme，最小的意义单位。</p>
<p>词素仍然是普通的字符串，不带有语义，但可以根据词素和相关信息去获得对应的 token（这话怎么理解？一个词素可能是关键字，也可能是标识符，得看它出现的位置？像 SQL 这样的语言确实有类似的例子……但这事要在词法分析阶段处理吗？）。但为了方便，我们识别词素时就要知道它的类型——操作符，字面量，关键字，字面量。</p>
<p>词素更多是概念性的，在代码里没有直接表示它的结构。</p>
<h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><p>识别词素是 scanner 的工作，scanner 要知道哪个字符属于哪个词素。从源代码中第一个字符开始，scanner 检查每个字符，并识别和消费它以及和它处在同一个词素中的字符，到达词素结尾时，便丢出相应的 token。scanner 循环执行该过程，直到到达字符串结尾，生成一个 token 序列。</p>
<p><img src="./lexigator.png" alt="Alt text"></p>
<p>scanner 有两个必须的状态——start，标识正在扫描的词素的开始位置，current 表示正在处理的字符的位置，这里需要维护 start，是因为我们需要知道从 start 到 current 之间的子字符串的信息。如果有必要，current 可能会再倒回 start，重新开始处理。处理完一个词素后，start 再指向 current，即去处理下一个词素。</p>
<p>为了在出错时方便地指定行数，也可以增加一个 line 状态，去指示当前 current 的所在行。</p>
<p>下面的代码展示了 scanner 运行的基本流程：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Token&gt; <span class="hljs-title function_">readTokens</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 只要还没读到源代码结尾，反复读</span><br>    <span class="hljs-keyword">while</span> (!isAtEnd()) &#123;<br>        start = current; <span class="hljs-comment">// 重设 start 到下一个词素开头</span><br>        scanToken(); <span class="hljs-comment">// 维护 current，读一个 token</span><br>    &#125;<br>    addToken(EOF); <span class="hljs-comment">// 全部读完了就添加一个特殊的 token 标识结束，这样写 parser 更干净些</span><br>    <span class="hljs-keyword">return</span> tokens;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">scanToken</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// ... 不断维护 current，读一个 token，出错了就直接抛异常</span><br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> advance(); <span class="hljs-comment">// 获得下一个字符，并维护 current</span><br>    <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-comment">// ... 根据 c 的值，执行相应逻辑（但不递归）</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>获取 token 时，有三个方法用来帮助读取字符：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 无条件读取当前字符，并将 current 指向下一个字符</span><br><span class="hljs-type">char</span> <span class="hljs-title function_">advance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> source.charAt(current++);<br>&#125;<br><br><span class="hljs-comment">// match 就像一个带条件的 advance 方法，检查当前字符满足了条件才去进行消费</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(<span class="hljs-type">char</span> expected)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isAtEnd()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (source.charAt(current) != expected) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 匹配的逻辑，需要维护 current，并返回 true</span><br>    current++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 返回 current 指向字符，不维护 current</span><br><span class="hljs-type">char</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (isAtEnd()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> source.charAt(current);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>如果所有词素只有单个字符，如<code>()[]+-*/;</code>这些，读 token 时直接读到这单个字符便可直接构造 token——</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scanToken</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> advance(); <span class="hljs-comment">// 获得下一个字符，并维护 current</span><br>    <span class="hljs-comment">// 在此时，c 是 current 的前一个位置的字符，同时也是 start 处的位置（只要后面 scanToken 没有递归调用，应该没有……）</span><br>    <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: addToken(LEFT_PAREN); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: addToken(RIGHT_PAREN); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>: addToken(LEFT_BRACE); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>: addToken(RIGHT_BRACE); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;,&#x27;</span>: addToken(COMMA); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;.&#x27;</span>: addToken(DOT); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: addToken(MINUS); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: addToken(PLUS); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;;&#x27;</span>: addToken(SEMICOLON); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: addToken(STAR); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>: <br>            Lox.error(line, <span class="hljs-string">&quot;Unexpected character.&quot;</span>); <span class="hljs-comment">// 这里只是打了个日志，然后忽略掉该字符继续去处理</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这里没有包括<code>!&lt;&gt;=</code>，因为这些字符既可能是单字符的词素如<code>!</code>，也可能是双字符的词素如<code>!=</code>，但这个也好办，往后再看一位就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scanToken</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> advance(); <span class="hljs-comment">// 获得 current 处的字符，并 current++</span><br>    <span class="hljs-comment">// 这时候 current 已经指向下一个需要处理的字符了</span><br>    <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-comment">// ... 单字符的 case</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;!&#x27;</span>:<br>            addToken(match(<span class="hljs-string">&#x27;=&#x27;</span>)? BANG_EQUAL : BANG);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;=&#x27;</span>:<br>            addToken(match(<span class="hljs-string">&#x27;=&#x27;</span>) ? EQUAL_EQUAL : EQUAL);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// ...&lt;=, &gt;=</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>除法<code>/</code>需要特别考虑，<code>//</code>是单行注释的语法，其后的东西将被忽略，直到遇到换行符。</p>
<p>所以遇到<code>/</code>时，要检查下一个字符是否也是<code>/</code>，如果真的是，反复移动 current，直到遇到换行符，保证 current 最终指向换行符。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>    <span class="hljs-keyword">if</span> (!match(<span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>        addToken(SLASH);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (peek() != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; !isAtEnd()) &#123;<br>        advance();<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></div></td></tr></table></figure>
<p>像 peek 这样检查当前字符但不把指针往后拨的操作称为“lookahead”，前向搜索。这里只是查询当前字符，称作前向搜索 1 个字符。语言的词法决定我们需要使用多少个字符的前向查找，字符数量越多性能越差，但很多语言的实现中只需要一两个字符的前向查找。</p>
<p>其实 match 也是前向搜索，它 peek 一下当前字符是否和需求匹配，匹配成功了才消费当前字符。</p>
<p>然后，是需要忽略的各种字符——</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:<br>    line++;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27; &#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\r&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\t&#x27;</span>: <br>    <span class="hljs-keyword">break</span>;<br></code></pre></div></td></tr></table></figure>
<h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><p>下一个对手是字符串字面量，即形如<code>&quot;Hello&quot;</code>的玩意。先不考虑字符串中出现双引号的情况。字符串相对好搞定，因为它的第一个字符永远是双引号。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&quot;&#x27;</span>: string(); <span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">string</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 该函数调用时，current 正指向字符串开始的&quot;的下一个字符，start 还在开始的&quot;上</span><br>    <span class="hljs-comment">// 找到另一个 &quot;</span><br>    <span class="hljs-keyword">while</span> (peek() != <span class="hljs-string">&#x27;&quot;&#x27;</span> &amp;&amp; !isAtEnd()) &#123;<br>        <span class="hljs-keyword">if</span> (peek() == <span class="hljs-string">&#x27;\n&#x27;</span>) line++; <span class="hljs-comment">// oh...</span><br>        advance();<br>    &#125;<br>    <span class="hljs-comment">// 到最后也没找着另一个&quot;</span><br>    <span class="hljs-keyword">if</span> (isAtEnd()) &#123;<br>        Lox.error(line, <span class="hljs-string">&quot;Unterminated string.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 此时，current 会指向字符串结尾的&quot;</span><br>    <span class="hljs-comment">// 要获得该字符串的实际代表的值，只需要获取&quot;&quot;之间的东西。</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">literal</span> <span class="hljs-operator">=</span> source.substring(start + <span class="hljs-number">1</span>, current);<span class="hljs-comment">// 前开后闭</span><br>    advance(); <span class="hljs-comment">// skip right &quot;，将 current 指向右双引号的下一个字符，这是因为 addToken 方法需要 start 和 current 的位置正确</span><br>    addToken(STRING, literal);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>字符串支持多行比只支持单行实现起来更方便，但这中间必须得插入维护 line 的逻辑……其实这个可以加到 advance 方法里。</p>
<h2 id="数字字面量"><a href="#数字字面量" class="headerlink" title="数字字面量"></a>数字字面量</h2><p>lox 中只有 double 来表示数字，和 js 一样，为了实现方便，不允许前导和后导小数点（方便实现<code>123.sqrt()</code>这样的调用）。</p>
<p>数字字面量的“trigger”也是容易找的——0-9，找后面连续的数字，若遇到小数点，需要检查小数点后一位是否也是数字。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">if</span> (isDigit(c)) &#123;<br>        number();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 原报错逻辑。..   </span><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">number</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 跳过中途所有数字</span><br>    <span class="hljs-keyword">while</span> (Character.isDigit(peek())) &#123;<br>        advance();<br>    &#125;<br><br>    <span class="hljs-comment">/// 如果遇到小数点，检查下一位是否还是数字，若是，继续</span><br>    <span class="hljs-keyword">if</span> (peek() == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; Character.isDigit(peekNext())) &#123;<br>        advance(); <span class="hljs-comment">// skip .</span><br>        <span class="hljs-keyword">while</span> (Character.isDigit(peek())) &#123;<br>            advance();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 此时 current 指向最后一个数字的下一个字符</span><br>    addToken(NUMBER, Double.parseDouble(source.substring(start, current)));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p>最后了，关键字以及标识符。匹配这玩意要满足最长匹配原则——如果当前看的玩意的部分同时满足两条词法，找最长的，比如有个<code>forever</code>，不能光看到这个<code>for</code>就认为它是关键字了，<code>forever</code>整个是合法的标识符，它比关键字更长。</p>
<p>实际上，关键字本身就是标识符，只是这些标识符被语言预先使用罢了，这也是为什么它们也叫保留字。检查标识符时，需检查它是否是保留字，这需要一个符号表去做映射。</p>
<p>读取标识符的逻辑也放在 default 里：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">if</span> (isDigit(c)) &#123;<br>        number();<br>        <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isAlpha(c)) &#123;<br>        identifier();<br>        <span class="hljs-keyword">break</span>;<br>    &#125; <br>    <span class="hljs-comment">// 原报错逻辑。..   </span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlpha</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-keyword">return</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) ||<br>            (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) ||<br>            c == <span class="hljs-string">&#x27;_&#x27;</span>;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlphaNumeric</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-keyword">return</span> isAlpha(c) || isDigit(c);<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">identifier</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 后面还是和 number 一样，读取直到非合法标识符字符</span><br>    <span class="hljs-keyword">while</span> (isAlphaNumeric(peek())) &#123;<br>        advance();<br>    &#125;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> source.substring(start, current);<br>    <span class="hljs-comment">// 再次注意，addToken 会获取 start 到 current 的字符串，不需要再自己传啥东西</span><br>    addToken(keywords.getOrDefault(value, IDENTIFIER));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">fun <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-comment">// this is a comment</span><br>    <span class="hljs-comment">/* multiple lines</span><br><span class="hljs-comment">       comment</span><br><span class="hljs-comment">    */</span><br>    fun <span class="hljs-title function_">go</span>(<span class="hljs-params">n, a, b</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">go</span>(n - <span class="hljs-number">1</span>, b, a + b)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">go</span>(n, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>得到：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">1:</span> [ <span class="hljs-attr">FUN :</span> <span class="hljs-string">fun</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">fib</span> ] [ <span class="hljs-attr">LEFT_PAREN :</span> <span class="hljs-string">(</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">n</span> ] [ <span class="hljs-attr">RIGHT_PAREN :</span> <span class="hljs-string">)</span> ] [ <span class="hljs-attr">LEFT_BRACE :</span> &#123; ]<br><span class="hljs-attr">6:</span> [ <span class="hljs-attr">FUN :</span> <span class="hljs-string">fun</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">go</span> ] [ <span class="hljs-attr">LEFT_PAREN :</span> <span class="hljs-string">(</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">n</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">a</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">b</span> ] [ <span class="hljs-attr">RIGHT_PAREN :</span> <span class="hljs-string">)</span> ] [ <span class="hljs-attr">LEFT_BRACE :</span> &#123; ]<br><span class="hljs-attr">7:</span> [ <span class="hljs-attr">IF :</span> <span class="hljs-string">if</span> ] [ <span class="hljs-attr">LEFT_PAREN :</span> <span class="hljs-string">(</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">n</span> ] [ <span class="hljs-attr">EQUAL_EQUAL :</span> <span class="hljs-string">==</span> ] [ <span class="hljs-attr">NUMBER :</span> <span class="hljs-number">0</span> ] [ <span class="hljs-attr">RIGHT_PAREN :</span> <span class="hljs-string">)</span> ] [ <span class="hljs-attr">LEFT_BRACE :</span> &#123; ]<br><span class="hljs-attr">8:</span> [ <span class="hljs-attr">RETURN :</span> <span class="hljs-string">return</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">a</span> ] [ <span class="hljs-attr">SEMICOLON :</span> <span class="hljs-string">;</span> ]<br><span class="hljs-attr">9:</span> [ <span class="hljs-attr">RIGHT_BRACE :</span> &#125; ]<br><span class="hljs-attr">10:</span> [ <span class="hljs-attr">RETURN :</span> <span class="hljs-string">return</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">go</span> ] [ <span class="hljs-attr">LEFT_PAREN :</span> <span class="hljs-string">(</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">n</span> ] [ <span class="hljs-attr">MINUS :</span> <span class="hljs-bullet">-</span> ] [ <span class="hljs-attr">NUMBER :</span> <span class="hljs-number">1</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">b</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">a</span> ] [ <span class="hljs-attr">PLUS :</span> <span class="hljs-string">+</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">b</span> ] [ <span class="hljs-attr">RIGHT_PAREN :</span> <span class="hljs-string">)</span> ]<br><span class="hljs-attr">11:</span> [ <span class="hljs-attr">RIGHT_BRACE :</span> &#125; ]<br><span class="hljs-attr">12:</span> [ <span class="hljs-attr">RETURN :</span> <span class="hljs-string">return</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">go</span> ] [ <span class="hljs-attr">LEFT_PAREN :</span> <span class="hljs-string">(</span> ] [ <span class="hljs-attr">IDENTIFIER :</span> <span class="hljs-string">n</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">NUMBER :</span> <span class="hljs-number">0</span> ] [ <span class="hljs-attr">COMMA :</span> , ] [ <span class="hljs-attr">NUMBER :</span> <span class="hljs-number">1</span> ] [ <span class="hljs-attr">RIGHT_PAREN :</span> <span class="hljs-string">)</span> ]<br><span class="hljs-attr">13:</span> [ <span class="hljs-attr">RIGHT_BRACE :</span> &#125; ]<br><span class="hljs-attr">14:</span> [ <span class="hljs-attr">EOF :</span>  ]<br></code></pre></div></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些玩意实际上也可以用正则表达式处理，但为了学习起见，这里手写。使用正则表达式的话，维护 line 就有点不明显，估计需要每次匹配成功后都检查上次和这次匹配之间的子字符串中有多少个换行符。</p>
<p>这种功能和正则表达式相同的玩意称为正则语言 regular language，它有一定限制——不能记忆之前的匹配情况，因此不能处理嵌套。</p>
<h1 id="代码表示"><a href="#代码表示" class="headerlink" title="代码表示"></a>代码表示</h1><p>这节真 tm 抽象。记录一下 <a target="_blank" rel="noopener" href="http://www.craftinginterpreters.com/representing-code.html#context-free-grammars">原文地址</a>。</p>
<h2 id="语法分析，BNF"><a href="#语法分析，BNF" class="headerlink" title="语法分析，BNF"></a>语法分析，BNF</h2><p>Token 相较于原始字符串乃至于词素已经是一个更丰富和抽象的概念了，但这还不够，需要根据 token 序列去得到一种更丰富和抽象的代码表示，parser 需要能够简单地生成它，interpreter 需要能够简单地使用它。这里的代码表示是树，就像 lisp 那样的玩意（但也有其他的代码表示，比如字节码）。</p>
<p>处理 token 序列时，再不能像词法分析一样使用类似正则语言的玩意来进行处理——需要考虑任意深度嵌套的情况，这是编程语言必须的。要能够做到这一点，需要一把新锤子——<strong>上下文无关文法 context-free grammar（CFG）</strong>，它是一种<strong>形式文法 formal grammar</strong>。 这里的上下文指的是分析特定符号/规则时它的上下文，上下文无关也就是说文法的规则只取决于规则本身，和周围环境无关，听上去就很纯。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21833944/answer/40689967">应该如何理解「上下文无关文法」？ - 徐辰的回答 - 知乎</a></p>
<p>词法分析是词法 lexical grammar，这里是语法 syntactic grammar。词法处理的原子是字符，字符组合产生词素和 token，词法由 Scanner 实现；语法处理的原子是 Token，Token 组合产生表达式（并非语言上的表达式），语法由 Parser 实现。</p>
<p>语法由规则组成，规则也叫<strong>产生式</strong>——规则可以产生语法中合法的字串。一个规则分为两部分——head 和 body，分别表示规则的名称，以及该规则会产生什么（token 串的形式）。body 由终结符和非终结符组成，前者就像语法中的“字面量”，后者为其他规则——这让规则之间可以组合，直接进行代换即可。<strong>在上下文无关文法中，head 部分总是只有一个符号——该规则和周围的环境不相关</strong>。</p>
<p>多个规则可以引用同一个名称，表示该规则可以产生多种 token 串。规则的 body 中可以引用自己。</p>
<p>一种描述这些产生式的语言是 BNF，BNF 也有自己的语法，类似正则，但原子是整个符号而非字符。</p>
<figure class="highlight bnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs BNF">breakfast  → protein &quot;with&quot; breakfast &quot;on the side&quot; ;<br>breakfast  → protein ;<br>breakfast  → bread ;<br><br>protein    → crispiness &quot;crispy&quot; &quot;bacon&quot; ;<br>protein    → &quot;sausage&quot; ;<br>protein    → cooked &quot;eggs&quot; ;<br><br>crispiness → &quot;really&quot; ;<br>crispiness → &quot;really&quot; crispiness ;<br><br>cooked     → &quot;scrambled&quot; ;<br>cooked     → &quot;poached&quot; ;<br>cooked     → &quot;fried&quot; ;<br><br>bread      → &quot;toast&quot; ;<br>bread      → &quot;biscuits&quot; ;<br>bread      → &quot;English muffin&quot; ;<br></code></pre></div></td></tr></table></figure>
<p>根据这些规则，我们能生成任意满足这些语法的符号串，注意下面的树形结构。</p>
<p><img src="./breakfast.png" alt="Alt text"></p>
<p>然后是 EBNF，支持括号，<code>|</code>，<code>*</code>，<code>+</code>，<code>?</code>，它们的语义和正则的相同：</p>
<figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">breakfast → protein ( <span class="hljs-string">&quot;with&quot;</span> breakfast <span class="hljs-string">&quot;on the side&quot;</span> )?<br>          <span class="hljs-string">| bread ;</span><br><br>protein   → <span class="hljs-string">&quot;really&quot;</span>+ <span class="hljs-string">&quot;crispy&quot;</span> <span class="hljs-string">&quot;bacon&quot;</span><br>          <span class="hljs-string">| &quot;</span>sausage<span class="hljs-string">&quot;</span><br>          <span class="hljs-string">| ( &quot;</span>scrambled<span class="hljs-string">&quot; | &quot;</span>poached<span class="hljs-string">&quot; | &quot;</span>fried<span class="hljs-string">&quot; ) &quot;</span>eggs<span class="hljs-string">&quot; ;</span><br><br>bread     → <span class="hljs-string">&quot;toast&quot;</span> <span class="hljs-string">| &quot;</span>biscuits<span class="hljs-string">&quot; | &quot;</span>English muffin<span class="hljs-string">&quot; ;</span><br></code></pre></div></td></tr></table></figure>
<p>不考虑早餐了（别面包，我是和食主义者。jpg），先考虑一下 lox 的一个更小的子集——纯字面的表达式，它由字面量，操作符和括号组成：</p>
<figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">expression     → literal<br>               <span class="hljs-string">| unary</span><br>               <span class="hljs-string">| binary</span><br>               <span class="hljs-string">| grouping ;</span><br><br>literal        → NUMBER <span class="hljs-string">| STRING | &quot;</span>true<span class="hljs-string">&quot; | &quot;</span>false<span class="hljs-string">&quot; | &quot;</span>nil<span class="hljs-string">&quot; ;</span><br>grouping       → <span class="hljs-string">&quot;(&quot;</span> expression <span class="hljs-string">&quot;)&quot;</span> ;<br>unary          → ( <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">| &quot;</span>!<span class="hljs-string">&quot; ) expression ;</span><br>binary         → expression operator expression ;<br>operator       → <span class="hljs-string">&quot;==&quot;</span> <span class="hljs-string">| &quot;</span>!=<span class="hljs-string">&quot; | &quot;</span>&lt;<span class="hljs-string">&quot; | &quot;</span>&lt;=<span class="hljs-string">&quot; | &quot;</span>&gt;<span class="hljs-string">&quot; | &quot;</span>&gt;=<span class="hljs-string">&quot;</span><br>               <span class="hljs-string">| &quot;</span>+<span class="hljs-string">&quot;  | &quot;</span>-<span class="hljs-string">&quot;  | &quot;</span>*<span class="hljs-string">&quot; | &quot;</span>/<span class="hljs-string">&quot; ;</span><br></code></pre></div></td></tr></table></figure>
<p>其中，NUMBER 和 STRING 被大写，大写表示是终结符而且符合条件的“字面量”太多以至于写不下来。</p>
<h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><p>根据这些产生式，可以编写相应的 java 类型去反映相关结构。这显然是一种树形结构（emm 可以说父子关系为“包括”？），因此叫语法树 Syntax Tree。语法树和抽象语法树 AST 有一定区别——前者包含产生式中任意的 token，即使它们是不必要的，比如 python 的三目 <code>ifexpr → expr &quot;if&quot; expr &quot;else&quot; expr</code>，语法树中就会包含这里的<code>&quot;if&quot;</code>和<code>&quot;else&quot;</code>，抽象语法树中就可以丢掉它。</p>
<p>这里当然可以使用一个普通的多叉树来表示语法树，但这里可以把 java 的类型系统利用一下——定义一个抽象父类 Expr 表示任何表达式，为字面量，操作符等都定义相应子类。</p>
<p>子类需要包含所有它需要包含的东西——对字面量，包含它的实际的值，对二元运算，包含它的操作符和左右的表达式。它或许会长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Literal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Expr</span> &#123;<br>        <span class="hljs-keyword">final</span> Object value;<br>    &#125;<br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Binary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Expr</span> &#123;<br>        <span class="hljs-keyword">final</span> Expr left;<br>        <span class="hljs-keyword">final</span> Token operator;<br>        <span class="hljs-keyword">final</span> Expr right;<br>    &#125;<br>    <span class="hljs-comment">// Other expressions...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>使用父子类来表达的话，就需要就需要在运行时获取特定节点的类型信息（不然怎么知道它有啥字段？），这可以使用 instanceof，但至少在 java8 里这玩意不安全，毕竟没有 sealed。然后不使用 instanceof 的话，给特定子类添加特定方法就需要影响所有子类。这里可以用访问者模式，其实本质就是扩展方法和模式匹配。</p>
<h2 id="生成语法树定义"><a href="#生成语法树定义" class="headerlink" title="生成语法树定义"></a>生成语法树定义</h2><p>这里写个脚本去手动生成相关代码，它接受一个父类名，以及每个子类名和它包含的字段，因为懒得拷贝，所以手写，用 ruby：</p>
<figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-comment"># 在该路径下生成该类 java 文件</span><br><span class="hljs-variable constant_">LOX_SOURCE_PATH</span> = <span class="hljs-string">&#x27;C:\Users\Administrator\Desktop\CODES\lox\src\main\java\me\yki\lox&#x27;</span><br><span class="hljs-variable constant_">PACKAGE</span> = <span class="hljs-string">&#x27;me.yki.lox&#x27;</span><br><span class="hljs-variable constant_">PARENT_CLASS_NAME</span> = <span class="hljs-string">&#x27;Expr&#x27;</span><br><br><span class="hljs-comment"># 编辑这里去添加子类定义</span><br><span class="hljs-variable constant_">SUBCLASS_DEFS</span> = <span class="hljs-string">%/</span><br><span class="hljs-string">  Binary   : Expr left, Token operator, Expr right</span><br><span class="hljs-string">  Grouping : Expr expression</span><br><span class="hljs-string">  Literal  : Object value</span><br><span class="hljs-string">  Unary    : Token operator, Expr right</span><br><span class="hljs-string">/</span>.strip<br> .split(<span class="hljs-string">&quot;\n&quot;</span>)<br> .map &#123;_1.strip &#125;<br> .filter &#123; <span class="hljs-keyword">not</span> _1.empty? &#125;<br> .map &#123; |<span class="hljs-params">class_def</span>|<br>   class_def.split(<span class="hljs-string">&#x27;:&#x27;</span>) =&gt; [class_name, body]<br>   class_name.strip!<br>   fields = body.strip.split(<span class="hljs-string">&#x27;,&#x27;</span>).map&#123;_1.strip.split <span class="hljs-string">&#x27; &#x27;</span>&#125;<br>   [class_name, fields]<br> &#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">indent</span>(<span class="hljs-params">space, str</span>)<br>  str.split(<span class="hljs-string">&quot;\n&quot;</span>).map&#123;<span class="hljs-string">&#x27; &#x27;</span> * space + _1&#125;.join(<span class="hljs-string">&quot;\n&quot;</span>).strip<br><span class="hljs-keyword">end</span><br><br>res =  <span class="hljs-string">&lt;&lt;~EOF</span><br><span class="hljs-string">  package <span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PACKAGE</span>&#125;</span>;</span><br><span class="hljs-string">  import lombok.Data;</span><br><span class="hljs-string">  public abstract class <span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span> &#123;</span><br><span class="hljs-string">      public interface <span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span>Visitor&lt;T&gt; &#123;</span><br><span class="hljs-string">          <span class="hljs-subst">#&#123;<span class="hljs-variable constant_">SUBCLASS_DEFS</span>.map&#123; <span class="hljs-string">&quot;T visit(<span class="hljs-subst">#&#123;_1[<span class="hljs-number">0</span>]&#125;</span> expr);&quot;</span> &#125;</span>.join(&quot;\n&quot;).then&#123;indent 8, _1&#125;&#125;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">      public abstract &lt;T&gt; T accept(<span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span>Visitor&lt;T&gt; visitor);</span><br><span class="hljs-string">      <span class="hljs-subst">#&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-variable constant_">SUBCLASS_DEFS</span>.map <span class="hljs-keyword">do</span> |<span class="hljs-params">field_defs</span>|</span></span><br><span class="hljs-subst"><span class="hljs-string">          subclass, fields = field_defs</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">&lt;&lt;~SUBEOF</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            @Data</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            public static class <span class="hljs-subst">#&#123;subclass&#125;</span> extends <span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span> &#123;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">                <span class="hljs-subst">#&#123;fields.map &#123;<span class="hljs-string">&quot;final <span class="hljs-subst">#&#123;_1[<span class="hljs-number">0</span>]&#125;</span> <span class="hljs-subst">#&#123;_1[<span class="hljs-number">1</span>]&#125;</span>;&quot;</span>&#125;</span>.join(&quot;\n&quot;).then&#123;indent 4, _1&#125;&#125;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">                @Override</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">                public &lt;T&gt; T accept(<span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span>Visitor&lt;T&gt; visitor) &#123;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">                    return visitor.visit(this);</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">                &#125;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            &#125;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">          SUBEOF</span></span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-keyword">end</span>.join(<span class="hljs-string">&quot;\n&quot;</span>).<span class="hljs-keyword">then</span>&#123;indent <span class="hljs-number">4</span>, _1&#125;</span></span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">      </span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">EOF</span><br><span class="hljs-string">Dir.chdir LOX_SOURCE_PATH</span><br><span class="hljs-string">File.write(&quot;<span class="hljs-subst">#&#123;<span class="hljs-variable constant_">PARENT_CLASS_NAME</span>&#125;</span>.java&quot;, res)</span><br></code></pre></div></td></tr></table></figure>
<p>最后，关于第一道题目，得到这样的结果：</p>
<figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">arglist</span> -&gt;</span>  expr <br><span class="hljs-function"><span class="hljs-title">arglist</span> -&gt;</span>  expr <span class="hljs-string">&quot;,&quot;</span> arglist<br><span class="hljs-function"><span class="hljs-title">expr</span> -&gt;</span> expr <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-string">&quot;)&quot;</span><br><span class="hljs-function"><span class="hljs-title">expr</span> -&gt;</span> expr <span class="hljs-string">&quot;(&quot;</span> arglist <span class="hljs-string">&quot;)&quot;</span><br><span class="hljs-function"><span class="hljs-title">expr</span> -&gt;</span> expr <span class="hljs-string">&quot;.&quot;</span> IDENTIFIER <br>expr → IDENTIFIER<br>expr → NUMBER<br></code></pre></div></td></tr></table></figure>
<p>看上去是某种函数调用或者取字段的语法，且支持数字作为对象。</p>
<h1 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h1><p>Parser 的任务即是解析表达式（token 序列）到 AST。上面，我们根据语法和 AST 去生成表达式， 现在要根据语法和表达式去生成 AST。前者是造句，后者是理解句子，后者才是真正的重头戏，事情真正变得不 trival 的地方。<strong>我们需要把所有 toekn 映射到终结符，然后找到是哪些规则生成了这些 token</strong>。</p>
<p>不 trival 的原因在于，答案并不唯一——同一套语法，能通过多种方式（AST）生成同一个 token 序列；同一个 token 序列，能解析成多个 AST。</p>
<p>考虑一套四则运算的 BNF，不考虑括号：</p>
<figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl">E<span class="hljs-function"><span class="hljs-title">xpr</span> -&gt;</span> NUMBER<br>E<span class="hljs-function"><span class="hljs-title">xpr</span> -&gt;</span> NUMBER op Expr<br><span class="hljs-function"><span class="hljs-title">op</span> -&gt;</span> <span class="hljs-string">&quot;+&quot;</span> | <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;/&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>这里第二条更符合直觉的写法是<code>Expr -&gt; Expr op Expr</code>，但这是一种“左递归”，在<strong>生成式规则中要避免左递归</strong>，想象在递归函数的第一行就调用自己。</p>
<p>考虑<code>1 - 2 * 3</code>，生成它有两种方式——先生成<code>*</code>部分，再生成<code>-</code>部分，或者反之；因此解析它也有两种方式——先解析<code>Expr * 3</code>，再解析<code>1 - 2</code>，或者是先解析<code>1 - Expr</code>，再解析<code>2 * 3</code>：</p>
<p><img src="./image.png" alt="Alt text"></p>
<p><img src="./image-1.png" alt="Alt text"></p>
<p>这决定了后续解释该 AST 时的计算顺序——前者会先执行 <code>1 - 2</code>，后者会先执行 <code>2 * 3</code>。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>这里需要定义结合性和优先级（其实就是打括号），结合这俩才能唯一地确定要生成怎样的 AST。</p>
<p>如何在 BNF 中体现结合性和优先级呢？重点是，必须要对 Expr 做出限制，不能让加减乘除直接全落到同一个的 Expr 上去，这丢失了它的优先级的信息。对于高优先级的运算符，必须让它不被低优先级运算符对应的规则去抓到。</p>
<p>对于优先级，简单的解决方案是为每个优先级的运算符创建自己的生成式，<strong>低优先级的运算符总是依赖高优先级的运算符，这保证生成时必须先生成高优先级的 AST，再生成低优先级的 AST，保证低优先级的运算符在 AST 中总是更靠近根部，而高优先级的运算符总是低优先级的运算符的子树</strong>，比如依此下面定义新的四则运算的规则，咱知道，加减的优先级低于乘除，乘除又低于括号。加减的两边称为项 Term，乘除的两边称为因子 Factor，在这里可以理解为“加减法表达式”和“乘除法表达式”：</p>
<figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl">E<span class="hljs-function"><span class="hljs-title">xpr</span> -&gt;</span> Term<br>T<span class="hljs-function"><span class="hljs-title">erm</span> -&gt;</span> Factor (( <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;+&quot;</span> ) Factor)*<br>F<span class="hljs-function"><span class="hljs-title">actor</span> -&gt;</span> Primary (( <span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;/&quot;</span> ) Primary)*<br>P<span class="hljs-function"><span class="hljs-title">rimary</span> -&gt;</span> NUMBER | <span class="hljs-string">&quot;(&quot;</span> Expr <span class="hljs-string">&quot;)&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>回到上面的 Lox 的 BNF：</p>
<figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">expression     → literal<br>               <span class="hljs-string">| unary</span><br>               <span class="hljs-string">| binary</span><br>               <span class="hljs-string">| grouping ;</span><br><br>literal        → NUMBER <span class="hljs-string">| STRING | &quot;</span>true<span class="hljs-string">&quot; | &quot;</span>false<span class="hljs-string">&quot; | &quot;</span>nil<span class="hljs-string">&quot; ;</span><br>grouping       → <span class="hljs-string">&quot;(&quot;</span> expression <span class="hljs-string">&quot;)&quot;</span> ;<br>unary          → ( <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">| &quot;</span>!<span class="hljs-string">&quot; ) expression ;</span><br>binary         → expression operator expression ;<br>operator       → <span class="hljs-string">&quot;==&quot;</span> <span class="hljs-string">| &quot;</span>!=<span class="hljs-string">&quot; | &quot;</span>&lt;<span class="hljs-string">&quot; | &quot;</span>&lt;=<span class="hljs-string">&quot; | &quot;</span>&gt;<span class="hljs-string">&quot; | &quot;</span>&gt;=<span class="hljs-string">&quot;</span><br>               <span class="hljs-string">| &quot;</span>+<span class="hljs-string">&quot;  | &quot;</span>-<span class="hljs-string">&quot;  | &quot;</span>*<span class="hljs-string">&quot; | &quot;</span>/<span class="hljs-string">&quot; ;</span><br></code></pre></div></td></tr></table></figure>
<p>关于优先级和结合性，在 c 和 lox 中有这样的规则，越上面优先级越低：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Name</th>
<th style="text-align:center">Operators</th>
<th style="text-align:center">Associates</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Equality</td>
<td style="text-align:center"><code>==</code> <code>!=</code></td>
<td style="text-align:center">Left</td>
</tr>
<tr>
<td style="text-align:center">Comparison</td>
<td style="text-align:center"><code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></td>
<td style="text-align:center">Left</td>
</tr>
<tr>
<td style="text-align:center">Term</td>
<td style="text-align:center"><code>-</code> <code>+</code></td>
<td style="text-align:center">Left</td>
</tr>
<tr>
<td style="text-align:center">Factor</td>
<td style="text-align:center"><code>/</code> <code>*</code></td>
<td style="text-align:center">Left</td>
</tr>
<tr>
<td style="text-align:center">Unary</td>
<td style="text-align:center"><code>!</code> <code>-</code></td>
<td style="text-align:center">Right</td>
</tr>
</tbody>
</table>
</div>
<p>对其中的每一个优先级，都需要一个对应规则，它被更低优先级的规则去引用，同时引用更高优先级的规则。</p>
<figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">expression</span> -&gt;</span> equality<br><span class="hljs-function"><span class="hljs-title">equality</span>   -&gt;</span> comparison ((<span class="hljs-string">&quot;==&quot;</span> | <span class="hljs-string">&quot;!=&quot;</span>) comparsion)*<br><span class="hljs-function"><span class="hljs-title">comparsion</span> -&gt;</span> term ((<span class="hljs-string">&quot;&gt;&quot;</span> | <span class="hljs-string">&quot;&gt;=&quot;</span> | <span class="hljs-string">&quot;&lt;&quot;</span> | <span class="hljs-string">&quot;&lt;=&quot;</span>) term)*<br><span class="hljs-function"><span class="hljs-title">term</span>       -&gt;</span> factor ((<span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;+&quot;</span>) factor)*<br><span class="hljs-function"><span class="hljs-title">factor</span>     -&gt;</span> unary ((<span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;/&quot;</span>) unary)*<br><span class="hljs-function"><span class="hljs-title">unary</span>      -&gt;</span> (<span class="hljs-string">&quot;!&quot;</span> | <span class="hljs-string">&quot;-&quot;</span>) unary | primary<br><span class="hljs-function"><span class="hljs-title">primary</span>    -&gt;</span> NUMBER | STRING | <span class="hljs-string">&quot;true&quot;</span> | <span class="hljs-string">&quot;false&quot;</span> | <span class="hljs-string">&quot;nil&quot;</span> <br>            | <span class="hljs-string">&quot;(&quot;</span> expression <span class="hljs-string">&quot;)&quot;</span> <br></code></pre></div></td></tr></table></figure>
<p>遗憾的是，单凭 BNF 似乎不允许控制结合性（不允许左递归的话）。这得留到 Parser 中去处理了。</p>
<h2 id="递归下降法"><a href="#递归下降法" class="headerlink" title="递归下降法"></a>递归下降法</h2><p>该开始整 parser 了。使用实现起来最简单但仍然强大的方式——递归下降法。递归下降法是一种<strong>自顶向下</strong>的解析器——它从最顶部的规则开始，在这里是 expression，然后再处理它的嵌套的子表达式，直到到达 AST 的叶子。与此相反的还有<strong>自底向上</strong>的解析器，从 primary 的表达式开始，组合成更复杂的形式。</p>
<p>递归下降法很容易根据语法规则直接映射到对应的命令式的代码：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Grammar notation</th>
<th style="text-align:left">Code representation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">rule</td>
<td style="text-align:left">函数，处理当前和接下来的几个 token，返回 AST（节点）</td>
</tr>
<tr>
<td style="text-align:center">Terminal</td>
<td style="text-align:left">匹配和消费 token 的代码</td>
</tr>
<tr>
<td style="text-align:center">Nonterminal</td>
<td style="text-align:left">调用相应 rule</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:left"></td>
<td>多路条件语句</td>
</tr>
<tr>
<td style="text-align:center">* or +</td>
<td style="text-align:left">循环语句</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">无 else，提前返回的条件语句</td>
</tr>
</tbody>
</table>
</div>
<p>递归下降——这些规则对应的函数会反复递归调用自身和其他规则函数。</p>
<h2 id="Parser-的实现"><a href="#Parser-的实现" class="headerlink" title="Parser 的实现"></a>Parser 的实现</h2><p>如何理解递归下降法的解析过程——贪婪。</p>
<p>Scanner 需要维护两个状态——start 和 current，表示当前处理的词素和字符的下标。而 Parser，好家伙，只需要一个，current，表示下一个需要处理的 Token。</p>
<p>同样的，Parser 需要一些获取当前/前后 token 同时维护 current 的方法，其中 peek 和 match 均前向搜索 1 步：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> tokens.get(current);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAtEnd</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> peek().type == EOF;<br>&#125;<br><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">previous</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> tokens.get(current - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">advance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isAtEnd()) current++;<br>    <span class="hljs-keyword">return</span> tokens.get(current);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TokenType type)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isAtEnd()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> peek().type == type;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(TokenType... types)</span> &#123;<br>    <span class="hljs-keyword">for</span> (TokenType type : types) &#123;<br>        <span class="hljs-keyword">if</span> (check(type)) &#123;<br>            advance();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这些方法已经足够了，先整出 equality：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">expr</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> equality();<br>&#125;<br><br><span class="hljs-comment">//equlity -&gt; comparsion ((&quot;!=&quot; | &quot;==&quot;) comparsion)*</span><br><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">equality</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Expr</span> <span class="hljs-variable">expr</span> <span class="hljs-operator">=</span> comparison();<br>    <span class="hljs-comment">// 如果看到了！=和==，就继续给它延伸下去</span><br>    <span class="hljs-keyword">while</span> (match(BANG_EQUAL, EQUAL_EQUAL)) &#123;<br>        <span class="hljs-type">Token</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> previous(); <span class="hljs-comment">// 获取在 while 里匹配的玩意</span><br>        <span class="hljs-type">Expr</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> comparison();<br>        <span class="hljs-comment">// 这一段则是自由发挥，容易发现当前子树会变成新的子树的左子树——左结合</span><br>        <span class="hljs-comment">// 如果新的子树为当前子树的右子树，则这就是个右结合</span><br>        expr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Binary(expr, operator, right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> expr;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>贪婪，如果没看到<code>!=</code>或<code>==</code>，就已经到头了，但若是看到了，就做相应处理并继续找<code>!=</code>和<code>==</code>。</p>
<p><img src="./sequence.png" alt="Alt text"></p>
<p>容易看到，这里这样处理的话会得到一个左结合——这棵树正常画的话，会逐渐往右上角生长。如果要右结合……好像就不是那么 trival 了，有点像右折叠，需要借助递归或栈来做操作。</p>
<p>然后，后面的也是一样的实现法，直到一元操作符和 primary 有些不同，但仍然是平铺直叙的。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// unary      -&gt; (&quot;!&quot; | &quot;-&quot;) unary | primary</span><br><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">unary</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (match(BANG, MINUS)) &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> previous();<br>        <span class="hljs-type">val</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> unary();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Unary(operator, value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> primary();<br>&#125;<br><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">primary</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> advance();<br>    <span class="hljs-keyword">if</span> (match(FALSE)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Literal(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (match(TRUE)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Literal(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (match(NIL)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Literal(<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">if</span> (match(NUMBER, STRING)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Literal(previous().literal);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (match(LEFT_PAREN)) &#123;<br>        <span class="hljs-type">Expr</span> <span class="hljs-variable">expr</span> <span class="hljs-operator">=</span> expression();<br>        <span class="hljs-comment">// 断言和消费 token</span><br>        consume(RIGHT_PAREN, <span class="hljs-string">&quot;Expect &#x27;)&#x27; after expression.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Grouping(expr);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>问题来了，primary 如果到最后也没有 return，该怎么办？</p>
<p>到最后也没有 return，这证明是出现了<strong>语法错误 syntax error</strong>，这里可以简单抛个异常了事，然后让用户看着 token 里指示的位置干瞪眼，但也可以做更多。但无论如何，到这一步，能用的 parser 已经完成了，只不过不够人性化。</p>
<p>不知道有啥更好的理解方式没有对递归下降的这一套…其实还蛮简单的，但不知道该怎么对它的行为建模。</p>
<h2 id="错误回复"><a href="#错误回复" class="headerlink" title="错误回复"></a>错误回复</h2><p>对 Parser 来说，其实检查不合法的 token 序列中的错误也是一个重要的工作。在生产中，parser 总是会遇上代码不完全，包含错误的情况——比如 IDE 的代码高亮和补全，在用户编辑代码时会不断地解析代码。Parser 应当正确处理错误，提供丰富的错误类型，避免级联错误，提供可能的解决方案，同时避免自己直接罢工、崩溃或无限循环，也就是说，从错误中恢复过来。</p>
<p>一个经受住实践考验的错误回复技术称为 <strong>panic mode</strong>，当 parser 检测到错误时，它进入到 panic mode，知道在当前，语法产生式的堆栈的某个中间部分中，至少一个 token 在当前状态中是不相符的。<strong>Parser 需要调整当前状态以及接下来的 token 序列，保证下一个记号符合当前正在解析的规则，这称为 synchronization</strong>。</p>
<p>需要选定特定规则作为<strong>同步点 synchronization point</strong>，在 panic mode 下，parser 跳出任意嵌套的产生式直到回到同步点以调整当前状态（调用栈），然后持续丢掉 token 直到遇上下一个合法的 token，中间这些被丢掉的 token 虽然无法报告它们的语法错误，但也避免了级联错误。可以想象，很多语言会以语句或块等来作为同步点。</p>
<p>如何跳出任意嵌套的产生式？该利用上高级语言的另一项特性——异常了。这里实现一个 consume 方法来报告错误并进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">consume</span><span class="hljs-params">(TokenType type, String message)</span> &#123;<br>    <span class="hljs-keyword">if</span> (check(type)) <span class="hljs-keyword">return</span> advance();<br>    <span class="hljs-keyword">throw</span> error(peek(), message);<br>&#125;<br><span class="hljs-keyword">private</span> ParseError <span class="hljs-title function_">error</span><span class="hljs-params">(Token token, String message)</span> &#123;<br>    Lox.error(token, message); <span class="hljs-comment">// 设置 hasError 标志，打印日志</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParseError</span>();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParseError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>这个 error 函数没有直接抛，这是考虑到有时候遇到了错误也仍需要继续处理，只是把错误报告一下，比如在 lox 中有限制函数参数的个数，如果传的太多但又符合语法，就报错但仍旧继续处理。又比如在 java 语言里写一个超过 int 最大值的字面量又没加 L，这种情况也是可以继续处理的。</p>
<p>然后关于丢掉 token，该如何丢呢？<strong>我们希望丢掉 token 直到下一个语句开始</strong>。同时也注意到，很多语句以关键字起始，for，class，var 等，丢掉直到遇到这些关键字也是好的。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronize</span><span class="hljs-params">()</span> &#123;<br>    advance(); <span class="hljs-comment">// 不合法的 token，先直接丢掉</span><br><br>    <span class="hljs-keyword">while</span> (!isAtEnd()) &#123;<br>        <span class="hljs-keyword">if</span> (previous().type == SEMICOLON) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果上一个 token 是 semicolon，这就是下一条语句的开始</span><br><br>        <span class="hljs-keyword">switch</span> (peek().type) &#123;<br>            <span class="hljs-comment">// 如果当前是这些关键字，不用再丢了</span><br>            <span class="hljs-keyword">case</span> CLASS: <span class="hljs-keyword">case</span> FUN: <span class="hljs-keyword">case</span> VAR: <span class="hljs-keyword">case</span> FOR: <br>            <span class="hljs-keyword">case</span> IF: <span class="hljs-keyword">case</span> WHILE: <span class="hljs-keyword">case</span> PRINT: <span class="hljs-keyword">case</span> RETURN:<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        advance();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>但这个方法后续再用，先让 parser 出现异常时直接无视即可。</p>
<h2 id="关于三目运算符"><a href="#关于三目运算符" class="headerlink" title="关于三目运算符"></a>关于三目运算符</h2><p>题目里有要求实现三目运算符的解析，这个比较有意思。</p>
<p>咱知道，三目可以模拟 if-elseif-else：</p>
<figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">co<span class="hljs-symbol">nd1</span> ? <br>    co<span class="hljs-symbol">nd4</span> ? a : b:<br>    co<span class="hljs-symbol">nd2</span> ?<br>        c:<br>        co<span class="hljs-symbol">nd3</span> ?<br>            d:<br>            e<br><br><span class="hljs-attr"># 等价于</span><br><span class="hljs-attr">if (cond1</span>) &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-comment">(cond4)</span> &#123;<br>        a<br>    &#125; else &#123;<br>        b<br>    &#125;<br>&#125; else <span class="hljs-keyword">if</span> <span class="hljs-comment">(cond2)</span> &#123;<br>    b<br>&#125; else <span class="hljs-keyword">if</span> <span class="hljs-comment">(cond3)</span> &#123;<br>    c<br>&#125; else &#123;<br>    d<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>容易发现，三目是右结合的，这倒是第一次处理右结合，但其实描述右结合是很容易的——只消在body里把引用下一个优先级的规则修改为引用自身就行了。</p>
<figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">ternary -&gt; <span class="hljs-built_in">equality</span> (<span class="hljs-string">&quot;?&quot;</span> ternary <span class="hljs-string">&quot;:&quot;</span> ternary)?<br></code></pre></div></td></tr></table></figure>
<p>实现其实很显然，显然到我有点没明白为啥会这么显然…需要新增加问号和冒号这两种 token。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Expr <span class="hljs-title function_">ternary</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">cond</span> <span class="hljs-operator">=</span> equality();<br>    <span class="hljs-keyword">if</span> (match(QUESTION)) &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> previous();<br>        <span class="hljs-type">val</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> ternary();<br>        consume(COLON, <span class="hljs-string">&quot;expect &#x27;:&#x27;.&quot;</span>);<br>        <span class="hljs-type">val</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> ternary();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>.Ternary(op, cond, left, right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cond;<br>&#125;<br></code></pre></div></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-NC-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12-19%E4%BD%BF%E7%94%A8TS%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">使用 TS 使用递归下降法实现解析四则运算</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09-17Perl%E5%85%A5%E9%97%A8.html">
                        <span class="hidden-mobile">Perl 入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start -->
<script src="/assets/prism-bundle.js"></script>
<script src="/assets/prism-plus.js" data-pjax=""></script>
<!-- hexo injector body_end end --></body>
</html>
