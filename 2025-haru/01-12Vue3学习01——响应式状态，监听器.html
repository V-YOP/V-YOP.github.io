

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="友纪V-λOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="正如上篇日记所说的，学学（复习）Vue 去换换思想，专注组合式 API">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue3 学习 01——响应式状态，监听器">
<meta property="og:url" content="http://example.com/2025-haru/01-12Vue3%E5%AD%A6%E4%B9%A001%E2%80%94%E2%80%94%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8.html">
<meta property="og:site_name" content="友纪V-λOP">
<meta property="og:description" content="正如上篇日记所说的，学学（复习）Vue 去换换思想，专注组合式 API">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-12T06:00:00.000Z">
<meta property="article:modified_time" content="2025-01-16T01:16:10.301Z">
<meta property="article:author" content="友纪V-λOP">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>Vue3 学习 01——响应式状态，监听器 - 友纪V-λOP</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":100},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="友纪V-λOP" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友纪V-λOP的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Vue3 学习 01——响应式状态，监听器">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-01-12 14:00" pubdate>
        2025年1月12日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Vue3 学习 01——响应式状态，监听器</h1>
            
            <div class="markdown-body">
              <p>继续做点笔记，因为笔记是边学边写的，所以前面的内容和后面的内容可能会有不一致，这时候以后面的内容为准。这与其说是笔记，不如说是学习记录。</p>
<h1 id="JS-代理机制"><a href="#JS-代理机制" class="headerlink" title="JS 代理机制"></a>JS 代理机制</h1><p>JS 的代理 Proxy 机制能够对对象的所有操作进行代理，包括：</p>
<ol>
<li>get：get 操作</li>
<li>set，set 操作</li>
<li>apply：函数调用，仅在对象是函数对象时才有意义；调用对象的函数的时候，实际上是先 get 到函数实例再进行调用，要拦截这个得拦截 get</li>
<li>construct：new 操作</li>
<li>has：in 操作</li>
<li>deleteProperty：delete 操作</li>
<li>……其他的一些，不表</li>
</ol>
<p>JS 的代理机制看上去比 python 的描述符协议更为强大，但它们实际上是不同的用途——JS 的代理机制创建新的对象用于替代原对象，而描述符协议是属于对象自身的。</p>
<p>Vue 使用代理机制去拦截对引用变量的 get，set 操作，实现 js 变量和 DOM 的双向绑定。</p>
<p>下面是一个使用代理的示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/** <span class="hljs-doctag">@type</span> &#123;<span class="hljs-type">ProxyHandler&lt;object&gt;</span>&#125; */</span><br><span class="hljs-keyword">const</span> printer = &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get&#x27;</span>, prop)<br>        <span class="hljs-keyword">return</span> target[prop] <br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, newValue</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set&#x27;</span>, prop)<br>        target[prop] = newValue<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;,<br>&#125;<br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;<br><br><span class="hljs-comment">/** <span class="hljs-doctag">@type</span> &#123;<span class="hljs-type">typeof obj</span>&#125; */</span><br><span class="hljs-keyword">const</span> proxiedObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, printer)<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxiedObject.<span class="hljs-property">a</span>) <span class="hljs-comment">// get a</span><br>proxiedObject.<span class="hljs-property">a</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// set a</span><br></code></pre></div></td></tr></table></figure>
<p>代理机制和描述符协议有着同样的缺陷——只代理对对象的操作（即操作对象“内部”），但对代理对象变量的 get、set 是无法拦截的（这时候操作的是对象本身，get 和 set 是更换了这个对象而非操作原对象）。这就限制了 Vue 的组合式 API 中的代理对象的格式——<strong>必须操作代理变量的 value 字段，而非操作代理对象本身</strong>。还好这个 typescript 能正确处理。</p>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h1><p>后面再提关于项目结构之类的玩意儿，先过概念。首先来一个经典的双向绑定案例。它引入了：</p>
<ol>
<li><strong>文本插值</strong>语法——在 HTML 文本中插入 js 表达式，这个表达式<strong>以当前组件实例为作用域去计算</strong>（实际上…是个沙箱环境，它只能访问部分全局变量），我们使用单文件结构，使用组合式 API，因此这里的作用域就是 script 标签。</li>
<li><code>v-on</code>语法，简写为<code>@</code>，允许从当前组件作用域中获取函数去绑定 DOM 事件，而且它能够后缀修饰符表示</li>
</ol>
<p>注意这里 <strong>v-on 绑定的是事件</strong>，比如这里我们把 click 事件绑定到<code>inc</code>上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>const count = ref(0)<br>function inc() &#123;<br>  count.value++<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button v-on:click=&quot;inc&quot;&gt;inc&lt;/button&gt;<br>  &lt;button v-on:click.prevent=&quot;inc&quot;&gt;inc&lt;/button&gt;<br>  &lt;button @click=&quot;inc&quot;&gt;inc&lt;/button&gt;<br>  &lt;button @click=&quot;inc()&quot;&gt;inc&lt;/button&gt;<br>  &lt;p&gt;counter: &#123;&#123; count &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></div></td></tr></table></figure>
<p>注意——DOM 更新和<code>count.value++</code>执行<strong>不是同步的</strong>——Vue 会缓冲所有状态的修改，在 <strong>next tick</strong> 后一并更新，这保证多次修改只会执行一次。nextTick 能够 await 到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; nextTick &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inc</span>(<span class="hljs-params"></span>) &#123;<br>  count.<span class="hljs-property">value</span>++<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">nextTick</span>()<br>  <span class="hljs-comment">// 现在 DOM 已经更新了</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>v-</code>开头的属性称为指令，指令可以有参数，比如上面的<code>v-on:click.prevent</code>中的 prevent；Vue 提供了许多内置指令，它就像模板引擎中提供的那些玩意。这设计思路就和 React 完全不同——React 全部都以 js 表达式来做，使用三目去实现 if，使用 map 去实现 for。不过 Vue 同样支持 JSX，因此支持 React 那种风格。</p>
<p><code>v-on</code>有一个及其操蛋的地方——传<code>inc</code>和传<code>inc()</code>效果是一样的，后者显然是不应该的，这证明<strong>它不是把内容当作一个纯粹的 js 表达式去看待</strong>，我认为这样很 tm 离谱。</p>
<p>实践证明，对<code>v-on</code>（以及其它的所有指令），<strong>它接受的表达式，并非是被当作普通的 JS 表达式去看待，同时它不是只执行一次，而是每次遇到相应事件时都进行执行</strong>。因为 Vue 对此做过特殊处理，所以<code>x.inc</code>能行，而<code>incN(5)</code>不能行。</p>
<p>下面给出一个例子，以及 v-on 的心智模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>const count = ref(0)<br>const incN = (n: number) =&gt; &#123;<br>    console.log(&#x27;incN invoked&#x27;) // logs every time<br>    const res = () =&gt; &#123;<br>      count.value += n<br>    &#125;<br>    res.self = res<br>    return res<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;  <br>  &lt;button @click=&quot;incN(5)&quot;&gt;doesn&#x27;t work&lt;/button&gt;<br>  &lt;button @click=&quot;count+=1&quot;&gt;works&lt;/button&gt;<br>  &lt;button @click=&quot;incN(5).self&quot;&gt;works&lt;/button&gt;<br>  &lt;p&gt;counter: &#123;&#123; count &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></div></td></tr></table></figure>
<p>建立<code>v-on</code>关于表达式的心智模型：</p>
<ol>
<li>表达式每次都会被执行，而非只执行一次（在 React 或原始 HTML 的编程模型中，都是只执行一次的）</li>
<li>表达式并非普通的 js 表达式——<strong>setup 中定义的 Ref，在表达式的顶层中会像普通变量那样操作，不需要获取 value 字段</strong>（而且 ts 能提供正确补全），比如表达式中可以出现<code>count++</code>和<code>count+=1</code></li>
<li>表达式执行时，Vue 会将<code>$event</code>添加到作用域中，它代表相应的 DOM 事件</li>
<li>表达式的最后一个操作是函数调用的时候（<strong>这里在运行时检查了表达式的语法树！</strong> JS 本身是做不到的！），<strong>直接执行表达式</strong></li>
<li>否则认为表达式会返回一个函数，以<code>$event</code>为参数执行该函数</li>
</ol>
<p>对于其它的内置指令，也要抱有警惕心，认识到它的表达式可能不是（必然不是）直接被传递给 js 的，Vue 在其中可以做任何幺蛾子。</p>
<p>不得不说，Vue 的这个设计会减少一些代码量，<strong>避免每次都在顶层写一个箭头函数</strong>去传递 event，但是会为闭包函数带来麻烦，而且会带来一定的心智负担，见仁见智吧。这里或许也体现了 Vue 的设计哲学——要实用，不要纯粹。v-on 的这个设计实际上对 v-for 也是方便的，后面会看到。</p>
<p><code>v-on</code>用来绑定函数我们已经清楚了，那关于绑定属性呢？绑定属性使用<code>v-bind</code>，这是一种单向绑定，就像 react 中我们做的那样；<code>v-model</code>则是双向绑定——它只支持部分元素如 input，textarea 等，但支持直接把变量和组件绑定，不需要手动处理 getter，setter。</p>
<p><code>v-bind</code>简写为<code>:</code>，因为它太过常用。下面展示了<code>v-bind</code>和<code>v-model</code>的简单用法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>const text = ref(&#123;a: 1&#125;)<br>const enabled = ref(true)<br>&lt;/script&gt;<br><br>&lt;template&gt; <br>  &lt;button @click=&quot;enabled=!enabled&quot;&gt;toggle&lt;/button&gt;<br>  &lt;input type=&quot;text&quot; :disabled=&quot;!enabled&quot; v-model=&quot;text&quot; /&gt;<br>  &lt;p&gt;text: &#123;&#123; text &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></div></td></tr></table></figure>
<p>显然——<code>v-bind</code>接受的是普通 js 表达式，而<code>v-model</code>接受的必须是 <strong>LHS</strong>——左值，可以赋值的值。下面专门去学习一下。</p>
<h1 id="ref，reactive，计算属性"><a href="#ref，reactive，计算属性" class="headerlink" title="ref，reactive，计算属性"></a>ref，reactive，计算属性</h1><p>对于响应式的变量，Vue 提供了两个实现——ref 和 reactive，它们各有其特性和用途，Vue 推荐优先使用 ref。计算属性的行为和 Ref 基本一致，这里也一并学习。</p>
<p>首先要知道，setup 只执行一次，不像 React 的函数式组件那样每次渲染都执行，这是起点。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>ref 函数接受一个初始化变量，返回<code>Ref</code>，Ref 是一个对象，其中把初始化的变量塞到 value <strong>属性</strong>中（注意这里没有使用 Proxy，只使用了 getter、setter 去实现同样效果，但如果变量不是基本类型，那它仍旧会被转换成响应式对象），允许去<strong>监听 js 代码中对 value 的修改</strong>并做出相应的操作。</p>
<p>Vue 对 ref 有一个独特的处理——对指令表达式中<strong>的顶层</strong>出现的 ref 变量，Vue 会自动给它解包。顶层是指语法树的顶层，如<code>a</code>，而<code>a.b</code>，其中 b 为 ref 变量时，这就无效了。下面的代码测试该行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br><br>const a = &#123;<br>  b: ref(&#x27;&#x27;)<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt; <br>  &lt;button @click=&quot;a.b.value += &#x27;!&#x27;&quot;&gt;emphsis&lt;/button&gt;<br>  &lt;input type=&quot;text&quot; v-model=&quot;a.b.value&quot; /&gt;<br>  &lt;input type=&quot;text&quot; v-model=&quot;a.b&quot; disabled/&gt; &lt;!-- always [object Object] --&gt;<br>  &lt;p&gt;模板变量则不一样——它会自动添加 value: &#123;&#123; a.b &#125;&#125;&lt;/p&gt;<br>  &lt;p&gt;text: &#123;&#123; a.b.value &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></div></td></tr></table></figure>
<p>这证明，对于指令表达式的执行，可以认为，Vue 会自动地使用同名的解包后的变量（即 value 字段的值）去<strong>遮蔽</strong>原来的 ref（同时记录 value 到 ref 的映射供后面操作），这使得顶层的 ref 不需要使用<code>.value</code>就能使用，而非顶层的 ref 必须显式给出<code>.value</code>。</p>
<p>文本插值的逻辑亦有差别——注意到，指令表达式中<code>a.b</code>是不支持的，但模板变量中<code>a.b</code>则支持，但仔细测试又会发现，<code>a.b + &#39;!&#39;</code>这样又是不支持的，需要显式给定<code>.value</code>。这证明，模板变量对 Ref 的处理实际上适应我之前的认知——<strong>模板变量能够同时处理 Ref 和基础变量，Ref 会自动解包</strong>。</p>
<p>上面说的<strong>遮蔽</strong>，看起来是无法通过单纯的 js 代码完成的，但其实仍旧是可以的——setup 函数可以认为是 return 了作用域下的所有变量，这里是记录了变量名的。这再次体现了 Vue 和 React 的不同之处——React 基于纯 js，即使是 jsx，实际上也只是 js 的语法糖，有等价的 js 存在；而 Vue 则是不追求这一点，做了更多封装，甚至不吝啬在运行时去解析和执行表达式，从而让语义能够<strong>超出 js 本身</strong>的限制，这对开发者来说更为便捷，但是会带来额外的心智负担，无法直接沿用 js 的心智模型，还是那句话，见仁见智吧。</p>
<p>这里会有一个疑惑——为什么要做这种“遮蔽”的魔法，而不是直接允许指令表达式能够接受 ref？这是因为<strong>为了方便在表达式中使用 js 表达式</strong>。比如下面的例子，如果不使用“遮蔽”的话，就会出现 ref 变量（对象）和基础变量互操作的应当避免的状况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>const text = ref(&#x27;hello！&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt; <br>  &lt;input type=&quot;text&quot; :value=&quot;text + &#x27;!&#x27;&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></div></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>执行指令表达式时，Vue 会使用同名解包后的变量遮蔽原 Ref 变量，非顶层的 Ref 变量享受不到这种遮蔽，只能手动解包；指令表达式不能返回 Ref 变量</li>
<li>执行文本插值时，Vue 同样会进行该遮蔽操作，但<strong>也支持插值表达式返回 Ref 变量</strong>（指令表达式则不支持），对于 Ref 变量，Vue 会自动将其解包</li>
</ol>
<p>ref 具有深层响应性——<strong>ref 即使在持有数组、嵌套对象时，其元素的变更仍然是能够被检测到的</strong>。这种深层的响应性来自于 ref 会将复杂对象<strong>递归地</strong>转换为响应式代理（基于 reactive 函数）。</p>
<p>ref 的缺点就在于它的深层响应性——对大型数据的响应性会影响性能，以及使用外部库的时候，也难以使用 ref 去集成。<strong>Vue 提供了 shallowRef，只追踪对<code>.value</code>的访问以进行优化</strong>。</p>
<h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h2><p>ref 接受一个值，然后把它包装到一个对象中，使用 value 属性去访问该值，监听变更的方式是 getter、setter。reactive 则是直接把对象本身<strong>递归地</strong>转换成代理，监听变更的方式是 Proxy。</p>
<p>实际上，这是说：</p>
<ol>
<li>当 x 是基本类型时，<code>ref(x) == shallowRef(x)</code></li>
<li>当 x 是嵌套类型时，<code>ref(x) == shallowRef(reactive(x))</code></li>
</ol>
<p>reactive 也可以单独拿出来用，这时候就不需要使用<code>.value</code>去访问了，而是直接去访问相应字段。<strong>reactive 函数支持对象、数组、Map，Set 等</strong>。</p>
<p>reactive 的一个缺点是，如果解构出来基本类型的值，那它的响应性就丢失了，这是显然的——基本类型直接被拷贝了。但对于嵌套的对象，它仍旧是具有响应性的，只不过不能更换对象自身，只能对自身进行修改罢了。</p>
<p><strong>reactive 对象中可以包含 ref 对象并且当作普通变量一样使用，只有在 ref 对象是原 reactive 对象的嵌套字段的时候，该 ref 对象会自动解包</strong>，当 ref 对象是数组、Map、Set 的元素时，不会自动解包。这个性质很奇怪，但可以根据 reactive 对象的类型签名做判断——<strong>reactive 函数的的类型演算和这里的逻辑应该是一致的</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">testA</span>: &#123;<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>&#125; = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>) &#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-attr">testB</span>: &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>&#125;&#125; = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">2</span>)&#125;&#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-attr">testC</span>: &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">number</span>&gt;[]&#125;&#125; = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: [<span class="hljs-title function_">ref</span>(<span class="hljs-number">2</span>)]&#125;&#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-attr">testD</span>: &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;&#125;&#125; = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)]])&#125;&#125;)<br></code></pre></div></td></tr></table></figure>
<p>Vue 同样提供了 shallowReactive，仅追踪浅层对象的变更。</p>
<h2 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h2><p>这个我们熟悉，类似 React 的 useMemo，但要再度重申——setup 函数只执行一次。</p>
<p>计算属性使用<code>computed</code>函数定义，<strong>该函数返回一个 Ref</strong>（实际上是 ComputedRef）。Vue 对计算属性的执行是显然的——执行计算属性函数，<strong>缓存</strong>返回值，检查该函数所依赖的所有变量并记录；如果这些变量有改变，则重新执行计算属性函数，缓存返回值，同时再度检查该函数依赖的所有变量并记录（依赖的变量可能会有变动）。</p>
<p>但和 React 不同的地方是，<strong>计算属性可以是可写的</strong>。计算属性传一个函数时认为是 getter，但也可以传一个包含<code>get</code>，<code>set</code>的方法代表 getter，setter。下面展示了计算属性的使用，一个是演示只读的计算属性，一个是演示可读写的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; computed, ref, type ComputedRef, type Ref, type WritableComputedRef &#125; from &#x27;vue&#x27;;<br><br>const counter = ref(0)<br>const firstName = ref(&#x27;&#x27;)<br>const lastName = ref(&#x27;&#x27;)<br><br>const isOdd: ComputedRef&lt;boolean&gt; = computed(() =&gt; &#123;<br>  return counter.value % 2 == 1<br>&#125;)<br><br>const fullName: WritableComputedRef&lt;string, string&gt; = computed(&#123;<br>  get() &#123;<br>    if (!firstName.value &amp;&amp; !lastName.value) &#123; return &#x27;&#x27; &#125;<br>    if (!lastName.value) &#123;return firstName.value&#125;<br>    return `$&#123;firstName.value&#125; $&#123;lastName.value&#125;`<br>  &#125;,<br>  set(value: string) &#123;<br>    if (!value) &#123;<br>      firstName.value = lastName.value = &#x27;&#x27;<br>      return<br>    &#125;<br>    const [fstName, ...last] = value.split(&#x27; &#x27;)<br>    firstName.value = fstName<br>    if (last.length !== 0) &#123;<br>      lastName.value = last.join(&#x27; &#x27;)<br>    &#125;<br>  &#125;<br>&#125;)<br><br>&lt;/script&gt;<br><br>&lt;template&gt; <br>&lt;button @click=&quot;counter+=1&quot;&gt;inc&lt;/button&gt;<br>&lt;input v-model=&quot;fullName&quot; placeholder=&quot;name&quot;/&gt;<br>&lt;p&gt;<br>  counter: &#123;&#123; counter &#125;&#125;&lt;br/&gt;<br>  isOdd: &#123;&#123; isOdd &#125;&#125;&lt;br/&gt;<br>  firstName: &#123;&#123; firstName &#125;&#125;&lt;br/&gt;<br>  lastName: &#123;&#123; lastName &#125;&#125;&lt;br/&gt;<br>&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></div></td></tr></table></figure>
<p>最新的 Vue 版本支持在计算属性的 getter 中接受参数得到<strong>上一个值</strong>，在某些场景可能有用。</p>
<p>最佳实践是：计算属性的 getter 不要有副作用，同时不要修改计算属性的返回值。</p>
<h1 id="侦听器-watch"><a href="#侦听器-watch" class="headerlink" title="侦听器 watch"></a>侦听器 watch</h1><p>上面一直在处理状态，该关注副作用了，侦听器就是 Vue 中的“useEffect”，而侦听器的定义确实和 React 那边类似。侦听器接受一个 Ref（包括 ComputedRef），Reactive，或者一个 getter 函数，或者前述内容组成的数组，作为自己的依赖，然后是回调。</p>
<p>显然能够预测到侦听器的行为——</p>
<ol>
<li>如果传给它的是 Ref，则将该 Ref 加入依赖中，Ref 变更时执行回调</li>
<li>如果传给它的是 Reactive，同上</li>
<li>如果传给它的是 getter，通过执行它去得到所有的依赖，并在它们变更时执行回调，<strong>就像临时地定义了一个计算属性一样</strong></li>
<li>如果传给它的是数组，对数组内的元素均执行上述操作</li>
</ol>
<p>注意，这里侦听器传变量的话得传 Ref，Reactive 变量，如果非 Ref（比如 Reactive 的某个基础类型的字段，比如 props 的某个字段），得<strong>用 getter</strong>。为什么呢？我们知道，Vue是通过代理或getter、setter去监听的，但从Vue编译器看来，<strong>组件的所有代码是“原子”的——Vue无法直接确定watch的参数究竟是来自哪个响应式变量——它只能看到这个变量当前的值</strong>，而传递getter就允许让Vue独立去调用它，并检查究竟对应的是哪个变量。</p>
<p>侦听器比 useEffect 更为强大——它会直接把当前的所有依赖值和变更前的依赖值都作为参数传过来供使用，无论有多少个依赖，注意到下面的例子中，<code>newValue</code>的类型即为<code>[obj]</code>的类型。</p>
<p>然而，上面说的“当前的所有依赖值和变更前的依赖值”，并不准确——只要我传给它的不是基础类型，这时候 newValue 是等于 oldValue 的，下面的例子中也有体现。这是因为，变更的是它的深层，它自己没有改变。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">a</span>: &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">1</span><br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-title function_">watch</span>([obj], <span class="hljs-function">(<span class="hljs-params">newValue, oldValue, onCleanup</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(newValue[<span class="hljs-number">0</span>], oldValue[<span class="hljs-number">0</span>])) <span class="hljs-comment">// true</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj changed&#x27;</span>, newValue[<span class="hljs-number">0</span>].<span class="hljs-property">a</span>.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<p>何时 oldValue 才有意义呢？使用基础类型的 Ref 的时候，以及使用 getter 函数的时候。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> a = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> b = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">0</span><br>&#125;)<br><br><span class="hljs-title function_">watch</span>([a, <span class="hljs-function">() =&gt;</span> b.<span class="hljs-property">value</span>], <span class="hljs-function">(<span class="hljs-params">newValue, oldValue, onCleanup</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue[<span class="hljs-number">0</span>] !== oldValue[<span class="hljs-number">0</span>] || newValue[<span class="hljs-number">1</span>] !== oldValue[<span class="hljs-number">1</span>])<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue, oldValue)<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<p>同时也注意到，监听器的回调的第三个参数<code>onCleanup</code>，这个参数用于<strong>这一趟的清理</strong>，它的行为等价于 React 的 useEffect return 的函数。</p>
<p>需要注意的是，<strong>对于 Ref 和 Reactive，watch 的监听是深层的，而对于 getter，对它的监听是浅层的，这就是说，getter 只有在返回不同对象的时候才认为需要执行回调</strong>。但这里可以配置是否使用深层监听，如果使用，则 getter 也会进行深层监听，这里不表。</p>
<p>监听器有诸多配置项，如配置只执行一次，如配置在定义时即刻执行，比如请求初始数据。</p>
<p>此外还有 watchEffect，它认为回调中操作到的依赖就是它的依赖，因此不需要传递依赖。<strong>watchEffect 必须是定义时即刻执行的，同时在回调是异步函数时，只有同步时访问的依赖会被监听到</strong>，这就是说，只有第一次 await 前访问的变量会被作为依赖。</p>
<p>不要认为监听器的依赖和 React Hook 的依赖是同一个东西，处理依赖的时候，总是扪心自问，我究竟什么时候才要重新执行我这个操作？</p>
<p>最后，监听器有和 useEffect 一样的问题——如果回调是 async 的，可能这一趟还没执行完的时候下一趟就开始执行了。考虑一个情景——我们在订单号变更的时候要修改展示的订单，这是一个异步调用，现在订单号变成 a，我们开始拉取数据，在数据到来之前，订单号又变成 b，开始拉取 b，这时候，如果 b 先拉取到，a 后拉取到，最后展示的就会是 a。</p>
<p>对于这个情况，Vue 和 React 的处理方式一致——用一个布尔变量表示是否忽略这一趟的结果，默认值为 false，在清理函数中把它设为 true，执行操作前检查它：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">(<span class="hljs-params">onCleanup</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> ignore = <span class="hljs-literal">false</span><br>  (<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">getUser</span>(id)<br>    <span class="hljs-keyword">if</span> (ignore) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;)()<br>  <span class="hljs-title function_">onCleanup</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    ignore = <span class="hljs-literal">true</span><br>  &#125;)<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<p>下面给一个实例——按下按钮后 3 秒钟后，将计数器加 1，其中多次按下时重置计时。<strong>这个场景其实不适合使用监听器，只是作为演示（直接做节流不就行了）</strong>，但其实 React 里也经常这么干（用一个没有意义的 state 去专门用来触发 Effect）。<strong>注意到 Vue 的代码比 React 的更为舒服</strong>——支持整个回调为 async 函数，这归功于 Vue 通过参数而非是通过返回值去得到清理函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref, watch &#125; from &#x27;vue&#x27;;<br><br>const counter = ref(0)<br><br>async function sleep(ms: number) &#123;<br>  return new Promise(resolve =&gt; setTimeout(resolve, ms))<br>&#125;<br><br>const refresher = ref(0) // 没有意义，只是用于通知 watch<br>watch(refresher, async (n,o,onCleanUp) =&gt; &#123;<br>  let ignore = false<br>  onCleanUp(() =&gt; ignore = true) // 如果函数是 async 的，onCleanUp 必须在 await 之前调用！<br>  await sleep(3000)<br>  if (ignore) return<br>  counter.value++<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt; <br>&lt;button @click=&quot;refresher++&quot;&gt;incDelay&lt;/button&gt;<br>&#123;&#123; counter &#125;&#125;<br>&lt;/template&gt;<br></code></pre></div></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-NC-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025-haru/01-13Vue3%E5%AD%A6%E4%B9%A002%E2%80%94%E2%80%94%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%8E%A7%E5%88%B6%E6%B5%81.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Vue3 学习 02——组件属性，“控制流”</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025-haru/01-10%E5%AD%A6%E4%B9%A0Python%E8%AE%A9%E6%88%91%E5%AD%A6%E4%BC%9A%E6%8E%A5%E5%8F%97%E4%B8%8D%E7%BA%AF%E7%B2%B9.html">
                        <span class="hidden-mobile">学习 Python 让我学会接受不纯粹</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start -->
<script src="/assets/prism-bundle.js"></script>
<script src="/assets/prism-plus.js" data-pjax=""></script>
<!-- hexo injector body_end end --></body>
</html>
