

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="友纪V-λOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="补课。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机系统要素学习笔记 Part1——从 NAND 到 CPU">
<meta property="og:url" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU.html">
<meta property="og:site_name" content="友纪V-λOP">
<meta property="og:description" content="补课。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/imageALU.png">
<meta property="og:image" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-3.png">
<meta property="og:image" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-4.png">
<meta property="og:image" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-5.png">
<meta property="og:image" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image.png">
<meta property="og:image" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-6.png">
<meta property="og:image" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-8.png">
<meta property="og:image" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-10.png">
<meta property="og:image" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/cpuArchi.png">
<meta property="article:published_time" content="2024-01-15T15:00:00.000Z">
<meta property="article:modified_time" content="2024-01-15T15:40:07.957Z">
<meta property="article:author" content="友纪V-λOP">
<meta property="article:tag" content="计算机组成">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/imageALU.png">
  
  
  <title>计算机系统要素学习笔记 Part1——从 NAND 到 CPU - 友纪V-λOP</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友纪V-λOP的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="计算机系统要素学习笔记 Part1——从 NAND 到 CPU">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-01-15 23:00" pubdate>
        2024年1月15日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机系统要素学习笔记 Part1——从 NAND 到 CPU</h1>
            
            <div class="markdown-body">
              <p>开摆多日，心态越来越好了。开始学底层，准备给它串起来！跟着 <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/build-a-computer">coursera&#x2F;building-a-computer</a> 做。考虑到某种学术诚信原则（虽然大概也没人管），不贴任何答案，只贴思路。</p>
<p>这篇笔记包括此课的 1-5 单元，第 6 单元汇编器和此课的 part2 留待下一篇笔记。</p>
<h1 id="组合门逻辑"><a href="#组合门逻辑" class="headerlink" title="组合门逻辑"></a>组合门逻辑</h1><p>简化主要是依靠德摩根律：<code>a and b = !(!a or !b)</code>，<code>a or b = !(!a and !b)</code>。</p>
<p>面对复杂的组件，写出它的真值表，对输出的每一列，找到它为 1 的行，对该行的每个输入，使用 and 拼接起来，其中为 0 的加 not，这样得到的子句只对该行为 1，将这些子句用 or 连接起来并化简便得到最终结果。</p>
<p>比如，对半加器，有：</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">out</th>
<th align="center">carry</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>对每一个输出，用 or 联立每个结果为 1 的行，有：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">out = (!a <span class="hljs-keyword">and </span><span class="hljs-keyword">b) </span><span class="hljs-keyword">or </span>(a <span class="hljs-keyword">and </span>!<span class="hljs-keyword">b)</span><br><span class="hljs-keyword"></span>carry = a <span class="hljs-keyword">and </span><span class="hljs-keyword">b</span><br></code></pre></div></td></tr></table></figure>

<h1 id="いろいろ"><a href="#いろいろ" class="headerlink" title="いろいろ"></a>いろいろ</h1><p>在这本书里，Nand 是 primitive 的，其它门都通过它来实现。</p>
<h2 id="Not-And-Or-Xor"><a href="#Not-And-Or-Xor" class="headerlink" title="Not, And, Or, Xor"></a>Not, And, Or, Xor</h2><p>考虑<code>a nand b = !(a and b)</code>, <code>a and a = a</code>, 有 <code>a nand a = !a</code>，即<code>!a = a nand a</code>。</p>
<p>Nand 是 Not And，有了 Not 了，再来个 Not 就得到 And 了，即<code>a and b = !(a nand b)</code></p>
<p>根据德摩根律，<code>a or b = !(!a and !b)</code>。现在 And，Not 和 Or 均有了，因此一切布尔函数均可以被表示了。</p>
<p>关于异或 Xor，其检查两个输入是否不同，不同则返回 1。</p>
<p><code>a xor b = (a and !b) or (b and !a)</code>。</p>
<h2 id="Mux-DMux"><a href="#Mux-DMux" class="headerlink" title="Mux, DMux"></a>Mux, DMux</h2><p>Mux 即多路复用器，它根据一个 sel 输入来从两个输入中选择一个做输出，sel 为 0 时选择 a，sel 为 1 时选择 b——就像一个 bit 的 if-else—— <code>sel == 0 ? a : b = (sel and b) or (!sel and a)</code>。</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">sel</th>
<th align="center">out</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>DMux 是数据分配器，它有一个输入，根据一个 sel 输入来从两个输出中选择一个做输出，就像电车难题那玩意……或者 go 那套。<code>outA = sel == 0 ? in : 0 = !sel and in</code>，<code>outB = sel == 1 ? in : 0 = sel and in</code>。</p>
<table>
<thead>
<tr>
<th align="center">in</th>
<th align="center">sel</th>
<th align="center">outA</th>
<th align="center">outB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>感觉有时候把 sel 当作 Mux 和 DMux 上的一个开关（状态），把 a，b，in 当作参数会有帮助。</p>
<h2 id="Or8Way-Mux4Way16，Mux8Way16-DMux4Way-DMux8Way"><a href="#Or8Way-Mux4Way16，Mux8Way16-DMux4Way-DMux8Way" class="headerlink" title="Or8Way, Mux4Way16，Mux8Way16, DMux4Way, DMux8Way"></a>Or8Way, Mux4Way16，Mux8Way16, DMux4Way, DMux8Way</h2><p>16Bit 的 Not 和 And 等的实现也没啥差，逐位做相应操作就得了。虽然有点怪，但 Mux16 也是逐位做同样操作。</p>
<p><strong>XWay 指的是有 X 路输入</strong>，16 表示 16 比特，因此 Or8Way 表示 8 路输入 Or 门，Mux8Way16 表示 16Bit 的 8 路输入的 Mux。</p>
<p>Or8Way 的实现是容易的，想想计算<code>1 + 2 + 3</code>是怎么算的，<code>(1 + 2) + 3</code>，虽然结合性无关紧要啦。</p>
<p>Mux4Way16 有 4 路输入，因此需要两个 sel 来标识使用哪路输入：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">Mux4Way a[16] b[16] c[16] d[16] sel[2] <br><span class="hljs-section">= case sel =&gt; 00: a, 01: b, 10: c, 11: d</span><br><span class="hljs-section">= (!sel[0] and !sel[1] and a) or (!sel[0] and sel[1] and b) ...</span><br></code></pre></div></td></tr></table></figure>

<p>可以给<code>!sel[0] and !sel[1]</code> 命名 selA，给<code>!sel[0] and sel[1]</code>命名 selB……来让实现更清晰。为了扩展 selA 的位长可以使用 Mux16。</p>
<p>更聪明的解决方案是逐步缩小“查询”的范围，首先根据 sel 的第一位，确定要查询的是<code>ac</code>还是<code>bd</code>，再根据 sel 的第二位决定是取<code>a</code>还是<code>b</code>，<code>c</code>还是<code>d</code>……</p>
<p>Mux8Way16 也是同样的思路，先根据 sel 的一二位确认要查询的范围是<code>ae</code>，<code>bf</code>，<code>cg</code>或<code>dh</code>，再根据第三位确认取<code>a</code>或是<code>e</code>……</p>
<p>DMux4&#x2F;8Way，从 4&#x2F;8 个输入中选择一个。思路也是一样的，但“查询”要改为“分发”，并且要先根据最高位决定分发到<code>ab</code>还是<code>cd</code>……</p>
<h2 id="半加器，全加器"><a href="#半加器，全加器" class="headerlink" title="半加器，全加器"></a>半加器，全加器</h2><p>十进制加法是怎么算的？比如，<code>4234+7639</code>。我们从右往左，挨个数字挨个数字做加法，如果加法的结果大于等于 10，给它左边的数上写一个 1 标识有进位（称作 carry），然后算左边的数的时候这个 1 也要算上，<strong>注意进位最大只会为 1</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">1     1<br> <span class="hljs-number"> 4 </span>2<span class="hljs-number"> 3 </span>4<br> <span class="hljs-number"> 7 </span>6<span class="hljs-number"> 3 </span>9<br> ------<span class="language-yaml"><span class="hljs-meta">---</span></span><br><span class="language-yaml"><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span></span><br><span class="language-yaml"></span><br></code></pre></div></td></tr></table></figure>

<p>二进制加法也一样，从右往左挨个数字做加法，如果加法的结果大于等于 10（二进制的 2），给它左边的数上写一个 1 标识有进位，算它左边的数的时候这个 1 也要算上……比如 <code>1101 + 1111</code>：</p>
<figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap"> <span class="hljs-number"> 1 </span>1 1<br> <span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>1<br> <span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<br> ------<span class="language-yaml"><span class="hljs-meta">---</span></span><br><span class="language-yaml"><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> </span><br></code></pre></div></td></tr></table></figure>

<p>注意这个算式的每一列，对于最左边的一位，是两个二进制数进行运算，对于其它的位，是上一位的进位以及这一位的两个二进制数，总共三个二进制数进行运算。<strong>实现两个二进制数的加法的硬件叫做半加器 Half Adder，实现三个二进制数的加法的硬件叫做全加器 Full Adder，能够看出来，只要能实现全加器，我们就能实现任意位数的二进制数的运算</strong>。</p>
<h1 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h1><p>ALU 即算术逻辑单元，是 CPU 中负责计算的部分，它有三个参数——f：决定当前使用的计算功能（预先规定好的，抉择多少部分在硬件实现，多少部分在软件实现是个两难的抉择），如加减乘除和逻辑运算，这通常是数个 bit 的输入，用来指示使用 ALU 的什么功能；两个输入 input1 和 input2，然后输出结果<code>f(input1, input2)</code>（以及一些其它的标识特定状态的输出，比如溢出）。</p>
<p>前面的各种基础门电路以及全加器，半加器，在不同的计算机中总是长得一样的，但 ALU 则更少通用性。</p>
<p>关于这里的 f，它是数个 bit 的标识位，从外界看来，特定 bit 的组合会标识要使用何种计算功能，在实现上，这些每个 bit 都是在<strong>通过对 x，y，x 和 y 要进行的运算，out 进行一系列的修改来最终实现特定的效果（即用户看到的功能）</strong>，比如这里要实现的 ALU 有六个标识位，每个标识位代表对 x，y 先执行特定操作，使用何种运算，以及对 out 做何种操作。</p>
<p><strong>实现是不止一种的，只需要最终的结果符合 specification 即可</strong>，这是说，下图中红框标出来的部分是实现相关的，是可以任意地去修改的，只要最终达到的效果满足该表即可。但该表的设计也是会考虑到实现的方便程度的。</p>
<p><img src="/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/imageALU.png"></p>
<h1 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h1><p>前面写的各种门电路，其行为就像纯函数——输出只取决于输入，一切都是瞬间完成的（实际并非如此）。这也决定它们无法保持有<strong>状态</strong>。这是组合逻辑。</p>
<p>物理的时间是连续的，使用间歇输出 1 和 0 的振荡器，能够将物理的时间进行划分成一个个离散的周期，每个周期作为一个时间单位。周期是原子的，不需要考虑周期内发生的事情（此乃谎言），只要周期设计的足够长，保证在周期结束时所有输入输出都已稳定。周期结束的时候是我们能看到系统当前逻辑状态的时候，同时也是根据当前状态和输入去更新所有输入输出状态的时候，即下一个周期的开始，所有输入输出马上又开始不确定了。</p>
<p><img src="/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-3.png"></p>
<p>时序逻辑使能够引入状态，让输出能够被当前状态（或者说上一次的输入）来决定。时序逻辑会引入时钟，最基础的能够保持状态的芯片叫做 DFF，Data flip-flop，它的行为是每个时刻输出上一个时刻的输入，<code>out(t) = in(t - 1)</code>，这里的 t 指第 t 个时钟周期。</p>
<p><img src="/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-4.png"></p>
<p>注意 t&#x3D;1 时 out 是不确定的，因为此时还没有上一个时钟周期。以及，计算机中的每一个 DFF 或者同类的元件必须连接同一个时钟。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dff</span>(<span class="hljs-params"><span class="hljs-keyword">in</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> lastState = dff.<span class="hljs-property">state</span><br>  dff.<span class="hljs-property">state</span> = <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">return</span> lastState<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>那如何利用 DFF 去保持状态呢？只要让当前时刻的输出等于上一时刻的输出，就等于是保持了这个输出作为状态。而为了让该状态能持续被保存，需要其能访问其上一个状态，也就是说这里需要造一个环路。为了避免输入的二义性，可以用一个 Mux 去区分，当前是要从输入中取数据还是从上一个状态中取数据，对于前者，对下一个周期，状态会改为当前的输入，否则状态保持不变。保持状态的组件，其实现的“模式”如下图，<strong>一切包含状态的组件，其实现总是类似的形式，无论它是寄存器，计数器还是内存</strong>。</p>
<p><img src="/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-5.png" alt="一般的时序逻辑的实现"></p>
<h2 id="1-Bit-寄存器，16Bit-寄存器"><a href="#1-Bit-寄存器，16Bit-寄存器" class="headerlink" title="1 Bit 寄存器，16Bit 寄存器"></a>1 Bit 寄存器，16Bit 寄存器</h2><p>load 为 1 表示去加载新的值（其实这个该叫 save 啊 hh），否则输出当前保存的值。</p>
<p><img src="/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image.png" alt="1 bit 寄存器"></p>
<p>在模拟时，周期要分为两个部分——tick 和 tock，tick 是存储器根据输入更改当前存储的值的时刻（此时处在周期的一个中间状态，似乎是上升沿），tock 是存储器修改输出值的时刻；tick 是当前周期的一个中间状态，tock 是下一个周期的开始。更多细节将来在其他课程再学。</p>
<p>16Bit 寄存器也是一样的，寄存器之间是平行的，它们一同保存状态，一同更新状态，因此 load 是需要是同一个 load。</p>
<h2 id="RAM8，RAM64，RAM512"><a href="#RAM8，RAM64，RAM512" class="headerlink" title="RAM8，RAM64，RAM512"></a>RAM8，RAM64，RAM512</h2><p>RAM8 是 8 地址的内存，每个地址对应一个 16Bit 的寄存器，每次只访问特定地址的寄存器，使用 DMux8Way 和 address 来决定 load 要写哪个地址，使用 Mux8Way16 和 address 来决定要读哪个地址。（纺锤形 w）</p>
<p>RAM64 是一样的，只不过把地址当作两部分看待，高 3 位从“外面”找到对应的 RAM8，低 3 位从 RAM8 中找到相应寄存器。</p>
<p>RAM512 是一样的，只不过把地址当作两部分看待，高 3 位从“外面”找到对应的 RAM64，低 6 位从 RAM64 中找到相应寄存器。</p>
<p>RAM4K（4096）是一样的，只不过把地址当作两部分看待，高 3 位从“外面”找到对应的 RAM512，低 9 位从 RAM512 中找到相应寄存器。</p>
<p>RAM16K 是一样的，只不过把地址当作两部分看待，高 2 位从“外面”找到对应的 RAM4096，低 12 位从 RAM4096 中找到相应寄存器。</p>
<h2 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h2><p>程序计数器，指示下一条要执行的指令的地址。寄存器需要有自增，覆盖（即跳转），置零的功能。</p>
<p>注意 PC 的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A 16-bit counter with load and reset control bits.</span><br><span class="hljs-comment"> * if      (reset[t] == 1) out[t+1] = 0</span><br><span class="hljs-comment"> * else if (load[t] == 1)  out[t+1] = in[t]</span><br><span class="hljs-comment"> * else if (inc[t] == 1)   out[t+1] = out[t] + 1  (integer addition)</span><br><span class="hljs-comment"> * else                    out[t+1] = out[t]</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>

<p>这有点像优先级，如果 reset 为 true，则 load 和 inc 就不管事了。为此需要反向来——先看 inc，暂存此时的结果（为原状态或原状态+1）；再看 load，如果 load 为 0，维持 inc 的结果，否则用 load 的结果（即输入）；再看 reset，如果 reset 为 0，维持 load 的结果，否则使用 reset 的结果（即 0），就像三个 Mux 的左结合的结果。</p>
<p>大概是这种感觉：</p>
<figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf"><span class="hljs-keyword">switch</span> &#123;<br>    temp = regOut<br>  <span class="hljs-keyword">case</span> inc:<br>    temp = regOut + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-built_in">load</span>:<br>    temp = <span class="hljs-built_in">in</span><br>  <span class="hljs-keyword">case</span> reset:<br>    temp = <span class="hljs-number">0</span><br>&#125;<br>regIn = temp<br></code></pre></div></td></tr></table></figure>

<p>另一个理解方式是通过计算的顺序来看，先把逻辑写成三目，这逻辑也可以写成：</p>
<figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">regIn = reset == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-type">load</span> == <span class="hljs-number">1</span> ? <span class="hljs-keyword">in</span> : <span class="hljs-type">inc</span> == <span class="hljs-number">1</span> ? <span class="hljs-keyword">out</span> + <span class="hljs-number">1</span> : <span class="hljs-keyword"><span class="hljs-keyword">out</span></span><br></code></pre></div></td></tr></table></figure>

<p>每一个三目是一个 Mux，根据三目的结合性，<strong>首先</strong>计算<code>inc == 1 ? out + 1 : out</code>，然后是<code>load == 1 ? in : ...</code>，因此 inc 的结果要喂给 load…然后 load 的结果又喂给 reset…</p>
<p>其依赖的寄存器的 load 总是设为 1。</p>
<h1 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h1><p>机器语言是硬件和软件的边界，机器语言由一系列的机器指令组成，程序员利用这些指令去进行运算，读写内存，操作寄存器等。高级语言设计是为了更抽象、更接近人类思维和富有表达力，机器语言设计是为了直接和完全地控制特定硬件平台。虽然优雅和强大也是被期望的，但它们得在满足直接操作硬件的基本需求之后才考虑。</p>
<p>硬件和机器语言是相辅相成的，既可以说是为了特定的硬件去设计机器语言，也可以说是为了特定的机器语言去设计相应硬件。需要理解其中一个来理解另一个，但同时两者很大程度上可以是独立的，比如可以在实际构建某计算机之前，先用高级语言写个虚拟机器去执行该计算机的机器语言程序以提供一些感性经验，从而能更好地做出决策，无论是对机器还是对机器语言（指令集）（这实际上也是说，同一个机器语言能对应不同的底层实现）。机器语言是用户的视角，用户通过机器语言能看到该计算机究竟能做什么，有何具体的特性（specification）。</p>
<p>忘掉硬件实现的话，机器语言中主要有三个抽象：处理器，内存和寄存器。可以认为机器语言是一种商定好的形式，设计用来使用处理器和寄存器去维护内存。</p>
<h2 id="Hack-机指令集"><a href="#Hack-机指令集" class="headerlink" title="Hack 机指令集"></a>Hack 机指令集</h2><p>Hack 机把指令和数据的地址区分开，指令存在 ROM 中，数据存在 RAM 中。</p>
<p>Hack 机的机器语言中有三个寄存器——D，A，M，D 代表数据（这玩意只有一个寄存器可用？），A 代表（ROM 或 RAM 中的）地址，M 代表内存，具体来说，代表的是<code>RAM[A]</code>。</p>
<p>Hack 机中有两种指令，A 指令和 C 指令，A 指令语法形如<code>@value</code>，其中 value 为非负十进制数，或者一个标识特定常量的符号（就像某些语言中的 label，用来指定 break 和 goto 的对象的）。A 指令设置 A 寄存器，以<strong>选择</strong>相应的内存<code>RAM[A]</code>或者要跳转到的指令（即下一条要执行的指令）<code>ROM[A]</code>。</p>
<p>C 指令语法为：<code>[ dest &quot;=&quot; ] comp [&quot;;&quot; jump]</code>，（<code>[]</code>表示可选）其中 comp 指定一个计算，dest 表示计算后的值要送往的地址，jump 表示根据计算的结果进行相应的跳转操作。</p>
<p><img src="/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-6.png"></p>
<p>示例如：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">@<span class="hljs-number">300</span> <span class="hljs-comment">// A = 300 </span><br>M=D<span class="hljs-number">-1</span>; <span class="hljs-comment">// RAM[300] = D - 1</span><br><br>@<span class="hljs-number">42</span> <span class="hljs-comment">// A = 42</span><br>D<span class="hljs-number">-1</span>;JEQ <span class="hljs-comment">// if D - 1 == 0 then goto 42 </span><br></code></pre></div></td></tr></table></figure>

<p>A 指令以 0 开头，其后 15 位来标识一个值（因此其会小于等于 2 的 15 次方减 1）。</p>
<p>C 指令以 1 开头，然后两个 bit 没有使用，始终为 1，然后 7 个字节指示 comp，3 个字节 dest，3 个字节 jump。</p>
<p><img src="/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-8.png"></p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>总不能一辈子活在 debug 页面里唱独角戏，要真正地处理现实问题，就得处理输入和输出。在 Hack 机中，映射特定的内存区域给屏幕和键盘，通过读写这些内存区域来进行输入和输出。</p>
<p>屏幕是输出设备，其会根据相应的内存映射去持续地刷新屏幕，具体来说，屏幕是 512x256 像素的，每个像素只有黑和白，因此只需要 1bit 信息（规定 1 是黑，0 是白，和常识是反着的），因此我们需要<code>512x256/16=8192</code>个字（word，在 hack 机中是 16 bit），即 8192 长度的内存去映射屏幕的像素信息。</p>
<p>键盘是输入设备，其会持续地根据用户的按键去使用其对应的值刷新某寄存器，对于字符和数字，使用 ASCII（字母使用大写的），对于功能按键，使用大于等于 128 的值，无按键时值为 0。</p>
<h2 id="Hack-Programming"><a href="#Hack-Programming" class="headerlink" title="Hack Programming"></a>Hack Programming</h2><p>使用高级语言编程时，有变量，表达式，控制流等概念，使用机器语言编程时，同样要采用这些概念，但和高级语言中不同的是，这些玩意并非是语言本身直接提供的，而是需要像模式，片段，或者样板一样去应用，使用多条指令去实现高级语言中一个语句的效果。在实际编写代码时，可以使用伪代码先把逻辑表示出来，再给它用人脑翻译成机器语言。</p>
<h3 id="寄存器和内存"><a href="#寄存器和内存" class="headerlink" title="寄存器和内存"></a>寄存器和内存</h3><p>首先是和高级语言不同的，这里有 D 寄存器的概念，它是许多操作的中介，因为硬件限制没法直接在两块内存间做操作，需要借助 D 和 A。</p>
<p>下面是一些对 D 和内存的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// D = 10</span><br>@<span class="hljs-number">10</span><br>D=A<br><br><span class="hljs-comment">// D++</span><br>D=D+<span class="hljs-number">1</span> <span class="hljs-comment">// 这个是直接支持的</span><br><br><span class="hljs-comment">// D = RAM[17]</span><br>@<span class="hljs-number">17</span><br>D=M<br><br><span class="hljs-comment">// RAM[17] = 0</span><br>@<span class="hljs-number">17</span><br>M=<span class="hljs-number">0</span><br><br><span class="hljs-comment">// RAM[17] = 10</span><br>@<span class="hljs-number">10</span> <br>D=A <span class="hljs-comment">// 注意这里因为 A 同时用来存立即数和地址（和指令地址），需要把 10 给缓存一下</span><br>@<span class="hljs-number">17</span><br>M=D<br><br><span class="hljs-comment">// RAM[5] = RAM[3]</span><br>@<span class="hljs-number">3</span><br>D=M<br>@<span class="hljs-number">5</span><br>M=D<br><br><span class="hljs-comment">// RAM[2] = RAM[0] + RAM[1]</span><br>@<span class="hljs-number">0</span><br>D=M<br>@<span class="hljs-number">1</span><br>D=D+M<br>@<span class="hljs-number">2</span><br>M=D<br></code></pre></div></td></tr></table></figure>

<p>此外，程序需要能被正确终止，解决方案是在代码最后进行一个无限循环，利用 jmp 去做到这一点。注意跳转的地址（下一条要执行的指令的地址）需要被正确地给定。注意每一行代码会被作为 ROM 中的每一个指令，因此只需要看有代码的行数即可确认跳转地址，注意这是从 0 开始的。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 比如这是一个实际的程序</span><br>@<span class="hljs-number">0</span> <span class="hljs-comment">// 第 0 行</span><br>D=M<br><br>@<span class="hljs-number">1</span> <span class="hljs-comment">// 第 2 行</span><br>D=D+M<br><br>@<span class="hljs-number">2</span><br>M=D <span class="hljs-comment">// 第 5 行</span><br><br>@<span class="hljs-number">6</span> <span class="hljs-comment">// 第 6 行（用@7 也行）</span><br><span class="hljs-number">0</span>;JMP <span class="hljs-comment">// 第 7 行，下一条指令执行第 6 行</span><br></code></pre></div></td></tr></table></figure>

<p>但这里有两个问题：</p>
<ol>
<li>A 指令中，数据和地址混在一起了，这显然不是很好的编程习惯</li>
<li>指定指令地址时，需要检查代码文件的文本内容才能确定相应地址，这是及其离谱的，特别是在代码很长，有很多注释和空白时，我隔这敲 BASIC 呢？</li>
</ol>
<p>它们均有解决方案，对于第一个问题，使用符号 R0-R15 去指代内存地址 0-15，这些符号被用作“虚拟寄存器”，使用这些符号能清晰地表示当前 A 存的值是一个内存地址，其他时候存的是值。为什么是 16 个？因为它们只是为了存一些临时的值，所以不需要定义太多。（如果这些寄存器直接就在 CPU 里就更好了，但为了硬件实现简单起见……）</p>
<p>同样地，可以给一些具有特定意义的内存地址命名，比如屏幕和键盘，实际上它们确实有，<code>SCREEN=16384</code>，<code>KBD=24576</code>。</p>
<!-- 同时在编程时我们也会期待能够创建符号来标识我们想把某块内存区域当作变量使用，但不关心该内存区域的具体位置，幸运的是这个功能是有的，下面变量相关的部分会提到。 -->

<p>第二个问题的解决方案是添加类似高级编程语言中的 label 的语法，其不代表实际的指令，只用来标识该处的实际地址（并创建临时的名字供引用），在翻译时将其进行转换。</p>
<h3 id="分支逻辑"><a href="#分支逻辑" class="headerlink" title="分支逻辑"></a>分支逻辑</h3><p>首先是分支逻辑，机器语言中只有 goto，所以分支逻辑需要使用 goto 去实现。需要稍微思考一下。其中使用了上面说的类似 label 的语法，使用<code>(LABEL)</code>去声明 label 并在其他地方引用，翻译时转换成 label 的下一条指令的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">if R0 &gt; 0</span><br><span class="hljs-comment">  R1 = 1</span><br><span class="hljs-comment">else</span><br><span class="hljs-comment">  R1 = 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">R2 = R1</span><br><span class="hljs-comment">*/</span><br><br>@R0<br>D=M<br><br>@THEN_COND<br>D;JGT<br><span class="hljs-comment">// else 条件（即未成功跳转）</span><br>  @R1<br>  M=<span class="hljs-number">0</span><br><br>  @FOLLOWING<br>  <span class="hljs-number">0</span>;JMP<br>(THEN_COND)<br>  @R1<br>  M=<span class="hljs-number">1</span><br><br>(FOLLOWING)<br>@R1<br>D=M<br>@R2<br>M=D<br><br>(END)<br>@END<br><span class="hljs-number">0</span>;JMP<br><br></code></pre></div></td></tr></table></figure>

<p>if，if-else 均有其样板。首先是只有 if，诀窍是 if 语句后的逻辑 following 紧跟 then_body，如果条件检查成功，直接跳转到 following，否则走 then_body 的逻辑，然后自然而然走 following 逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">if (cond) &#123;</span><br><span class="hljs-comment">  then_body</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">following</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// </span><br>@THEN_BODY<br>cond;jmpStmt<br>@FOLLOWING<br><span class="hljs-number">0</span>;jmp<br>  (THEN_BODY)<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ...THEN BODY</span><br><span class="hljs-comment">  */</span><br>(FOLLOWING)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  ...following</span><br><span class="hljs-comment">*/</span><br><br></code></pre></div></td></tr></table></figure>

<p>if-else 是同样的，但可以先把 else_body 放前面，在检查失败后直接执行 else_body，然后再跳转到 following，then_body 放到 else_body 后，这样其执行完了就直接开始执行 following</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">if (cond) &#123;</span><br><span class="hljs-comment">  then_body</span><br><span class="hljs-comment">&#125; else &#123;</span><br><span class="hljs-comment">  else_body</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">following</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// </span><br><br>@THEN_BODY<br>cond;jmpStmt<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  else_body</span><br><span class="hljs-comment">  */</span><br>  @FOLLOWING<br>  <span class="hljs-number">0</span>;JMP<br>(THEN_BODY)<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    then_body</span><br><span class="hljs-comment">  */</span><br>(FOLLOWING)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  following</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>

<p>elseif 就有点整蛊，虽可以直接把 else 后面的 if 直接丢到 else 里，但这会造成太深的嵌套，非常难受。这时候不如按序检查每一个分支，检查成功则跳转到相应的逻辑，每个逻辑块最后都跳转到 FOLLOWING，else_body 紧跟在所有检查之后，并尾随一个跳转到 FOLLOWING。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">if (cond1) &#123;</span><br><span class="hljs-comment">  branch1</span><br><span class="hljs-comment">&#125; else if (cond2) &#123;</span><br><span class="hljs-comment">  branch2</span><br><span class="hljs-comment">&#125; else &#123;</span><br><span class="hljs-comment">  else_body</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">following</span><br><span class="hljs-comment">*/</span><br><br>@BRANCH1<br>cond1;jmpStmt<br>@BRANCH2<br>cond2;jmpStmt<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    else_body</span><br><span class="hljs-comment">  */</span><br>  @FOLLOWING<br>  <span class="hljs-number">0</span>;JMP<br><br>(BRANCH1)<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    branch1</span><br><span class="hljs-comment">  */</span><br>  @FOLLOWING<br>  <span class="hljs-number">0</span>;JMP<br>(BRANCH2)<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    branch2</span><br><span class="hljs-comment">  */</span><br>  @FOLLOWING<br>  <span class="hljs-number">0</span>;JMP<br><br>(FOLLOWING)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  following </span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>

<p>能注意到，分支逻辑都是向后跳转。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>考虑交换 R1 和 R0，藉由 R2：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// temp = R0</span><br>@R0<br>D=M<br>@R2<br>M=D<br><br><span class="hljs-comment">// R0 = R1</span><br>@R1<br>D=M<br>@R0<br>M=D<br><br><span class="hljs-comment">// R1 = temp</span><br>@R2<br>D=M<br>@R1<br>M=D<br></code></pre></div></td></tr></table></figure>

<p>问题在于，这里并不是必须要 R2，任意一块内存都可以，特意去指定某块内存会把人弄糊涂。好在 assembler 有一个 feature——如果发现某个名字是没有定义过的（即其并非是预定义的如 R0-R15，也并非被<code>(LABEL)</code>语法去创建），它会自动地去将其替换为一个特定的内存地址，使该名字总是指向同一片内存地址，同时不会和其他名字指向的内存地址重复（实际上每个首次出现的名字对应的内存地址就是从 16 开始递增）。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// temp = R0</span><br>@R0<br>D=M<br>@temp<br>M=D<br><br><span class="hljs-comment">// R0 = R1</span><br>@R1<br>D=M<br>@R0<br>M=D<br><br><span class="hljs-comment">// R1 = temp</span><br>@temp<br>D=M<br>@R1<br>M=D<br></code></pre></div></td></tr></table></figure>

<p>这就是“变量”，约定变量的名字是小驼峰。</p>
<p>使用变量而非绝对地址的另一个原因是，程序现在不必须放到 ROM 的开始位置了，放到任何位置都行，只要在进行翻译时正确处理各种名字映射的地址即可。这也允许同时加载多个程序。</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>考虑<code>1 + 2 + .. + 100</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">n = <span class="hljs-number">100</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + n<br>    n = n - <span class="hljs-number">1</span><br>R1 = n<br></code></pre></div></td></tr></table></figure>

<p>显然，while 可以用 goto 去模拟一下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">n = <span class="hljs-number">100</span><br>sum = <span class="hljs-number">0</span><br>(WHILE)<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>: <span class="hljs-keyword">goto</span> FOLLOWING<br>  sum = sum + n<br>  n = n - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">goto</span> WHILE<br>(FOLLOWING)<br>R1 = sum<br></code></pre></div></td></tr></table></figure>

<p>翻译后得到下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// sum 1 + 2 + .. + 100</span><br><br><span class="hljs-comment">// n = 100</span><br>@<span class="hljs-number">100</span><br>D=A<br>@n<br>M=D<br><br><span class="hljs-comment">// sum = 0</span><br>@<span class="hljs-number">0</span><br>D=A<br>@sum<br>M=D<br><br>(WHILE)<br><span class="hljs-comment">// if n &lt;= 0: goto FOLLOWING</span><br>@n<br>D=M<br>@FOLLOWING<br>D;JLE<br><br><span class="hljs-comment">// sum = sum + n</span><br>@sum<br>D=M<br>@n<br>D=D+M<br>@sum<br>M=D<br><br><span class="hljs-comment">// n = n - 1</span><br>@n<br>M=M<span class="hljs-number">-1</span><br><span class="hljs-comment">// goto WHILE</span><br>@WHILE <br><span class="hljs-number">0</span>;JMP<br><br>(FOLLOWING)<br><span class="hljs-comment">// R1 = sum</span><br>@sum<br>D=M<br>@R1<br>M=D<br></code></pre></div></td></tr></table></figure>

<h3 id="指针（数组）"><a href="#指针（数组）" class="headerlink" title="指针（数组）"></a>指针（数组）</h3><p>如果需要使用指针，一定会手动对 A 赋值。下面是设置内存地址 100-109 为-1 的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// for (i = 0; i &lt; 9; i++)</span><br><span class="hljs-comment">//    arr[i] = -1</span><br><br><span class="hljs-comment">// i = 0</span><br><span class="hljs-comment">// arr = 100</span><br><span class="hljs-comment">// n = 9</span><br><span class="hljs-comment">// addr = 0</span><br><span class="hljs-comment">// (LOOP)</span><br><span class="hljs-comment">// D = i</span><br><span class="hljs-comment">// D = D - n</span><br><span class="hljs-comment">// if D &gt; 0: goto END</span><br><span class="hljs-comment">//     D = arr</span><br><span class="hljs-comment">//     D = D + i</span><br><span class="hljs-comment">//     RAM[D] = -1</span><br><span class="hljs-comment">// (END)</span><br><br>@i<br>M=<span class="hljs-number">0</span><br><br>@<span class="hljs-number">100</span><br>D=A<br>@arr<br>M=D<br><br>@<span class="hljs-number">9</span><br>D=A<br>@n<br>M=D<br><br>@addr<br>M=<span class="hljs-number">0</span><br><br>(LOOP)<br>    <span class="hljs-comment">// D = i</span><br>    <span class="hljs-comment">// D = D - n</span><br>    <span class="hljs-comment">// if D &gt; 0: goto END</span><br>    @i<br>    D=M<br>    @n<br>    D=D-M<br><br>    @END<br>    D;JGT<br>    <br>    @arr<br>    D=M<br>    @i<br>    A=D+M<br>    <br>    M=<span class="hljs-number">-1</span><br><br>    @i<br>    M=M+<span class="hljs-number">1</span><br><br>    @LOOP<br>    <span class="hljs-number">0</span>;JMP<br>(END)<br>@END<br><span class="hljs-number">0</span>;JMP<br></code></pre></div></td></tr></table></figure>

<h1 id="Hack-机"><a href="#Hack-机" class="headerlink" title="Hack 机"></a>Hack 机</h1><p>计算机的工作是两个步骤的循环——Fetch，取指令，和 Execute，执行指令。</p>
<p>Fetch——（下一条指令的地址在上一个时钟周期中计算和设置，所以这周期能直接拿到指令的值）从 PC 中读下一条指令的地址，并从 program memory 中拿到指令的值并存储起来，而 Execute 根据当前的指令去读写 data memory，去读写寄存器，执行操作，维护 PC……</p>
<p>值得注意的是，<strong>冯诺依曼架构中，数据和程序是放一起的</strong>，因此只能要么取数据，要么取指令，不能同时做这两件事。但 Hack 机将数据和程序代码分离，因此可以在一个时钟周期内同时获取数据和指令，这让 CPU 的实现极其简单，任何指令均在一个时钟周期内完成，也就是说 Fetch 和 Execute 这两个步骤可以说是同时完成的。</p>
<p>如果指令不能在一个时钟周期内完成该怎么办？采用有限状态机的思想，最简单的方式是增加一个寄存器State，表示当前处于何种状态。</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>下面的内容很多可能仅限于 Hack 机。</p>
<p>CPU 主要有两个工作——执行指令，以及找到下一条要执行的指令。</p>
<p>CPU 要包含哪些“状态”呢？首先是 D 寄存器和 A 寄存器，寄存器要能够以最小代价去访问，以及 PC——要记录当前正在执行的指令的地址。实际上就这仨。</p>
<p>然后确认 CPU 的“入参”，CPU 需要知道下一条要执行的指令（本身），需要知道当前选择的内存的值（也就是 M，或者说<code>Memory[A]</code>），因此需要接受指令和内存值作为输入，此外还有一个 reset 输入要用来重置 PC 为 0。</p>
<p>“返回值”呢？CPU 需要且唯一需要对外部进行的操作就是把当前的结果写内存，因此 CPU 需要把当前的计算结果给传递出来；但要注意当前的计算结果总是会传递出来的，但目的地不一定是内存，因此需要一个标志位去标识当前是否意图写内存；此外，CPU 需要把当前的内存地址和指令地址告知 RAM 和 ROM 以让它们把数据和指令传给 CPU，因此这些也需要输出（注意从 RAM，ROM 中读数据是组合逻辑，马上就能看到结果的）。</p>
<p><img src="/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/image-10.png"></p>
<p>CPU 的实际实现是这样，其中 C 指的是各种控制位。根据这张图已足够去把 CPU 实现出来了。注意其中每个组件都接受一些控制位。PC 相关的部分为所谓的控制器。</p>
<p><img src="/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU/cpuArchi.png"></p>
<p>但不要这张图，也能把 CPU 给弄出来，已知 CPU 的“签名”和“状态”，只要解决下面的问题即可，而它们的答案基本全藏在指令的结构里（这也证明底层实现和指令集设计的相关性……）：</p>
<ol>
<li>A 指令是如何处理的？C 指令是如何处理的？</li>
<li>ALU 的入参是谁？ALU 的计算结果需要传递给谁？</li>
<li>PC 输出给谁？平常的逻辑是什么，如何实现？什么情况下才进行跳转？为了实现跳转，PC 的入参应当是谁？</li>
</ol>
<p>问题一，A 指令和 C 指令通过最高位去区分，A 指令会直接设置 A 寄存器，所以指令输入需要直接连接 A 寄存器，但同时意识到 A 寄存器也是 ALU 的输出对象，因此这里需要一个 Mux。同时注意在处理 A 指令中，指令是当作数据去处理的，它的每一位都没有任何特殊含义，因此在处理 A 指令时，需要把所有的控制位给它 disable 掉再传递给各个组件。</p>
<p>问题二，ALU 的入参根据指令的定义，D 是且一定是第一个入参，而第二个入参通过 a 标识符去区分是 M 还是 A，因此 D 寄存器直接连接 ALU，M（即输入的 inM）和 A 寄存器需要通过 Mux 去连接 ALU；指令的目的地为 A、M 和 D，因此 A 寄存器，D 寄存器和 outM 是 ALU 的输出。</p>
<p>问题三，PC 指示下一条要执行的指令，因此它要把当前指令地址给传出去，因此输出给 pc。平常的逻辑为自增，因此 inc 要始终设为 true（根据 PC 的性质，如果 load 为 true 或 reset 为 true 能够覆盖掉 inc，因此这样操作是没问题的）；当判断 ALU 的 zr，ng 标识符和当前指令的 3 个 jmp 位相匹配时（实现这玩意就能意识到为啥 jmp 位要那样设计了），就需要进行跳转操作了，此时要将 load 设为 true；跳转会重设当前地址为 A 寄存器的输出，因此 A 寄存器的输出要作为 PC 的输入。此外，reset 的逻辑也是和 PC 相关的——把程序计数器的值置为 0，所以 reset 也直接连给 PC。</p>
<p>这些已足够。</p>
<h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>ROM 是组合逻辑，接受地址，返回指令，没啥可说的。</p>
<h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p>实现 RAM 也能让人意识到为何内存，屏幕和键盘的地址要那样设计，RAM 的地址长度为 15bit，即允许寻址<code>2^15=32768</code>个地址，但只有<code>2^14=16384</code>个地址是 RAM 的，<strong>随后</strong><code>2^13=8192</code>个地址分配给 SCREEN，<strong>随后</strong> 1 个地址分配给 KBD。因此实现 RAM 时需要明确当前是在读写 RAM 还是 SCREEN，还是在读 KBD。</p>
<p>如何区分？容易发现，<strong>对所有 RAM 的地址，它的前两位为 0，RAM 最后一个地址的后面所有位为 1；对于 SCREEN 的地址，它的最高位为 0，第二位为 1，SCREEN 最后一个地址的后面所有位为 1；对于 KBD，它前两位均为 1，剩下为 0</strong>。用一个 Mux4Way16 就能区分了。</p>
<h2 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h2><p>没啥说的。</p>
<!-- 
TODO TODO TODO
## 信息流，总线

内存，寄存器，ALU，PC，将它们联系到一起的是信息流，即从他们之间传递信息。信息有三种：数据——当前要计算的数据，地址——当前执行的指令的地址，要取数据的地址……，和控制——这个特定的时间点要做什么。信息流对应的物理结构是总线，因此这三种信息都有对应的总线。

想象这些组件之间的连接时不要想着它们直接相连，而是想象着它们藉由总线相连，这更接近实际。

研究每个组件会连接哪些总线（即需要读写该总线），就能对各组件之间的关系更加清楚，方便地构建计算机。

![](image-9.png)

首先是 ALU，ALU 需要读数据，需要写数据，同时需要根据当前的指令去决定具体要进行的操作，并根据执行结果去决定下一步要执行的操作（条件跳转），因此 ALU 需要读写数据总线和控制总线。

然后是寄存器，寄存器也要决定是读还是写，处理哪个寄存器，因此需要读控制总线，寄存器会喂给 ALU 数据，喂给内存地址，同时要从数据总线中读值，因此要读写数据总线，写地址总线，

内存也需要决定当前是读是写，因此需要读控制总线，需要知道要读写哪个内存地址，因此需要读地址总线，需要把内存中的值送出去，又需要读值来设置内存，因此需要读写数据总线。

## Fetch Execute Cycle

计算机工作的每个时钟周期的工作是——Fetch，取指令，和 Execute，执行指令。

Fetch——（下一条指令的地址在上一个时钟周期中计算和设置，所以这周期能直接拿到指令的值）从 PC 中读下一条指令的地址，并从 program memory 中拿到指令的值并存储起来，而 Execute 根据当前的指令去读写 data memory，去读写寄存器，执行操作，维护 PC……

值得注意的是，**冯诺依曼架构中，数据和程序是放一起的**，因此在传地址给内存的时候要用一个 Mux 去区分当前是取数据还是取指令。哈佛架构这俩是分离的。

---

问题——真实的架构中如何处理 IO

问题——在当前的同一套 ALU 下，可以有多套机器语言（指令集）的实现吗？ALU 的指令和机器语言中的指令有何区别？ 

-->

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-NC-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/02-06%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part2%E2%80%94%E2%80%94%E4%BB%8E%E6%B1%87%E7%BC%96%E5%99%A8%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机系统要素学习笔记 Part2——从汇编器到虚拟机</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01-06%E7%90%86%E8%A7%A3pratt_parsing.html">
                        <span class="hidden-mobile">理解 Pratt parsing——自顶向下算符优先解析法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start -->
<script src="/assets/prism-bundle.js"></script>
<script src="/assets/prism-plus.js" data-pjax=""></script>
<!-- hexo injector body_end end --></body>
</html>
