

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="友纪V-λOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="写篇笔记记录一下对 pratt parsing 的心智模型，这玩意需要的代码量很少，但理解难度上天，给我看了快两三天才稍微有点明白，还是得做点笔记记录一下，这大概是我回炉次数最多的笔记，反反复复调整代码结构和文字描述以保证清晰……最终效果还是比较满意的。感觉应上了那句老话——先把书读厚，再把书读薄。">
<meta property="og:type" content="article">
<meta property="og:title" content="理解 Pratt parsing——自顶向下算符优先解析法">
<meta property="og:url" content="http://example.com/2024/01-06%E7%90%86%E8%A7%A3pratt_parsing.html">
<meta property="og:site_name" content="友纪V-λOP">
<meta property="og:description" content="写篇笔记记录一下对 pratt parsing 的心智模型，这玩意需要的代码量很少，但理解难度上天，给我看了快两三天才稍微有点明白，还是得做点笔记记录一下，这大概是我回炉次数最多的笔记，反反复复调整代码结构和文字描述以保证清晰……最终效果还是比较满意的。感觉应上了那句老话——先把书读厚，再把书读薄。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-01-06T05:00:00.000Z">
<meta property="article:modified_time" content="2024-01-06T05:37:09.855Z">
<meta property="article:author" content="友纪V-λOP">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>理解 Pratt parsing——自顶向下算符优先解析法 - 友纪V-λOP</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="友纪V-λOP" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>友纪V-λOP的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="理解 Pratt parsing——自顶向下算符优先解析法">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-01-06 13:00" pubdate>
        2024年1月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      33k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">理解 Pratt parsing——自顶向下算符优先解析法</h1>
            
            <div class="markdown-body">
              <p>写篇笔记记录一下对 pratt parsing 的心智模型，这玩意需要的代码量很少，但理解难度上天，给我看了快两三天才稍微有点明白，还是得做点笔记记录一下，这大概是我回炉次数最多的笔记，反反复复调整代码结构和文字描述以保证清晰……最终效果还是比较满意的。感觉应上了那句老话——先把书读厚，再把书读薄。</p>
<p>关于 pratt parsing 的实际业务流程，主要是参考了 <a target="_blank" rel="noopener" href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html">这篇文章</a>。建立心智模型时部分地采用了这篇文章的 BP 概念，但没有使用 BP 表示结合性，因此要求运算符两边的 BP 是相同的，因此 BP 在这里实际上就是所谓的优先级。另外这篇文章的实现过于难懂了，loop 里面的各种 break 试图搅拌我的脑子，但实际的业务流程是能够更简单地去表示的。</p>
<p>关于 parselet，主要是参考了 <a target="_blank" rel="noopener" href="https://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">这篇文章</a>，但并没有上来就引入 parselet 的概念，发现那样操作实在有点让人难懂…而且这篇文章没有提及前缀运算符的优先级。</p>
<p>循序渐进，首先实现对优先级的支持，然后是结合性的支持；然后，依次添加前缀，后缀，括号，取数组，三目的支持；这时代码已经乱成渣滓了，因此进行相应抽象，引入 parselet 的概念，将各运算符的逻辑抽离出来，再次实现之前已经实现的部分；最后另外使用栈去实现一下四则运算表达式的计算，因为其思想和 pratt 是基本一致的，而我之前从来没理解过那玩意是怎么操作。</p>
<p>完整的实现代码在最后。</p>
<hr>
<p>pratt parsing，即自顶向下算符优先解析法，是一种特别适用于解析表达式的解析法，它能轻易地使用表去表示各算符的优先级和结合性，同时也能够很容易引入各种复杂的算符比如三目，数组索引等。理解 pratt parsing 我感觉有两个关键：</p>
<ol>
<li>读取任意表达式时，根据 token 出现的位置和 token 的类型，我们马上就能识别出它是什么类型，属于哪个语法树节点，比如<code>1 + 2</code>，读到<code>1</code>后，我们马上就能知道这将是某操作符的左操作数，接下来要读一个中缀操作符（如果没到 EOF 的话）；比如<code>-1 + 2</code>，看到一个<code>-</code>，我们马上就知道这是一个前缀操作符，后面要读一个表达式</li>
<li>（这点是 pratt parsing 的精髓吧？）在尝试获取某操作符的右操作数的时候，对于可能的右操作数，只需要比较它右边的操作符的优先级和该操作符的优先级即可确认它是该操作符的右操作数还是它右边操作符的左操作数。这么说有点晦涩，但这个性质造成的特性是，<strong>某操作符的右操作数，是该操作符右边所有优先级高于该操作符的部分，获取这部分后就能为该操作符建立语法树；如果该操作符右边的第一个操作符的优先级比自己低，那右操作数就是下一个 token，马上就可以建立相应的语法树</strong>，这是说，<code>1 + 2 * 3 ^ 4 * 5 + 6 = (1 + (2 * 3 ^ 4 * 5)) + 6</code>，而<code>1 * 2 - 1  = (1 * 2) - 1 </code>，理解这一点，就能够理解下面的第一版 pratt</li>
</ol>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>先无视结合性，且只考虑中缀操作符。考虑下面的表达式，<code>^</code>为指数运算，优先级比<code>*</code>高：</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>+ <span class="hljs-number">2</span> * <span class="hljs-number">3</span> ^ <span class="hljs-number">4</span> <br></code></pre></div></td></tr></table></figure>

<p>如何解析它呢？作为人类，我们知道，<code>^</code>优先级最高，所以先把<code>3 ^ 4</code> 括起来，<code>*</code> 优先级次之，所以再把<code>2 * (3 ^ 4)</code> 括起来，然后是<code>+</code>，然后是<code>@</code>（假设它优先级比<code>+</code>低），总之添加括号是这个顺序：</p>
<figure class="highlight haxe"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-number">1</span> + <span class="hljs-number">2</span> * <span class="hljs-number">3</span> ^ <span class="hljs-number">4</span> <span class="hljs-meta">@ 5</span><br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> * (<span class="hljs-number">3</span> ^ <span class="hljs-number">4</span>) <span class="hljs-meta">@ 5</span><br><span class="hljs-number">1</span> + (<span class="hljs-number">2</span> * (<span class="hljs-number">3</span> ^ <span class="hljs-number">4</span>)) <span class="hljs-meta">@ 5</span><br>(<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> * (<span class="hljs-number">3</span> ^ <span class="hljs-number">4</span>))) <span class="hljs-meta">@ 5</span><br>((<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> * (<span class="hljs-number">3</span> ^ <span class="hljs-number">4</span>))) <span class="hljs-meta">@ 5)</span><br></code></pre></div></td></tr></table></figure>

<p>但计算机不是人，更擅长从左往右看，模仿计算机该怎样进行操作呢？首先把优先级规定一下，规定<code>@</code>，<code>+</code>，<code>*</code>，<code>^</code>优先级分别为 1，2，3，4，然后把优先级标在操作数和操作符之间：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> + <span class="hljs-number">2</span> * <span class="hljs-number">3</span> ^ <span class="hljs-number">4</span> @ <span class="hljs-number">5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">7</span><br> <span class="hljs-attribute">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>

<p>假装自己是计算机，从左往右读，首先看到<code>1</code>和<code>+</code>，马上能够明白，<code>1</code> 是 <code>+</code> 的左操作数，于是，<strong>现在的问题是找到 <code>+</code> 的右操作数</strong>。</p>
<p>但这里已知<code>1</code>要和<code>+</code>结合，所以这里可以预先加上一个<code>(</code>（别真加！）：</p>
<figure class="highlight tap"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">(1 +<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 3 </span>^<span class="hljs-number"> 4 </span>@<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>* 7<br> <span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>3<span class="hljs-number"> 4 </span>4<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>3<br></code></pre></div></td></tr></table></figure>

<p><strong>加一个括号表示建立了部分语法树节点，第一个 token 是左操作数，第二个 token 是操作符</strong>。</p>
<p>继续读，发现读到一个<code>2</code>，后面跟着一个<code>*</code>。然后这时候就要问，<code>2</code>是<code>+</code>的右操作数吗，或者说，<code>2</code>和<code>+</code>结合吗？不是，<code>*</code>的优先级高于<code>+</code>，所以<code>2</code>将首先和<code>*</code>结合。</p>
<p>ok，知道 2 要和<code>*</code>结合，我们首先可以在<code>+</code> 的右边加上一个<code>(</code>了：</p>
<figure class="highlight tap"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">(1 + (2 *<span class="hljs-number"> 3 </span>^<span class="hljs-number"> 4 </span>@<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>* 7<br> <span class="hljs-number"> 2 </span>2 <span class="hljs-number"> 3 </span>3<span class="hljs-number"> 4 </span>4<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>3<br></code></pre></div></td></tr></table></figure>

<p>光看 <code>2 * 3 ^ 4 @ 5</code>，我们已经读到<code>2</code>和<code>*</code>，<strong>现在的问题是找到 <code>*</code> 的右操作数</strong>。能直接猴急地马上把<code>2 * 3</code> 给括起来吗？不行，这需要首先确认<code>3</code> 要和 <code>*</code> 结合，我们继续读，发现<code>3</code>右边是个<code>^</code>，<code>^</code>优先级高于<code>*</code>，所以 3 和<code>^</code>结合，又得在<code>*</code>的右边再括一个括号了：</p>
<figure class="highlight tap"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">(1 + (2 * (3 ^<span class="hljs-number"> 4 </span>@<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>* 7<br><span class="hljs-number"> 2 </span>2 <span class="hljs-number"> 3 </span>3  <span class="hljs-number"> 4 </span>4<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>3<br></code></pre></div></td></tr></table></figure>

<p>光看 <code>3 ^ 4 @ 5</code>，已经读到了<code>3</code>和<code>^</code>，<strong>现在的问题是找到 <code>^</code> 的右操作数</strong>，需要确认<code>4</code>是否是和<code>^</code>结合，能发现<code>4</code>右边是<code>@</code>，优先级比<code>^</code>低，所以<code>4</code>和<code>^</code>结合，我们找到了<code>^</code>的右操作数。</p>
<p>找到了<code>^</code>的左右操作数，<strong>我们可以建立<code>^</code>相应的语法树节点了</strong>：</p>
<figure class="highlight tap"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">(1 + (2 * (3 ^ 4) @<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>* 7<br></code></pre></div></td></tr></table></figure>

<p><strong>一对括号表示创建了一个完整的语法树节点</strong>，在这里我们为<code>3 ^ 4</code>创建了相应语法树节点。</p>
<p>把<code>3 ^ 4</code> 括起来后，我们又发现我们找到了<code>*</code>的右操作数了（即语法树节点<code>3 ^ 4</code>），<strong>我们可以建立<code>*</code>相应的语法树节点了</strong>：</p>
<figure class="highlight clojure"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clojure">(<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> * (<span class="hljs-number">3</span> ^ <span class="hljs-number">4</span>)) @ <span class="hljs-number">5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure>

<p>把 <code>2 * (3 ^ 4)</code> 括起来，我们又发现这个节点是<code>+</code> 的右操作数了。</p>
<p>这就回答了上面的第一个问题——求<code>+</code> 的右操作数，求了<code>+</code>的右操作数之后，再做什么？当然是再建立<code>+</code>相应的语法树节点了，再括一个：</p>
<figure class="highlight tap"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">(1 + (2 * (3 ^ 4))) @<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>* 7<br></code></pre></div></td></tr></table></figure>

<p>问的第一个问题已经被回答了，但解析还没结束——建立了语法树<code>(1 + (2 * (3 ^ 4)))</code>，但还有<code> @ 5 + 6 * 7</code>没处理呢。将已经处理完的语法树写作 X（它已经是“原子”的了），现在表达式写作：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">X</span> @ <span class="hljs-number">5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">7</span><br> <span class="hljs-attribute">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>

<p>问题又变为解析该表达式。从左往右读，首先看到 X 和<code>@</code>，我们又开始问问题了，<code>@</code>的右操作数是什么……</p>
<p>再考虑另一个表达式，<code>1 + 2 + 3 + 4</code>，它读到一个 1，给它暂存作为 X：</p>
<figure class="highlight nginx"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">X</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span><br> <span class="hljs-regexp"> ^</span><br>where x = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>

<p>然后继续读，读到一个<code>+</code>，马上明白，X 是<code>+</code>的左操作数，于是问，<code>+</code>的右操作数是什么？往前一看，是<code>2</code>，ok，建立语法树<code>(X + 2)</code>，并再次命名为 X：</p>
<figure class="highlight nginx"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">X</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span><br> <span class="hljs-regexp"> ^</span><br>where x = (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure>

<p>然后继续……</p>
<figure class="highlight nginx"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">X</span> + <span class="hljs-number">4</span><span class="hljs-regexp"></span><br><span class="hljs-regexp">^</span><br>where x = ((<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) + <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure>

<p>后面不用描述了，注意这操作和在递归下降法中解析左结合的操作符是基本一样的。</p>
<p>如何理解特定某一趟的行为呢？可以认为，每一次求右操作数时，它把所有<strong>高于上一操作符优先级的部分</strong>全都给括起来了，然后当成黑箱返回过来：</p>
<figure class="highlight tap"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">对于<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 3 </span>^<span class="hljs-number"> 4 </span>@<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 7 </span>@ 1<br><br>         <span class="hljs-number"> 3 </span>^ 4<br>    <span class="hljs-number"> 2 </span>* -------         * 7<br>1 + ------------     + 6<br>                 @<span class="hljs-number"> 5 </span>        @ 1<br><br></code></pre></div></td></tr></table></figure>

<p>求到右操作数后，建立语法树，把当前结果暂存，继续进行该操作（就像一个循环）：</p>
<figure class="highlight ada"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">           * <span class="hljs-number">7</span><br>       + <span class="hljs-number">6</span> <span class="hljs-comment">---</span><br>X @ <span class="hljs-number">5</span> <span class="hljs-comment">--------  @ 1</span><br><br></code></pre></div></td></tr></table></figure>

<p>能发现，在寻找右操作数时，所有优先级比该操作符高的操作符及相关操作数会作为右操作数的一部分，比如<code>1 + 2 * 3 ^ 4 @ 5</code>，能直接发现<code>+</code>的右操作数是<code>(2 * 3 ^ 4)</code>，而对于<code>1 + 2 @ 3</code>，右操作数是 2。</p>
<p>能发现，<strong>只需要记住上一个操作符的优先级，我们能从表达式的任意位置开始进行解析</strong>。</p>
<p>伪代码表示或许会是这样（假设这里是解析它，因此目标是生成 AST）：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">algo</span>(<span class="hljs-params">lexer, lastOp = ZERO_PRECEDENCE_OP</span>):<br>  x = Expr.<span class="hljs-type">Literal</span>(lexer.nextAtom())<br>  <span class="hljs-keyword">while</span> currentOpPrecedenceHigherThan(lastOp):<br>    op = lexer.nextOp()<br>    right = algo(lexer, op)<br>    x = Expr.Binary(op, x, right)<br>  <span class="hljs-keyword">return</span> x<br></code></pre></div></td></tr></table></figure>

<p><strong>algo 的行为是解析表达式中优先级高于特定优先级的部分</strong>。lastOp 的缺省值 ZERO_PRECEDENCE_OP 怎么理解呢？约定所有操作符的优先级都大于 0，因此初始的上一个操作符设为 0 就能保证把整个表达式都读进去了，也就是说<strong>对于第一趟 algo，while 的条件总为真</strong>。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了学习方便，定义一个很糙的 Lexer，规定所有 Token 均为单字符，Atom 形如<code>/[a-zA-Z0-9]/</code>，其它的认为是 Op。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">AtomToken</span> = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ATOM&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">OpToken</span> = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-built_in">string</span>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">EofToken</span> = &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Token</span> = <span class="hljs-title class_">AtomToken</span> | <span class="hljs-title class_">OpToken</span> | <span class="hljs-title class_">EofToken</span><br><br><span class="hljs-keyword">function</span> tokenMatch&lt;T&gt;(<span class="hljs-attr">token</span>: <span class="hljs-title class_">Token</span>, <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Partial</span>&lt;&#123;<span class="hljs-attr">ATOM</span>: <span class="hljs-function">(<span class="hljs-params">t: AtomToken</span>) =&gt;</span> T, <span class="hljs-attr">OP</span>: <span class="hljs-function">(<span class="hljs-params">t: OpToken</span>) =&gt;</span> T, <span class="hljs-attr">EOF</span>: <span class="hljs-function">(<span class="hljs-params">t: EofToken</span>) =&gt;</span> T&#125;&gt;) &#123;<br>  <span class="hljs-keyword">if</span> (!fn[token.<span class="hljs-property">type</span>]) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`pattern match failed, type: <span class="hljs-subst">$&#123;token.<span class="hljs-keyword">type</span>&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> (fn[token.<span class="hljs-property">type</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)(token)<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Lexer</span> = &#123;<br>  <span class="hljs-title function_">next</span>(): <span class="hljs-title class_">Token</span>,<br>  <span class="hljs-title function_">peek</span>(): <span class="hljs-title class_">Token</span>,<br>  <span class="hljs-title function_">nextAtom</span>(): <span class="hljs-title class_">AtomToken</span><br>  <span class="hljs-title function_">nextOp</span>(): <span class="hljs-title class_">OpToken</span><br>  <span class="hljs-title function_">peekAtom</span>(): <span class="hljs-title class_">AtomToken</span>,<br>  <span class="hljs-title function_">peekOp</span>(): <span class="hljs-title class_">OpToken</span><br>  <span class="hljs-title function_">isAtEnd</span>(): <span class="hljs-built_in">boolean</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkLexer</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Lexer</span> &#123;<br>  <span class="hljs-keyword">const</span> tokens = source.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span>!<span class="hljs-regexp">/\s/</span>.<span class="hljs-title function_">test</span>(c))<br>    .<span class="hljs-property">map</span>&lt;<span class="hljs-title class_">Token</span>&gt;(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-regexp">/[a-zA-Z0-9]/</span>.<span class="hljs-title function_">test</span>(c) ? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ATOM&#x27;</span>, <span class="hljs-attr">literal</span>: c &#125; : &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: c&#125;)<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-params">token: Token, <span class="hljs-keyword">type</span>: Token[<span class="hljs-string">&#x27;type&#x27;</span>]</span>): <span class="hljs-built_in">any</span> &#123;<br>    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> != <span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Expect <span class="hljs-subst">$&#123;<span class="hljs-keyword">type</span>&#125;</span>, got <span class="hljs-subst">$&#123;token.<span class="hljs-keyword">type</span>&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> token<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> tokens.<span class="hljs-title function_">shift</span>() ?? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> tokens[<span class="hljs-number">0</span>] ?? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    next,<br>    peek,<br>    <span class="hljs-title function_">nextAtom</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">next</span>(), <span class="hljs-string">&#x27;ATOM&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">nextOp</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">next</span>(), <span class="hljs-string">&#x27;OP&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">peekAtom</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">peek</span>(), <span class="hljs-string">&#x27;ATOM&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">peekOp</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">peek</span>(), <span class="hljs-string">&#x27;OP&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">isAtEnd</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> tokens.<span class="hljs-property">length</span> == <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Expr</span> = (&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LITERAL&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">AtomToken</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">OpToken</span>, <span class="hljs-attr">left</span>: <span class="hljs-title class_">Expr</span>, <span class="hljs-attr">right</span>: <span class="hljs-title class_">Expr</span><br>&#125;) &amp; &#123; <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span> &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkBinary</span>(<span class="hljs-params">op: OpToken, left: Expr, right: Expr</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, op, left, right, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">$&#123;left.toString()&#125;</span> <span class="hljs-subst">$&#123;op.op&#125;</span> <span class="hljs-subst">$&#123;right.toString()&#125;</span>)`</span><br>  &#125;&#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkLiteral</span>(<span class="hljs-params">value: AtomToken</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LITERAL&#x27;</span>, value, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> value.<span class="hljs-property">value</span> &#125; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>然后，实现上面的 algo 函数，这里为它取名叫 expr，这里同时定义了各运算符的优先级，获取优先级的函数同时要传入操作符的位置，因为同一个操作符在不同位置可以拥有不同优先级：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">OpDef</span> = &#123;<span class="hljs-attr">token</span>: <span class="hljs-title class_">OpToken</span>, <span class="hljs-attr">precedence</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span> | <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-attr">position</span>: <span class="hljs-string">&#x27;postfix&#x27;</span> | <span class="hljs-string">&#x27;infix&#x27;</span> | <span class="hljs-string">&#x27;prefix&#x27;</span>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">ZERO_OP_DEF</span>: <span class="hljs-title class_">OpDef</span> = &#123; <span class="hljs-attr">precedence</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-attr">position</span>: <span class="hljs-string">&#x27;infix&#x27;</span>, <span class="hljs-attr">token</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;ZERO&#x27;</span> &#125; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">opDef</span>(<span class="hljs-params">token: OpToken, position: OpDef[<span class="hljs-string">&#x27;position&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, assoc: OpDef[<span class="hljs-string">&#x27;assoc&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;token, precedence, assoc, position&#125;<br>  &#125;<br>  <span class="hljs-keyword">switch</span> (position) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;infix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ZERO&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">ZERO_OP_DEF</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;R&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">break</span><br>  &#125;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`unknown <span class="hljs-subst">$&#123;position&#125;</span> operator: <span class="hljs-subst">$&#123;token.op&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">precedenceHigherThan</span>(<span class="hljs-params">lexer: Lexer, lastOp: OpDef</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> currentOp = <span class="hljs-title function_">opDef</span>(lexer.<span class="hljs-title function_">peekOp</span>(), <span class="hljs-string">&#x27;infix&#x27;</span>)<br>  <span class="hljs-keyword">return</span> currentOp.<span class="hljs-property">precedence</span> &gt; lastOp.<span class="hljs-property">precedence</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOpDef: OpDef = ZERO_OP_DEF</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">mkLiteral</span>(lexer.<span class="hljs-title function_">nextAtom</span>())<br>  <span class="hljs-keyword">while</span> (<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOpDef)) &#123;<br>    <span class="hljs-keyword">const</span> op = lexer.<span class="hljs-title function_">nextOp</span>()<br>    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">expr</span>(lexer, <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;infix&#x27;</span>))<br>    x = <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>  &#125;<br>  <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">parseAndPrint</span> = (<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">expr</span>(<span class="hljs-title function_">mkLexer</span>(str)).<span class="hljs-title function_">toString</span>())<br><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2&quot;</span>) <span class="hljs-comment">// (1 + 2)</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 * 3&quot;</span>) <span class="hljs-comment">// (1 + (2 * 3))</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 * 3 ^ 4&quot;</span>) <span class="hljs-comment">// (1 + (2 * (3 ^ 4)))</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 * 3 ^ 4 @ 5&quot;</span>) <span class="hljs-comment">// ((1 + (2 * (3 ^ 4))) @ 5)</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 @ 3&quot;</span>) <span class="hljs-comment">// ((1 + 2) @ 3)</span><br></code></pre></div></td></tr></table></figure>

<h1 id="结合性"><a href="#结合性" class="headerlink" title="结合性"></a>结合性</h1><p>优先级能处理了，那结合性呢？看看当前的实现的结合性是怎样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 + 3&quot;</span>) <span class="hljs-comment">// ((1 + 2) + 3)</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 ^ 2 ^ 3&quot;</span>) <span class="hljs-comment">// ((1 ^ 2) ^ 3)</span><br></code></pre></div></td></tr></table></figure>

<p>看上去是左结合，将优先级检查中<code>currentOp.precedence &gt; op.precedence</code>的<code>&gt;</code>改为<code>&gt;=</code>能得到右结合的结果，因此，只需要调整比较优先级的逻辑即可实现结合性：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">precedenceHigherThan</span>(<span class="hljs-params">lexer: Lexer, lastOp: OpDef</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> currentOp = <span class="hljs-title function_">opDef</span>(lexer.<span class="hljs-title function_">peekOp</span>(), <span class="hljs-string">&#x27;infix&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (currentOp.<span class="hljs-property">precedence</span> != lastOp.<span class="hljs-property">precedence</span>) &#123;<br>    <span class="hljs-keyword">return</span> currentOp.<span class="hljs-property">precedence</span> &gt; lastOp.<span class="hljs-property">precedence</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (currentOp.<span class="hljs-property">assoc</span> != lastOp.<span class="hljs-property">assoc</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`同一优先级两运算符 <span class="hljs-subst">$&#123;currentOp.token.op&#125;</span>, <span class="hljs-subst">$&#123;lastOp.token.op&#125;</span> 有不同结合性！`</span>)<br>  &#125;<br>  <span class="hljs-comment">// 对于 1 + 2 + 3，+是左结合，认为右边（current）的+优先级小于左边（last）的+</span><br>  <span class="hljs-comment">// 所以左结合要返回 false</span><br>  <span class="hljs-keyword">return</span> currentOp.<span class="hljs-property">assoc</span> === <span class="hljs-string">&#x27;L&#x27;</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 + 2 + 3&quot;</span>) <span class="hljs-comment">// ((1 + 2) + 3)</span><br><span class="hljs-title function_">parseAndPrint</span>(<span class="hljs-string">&quot;1 ^ 2 ^ 3&quot;</span>) <span class="hljs-comment">// (1 ^ (2 ^ 3))</span><br></code></pre></div></td></tr></table></figure>

<h1 id="前缀操作符"><a href="#前缀操作符" class="headerlink" title="前缀操作符"></a>前缀操作符</h1><p>然后实现前缀和中缀操作符，关于这两种操作符的性质，参考一下 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">js 的相关文档</a>，一般来说前缀和中缀的操作符的优先级都要比中缀的高。</p>
<p>如何理解前缀运算符？<strong>前缀运算符就像是一个没有左操作符的中缀操作符</strong>，比如<code>-1 + 2</code>，理解为<code>X - 1 + 2</code>，前缀运算符也有其优先级，它优先级比幂运算低，也就是说<code>-2 ^ 3 = - (2 ^ 3)</code>。要处理前缀运算符，需要修改第一次读取 x 时的逻辑——如果为 op，走前缀运算符逻辑，否则走原逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 添加新 Expr Prefix……</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">opDef</span>(<span class="hljs-params">token: OpToken, position: OpDef[<span class="hljs-string">&#x27;position&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, assoc: OpDef[<span class="hljs-string">&#x27;assoc&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;token, precedence, assoc, position&#125;<br>  &#125;<br>  <span class="hljs-keyword">switch</span> (position) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;prefix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;R&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;infix&#x27;</span>:<br>      <span class="hljs-comment">/* ... */</span><br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`unknown <span class="hljs-subst">$&#123;position&#125;</span> operator: <span class="hljs-subst">$&#123;token.op&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOpDef: OpDef = ZERO_OP_DEF</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">tokenMatch</span>(lexer.<span class="hljs-title function_">next</span>(), &#123;<br>    <span class="hljs-title function_">ATOM</span>(<span class="hljs-params">t</span>) &#123;<br>      <span class="hljs-comment">// 原逻辑</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkLiteral</span>(t)<br>    &#125;,<br>    <span class="hljs-title function_">OP</span>(<span class="hljs-params">op</span>) &#123;<br>      <span class="hljs-keyword">const</span> def = <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;prefix&#x27;</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkPrefix</span>(op, <span class="hljs-title function_">expr</span>(lexer, def))<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">while</span> (<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOpDef)) &#123;<br>    <span class="hljs-keyword">const</span> op = lexer.<span class="hljs-title function_">nextOp</span>()<br>    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">expr</span>(lexer, <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;infix&#x27;</span>))<br>    x = <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>  &#125;<br>  <span class="hljs-keyword">return</span> x<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<p>实践可以发现，前缀操作符的优先级<strong>只会改变它右边的表达式的解析顺序，它不关心当前的 lastOp</strong>。同时，前缀操作符的结合性是无关紧要的——无论是什么结合性，它本质上都得走右结合。</p>
<h1 id="后缀操作符"><a href="#后缀操作符" class="headerlink" title="后缀操作符"></a>后缀操作符</h1><p>后缀操作符和中缀操作符其实形式一致，<strong>它们均是先读了左操作数，再根据当前操作符决定进一步操作，如果是加减乘除等，就走相应中缀逻辑，如果是阶乘<code>!</code>，就走相应后缀的逻辑</strong>……为了实现方便，这里要求后缀操作符和中缀操作符不能重复（这也没啥问题，有哪个语言这个是重复的？）。规定阶乘的优先级要高于<code>^</code>。</p>
<p><strong>因为在检测操作数后的操作符时，中缀和后缀操作符都可能会出现，所以 opDef 函数需要允许返回 null，在没找到相应操作符时不直接失败</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">opDef</span>(<span class="hljs-params">token: OpToken, position: OpDef[<span class="hljs-string">&#x27;position&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, assoc: OpDef[<span class="hljs-string">&#x27;assoc&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;token, precedence, assoc, position&#125;<br>  &#125;<br>  <span class="hljs-keyword">switch</span> (position) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;prefix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;infix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ZERO&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">ZERO_OP_DEF</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;L&#x27;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;R&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;postfix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;!&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;R&#x27;</span>)<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>然后，修改检查优先级的函数，获取当前操作符时同时检查中缀和后缀；<strong>如果没有获取到当前操作符的定义，返回 false</strong>，这样设计在后面会看到好处。然后修改 expr 函数，<strong>根据操作符的性质把业务分发给相应的代码块</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">precedenceHigherThan</span>(<span class="hljs-params">lexer: Lexer, lastOp: OpDef</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> currentOp = <span class="hljs-title function_">opDef</span>(lexer.<span class="hljs-title function_">peekOp</span>(), <span class="hljs-string">&#x27;infix&#x27;</span>) ?? <span class="hljs-title function_">opDef</span>(lexer.<span class="hljs-title function_">peekOp</span>(), <span class="hljs-string">&#x27;postfix&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (currentOp == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (currentOp.<span class="hljs-property">precedence</span> != lastOp.<span class="hljs-property">precedence</span>) &#123;<br>    <span class="hljs-keyword">return</span> currentOp.<span class="hljs-property">precedence</span> &gt; lastOp.<span class="hljs-property">precedence</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (currentOp.<span class="hljs-property">assoc</span> != lastOp.<span class="hljs-property">assoc</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`同一优先级两运算符 <span class="hljs-subst">$&#123;currentOp.token.op&#125;</span>, <span class="hljs-subst">$&#123;lastOp.token.op&#125;</span> 有不同结合性！`</span>)<br>  &#125;<br>  <span class="hljs-comment">// 对于 1 + 2 + 3，+是左结合，认为右边（current）的+优先级小于左边（last）的+</span><br>  <span class="hljs-comment">// 所以左结合要返回 false</span><br>  <span class="hljs-keyword">return</span> currentOp.<span class="hljs-property">assoc</span> === <span class="hljs-string">&#x27;L&#x27;</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOpDef: OpDef = ZERO_OP_DEF</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">tokenMatch</span>(lexer.<span class="hljs-title function_">next</span>(), &#123;<br>    <span class="hljs-title function_">ATOM</span>(<span class="hljs-params">t</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkLiteral</span>(t)  <span class="hljs-comment">// 原逻辑</span><br>    &#125;, <br>    <span class="hljs-title function_">OP</span>(<span class="hljs-params">op</span>) &#123;<br>      <span class="hljs-keyword">const</span> def = <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;prefix&#x27;</span>)<br>      <span class="hljs-keyword">if</span> (!def) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`unknown prefix op: <span class="hljs-subst">$&#123;def&#125;</span>`</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkPrefix</span>(op, <span class="hljs-title function_">expr</span>(lexer, def))<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">while</span> (<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOpDef)) &#123;<br>    <span class="hljs-keyword">const</span> op = lexer.<span class="hljs-title function_">nextOp</span>()<br>    <span class="hljs-keyword">const</span> infixOpDef = <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;infix&#x27;</span>)<br>    <span class="hljs-keyword">const</span> postfixOpDef = <span class="hljs-title function_">opDef</span>(op, <span class="hljs-string">&#x27;postfix&#x27;</span>)<br>    <span class="hljs-comment">// 如果是中缀</span><br>    <span class="hljs-keyword">if</span> (infixOpDef) &#123;<br>      <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">expr</span>(lexer, infixOpDef)<br>      x = <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (postfixOpDef) &#123;<br>      x = <span class="hljs-title function_">mkPostfix</span>(op, x)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 这里不可能到达，precedenceHigherThan 为 true 要求操作符必须是合法的中缀或后缀操作符</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Impossible&#x27;</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h1><p>然后是括号，没有括号怎么成？</p>
<p>如何处理括号呢？考虑表达式<code>1 * (2 + 3) * 4</code>能注意到，左括号<code>(</code>是出现在操作符之前，右括号<code>)</code>出现在操作符之后，所以处理左括号的逻辑理应放到前缀操作符，右括号的逻辑理应放到后缀操作符中……</p>
<p>先处理左括号，注意<strong>在处理括号中的表达式时，它是不关心括号之前的操作符的优先级的，因此 lastOp 重设为 0</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOpDef: OpDef = ZERO_OP_DEF</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">tokenMatch</span>(lexer.<span class="hljs-title function_">next</span>(), &#123;<br>    <span class="hljs-title function_">ATOM</span>(<span class="hljs-params">t</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkLiteral</span>(t)  <span class="hljs-comment">// 原逻辑</span><br>    &#125;, <br>    <span class="hljs-title function_">OP</span>(<span class="hljs-params">op</span>) &#123;<br>      <span class="hljs-keyword">if</span> (op.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> inner = <span class="hljs-title function_">expr</span>(lexer)<br>        lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;)&#x27;</span>)<br>        <span class="hljs-keyword">return</span> inner<br>      &#125;<br>      <span class="hljs-comment">// 前缀操作符</span><br>    &#125;<br>  &#125;)<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>但其实只改这里就行了，不需要在后缀的部分显式处理<code>)</code>：while 在检查当前操作符的优先级时会遇到<code>)</code>，然后它发现没有<code>)</code>的中缀、后缀操作符的定义，因此马上停止解析，把当前的 x 返回出来，<code>)</code>就像一堵墙，把所有解析过程给它阻断，最后控制流又回到前缀中处理<code>(</code>的那部分代码去处理，消费掉这个<code>)</code>。</p>
<h1 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h1><p>数组索引形如<code>1 + a[i] + 3</code>，这里有让人将它分到中缀运算符的冲动，但其实它分到后缀更合适——<strong>i 的范围是明确界定的，不参与优先级的运算</strong>。</p>
<p>但要我觉得，其实放哪都一样，它和后缀的<code>!</code>，中缀的<code>+-*/^</code>并非一路货色，<strong>实际上每个中缀（出现在第一个操作数后的）操作符都有自己的处理逻辑，只不过某些运算符的逻辑正好一样罢了</strong>，后面实际上也是这样操作的。</p>
<p><strong>需要定义后缀操作符<code>[</code>的优先级</strong>——这里究竟应当解释为<code>(1 + a)[i] + 3</code>还是<code>1 + (a[i]) + 3</code>呢？此外，处理<code>[i]</code>中的 i 和处理括号时的行为是相同的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">opDef</span>(<span class="hljs-params">token: OpToken, position: OpDef[<span class="hljs-string">&#x27;position&#x27;</span>]</span>): <span class="hljs-title class_">OpDef</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">switch</span> (position) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;postfix&#x27;</span>:<br>      <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;!&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkOpDef</span>(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;R&#x27;</span>) <br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOpDef: OpDef = ZERO_OP_DEF</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOpDef)) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (infixOpDef) &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (postfixOpDef) &#123;<br>      <span class="hljs-keyword">if</span> (op.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> i = <span class="hljs-title function_">expr</span>(lexer)<br>        lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;]&#x27;</span>)<br>        x = <span class="hljs-title function_">mkBinary</span>(op, x, i)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 原逻辑</span><br>        x = <span class="hljs-title function_">mkPostfix</span>(op, x)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 这里不可能到达，precedenceHigherThan 为 true 要求操作符必须是合法的中缀或后缀</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Impossible&#x27;</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h1><p>最后是三目，最终 boss。作为一个现代语言，要我说就不该支持三目，让三目滚蛋，换成 if 表达式。但这里还是实现一下。</p>
<p>如何理解三目呢？<code>a ? b : c</code>，一种最直接的方式是，<strong>将<code>?:</code>想象成一对括号，从而让 b 不再参与优先级的计算以简化问题</strong>。对于<code>a ? b : c ? d : e</code>，将它理解为<code>a ?: c ?: e</code>即可，记住三目是右结合的。并非所有语言的三目都是这样实现的，但同时并非所有语言的三目的行为都是一样的（恼，正经人谁用三目不加括号的？除了右结合，假设三目的其他特性都是作死）</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (infixOpDef) &#123;<br>  <span class="hljs-keyword">if</span> (op.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> thenExpr = <span class="hljs-title function_">expr</span>(lexer)<br>    lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br>    <span class="hljs-keyword">const</span> elseExpr = <span class="hljs-title function_">expr</span>(lexer, infixOpDef) <span class="hljs-comment">// 把优先级得带上！ ? 和：中间的部分等于是加了括号，但：后面的部分优先级是起作用的</span><br>    x = <span class="hljs-title function_">mkTernary</span>(op, x, thenExpr, elseExpr)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 原逻辑</span><br>    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">expr</span>(lexer, infixOpDef)<br>    x = <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="抽象各运算符的逻辑"><a href="#抽象各运算符的逻辑" class="headerlink" title="抽象各运算符的逻辑"></a>抽象各运算符的逻辑</h1><p>在 pratt parsing 法中，<strong>一切操作符归根结底是前缀操作符和中缀操作符</strong>——如果操作符比第一个操作数先出现，则是前缀操作符，否则是中缀操作符（虽然它叫中缀，但只是说指示对应操作符的 token 出现在第一个操作数之后，无关其他操作数在什么位置，有多少个操作数）。另外，<strong>Atom 也认为是前缀操作符</strong>。</p>
<p>为此，可以把不同运算符的逻辑都抽象出来——加减乘除？自增自减，阶乘？乃至于括号，三目，数组运算符？甚至 Atom？都抽象出对应的逻辑（并让这些逻辑都可以回调 expr），这些逻辑块称为 Parselet，这些 Parselet 均返回<code>Expr</code>，<strong>前缀和中缀需要各自定义相应的 Parselet 类型，因为它们已知的信息不同——前缀只知道当前的 token，中缀知道已有的 x 和当前的 token</strong>。这些 Parselet 进行自己的逻辑时必然会回调 expr 函数。</p>
<p>假设我们已经把每个 parselet 都抽象出来了，但将它们硬编码到了 expr 函数中，形式可能会是这样的：</p>
<figure class="highlight livescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">def expr(lexer, lastOp):<br>  xToken = lexer.next()<br>  x = xToken match &#123;<br>    <span class="hljs-comment"># 这里的 atom@Atom(_) 模仿的是 haskell 的相应语法，在模式匹配成功后再次把整个模式对应的值都赋给它</span><br>    atom@Atom(_) =&gt; atomPrefixParselet(lexer, atom) <span class="hljs-comment"># 注意到 parselet 是不需要知晓当前的 lastOp 信息的</span><br>    op@Op(<span class="hljs-string">&#x27;(&#x27;</span>)   =&gt; parenPrefixParselet(lexer, op)<br>    op@Op(<span class="hljs-string">&#x27;+&#x27;</span>)   =&gt; plusPrefixParselet(lexer, op)<br>    op@Op(<span class="hljs-string">&#x27;-&#x27;</span>)   =&gt; minusPrefixParselet(lexer, op)<br>    <span class="hljs-comment"># ...</span><br>    _            =&gt; panic(<span class="hljs-string">&quot;unknown token: ...&quot;</span>)<br>  &#125;<br>  <span class="hljs-comment"># 注意 precedenceHigherThan 仍旧需要知道各操作符的优先级，这点不能变</span><br>  <span class="hljs-keyword">while</span> precedenceHigherThan(lexer, lastOp):<br>    op = lexer.next()<br>    <span class="hljs-comment"># 注意这里的左结合行为</span><br>    x = op match &#123;<br>      op@Op(<span class="hljs-string">&#x27;?&#x27;</span>) =&gt; conditionalInfixParselet(lexer, x, op)<br>      op@Op(<span class="hljs-string">&#x27;[&#x27;</span>) =&gt; arrayAccessInfixParselet(lexer, x, op)<br>      op@Op(<span class="hljs-string">&#x27;+&#x27;</span>) =&gt; plusInfixParselet(lexer, x, op) <br>      op@Op(<span class="hljs-string">&#x27;!&#x27;</span>) =&gt; factorialInfixParselet(lexer, x, op) <br>      <span class="hljs-comment"># ...</span><br>      _          =&gt; panic(<span class="hljs-string">&#x27;impossible&#x27;</span>) <span class="hljs-comment"># 如果 token 没定义过，它根本不可能进到 while 里来</span><br>    &#125;<br>  <span class="hljs-keyword">return</span> x<br></code></pre></div></td></tr></table></figure>

<p>如何避免硬编码相应 parselet 到 expr 函数中呢？能注意到这里实际上是根据 token 的 type 和 value 去决定分发到哪个 parselet 上，<strong>因此我们可以建立相应哈希表，根据 type 和 value 获取相应 parselet</strong>（工业上必定是类似的操作），但这 key 有两个实际上不太优雅，我们可以做两次分发，为每个 type 定义相应 parselet（这样甚至能把泛型给利用起来了），再让这些 parselet 根据 value 去分发到对应 parselet，缺点是代码比较复杂些。</p>
<p><strong>这里走最省事的方式——每个 parselet 都直接定义相应谓词检查该 token 自己要不要</strong>，这是不合适的，应当在“编译期”就知晓当前的定义，因为需要检查当前的优先级和结合性规则是否合法。</p>
<p>最终形状可能会是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer, lastOp</span>):<br>  xToken = lexer.<span class="hljs-built_in">next</span>()<br>  x: Expr = prefixParseletMap[xToken](lexer, xToken) <span class="hljs-comment"># getPrefixParselet 可能失败</span><br>  <span class="hljs-keyword">while</span> precedenceHigherThan(lexer, lastOp):<br>    op = lexer.<span class="hljs-built_in">next</span>()<br>    x = infixParselet[op](lexer, x, op)<br>  <span class="hljs-keyword">return</span> x<br></code></pre></div></td></tr></table></figure>

<p>但注意 precedenceHigherThan 的实现，precedenceHigherThan 同样需要知道<strong>这里的 op</strong>（通过 peek）的优先级。因此，我们可以将优先级信息保存到 parselet 中，在 precedenceHigherThan 函数中同样去找到 parselet，再找到优先级信息。</p>
<p><strong>但前缀操作符也有优先级信息——这决定前缀操作符后的 atom 是和它先结合还是和它的下一个操作符先结合</strong>，总之能得到下面的类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PrefixParselet</span> = &#123;<br>  <span class="hljs-attr">accept</span>: <span class="hljs-function">(<span class="hljs-params">token: Token</span>) =&gt;</span> <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">precedence</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-comment">// 这里 expr 调用 parselet 的时候把自己也给传进去，保证 parselet 在看不到 expr 函数的情况下也能直接调用 expr 函数</span><br>  <span class="hljs-attr">parse</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, x: Token, exprFn: Parser[<span class="hljs-string">&#x27;expr&#x27;</span>]</span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">InfixParselet</span> = &#123;<br>  <span class="hljs-attr">accept</span>: <span class="hljs-function">(<span class="hljs-params">token: Token</span>) =&gt;</span> <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">precedence</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span> | <span class="hljs-string">&#x27;R&#x27;</span>,<br>  <span class="hljs-attr">parse</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, x: Expr, op: Token, exprFn: Parser[<span class="hljs-string">&#x27;expr&#x27;</span>]</span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parser</span> = &#123;<br>  <span class="hljs-comment">// 因为谓词直接定义在 parselet 上了…</span><br>  <span class="hljs-attr">registerPrefixParselet</span>: <span class="hljs-function">(<span class="hljs-params">parselet: PrefixParselet</span>) =&gt;</span> <span class="hljs-built_in">void</span>,<br>  <span class="hljs-attr">registerInfixParselet</span>: <span class="hljs-function">(<span class="hljs-params">parselet: InfixParselet</span>) =&gt;</span> <span class="hljs-built_in">void</span>,<br>  <span class="hljs-attr">expr</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, lastOpPrecedence?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>注意 expr 不需要知晓上一个操作符的结合性——如果上一个操作符的优先级和当前操作符的优先级相同，则它们的结合性会是一致的，不然这语法规则就是有歧义的——同一个优先级下的操作符的结合性需要一致</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newParser</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Parser</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">prefixParselets</span>: <span class="hljs-title class_">PrefixParselet</span>[] = []<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">infixParselets</span>: <span class="hljs-title class_">InfixParselet</span>[] = []<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPrefixParselet</span>(<span class="hljs-params">token: Token</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = prefixParselets.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">parselet</span> =&gt;</span> parselet.<span class="hljs-title function_">accept</span>(token))<br>    <span class="hljs-keyword">if</span> (!res) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`No Prefix parselet defined for <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(token)&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getInfixParselet</span>(<span class="hljs-params">token: Token</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = infixParselets.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">parselet</span> =&gt;</span> parselet.<span class="hljs-title function_">accept</span>(token))<br>    <span class="hljs-keyword">return</span> res ?? <span class="hljs-literal">null</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">precedenceHigherThan</span>(<span class="hljs-params">lexer: Lexer, lastOpPrecedence: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> currentParselet = <span class="hljs-title function_">getInfixParselet</span>(lexer.<span class="hljs-title function_">peek</span>())<br>    <span class="hljs-keyword">if</span> (currentParselet == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (currentParselet.<span class="hljs-property">precedence</span> != lastOpPrecedence) &#123;<br>      <span class="hljs-keyword">return</span> currentParselet.<span class="hljs-property">precedence</span> &gt; lastOpPrecedence<br>    &#125;<br>    <span class="hljs-keyword">return</span> currentParselet.<span class="hljs-property">assoc</span> === <span class="hljs-string">&#x27;L&#x27;</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOp = <span class="hljs-number">0</span></span>): <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-keyword">const</span> xToken = lexer.<span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">getPrefixParselet</span>(xToken).<span class="hljs-title function_">parse</span>(lexer, xToken, expr)<br>    <span class="hljs-keyword">while</span>(<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOp)) &#123;<br>      <span class="hljs-keyword">const</span> op = lexer.<span class="hljs-title function_">next</span>()<br>      x = <span class="hljs-title function_">getInfixParselet</span>(op)!.<span class="hljs-title function_">parse</span>(lexer, x, op, expr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>  &#125; <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-params">parselet</span>) &#123; infixParselets.<span class="hljs-title function_">push</span>(parselet) &#125;,<br>    <span class="hljs-title function_">registerPrefixParselet</span>(<span class="hljs-params">parselet</span>) &#123; prefixParselets.<span class="hljs-title function_">push</span>(parselet) &#125;,<br>    expr<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>接下来，用 parselet 把之前定义过的东西再定义一次，其中为“一般”的前缀、中缀、后缀操作符定义了相关函数以方便其的定义，但像原子，括号，三目，数组索引等语法仍需要手写相应 parselet。</p>
<p><strong>注意 parselet 在被调用时，触发 parselet 的 token 已经被消费了，不需要在 parselet 中进行消费操作</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> parser = <span class="hljs-title function_">newParser</span>()<br><br><span class="hljs-comment">// 原子</span><br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">// 这个优先级不会被使用到</span><br>  <span class="hljs-attr">accept</span>: <span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> token.<span class="hljs-property">type</span> == <span class="hljs-string">&#x27;ATOM&#x27;</span>,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkLiteral</span>(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">AtomToken</span>)<br>  &#125;,<br>&#125;)<br><br><span class="hljs-comment">// 括号</span><br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">// 同样的不会使用到</span><br>  <span class="hljs-attr">accept</span>: <span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> token.<span class="hljs-property">type</span> == <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;(&#x27;</span>,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">exprFn</span>(lexer)<br>    <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">nextOp</span>().<span class="hljs-property">op</span> !== <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Expect &#x27;)&#x27;`</span>)<br>    <span class="hljs-keyword">return</span> res<br>  &#125;,<br>&#125;)<br><br><span class="hljs-comment">// 一般的前缀运算符对应的 praselet</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">prefixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">PrefixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    precedence,<br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkPrefix</span>(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>, right)<br>    &#125;,<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 一般的中缀运算符对应的 parselet</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, assoc: <span class="hljs-string">&#x27;L&#x27;</span>| <span class="hljs-string">&#x27;R&#x27;</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">InfixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123; <br>    assoc, precedence,<br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>      op = op <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span><br>      <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>    &#125;,<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 一般的后缀运算符对应的 parselet</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">suffixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">InfixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    precedence, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-comment">// 后缀运算符的结合性是个有意思的问题…但一般来说，后缀运算符的优先级会高于中缀，因此结合性应当是不起作用的</span><br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkPostfix</span>(op <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>, x)<br>    &#125;,<br>  &#125;<br>&#125;<br><br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(<span class="hljs-title function_">prefixOperators</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;+-!&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;+-&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;*/%&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;^&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">suffixOperators</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;!&#x27;</span>))<br><br><span class="hljs-comment">// 数组索引</span><br>parser.<span class="hljs-title function_">registerInfixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-comment">// 这个结合性同样是没意义的，因为数组索引属于后缀运算符</span><br>  <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>    <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;[&#x27;</span><br>  &#125;,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">exprFn</span>(lexer)<br>    lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;]&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkBinary</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;[]&#x27;</span>&#125;, x, index)<br>  &#125;,<br>&#125;)<br><span class="hljs-comment">// 三目</span><br>parser.<span class="hljs-title function_">registerInfixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-comment">// 三目的结合性有用</span><br>  <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>    <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;?&#x27;</span><br>  &#125;,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> thenExpr = <span class="hljs-title function_">exprFn</span>(lexer)<br>    lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br>    <span class="hljs-keyword">const</span> elseExpr = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkTernary</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;?:&#x27;</span>&#125;, x, thenExpr, elseExpr)<br>  &#125;,<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<h1 id="使用栈处理四则运算"><a href="#使用栈处理四则运算" class="headerlink" title="使用栈处理四则运算"></a>使用栈处理四则运算</h1><p>在学习 pratt 解析后，我突然意识到其实使用栈来处理四则运算表达式的思想和 partt 是一致的——，<strong>如果遇到的上一个操作符的优先级大于等于当前的（左结合），则栈顶的操作数就是右操作数，去马上计算该操作符对应的表达式</strong>（<strong>马上</strong>得给它标红）。这样把整个表达式过一遍后，<strong>所有连续的非严格降序的操作符都已被计算，因此没有处理的操作符的优先级会是一个非严格升序的状态</strong>，再处理这些升序的操作符即可，巧的是操作符出栈的顺序正好就是计算的顺序。</p>
<p>比如，计算<code>1 + 4 * 2 * 3 + 2</code>，读到第二个<code>*</code>后<strong>马上</strong>计算<code>4 * 2</code>，然后读到第二个<code>+</code>后，马上计算 <code>8 * 3</code>，最后表达式会变成<code>1 + 24 + 2</code>，但此时就停止了——<strong>业务逻辑是在遇到操作符时执行的</strong>，所以最终还得把这个表达式再操作一遍，但操作这个是很方便的。</p>
<p>为什么需要维护两个栈？因为我们总是需要上一个操作符的优先级信息，所以操作数和操作符分开放。先不考虑括号的话，实现会是下面这样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> stackTop&lt;T&gt;(<span class="hljs-attr">stack</span>: T[]): T &#123;<br>  <span class="hljs-keyword">if</span> (!stack || stack.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;stack is empty&#x27;</span>)<br>  <span class="hljs-keyword">return</span> stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">applyEvalOnce</span>(<span class="hljs-params">numStack: <span class="hljs-built_in">number</span>[], opStack: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">applyOp</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, op: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> a + b<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> a - b<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">return</span> a * b<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> a / b<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ZERO&#x27;</span>: <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()<br>  &#125;<br>  <br>  <span class="hljs-keyword">const</span> b = numStack.<span class="hljs-title function_">pop</span>()!<br>  <span class="hljs-keyword">const</span> a = numStack.<span class="hljs-title function_">pop</span>()!<br>  <span class="hljs-keyword">const</span> op = opStack.<span class="hljs-title function_">pop</span>()!<br>  numStack.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">applyOp</span>(a, op, b)) <br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">precedence</span>(<span class="hljs-params">op: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">map</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">number</span>&gt; = &#123;<br>    <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ZERO&#x27;</span>: <span class="hljs-number">0</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> map[op]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">evalExpr</span>(<span class="hljs-params">expr: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">const</span> lexer = <span class="hljs-title function_">mkLexer</span>(expr)<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">numStack</span>: <span class="hljs-built_in">number</span>[] = [-<span class="hljs-number">9999</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">opStack</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;ZERO&#x27;</span>]<br><br>  <span class="hljs-keyword">while</span> (!lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>    <span class="hljs-keyword">const</span> token = lexer.<span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;ATOM&#x27;</span>) &#123;<br>      numStack.<span class="hljs-title function_">push</span>(+token.<span class="hljs-property">literal</span>)<br>      <span class="hljs-keyword">continue</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> op = (token <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>).<span class="hljs-property">op</span><br>    <span class="hljs-comment">// 如果当前优先级小于等于上一个操作符的优先级，上一个操作符已经可以执行了</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">precedence</span>(op) &lt;= <span class="hljs-title function_">precedence</span>(<span class="hljs-title function_">stackTop</span>(opStack))) &#123;<br>      <span class="hljs-title function_">applyEvalOnce</span>(numStack, opStack)<br>    &#125;<br>    opStack.<span class="hljs-title function_">push</span>(op) <br>  &#125;<br>  <span class="hljs-comment">// 然后，栈中仍剩的操作符将是升序的</span><br>  <span class="hljs-keyword">while</span> (opStack.<span class="hljs-property">length</span> != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title function_">applyEvalOnce</span>(numStack, opStack)<br>  &#125;<br>  <span class="hljs-keyword">return</span> numStack[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>注意这实现中为了处理方便，不用在检查上一个操作符的时候检查操作符栈非空，给它填充一个最低优先级的操作符，并让它的语义为返回右操作数。</p>
<p>然后是括号，括号很 trick，括号就像一堵高墙，阻止左括号前面的操作符进行计算，比如对<code>1 * (2 + 3)</code>，不能在遇到<code>+</code>的时候把<code>(</code>当作操作符去处理了（同时也不能遇到<code>(</code>先把<code>*</code>给处理了，因此左括号要走自己的逻辑），因此可以给左括号设置一个很<strong>低</strong>的优先级来避免它猴急。但<strong>此后仍然是照常计算，直到遇到右括号</strong>，此时在操作符栈中，左括号上面的操作符的优先级会是非严格升序的，因此在遇到左括号之前把它们全都给计算掉，然后扔掉栈顶的左括号即可，这样就计算出来了括号中的结果并填入操作符栈中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">precedence</span>(<span class="hljs-params">op: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">map</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">number</span>&gt; = &#123;<br>    <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ZERO&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;|&#x27;</span>: -<span class="hljs-number">999</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> map[op]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">evalExpr</span>(<span class="hljs-params">expr: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">const</span> lexer = <span class="hljs-title function_">mkLexer</span>(expr)<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">numStack</span>: <span class="hljs-built_in">number</span>[] = [-<span class="hljs-number">9999</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">opStack</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;ZERO&#x27;</span>]<br><br>  <span class="hljs-keyword">while</span> (!lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>    <span class="hljs-keyword">const</span> token = lexer.<span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;ATOM&#x27;</span>) &#123;<br>      numStack.<span class="hljs-title function_">push</span>(+token.<span class="hljs-property">literal</span>)<br>      <span class="hljs-keyword">continue</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> op = (token <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>).<span class="hljs-property">op</span><br>    <span class="hljs-keyword">if</span> (op === <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 其实这时候 push 个啥都行，它只是个标识符，所以这里 push 一个&#x27;|&#x27;因为它更应景</span><br>      opStack.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;|&#x27;</span>) <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op === <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-title function_">stackTop</span>(opStack) !== <span class="hljs-string">&#x27;|&#x27;</span>) &#123;<br>        <span class="hljs-title function_">applyEvalOnce</span>(numStack, opStack)<br>      &#125;<br>      opStack.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// 丢掉 &#x27;|&#x27;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">precedence</span>(op) &lt;= <span class="hljs-title function_">precedence</span>(<span class="hljs-title function_">stackTop</span>(opStack))) &#123;<br>        <span class="hljs-title function_">applyEvalOnce</span>(numStack, opStack)<br>      &#125;<br>      opStack.<span class="hljs-title function_">push</span>(op) <br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (opStack.<span class="hljs-property">length</span> != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title function_">applyEvalOnce</span>(numStack, opStack)<br>  &#125;<br>  <span class="hljs-keyword">return</span> numStack[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="pratt-完整实现"><a href="#pratt-完整实现" class="headerlink" title="pratt 完整实现"></a>pratt 完整实现</h1><figure class="highlight typescript"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">AtomToken</span> = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ATOM&#x27;</span>, <span class="hljs-attr">literal</span>: <span class="hljs-built_in">string</span>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">OpToken</span> = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-built_in">string</span>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">EofToken</span> = &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Token</span> = <span class="hljs-title class_">AtomToken</span> | <span class="hljs-title class_">OpToken</span> | <span class="hljs-title class_">EofToken</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Lexer</span> = &#123;<br>  <span class="hljs-title function_">next</span>(): <span class="hljs-title class_">Token</span>,<br>  <span class="hljs-title function_">peek</span>(): <span class="hljs-title class_">Token</span>,<br>  <span class="hljs-title function_">nextAtom</span>(): <span class="hljs-title class_">AtomToken</span><br>  <span class="hljs-title function_">nextOp</span>(value?: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">OpToken</span><br>  <span class="hljs-title function_">peekAtom</span>(): <span class="hljs-title class_">AtomToken</span>,<br>  <span class="hljs-title function_">peekOp</span>(): <span class="hljs-title class_">OpToken</span><br>  <span class="hljs-title function_">isAtEnd</span>(): <span class="hljs-built_in">boolean</span><br>&#125;<br><br><span class="hljs-keyword">function</span> tokenMatch&lt;T&gt;(<span class="hljs-attr">token</span>: <span class="hljs-title class_">Token</span>, <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Partial</span>&lt;&#123;<span class="hljs-attr">ATOM</span>: <span class="hljs-function">(<span class="hljs-params">t: AtomToken</span>) =&gt;</span> T, <span class="hljs-attr">OP</span>: <span class="hljs-function">(<span class="hljs-params">t: OpToken</span>) =&gt;</span> T, <span class="hljs-attr">EOF</span>: <span class="hljs-function">(<span class="hljs-params">t: EofToken</span>) =&gt;</span> T&#125;&gt;) &#123;<br>  <span class="hljs-keyword">if</span> (!fn[token.<span class="hljs-property">type</span>]) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`pattern match failed, type: <span class="hljs-subst">$&#123;token.<span class="hljs-keyword">type</span>&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> (fn[token.<span class="hljs-property">type</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)(token)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkLexer</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Lexer</span> &#123;<br>  <span class="hljs-keyword">const</span> tokens = source.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span>!<span class="hljs-regexp">/\s/</span>.<span class="hljs-title function_">test</span>(c))<br>    .<span class="hljs-property">map</span>&lt;<span class="hljs-title class_">Token</span>&gt;(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-regexp">/[a-zA-Z0-9]/</span>.<span class="hljs-title function_">test</span>(c) ? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ATOM&#x27;</span>, <span class="hljs-attr">literal</span>: c &#125; : &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: c&#125;)<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-params">token: Token, <span class="hljs-keyword">type</span>: Token[<span class="hljs-string">&#x27;type&#x27;</span>]</span>): <span class="hljs-built_in">any</span> &#123;<br>    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> != <span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Expect <span class="hljs-subst">$&#123;<span class="hljs-keyword">type</span>&#125;</span>, got <span class="hljs-subst">$&#123;token.<span class="hljs-keyword">type</span>&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> token<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> tokens.<span class="hljs-title function_">shift</span>() ?? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> tokens[<span class="hljs-number">0</span>] ?? &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;EOF&#x27;</span> &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    next,<br>    peek,<br>    <span class="hljs-title function_">nextAtom</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">next</span>(), <span class="hljs-string">&#x27;ATOM&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">nextOp</span>(<span class="hljs-params">value?: <span class="hljs-built_in">string</span></span>) &#123;<br>      <span class="hljs-keyword">const</span> op = <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">next</span>(), <span class="hljs-string">&#x27;OP&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span><br>      <span class="hljs-keyword">if</span> (value &amp;&amp; value != op.<span class="hljs-property">op</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Expect <span class="hljs-subst">$&#123;value&#125;</span>, got <span class="hljs-subst">$&#123;op.op&#125;</span>`</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> op<br>    &#125;,<br>    <span class="hljs-title function_">peekAtom</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">peek</span>(), <span class="hljs-string">&#x27;ATOM&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">peekOp</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">assertTokenType</span>(<span class="hljs-title function_">peek</span>(), <span class="hljs-string">&#x27;OP&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">isAtEnd</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> tokens.<span class="hljs-property">length</span> == <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Expr</span> = (&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LITERAL&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">AtomToken</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;UNARY&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">OpToken</span>, <span class="hljs-attr">right</span>: <span class="hljs-title class_">Expr</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">OpToken</span>, <span class="hljs-attr">left</span>: <span class="hljs-title class_">Expr</span>, <span class="hljs-attr">right</span>: <span class="hljs-title class_">Expr</span><br>&#125; | &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;TERNARY&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">OpToken</span>, <span class="hljs-attr">left</span>: <span class="hljs-title class_">Expr</span>, <span class="hljs-attr">middle</span>: <span class="hljs-title class_">Expr</span>, <span class="hljs-attr">right</span>: <span class="hljs-title class_">Expr</span><br>&#125;) &amp; &#123; <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span> &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkLiteral</span>(<span class="hljs-params">value: AtomToken</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LITERAL&#x27;</span>, value, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> value.<span class="hljs-property">literal</span> &#125; &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkUnary</span>(<span class="hljs-params">op: OpToken, right: Expr</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;UNARY&#x27;</span>, op, right, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">$&#123;op.op&#125;</span> <span class="hljs-subst">$&#123;right&#125;</span>)`</span> &#125; &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkBinary</span>(<span class="hljs-params">op: OpToken, left: Expr, right: Expr</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BINARY&#x27;</span>, op, left, right, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">$&#123;op.op&#125;</span> <span class="hljs-subst">$&#123;left&#125;</span> <span class="hljs-subst">$&#123;right&#125;</span>)`</span><br>  &#125;&#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkTernary</span>(<span class="hljs-params">op: OpToken, left: Expr, middle: Expr, right: Expr</span>): <span class="hljs-title class_">Expr</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;TERNARY&#x27;</span>, op, left, middle, right, <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">$&#123;op.op&#125;</span> <span class="hljs-subst">$&#123;left&#125;</span> <span class="hljs-subst">$&#123;middle&#125;</span> <span class="hljs-subst">$&#123;right&#125;</span>)`</span> &#125; &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PrefixParselet</span> = &#123;<br>  <span class="hljs-attr">accept</span>: <span class="hljs-function">(<span class="hljs-params">token: Token</span>) =&gt;</span> <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">precedence</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-comment">// 这里 expr 调用 parselet 的时候把自己也给传进去，保证 parselet 在看不到 expr 函数的情况下也能直接调用 expr 函数</span><br>  <span class="hljs-attr">parse</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, x: Token, exprFn: Parser[<span class="hljs-string">&#x27;expr&#x27;</span>]</span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">InfixParselet</span> = &#123;<br>  <span class="hljs-attr">accept</span>: <span class="hljs-function">(<span class="hljs-params">token: Token</span>) =&gt;</span> <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">precedence</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span> | <span class="hljs-string">&#x27;R&#x27;</span>,<br>  <span class="hljs-attr">parse</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, x: Expr, op: Token, exprFn: Parser[<span class="hljs-string">&#x27;expr&#x27;</span>]</span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parser</span> = &#123;<br>  <span class="hljs-comment">// 因为谓词直接定义在 parselet 上了…</span><br>  <span class="hljs-attr">registerPrefixParselet</span>: <span class="hljs-function">(<span class="hljs-params">parselet: PrefixParselet</span>) =&gt;</span> <span class="hljs-built_in">void</span>,<br>  <span class="hljs-attr">registerInfixParselet</span>: <span class="hljs-function">(<span class="hljs-params">parselet: InfixParselet</span>) =&gt;</span> <span class="hljs-built_in">void</span>,<br>  <span class="hljs-attr">expr</span>: <span class="hljs-function">(<span class="hljs-params">lexer: Lexer, lastOpPrecedence?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-title class_">Expr</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">newParser</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Parser</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">prefixParselets</span>: <span class="hljs-title class_">PrefixParselet</span>[] = []<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">infixParselets</span>: <span class="hljs-title class_">InfixParselet</span>[] = []<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPrefixParselet</span>(<span class="hljs-params">token: Token</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = prefixParselets.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">parselet</span> =&gt;</span> parselet.<span class="hljs-title function_">accept</span>(token))<br>    <span class="hljs-keyword">if</span> (!res) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`No Prefix parselet defined for <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(token)&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getInfixParselet</span>(<span class="hljs-params">token: Token</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = infixParselets.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">parselet</span> =&gt;</span> parselet.<span class="hljs-title function_">accept</span>(token))<br>    <span class="hljs-keyword">return</span> res ?? <span class="hljs-literal">null</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">precedenceHigherThan</span>(<span class="hljs-params">lexer: Lexer, lastOpPrecedence: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">isAtEnd</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> currentParselet = <span class="hljs-title function_">getInfixParselet</span>(lexer.<span class="hljs-title function_">peek</span>())<br>    <span class="hljs-keyword">if</span> (currentParselet == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (currentParselet.<span class="hljs-property">precedence</span> != lastOpPrecedence) &#123;<br>      <span class="hljs-keyword">return</span> currentParselet.<span class="hljs-property">precedence</span> &gt; lastOpPrecedence<br>    &#125;<br>    <span class="hljs-keyword">return</span> currentParselet.<span class="hljs-property">assoc</span> === <span class="hljs-string">&#x27;L&#x27;</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">expr</span>(<span class="hljs-params">lexer: Lexer, lastOp = <span class="hljs-number">0</span></span>): <span class="hljs-title class_">Expr</span> &#123;<br>    <span class="hljs-keyword">const</span> xToken = lexer.<span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">getPrefixParselet</span>(xToken).<span class="hljs-title function_">parse</span>(lexer, xToken, expr)<br>    <span class="hljs-keyword">while</span>(<span class="hljs-title function_">precedenceHigherThan</span>(lexer, lastOp)) &#123;<br>      <span class="hljs-keyword">const</span> op = lexer.<span class="hljs-title function_">next</span>()<br>      x = <span class="hljs-title function_">getInfixParselet</span>(op)!.<span class="hljs-title function_">parse</span>(lexer, x, op, expr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>  &#125; <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-params">parselet</span>) &#123; infixParselets.<span class="hljs-title function_">push</span>(parselet) &#125;,<br>    <span class="hljs-title function_">registerPrefixParselet</span>(<span class="hljs-params">parselet</span>) &#123; prefixParselets.<span class="hljs-title function_">push</span>(parselet) &#125;,<br>    expr<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> parser = <span class="hljs-title function_">newParser</span>()<br><br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">// 这个优先级不会被使用到</span><br>  <span class="hljs-attr">accept</span>: <span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> token.<span class="hljs-property">type</span> == <span class="hljs-string">&#x27;ATOM&#x27;</span>,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkLiteral</span>(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">AtomToken</span>)<br>  &#125;,<br>&#125;)<br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">// 同样的不会使用到</span><br>  <span class="hljs-attr">accept</span>: <span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> token.<span class="hljs-property">type</span> == <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;(&#x27;</span>,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">exprFn</span>(lexer)<br>    <span class="hljs-keyword">if</span> (lexer.<span class="hljs-title function_">nextOp</span>().<span class="hljs-property">op</span> !== <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Expect &#x27;)&#x27;`</span>)<br>    <span class="hljs-keyword">return</span> res<br>  &#125;,<br>&#125;)<br><br><span class="hljs-comment">// 一般的前缀运算符对应的 praselet</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">prefixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">PrefixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    precedence,<br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, exprFn</span>) &#123;<br>        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkUnary</span>(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>, right)<br>    &#125;,<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 一般的中缀运算符对应的 parselet</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, assoc: <span class="hljs-string">&#x27;L&#x27;</span>| <span class="hljs-string">&#x27;R&#x27;</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">InfixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123; <br>    assoc, precedence,<br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>      op = op <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span><br>      <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkBinary</span>(op, x, right)<br>    &#125;,<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">suffixOperators</span>(<span class="hljs-params">precedence: <span class="hljs-built_in">number</span>, ops: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">InfixParselet</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    precedence, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-comment">// 后缀运算符的结合性是个有意思的问题…但一般来说，后缀运算符的优先级会高于中缀，因此结合性应当是不起作用的</span><br>    <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>      <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; ops.<span class="hljs-title function_">includes</span>(token.<span class="hljs-property">op</span>)<br>    &#125;,<br>    <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkUnary</span>(op <span class="hljs-keyword">as</span> <span class="hljs-title class_">OpToken</span>, x)<br>    &#125;,<br>  &#125;<br>&#125;<br><br>parser.<span class="hljs-title function_">registerPrefixParselet</span>(<span class="hljs-title function_">prefixOperators</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;+-!&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;+-&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;*/%&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">infixOperators</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;^&#x27;</span>))<br>parser.<span class="hljs-title function_">registerInfixParselet</span>(<span class="hljs-title function_">suffixOperators</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;!&#x27;</span>))<br><br><span class="hljs-comment">// 数组索引</span><br>parser.<span class="hljs-title function_">registerInfixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-comment">// 这个结合性同样是没意义的，因为数组索引属于后缀运算符</span><br>  <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>    <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;[&#x27;</span><br>  &#125;,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">exprFn</span>(lexer)<br>    lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;]&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkBinary</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;[]&#x27;</span>&#125;, x, index)<br>  &#125;,<br>&#125;)<br><span class="hljs-comment">// 三目</span><br>parser.<span class="hljs-title function_">registerInfixParselet</span>(&#123;<br>  <span class="hljs-attr">precedence</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">assoc</span>: <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-comment">// 三目的结合性有用</span><br>  <span class="hljs-title function_">accept</span>(<span class="hljs-params">token</span>) &#123;<br>    <span class="hljs-keyword">return</span> token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;OP&#x27;</span> &amp;&amp; token.<span class="hljs-property">op</span> === <span class="hljs-string">&#x27;?&#x27;</span><br>  &#125;,<br>  <span class="hljs-title function_">parse</span>(<span class="hljs-params">lexer, x, op, exprFn</span>) &#123;<br>    <span class="hljs-keyword">const</span> thenExpr = <span class="hljs-title function_">exprFn</span>(lexer)<br>    lexer.<span class="hljs-title function_">nextOp</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br>    <span class="hljs-keyword">const</span> elseExpr = <span class="hljs-title function_">exprFn</span>(lexer, <span class="hljs-variable language_">this</span>.<span class="hljs-property">precedence</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mkTernary</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;OP&#x27;</span>, <span class="hljs-attr">op</span>: <span class="hljs-string">&#x27;?:&#x27;</span>&#125;, x, thenExpr, elseExpr)<br>  &#125;,<br>&#125;)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">parse</span> = (<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parser.<span class="hljs-title function_">expr</span>(<span class="hljs-title function_">mkLexer</span>(str)).<span class="hljs-title function_">toString</span>())<br><br><span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;3 + a[i[2]![3] * 2 + 1]&#x27;</span>) <span class="hljs-comment">// (+ 3 ([] a (+ (* ([] (! ([] i 2)) 3) 2) 1)))</span><br><span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;a ? b + 1 : c + d ? d : e + 2&#x27;</span>) <span class="hljs-comment">// (?: a (+ b 1) (?: (+ c d) d (+ e 2)))</span><br></code></pre></div></td></tr></table></figure>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-NC-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01-15%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1%E2%80%94%E2%80%94%E4%BB%8ENAND%E5%88%B0CPU.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机系统要素学习笔记 Part1——从 NAND 到 CPU</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12-28%E3%80%8ACrafting-Interpreters%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%EF%BC%8C%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90.html">
                        <span class="hidden-mobile">《Crafting Interpreters》学习笔记 2——状态，控制流，函数，语义分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start -->
<script src="/assets/prism-bundle.js"></script>
<script src="/assets/prism-plus.js" data-pjax=""></script>
<!-- hexo injector body_end end --></body>
</html>
